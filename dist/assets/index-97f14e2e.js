function _mergeNamespaces(s, e) {
  for (var a = 0; a < e.length; a++) {
    const o = e[a]
    if (typeof o != "string" && !Array.isArray(o)) {
      for (const c in o)
        if (c !== "default" && !(c in s)) {
          const d = Object.getOwnPropertyDescriptor(o, c)
          d &&
            Object.defineProperty(
              s,
              c,
              d.get ? d : { enumerable: !0, get: () => o[c] }
            )
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(s, Symbol.toStringTag, { value: "Module" })
  )
}
;(function () {
  const e = document.createElement("link").relList
  if (e && e.supports && e.supports("modulepreload")) return
  for (const c of document.querySelectorAll('link[rel="modulepreload"]')) o(c)
  new MutationObserver((c) => {
    for (const d of c)
      if (d.type === "childList")
        for (const g of d.addedNodes)
          g.tagName === "LINK" && g.rel === "modulepreload" && o(g)
  }).observe(document, { childList: !0, subtree: !0 })
  function a(c) {
    const d = {}
    return (
      c.integrity && (d.integrity = c.integrity),
      c.referrerPolicy && (d.referrerPolicy = c.referrerPolicy),
      c.crossOrigin === "use-credentials"
        ? (d.credentials = "include")
        : c.crossOrigin === "anonymous"
        ? (d.credentials = "omit")
        : (d.credentials = "same-origin"),
      d
    )
  }
  function o(c) {
    if (c.ep) return
    c.ep = !0
    const d = a(c)
    fetch(c.href, d)
  }
})()
var commonjsGlobal =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {}
function getDefaultExportFromCjs(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default")
    ? s.default
    : s
}
function getAugmentedNamespace(s) {
  if (s.__esModule) return s
  var e = s.default
  if (typeof e == "function") {
    var a = function o() {
      return this instanceof o
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments)
    }
    a.prototype = e.prototype
  } else a = {}
  return (
    Object.defineProperty(a, "__esModule", { value: !0 }),
    Object.keys(s).forEach(function (o) {
      var c = Object.getOwnPropertyDescriptor(s, o)
      Object.defineProperty(
        a,
        o,
        c.get
          ? c
          : {
              enumerable: !0,
              get: function () {
                return s[o]
              },
            }
      )
    }),
    a
  )
}
var jsxRuntime = { exports: {} },
  reactJsxRuntime_production_min = {},
  react = { exports: {} },
  react_production_min = {}
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var l$1 = Symbol.for("react.element"),
  n$1 = Symbol.for("react.portal"),
  p$3 = Symbol.for("react.fragment"),
  q$1 = Symbol.for("react.strict_mode"),
  r = Symbol.for("react.profiler"),
  t = Symbol.for("react.provider"),
  u = Symbol.for("react.context"),
  v$2 = Symbol.for("react.forward_ref"),
  w$1 = Symbol.for("react.suspense"),
  x$1 = Symbol.for("react.memo"),
  y = Symbol.for("react.lazy"),
  z$1 = Symbol.iterator
function A$1(s) {
  return s === null || typeof s != "object"
    ? null
    : ((s = (z$1 && s[z$1]) || s["@@iterator"]),
      typeof s == "function" ? s : null)
}
var B$1 = {
    isMounted: function () {
      return !1
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  C$1 = Object.assign,
  D$1 = {}
function E$1(s, e, a) {
  ;(this.props = s),
    (this.context = e),
    (this.refs = D$1),
    (this.updater = a || B$1)
}
E$1.prototype.isReactComponent = {}
E$1.prototype.setState = function (s, e) {
  if (typeof s != "object" && typeof s != "function" && s != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    )
  this.updater.enqueueSetState(this, s, e, "setState")
}
E$1.prototype.forceUpdate = function (s) {
  this.updater.enqueueForceUpdate(this, s, "forceUpdate")
}
function F() {}
F.prototype = E$1.prototype
function G$1(s, e, a) {
  ;(this.props = s),
    (this.context = e),
    (this.refs = D$1),
    (this.updater = a || B$1)
}
var H$1 = (G$1.prototype = new F())
H$1.constructor = G$1
C$1(H$1, E$1.prototype)
H$1.isPureReactComponent = !0
var I$1 = Array.isArray,
  J = Object.prototype.hasOwnProperty,
  K$1 = { current: null },
  L$1 = { key: !0, ref: !0, __self: !0, __source: !0 }
function M$1(s, e, a) {
  var o,
    c = {},
    d = null,
    g = null
  if (e != null)
    for (o in (e.ref !== void 0 && (g = e.ref),
    e.key !== void 0 && (d = "" + e.key),
    e))
      J.call(e, o) && !L$1.hasOwnProperty(o) && (c[o] = e[o])
  var _ = arguments.length - 2
  if (_ === 1) c.children = a
  else if (1 < _) {
    for (var b = Array(_), j = 0; j < _; j++) b[j] = arguments[j + 2]
    c.children = b
  }
  if (s && s.defaultProps)
    for (o in ((_ = s.defaultProps), _)) c[o] === void 0 && (c[o] = _[o])
  return {
    $$typeof: l$1,
    type: s,
    key: d,
    ref: g,
    props: c,
    _owner: K$1.current,
  }
}
function N$1(s, e) {
  return {
    $$typeof: l$1,
    type: s.type,
    key: e,
    ref: s.ref,
    props: s.props,
    _owner: s._owner,
  }
}
function O$1(s) {
  return typeof s == "object" && s !== null && s.$$typeof === l$1
}
function escape$1(s) {
  var e = { "=": "=0", ":": "=2" }
  return (
    "$" +
    s.replace(/[=:]/g, function (a) {
      return e[a]
    })
  )
}
var P$1 = /\/+/g
function Q$1(s, e) {
  return typeof s == "object" && s !== null && s.key != null
    ? escape$1("" + s.key)
    : e.toString(36)
}
function R$1(s, e, a, o, c) {
  var d = typeof s
  ;(d === "undefined" || d === "boolean") && (s = null)
  var g = !1
  if (s === null) g = !0
  else
    switch (d) {
      case "string":
      case "number":
        g = !0
        break
      case "object":
        switch (s.$$typeof) {
          case l$1:
          case n$1:
            g = !0
        }
    }
  if (g)
    return (
      (g = s),
      (c = c(g)),
      (s = o === "" ? "." + Q$1(g, 0) : o),
      I$1(c)
        ? ((a = ""),
          s != null && (a = s.replace(P$1, "$&/") + "/"),
          R$1(c, e, a, "", function (j) {
            return j
          }))
        : c != null &&
          (O$1(c) &&
            (c = N$1(
              c,
              a +
                (!c.key || (g && g.key === c.key)
                  ? ""
                  : ("" + c.key).replace(P$1, "$&/") + "/") +
                s
            )),
          e.push(c)),
      1
    )
  if (((g = 0), (o = o === "" ? "." : o + ":"), I$1(s)))
    for (var _ = 0; _ < s.length; _++) {
      d = s[_]
      var b = o + Q$1(d, _)
      g += R$1(d, e, a, b, c)
    }
  else if (((b = A$1(s)), typeof b == "function"))
    for (s = b.call(s), _ = 0; !(d = s.next()).done; )
      (d = d.value), (b = o + Q$1(d, _++)), (g += R$1(d, e, a, b, c))
  else if (d === "object")
    throw (
      ((e = String(s)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(s).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    )
  return g
}
function S$1(s, e, a) {
  if (s == null) return s
  var o = [],
    c = 0
  return (
    R$1(s, o, "", "", function (d) {
      return e.call(a, d, c++)
    }),
    o
  )
}
function T$1(s) {
  if (s._status === -1) {
    var e = s._result
    ;(e = e()),
      e.then(
        function (a) {
          ;(s._status === 0 || s._status === -1) &&
            ((s._status = 1), (s._result = a))
        },
        function (a) {
          ;(s._status === 0 || s._status === -1) &&
            ((s._status = 2), (s._result = a))
        }
      ),
      s._status === -1 && ((s._status = 0), (s._result = e))
  }
  if (s._status === 1) return s._result.default
  throw s._result
}
var U$1 = { current: null },
  V$1 = { transition: null },
  W$1 = {
    ReactCurrentDispatcher: U$1,
    ReactCurrentBatchConfig: V$1,
    ReactCurrentOwner: K$1,
  }
react_production_min.Children = {
  map: S$1,
  forEach: function (s, e, a) {
    S$1(
      s,
      function () {
        e.apply(this, arguments)
      },
      a
    )
  },
  count: function (s) {
    var e = 0
    return (
      S$1(s, function () {
        e++
      }),
      e
    )
  },
  toArray: function (s) {
    return (
      S$1(s, function (e) {
        return e
      }) || []
    )
  },
  only: function (s) {
    if (!O$1(s))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      )
    return s
  },
}
react_production_min.Component = E$1
react_production_min.Fragment = p$3
react_production_min.Profiler = r
react_production_min.PureComponent = G$1
react_production_min.StrictMode = q$1
react_production_min.Suspense = w$1
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1
react_production_min.cloneElement = function (s, e, a) {
  if (s == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        s +
        "."
    )
  var o = C$1({}, s.props),
    c = s.key,
    d = s.ref,
    g = s._owner
  if (e != null) {
    if (
      (e.ref !== void 0 && ((d = e.ref), (g = K$1.current)),
      e.key !== void 0 && (c = "" + e.key),
      s.type && s.type.defaultProps)
    )
      var _ = s.type.defaultProps
    for (b in e)
      J.call(e, b) &&
        !L$1.hasOwnProperty(b) &&
        (o[b] = e[b] === void 0 && _ !== void 0 ? _[b] : e[b])
  }
  var b = arguments.length - 2
  if (b === 1) o.children = a
  else if (1 < b) {
    _ = Array(b)
    for (var j = 0; j < b; j++) _[j] = arguments[j + 2]
    o.children = _
  }
  return { $$typeof: l$1, type: s.type, key: c, ref: d, props: o, _owner: g }
}
react_production_min.createContext = function (s) {
  return (
    (s = {
      $$typeof: u,
      _currentValue: s,
      _currentValue2: s,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (s.Provider = { $$typeof: t, _context: s }),
    (s.Consumer = s)
  )
}
react_production_min.createElement = M$1
react_production_min.createFactory = function (s) {
  var e = M$1.bind(null, s)
  return (e.type = s), e
}
react_production_min.createRef = function () {
  return { current: null }
}
react_production_min.forwardRef = function (s) {
  return { $$typeof: v$2, render: s }
}
react_production_min.isValidElement = O$1
react_production_min.lazy = function (s) {
  return { $$typeof: y, _payload: { _status: -1, _result: s }, _init: T$1 }
}
react_production_min.memo = function (s, e) {
  return { $$typeof: x$1, type: s, compare: e === void 0 ? null : e }
}
react_production_min.startTransition = function (s) {
  var e = V$1.transition
  V$1.transition = {}
  try {
    s()
  } finally {
    V$1.transition = e
  }
}
react_production_min.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.")
}
react_production_min.useCallback = function (s, e) {
  return U$1.current.useCallback(s, e)
}
react_production_min.useContext = function (s) {
  return U$1.current.useContext(s)
}
react_production_min.useDebugValue = function () {}
react_production_min.useDeferredValue = function (s) {
  return U$1.current.useDeferredValue(s)
}
react_production_min.useEffect = function (s, e) {
  return U$1.current.useEffect(s, e)
}
react_production_min.useId = function () {
  return U$1.current.useId()
}
react_production_min.useImperativeHandle = function (s, e, a) {
  return U$1.current.useImperativeHandle(s, e, a)
}
react_production_min.useInsertionEffect = function (s, e) {
  return U$1.current.useInsertionEffect(s, e)
}
react_production_min.useLayoutEffect = function (s, e) {
  return U$1.current.useLayoutEffect(s, e)
}
react_production_min.useMemo = function (s, e) {
  return U$1.current.useMemo(s, e)
}
react_production_min.useReducer = function (s, e, a) {
  return U$1.current.useReducer(s, e, a)
}
react_production_min.useRef = function (s) {
  return U$1.current.useRef(s)
}
react_production_min.useState = function (s) {
  return U$1.current.useState(s)
}
react_production_min.useSyncExternalStore = function (s, e, a) {
  return U$1.current.useSyncExternalStore(s, e, a)
}
react_production_min.useTransition = function () {
  return U$1.current.useTransition()
}
react_production_min.version = "18.2.0"
react.exports = react_production_min
var reactExports = react.exports
const React = getDefaultExportFromCjs(reactExports),
  React$1 = _mergeNamespaces({ __proto__: null, default: React }, [
    reactExports,
  ])
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var f = reactExports,
  k = Symbol.for("react.element"),
  l = Symbol.for("react.fragment"),
  m$1 = Object.prototype.hasOwnProperty,
  n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  p$2 = { key: !0, ref: !0, __self: !0, __source: !0 }
function q(s, e, a) {
  var o,
    c = {},
    d = null,
    g = null
  a !== void 0 && (d = "" + a),
    e.key !== void 0 && (d = "" + e.key),
    e.ref !== void 0 && (g = e.ref)
  for (o in e) m$1.call(e, o) && !p$2.hasOwnProperty(o) && (c[o] = e[o])
  if (s && s.defaultProps)
    for (o in ((e = s.defaultProps), e)) c[o] === void 0 && (c[o] = e[o])
  return { $$typeof: k, type: s, key: d, ref: g, props: c, _owner: n.current }
}
reactJsxRuntime_production_min.Fragment = l
reactJsxRuntime_production_min.jsx = q
reactJsxRuntime_production_min.jsxs = q
jsxRuntime.exports = reactJsxRuntime_production_min
var jsxRuntimeExports = jsxRuntime.exports,
  client = {},
  reactDom = { exports: {} },
  reactDom_production_min = {},
  scheduler$2 = { exports: {} },
  scheduler_production_min$2 = {}
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function (s) {
  function e(gt, At) {
    var bt = gt.length
    gt.push(At)
    e: for (; 0 < bt; ) {
      var Tt = (bt - 1) >>> 1,
        It = gt[Tt]
      if (0 < c(It, At)) (gt[Tt] = At), (gt[bt] = It), (bt = Tt)
      else break e
    }
  }
  function a(gt) {
    return gt.length === 0 ? null : gt[0]
  }
  function o(gt) {
    if (gt.length === 0) return null
    var At = gt[0],
      bt = gt.pop()
    if (bt !== At) {
      gt[0] = bt
      e: for (var Tt = 0, It = gt.length, $t = It >>> 1; Tt < $t; ) {
        var Xt = 2 * (Tt + 1) - 1,
          qt = gt[Xt],
          en = Xt + 1,
          yn = gt[en]
        if (0 > c(qt, bt))
          en < It && 0 > c(yn, qt)
            ? ((gt[Tt] = yn), (gt[en] = bt), (Tt = en))
            : ((gt[Tt] = qt), (gt[Xt] = bt), (Tt = Xt))
        else if (en < It && 0 > c(yn, bt))
          (gt[Tt] = yn), (gt[en] = bt), (Tt = en)
        else break e
      }
    }
    return At
  }
  function c(gt, At) {
    var bt = gt.sortIndex - At.sortIndex
    return bt !== 0 ? bt : gt.id - At.id
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var d = performance
    s.unstable_now = function () {
      return d.now()
    }
  } else {
    var g = Date,
      _ = g.now()
    s.unstable_now = function () {
      return g.now() - _
    }
  }
  var b = [],
    j = [],
    $ = 1,
    _e = null,
    tt = 3,
    st = !1,
    at = !1,
    ot = !1,
    ut = typeof setTimeout == "function" ? setTimeout : null,
    it = typeof clearTimeout == "function" ? clearTimeout : null,
    ct = typeof setImmediate < "u" ? setImmediate : null
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling)
  function lt(gt) {
    for (var At = a(j); At !== null; ) {
      if (At.callback === null) o(j)
      else if (At.startTime <= gt)
        o(j), (At.sortIndex = At.expirationTime), e(b, At)
      else break
      At = a(j)
    }
  }
  function ht(gt) {
    if (((ot = !1), lt(gt), !at))
      if (a(b) !== null) (at = !0), Mt(dt)
      else {
        var At = a(j)
        At !== null && wt(ht, At.startTime - gt)
      }
  }
  function dt(gt, At) {
    ;(at = !1), ot && ((ot = !1), it(_t), (_t = -1)), (st = !0)
    var bt = tt
    try {
      for (
        lt(At), _e = a(b);
        _e !== null && (!(_e.expirationTime > At) || (gt && !Rt()));

      ) {
        var Tt = _e.callback
        if (typeof Tt == "function") {
          ;(_e.callback = null), (tt = _e.priorityLevel)
          var It = Tt(_e.expirationTime <= At)
          ;(At = s.unstable_now()),
            typeof It == "function" ? (_e.callback = It) : _e === a(b) && o(b),
            lt(At)
        } else o(b)
        _e = a(b)
      }
      if (_e !== null) var $t = !0
      else {
        var Xt = a(j)
        Xt !== null && wt(ht, Xt.startTime - At), ($t = !1)
      }
      return $t
    } finally {
      ;(_e = null), (tt = bt), (st = !1)
    }
  }
  var pt = !1,
    vt = null,
    _t = -1,
    yt = 5,
    Et = -1
  function Rt() {
    return !(s.unstable_now() - Et < yt)
  }
  function Ft() {
    if (vt !== null) {
      var gt = s.unstable_now()
      Et = gt
      var At = !0
      try {
        At = vt(!0, gt)
      } finally {
        At ? kt() : ((pt = !1), (vt = null))
      }
    } else pt = !1
  }
  var kt
  if (typeof ct == "function")
    kt = function () {
      ct(Ft)
    }
  else if (typeof MessageChannel < "u") {
    var Nt = new MessageChannel(),
      Dt = Nt.port2
    ;(Nt.port1.onmessage = Ft),
      (kt = function () {
        Dt.postMessage(null)
      })
  } else
    kt = function () {
      ut(Ft, 0)
    }
  function Mt(gt) {
    ;(vt = gt), pt || ((pt = !0), kt())
  }
  function wt(gt, At) {
    _t = ut(function () {
      gt(s.unstable_now())
    }, At)
  }
  ;(s.unstable_IdlePriority = 5),
    (s.unstable_ImmediatePriority = 1),
    (s.unstable_LowPriority = 4),
    (s.unstable_NormalPriority = 3),
    (s.unstable_Profiling = null),
    (s.unstable_UserBlockingPriority = 2),
    (s.unstable_cancelCallback = function (gt) {
      gt.callback = null
    }),
    (s.unstable_continueExecution = function () {
      at || st || ((at = !0), Mt(dt))
    }),
    (s.unstable_forceFrameRate = function (gt) {
      0 > gt || 125 < gt
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (yt = 0 < gt ? Math.floor(1e3 / gt) : 5)
    }),
    (s.unstable_getCurrentPriorityLevel = function () {
      return tt
    }),
    (s.unstable_getFirstCallbackNode = function () {
      return a(b)
    }),
    (s.unstable_next = function (gt) {
      switch (tt) {
        case 1:
        case 2:
        case 3:
          var At = 3
          break
        default:
          At = tt
      }
      var bt = tt
      tt = At
      try {
        return gt()
      } finally {
        tt = bt
      }
    }),
    (s.unstable_pauseExecution = function () {}),
    (s.unstable_requestPaint = function () {}),
    (s.unstable_runWithPriority = function (gt, At) {
      switch (gt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break
        default:
          gt = 3
      }
      var bt = tt
      tt = gt
      try {
        return At()
      } finally {
        tt = bt
      }
    }),
    (s.unstable_scheduleCallback = function (gt, At, bt) {
      var Tt = s.unstable_now()
      switch (
        (typeof bt == "object" && bt !== null
          ? ((bt = bt.delay),
            (bt = typeof bt == "number" && 0 < bt ? Tt + bt : Tt))
          : (bt = Tt),
        gt)
      ) {
        case 1:
          var It = -1
          break
        case 2:
          It = 250
          break
        case 5:
          It = 1073741823
          break
        case 4:
          It = 1e4
          break
        default:
          It = 5e3
      }
      return (
        (It = bt + It),
        (gt = {
          id: $++,
          callback: At,
          priorityLevel: gt,
          startTime: bt,
          expirationTime: It,
          sortIndex: -1,
        }),
        bt > Tt
          ? ((gt.sortIndex = bt),
            e(j, gt),
            a(b) === null &&
              gt === a(j) &&
              (ot ? (it(_t), (_t = -1)) : (ot = !0), wt(ht, bt - Tt)))
          : ((gt.sortIndex = It), e(b, gt), at || st || ((at = !0), Mt(dt))),
        gt
      )
    }),
    (s.unstable_shouldYield = Rt),
    (s.unstable_wrapCallback = function (gt) {
      var At = tt
      return function () {
        var bt = tt
        tt = At
        try {
          return gt.apply(this, arguments)
        } finally {
          tt = bt
        }
      }
    })
})(scheduler_production_min$2)
scheduler$2.exports = scheduler_production_min$2
var schedulerExports$1 = scheduler$2.exports
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var aa = reactExports,
  ca = schedulerExports$1
function p$1(s) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + s, a = 1;
    a < arguments.length;
    a++
  )
    e += "&args[]=" + encodeURIComponent(arguments[a])
  return (
    "Minified React error #" +
    s +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  )
}
var da = new Set(),
  ea = {}
function fa(s, e) {
  ha(s, e), ha(s + "Capture", e)
}
function ha(s, e) {
  for (ea[s] = e, s = 0; s < e.length; s++) da.add(e[s])
}
var ia = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  ja = Object.prototype.hasOwnProperty,
  ka =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  la = {},
  ma = {}
function oa(s) {
  return ja.call(ma, s)
    ? !0
    : ja.call(la, s)
    ? !1
    : ka.test(s)
    ? (ma[s] = !0)
    : ((la[s] = !0), !1)
}
function pa(s, e, a, o) {
  if (a !== null && a.type === 0) return !1
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0
    case "boolean":
      return o
        ? !1
        : a !== null
        ? !a.acceptsBooleans
        : ((s = s.toLowerCase().slice(0, 5)), s !== "data-" && s !== "aria-")
    default:
      return !1
  }
}
function qa(s, e, a, o) {
  if (e === null || typeof e > "u" || pa(s, e, a, o)) return !0
  if (o) return !1
  if (a !== null)
    switch (a.type) {
      case 3:
        return !e
      case 4:
        return e === !1
      case 5:
        return isNaN(e)
      case 6:
        return isNaN(e) || 1 > e
    }
  return !1
}
function v$1(s, e, a, o, c, d, g) {
  ;(this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = o),
    (this.attributeNamespace = c),
    (this.mustUseProperty = a),
    (this.propertyName = s),
    (this.type = e),
    (this.sanitizeURL = d),
    (this.removeEmptyString = g)
}
var z = {}
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (s) {
    z[s] = new v$1(s, 0, !1, s, null, !1, !1)
  })
;[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (s) {
  var e = s[0]
  z[e] = new v$1(e, 1, !1, s[1], null, !1, !1)
})
;["contentEditable", "draggable", "spellCheck", "value"].forEach(function (s) {
  z[s] = new v$1(s, 2, !1, s.toLowerCase(), null, !1, !1)
})
;[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (s) {
  z[s] = new v$1(s, 2, !1, s, null, !1, !1)
})
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (s) {
    z[s] = new v$1(s, 3, !1, s.toLowerCase(), null, !1, !1)
  })
;["checked", "multiple", "muted", "selected"].forEach(function (s) {
  z[s] = new v$1(s, 3, !0, s, null, !1, !1)
})
;["capture", "download"].forEach(function (s) {
  z[s] = new v$1(s, 4, !1, s, null, !1, !1)
})
;["cols", "rows", "size", "span"].forEach(function (s) {
  z[s] = new v$1(s, 6, !1, s, null, !1, !1)
})
;["rowSpan", "start"].forEach(function (s) {
  z[s] = new v$1(s, 5, !1, s.toLowerCase(), null, !1, !1)
})
var ra = /[\-:]([a-z])/g
function sa(s) {
  return s[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (s) {
    var e = s.replace(ra, sa)
    z[e] = new v$1(e, 1, !1, s, null, !1, !1)
  })
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (s) {
    var e = s.replace(ra, sa)
    z[e] = new v$1(e, 1, !1, s, "http://www.w3.org/1999/xlink", !1, !1)
  })
;["xml:base", "xml:lang", "xml:space"].forEach(function (s) {
  var e = s.replace(ra, sa)
  z[e] = new v$1(e, 1, !1, s, "http://www.w3.org/XML/1998/namespace", !1, !1)
})
;["tabIndex", "crossOrigin"].forEach(function (s) {
  z[s] = new v$1(s, 1, !1, s.toLowerCase(), null, !1, !1)
})
z.xlinkHref = new v$1(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
)
;["src", "href", "action", "formAction"].forEach(function (s) {
  z[s] = new v$1(s, 1, !1, s.toLowerCase(), null, !0, !0)
})
function ta(s, e, a, o) {
  var c = z.hasOwnProperty(e) ? z[e] : null
  ;(c !== null
    ? c.type !== 0
    : o ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (qa(e, a, c, o) && (a = null),
    o || c === null
      ? oa(e) && (a === null ? s.removeAttribute(e) : s.setAttribute(e, "" + a))
      : c.mustUseProperty
      ? (s[c.propertyName] = a === null ? (c.type === 3 ? !1 : "") : a)
      : ((e = c.attributeName),
        (o = c.attributeNamespace),
        a === null
          ? s.removeAttribute(e)
          : ((c = c.type),
            (a = c === 3 || (c === 4 && a === !0) ? "" : "" + a),
            o ? s.setAttributeNS(o, e, a) : s.setAttribute(e, a))))
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  va = Symbol.for("react.element"),
  wa = Symbol.for("react.portal"),
  ya = Symbol.for("react.fragment"),
  za = Symbol.for("react.strict_mode"),
  Aa = Symbol.for("react.profiler"),
  Ba = Symbol.for("react.provider"),
  Ca = Symbol.for("react.context"),
  Da = Symbol.for("react.forward_ref"),
  Ea = Symbol.for("react.suspense"),
  Fa = Symbol.for("react.suspense_list"),
  Ga = Symbol.for("react.memo"),
  Ha = Symbol.for("react.lazy"),
  Ia = Symbol.for("react.offscreen"),
  Ja = Symbol.iterator
function Ka(s) {
  return s === null || typeof s != "object"
    ? null
    : ((s = (Ja && s[Ja]) || s["@@iterator"]),
      typeof s == "function" ? s : null)
}
var A = Object.assign,
  La
function Ma(s) {
  if (La === void 0)
    try {
      throw Error()
    } catch (a) {
      var e = a.stack.trim().match(/\n( *(at )?)/)
      La = (e && e[1]) || ""
    }
  return (
    `
` +
    La +
    s
  )
}
var Na = !1
function Oa(s, e) {
  if (!s || Na) return ""
  Na = !0
  var a = Error.prepareStackTrace
  Error.prepareStackTrace = void 0
  try {
    if (e)
      if (
        ((e = function () {
          throw Error()
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error()
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, [])
        } catch (j) {
          var o = j
        }
        Reflect.construct(s, [], e)
      } else {
        try {
          e.call()
        } catch (j) {
          o = j
        }
        s.call(e.prototype)
      }
    else {
      try {
        throw Error()
      } catch (j) {
        o = j
      }
      s()
    }
  } catch (j) {
    if (j && o && typeof j.stack == "string") {
      for (
        var c = j.stack.split(`
`),
          d = o.stack.split(`
`),
          g = c.length - 1,
          _ = d.length - 1;
        1 <= g && 0 <= _ && c[g] !== d[_];

      )
        _--
      for (; 1 <= g && 0 <= _; g--, _--)
        if (c[g] !== d[_]) {
          if (g !== 1 || _ !== 1)
            do
              if ((g--, _--, 0 > _ || c[g] !== d[_])) {
                var b =
                  `
` + c[g].replace(" at new ", " at ")
                return (
                  s.displayName &&
                    b.includes("<anonymous>") &&
                    (b = b.replace("<anonymous>", s.displayName)),
                  b
                )
              }
            while (1 <= g && 0 <= _)
          break
        }
    }
  } finally {
    ;(Na = !1), (Error.prepareStackTrace = a)
  }
  return (s = s ? s.displayName || s.name : "") ? Ma(s) : ""
}
function Pa(s) {
  switch (s.tag) {
    case 5:
      return Ma(s.type)
    case 16:
      return Ma("Lazy")
    case 13:
      return Ma("Suspense")
    case 19:
      return Ma("SuspenseList")
    case 0:
    case 2:
    case 15:
      return (s = Oa(s.type, !1)), s
    case 11:
      return (s = Oa(s.type.render, !1)), s
    case 1:
      return (s = Oa(s.type, !0)), s
    default:
      return ""
  }
}
function Qa(s) {
  if (s == null) return null
  if (typeof s == "function") return s.displayName || s.name || null
  if (typeof s == "string") return s
  switch (s) {
    case ya:
      return "Fragment"
    case wa:
      return "Portal"
    case Aa:
      return "Profiler"
    case za:
      return "StrictMode"
    case Ea:
      return "Suspense"
    case Fa:
      return "SuspenseList"
  }
  if (typeof s == "object")
    switch (s.$$typeof) {
      case Ca:
        return (s.displayName || "Context") + ".Consumer"
      case Ba:
        return (s._context.displayName || "Context") + ".Provider"
      case Da:
        var e = s.render
        return (
          (s = s.displayName),
          s ||
            ((s = e.displayName || e.name || ""),
            (s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef")),
          s
        )
      case Ga:
        return (
          (e = s.displayName || null), e !== null ? e : Qa(s.type) || "Memo"
        )
      case Ha:
        ;(e = s._payload), (s = s._init)
        try {
          return Qa(s(e))
        } catch {}
    }
  return null
}
function Ra(s) {
  var e = s.type
  switch (s.tag) {
    case 24:
      return "Cache"
    case 9:
      return (e.displayName || "Context") + ".Consumer"
    case 10:
      return (e._context.displayName || "Context") + ".Provider"
    case 18:
      return "DehydratedFragment"
    case 11:
      return (
        (s = e.render),
        (s = s.displayName || s.name || ""),
        e.displayName || (s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef")
      )
    case 7:
      return "Fragment"
    case 5:
      return e
    case 4:
      return "Portal"
    case 3:
      return "Root"
    case 6:
      return "Text"
    case 16:
      return Qa(e)
    case 8:
      return e === za ? "StrictMode" : "Mode"
    case 22:
      return "Offscreen"
    case 12:
      return "Profiler"
    case 21:
      return "Scope"
    case 13:
      return "Suspense"
    case 19:
      return "SuspenseList"
    case 25:
      return "TracingMarker"
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null
      if (typeof e == "string") return e
  }
  return null
}
function Sa(s) {
  switch (typeof s) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return s
    case "object":
      return s
    default:
      return ""
  }
}
function Ta(s) {
  var e = s.type
  return (
    (s = s.nodeName) &&
    s.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  )
}
function Ua(s) {
  var e = Ta(s) ? "checked" : "value",
    a = Object.getOwnPropertyDescriptor(s.constructor.prototype, e),
    o = "" + s[e]
  if (
    !s.hasOwnProperty(e) &&
    typeof a < "u" &&
    typeof a.get == "function" &&
    typeof a.set == "function"
  ) {
    var c = a.get,
      d = a.set
    return (
      Object.defineProperty(s, e, {
        configurable: !0,
        get: function () {
          return c.call(this)
        },
        set: function (g) {
          ;(o = "" + g), d.call(this, g)
        },
      }),
      Object.defineProperty(s, e, { enumerable: a.enumerable }),
      {
        getValue: function () {
          return o
        },
        setValue: function (g) {
          o = "" + g
        },
        stopTracking: function () {
          ;(s._valueTracker = null), delete s[e]
        },
      }
    )
  }
}
function Va(s) {
  s._valueTracker || (s._valueTracker = Ua(s))
}
function Wa(s) {
  if (!s) return !1
  var e = s._valueTracker
  if (!e) return !0
  var a = e.getValue(),
    o = ""
  return (
    s && (o = Ta(s) ? (s.checked ? "true" : "false") : s.value),
    (s = o),
    s !== a ? (e.setValue(s), !0) : !1
  )
}
function Xa(s) {
  if (((s = s || (typeof document < "u" ? document : void 0)), typeof s > "u"))
    return null
  try {
    return s.activeElement || s.body
  } catch {
    return s.body
  }
}
function Ya(s, e) {
  var a = e.checked
  return A({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: a ?? s._wrapperState.initialChecked,
  })
}
function Za(s, e) {
  var a = e.defaultValue == null ? "" : e.defaultValue,
    o = e.checked != null ? e.checked : e.defaultChecked
  ;(a = Sa(e.value != null ? e.value : a)),
    (s._wrapperState = {
      initialChecked: o,
      initialValue: a,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    })
}
function ab(s, e) {
  ;(e = e.checked), e != null && ta(s, "checked", e, !1)
}
function bb(s, e) {
  ab(s, e)
  var a = Sa(e.value),
    o = e.type
  if (a != null)
    o === "number"
      ? ((a === 0 && s.value === "") || s.value != a) && (s.value = "" + a)
      : s.value !== "" + a && (s.value = "" + a)
  else if (o === "submit" || o === "reset") {
    s.removeAttribute("value")
    return
  }
  e.hasOwnProperty("value")
    ? cb(s, e.type, a)
    : e.hasOwnProperty("defaultValue") && cb(s, e.type, Sa(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (s.defaultChecked = !!e.defaultChecked)
}
function db(s, e, a) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var o = e.type
    if (
      !(
        (o !== "submit" && o !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return
    ;(e = "" + s._wrapperState.initialValue),
      a || e === s.value || (s.value = e),
      (s.defaultValue = e)
  }
  ;(a = s.name),
    a !== "" && (s.name = ""),
    (s.defaultChecked = !!s._wrapperState.initialChecked),
    a !== "" && (s.name = a)
}
function cb(s, e, a) {
  ;(e !== "number" || Xa(s.ownerDocument) !== s) &&
    (a == null
      ? (s.defaultValue = "" + s._wrapperState.initialValue)
      : s.defaultValue !== "" + a && (s.defaultValue = "" + a))
}
var eb = Array.isArray
function fb(s, e, a, o) {
  if (((s = s.options), e)) {
    e = {}
    for (var c = 0; c < a.length; c++) e["$" + a[c]] = !0
    for (a = 0; a < s.length; a++)
      (c = e.hasOwnProperty("$" + s[a].value)),
        s[a].selected !== c && (s[a].selected = c),
        c && o && (s[a].defaultSelected = !0)
  } else {
    for (a = "" + Sa(a), e = null, c = 0; c < s.length; c++) {
      if (s[c].value === a) {
        ;(s[c].selected = !0), o && (s[c].defaultSelected = !0)
        return
      }
      e !== null || s[c].disabled || (e = s[c])
    }
    e !== null && (e.selected = !0)
  }
}
function gb(s, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(p$1(91))
  return A({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + s._wrapperState.initialValue,
  })
}
function hb(s, e) {
  var a = e.value
  if (a == null) {
    if (((a = e.children), (e = e.defaultValue), a != null)) {
      if (e != null) throw Error(p$1(92))
      if (eb(a)) {
        if (1 < a.length) throw Error(p$1(93))
        a = a[0]
      }
      e = a
    }
    e == null && (e = ""), (a = e)
  }
  s._wrapperState = { initialValue: Sa(a) }
}
function ib(s, e) {
  var a = Sa(e.value),
    o = Sa(e.defaultValue)
  a != null &&
    ((a = "" + a),
    a !== s.value && (s.value = a),
    e.defaultValue == null && s.defaultValue !== a && (s.defaultValue = a)),
    o != null && (s.defaultValue = "" + o)
}
function jb(s) {
  var e = s.textContent
  e === s._wrapperState.initialValue && e !== "" && e !== null && (s.value = e)
}
function kb(s) {
  switch (s) {
    case "svg":
      return "http://www.w3.org/2000/svg"
    case "math":
      return "http://www.w3.org/1998/Math/MathML"
    default:
      return "http://www.w3.org/1999/xhtml"
  }
}
function lb(s, e) {
  return s == null || s === "http://www.w3.org/1999/xhtml"
    ? kb(e)
    : s === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : s
}
var mb,
  nb = (function (s) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, a, o, c) {
          MSApp.execUnsafeLocalFunction(function () {
            return s(e, a, o, c)
          })
        }
      : s
  })(function (s, e) {
    if (s.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in s)
      s.innerHTML = e
    else {
      for (
        mb = mb || document.createElement("div"),
          mb.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = mb.firstChild;
        s.firstChild;

      )
        s.removeChild(s.firstChild)
      for (; e.firstChild; ) s.appendChild(e.firstChild)
    }
  })
function ob(s, e) {
  if (e) {
    var a = s.firstChild
    if (a && a === s.lastChild && a.nodeType === 3) {
      a.nodeValue = e
      return
    }
  }
  s.textContent = e
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  qb = ["Webkit", "ms", "Moz", "O"]
Object.keys(pb).forEach(function (s) {
  qb.forEach(function (e) {
    ;(e = e + s.charAt(0).toUpperCase() + s.substring(1)), (pb[e] = pb[s])
  })
})
function rb(s, e, a) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : a || typeof e != "number" || e === 0 || (pb.hasOwnProperty(s) && pb[s])
    ? ("" + e).trim()
    : e + "px"
}
function sb(s, e) {
  s = s.style
  for (var a in e)
    if (e.hasOwnProperty(a)) {
      var o = a.indexOf("--") === 0,
        c = rb(a, e[a], o)
      a === "float" && (a = "cssFloat"), o ? s.setProperty(a, c) : (s[a] = c)
    }
}
var tb = A(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
)
function ub(s, e) {
  if (e) {
    if (tb[s] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(p$1(137, s))
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(p$1(60))
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(p$1(61))
    }
    if (e.style != null && typeof e.style != "object") throw Error(p$1(62))
  }
}
function vb(s, e) {
  if (s.indexOf("-") === -1) return typeof e.is == "string"
  switch (s) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1
    default:
      return !0
  }
}
var wb = null
function xb(s) {
  return (
    (s = s.target || s.srcElement || window),
    s.correspondingUseElement && (s = s.correspondingUseElement),
    s.nodeType === 3 ? s.parentNode : s
  )
}
var yb = null,
  zb = null,
  Ab = null
function Bb(s) {
  if ((s = Cb(s))) {
    if (typeof yb != "function") throw Error(p$1(280))
    var e = s.stateNode
    e && ((e = Db(e)), yb(s.stateNode, s.type, e))
  }
}
function Eb(s) {
  zb ? (Ab ? Ab.push(s) : (Ab = [s])) : (zb = s)
}
function Fb() {
  if (zb) {
    var s = zb,
      e = Ab
    if (((Ab = zb = null), Bb(s), e)) for (s = 0; s < e.length; s++) Bb(e[s])
  }
}
function Gb(s, e) {
  return s(e)
}
function Hb() {}
var Ib = !1
function Jb(s, e, a) {
  if (Ib) return s(e, a)
  Ib = !0
  try {
    return Gb(s, e, a)
  } finally {
    ;(Ib = !1), (zb !== null || Ab !== null) && (Hb(), Fb())
  }
}
function Kb(s, e) {
  var a = s.stateNode
  if (a === null) return null
  var o = Db(a)
  if (o === null) return null
  a = o[e]
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      ;(o = !o.disabled) ||
        ((s = s.type),
        (o = !(
          s === "button" ||
          s === "input" ||
          s === "select" ||
          s === "textarea"
        ))),
        (s = !o)
      break e
    default:
      s = !1
  }
  if (s) return null
  if (a && typeof a != "function") throw Error(p$1(231, e, typeof a))
  return a
}
var Lb = !1
if (ia)
  try {
    var Mb = {}
    Object.defineProperty(Mb, "passive", {
      get: function () {
        Lb = !0
      },
    }),
      window.addEventListener("test", Mb, Mb),
      window.removeEventListener("test", Mb, Mb)
  } catch {
    Lb = !1
  }
function Nb(s, e, a, o, c, d, g, _, b) {
  var j = Array.prototype.slice.call(arguments, 3)
  try {
    e.apply(a, j)
  } catch ($) {
    this.onError($)
  }
}
var Ob = !1,
  Pb = null,
  Qb = !1,
  Rb = null,
  Sb = {
    onError: function (s) {
      ;(Ob = !0), (Pb = s)
    },
  }
function Tb(s, e, a, o, c, d, g, _, b) {
  ;(Ob = !1), (Pb = null), Nb.apply(Sb, arguments)
}
function Ub(s, e, a, o, c, d, g, _, b) {
  if ((Tb.apply(this, arguments), Ob)) {
    if (Ob) {
      var j = Pb
      ;(Ob = !1), (Pb = null)
    } else throw Error(p$1(198))
    Qb || ((Qb = !0), (Rb = j))
  }
}
function Vb(s) {
  var e = s,
    a = s
  if (s.alternate) for (; e.return; ) e = e.return
  else {
    s = e
    do (e = s), e.flags & 4098 && (a = e.return), (s = e.return)
    while (s)
  }
  return e.tag === 3 ? a : null
}
function Wb(s) {
  if (s.tag === 13) {
    var e = s.memoizedState
    if (
      (e === null && ((s = s.alternate), s !== null && (e = s.memoizedState)),
      e !== null)
    )
      return e.dehydrated
  }
  return null
}
function Xb(s) {
  if (Vb(s) !== s) throw Error(p$1(188))
}
function Yb(s) {
  var e = s.alternate
  if (!e) {
    if (((e = Vb(s)), e === null)) throw Error(p$1(188))
    return e !== s ? null : s
  }
  for (var a = s, o = e; ; ) {
    var c = a.return
    if (c === null) break
    var d = c.alternate
    if (d === null) {
      if (((o = c.return), o !== null)) {
        a = o
        continue
      }
      break
    }
    if (c.child === d.child) {
      for (d = c.child; d; ) {
        if (d === a) return Xb(c), s
        if (d === o) return Xb(c), e
        d = d.sibling
      }
      throw Error(p$1(188))
    }
    if (a.return !== o.return) (a = c), (o = d)
    else {
      for (var g = !1, _ = c.child; _; ) {
        if (_ === a) {
          ;(g = !0), (a = c), (o = d)
          break
        }
        if (_ === o) {
          ;(g = !0), (o = c), (a = d)
          break
        }
        _ = _.sibling
      }
      if (!g) {
        for (_ = d.child; _; ) {
          if (_ === a) {
            ;(g = !0), (a = d), (o = c)
            break
          }
          if (_ === o) {
            ;(g = !0), (o = d), (a = c)
            break
          }
          _ = _.sibling
        }
        if (!g) throw Error(p$1(189))
      }
    }
    if (a.alternate !== o) throw Error(p$1(190))
  }
  if (a.tag !== 3) throw Error(p$1(188))
  return a.stateNode.current === a ? s : e
}
function Zb(s) {
  return (s = Yb(s)), s !== null ? $b(s) : null
}
function $b(s) {
  if (s.tag === 5 || s.tag === 6) return s
  for (s = s.child; s !== null; ) {
    var e = $b(s)
    if (e !== null) return e
    s = s.sibling
  }
  return null
}
var ac = ca.unstable_scheduleCallback,
  bc = ca.unstable_cancelCallback,
  cc = ca.unstable_shouldYield,
  dc = ca.unstable_requestPaint,
  B = ca.unstable_now,
  ec = ca.unstable_getCurrentPriorityLevel,
  fc = ca.unstable_ImmediatePriority,
  gc = ca.unstable_UserBlockingPriority,
  hc = ca.unstable_NormalPriority,
  ic = ca.unstable_LowPriority,
  jc = ca.unstable_IdlePriority,
  kc = null,
  lc = null
function mc(s) {
  if (lc && typeof lc.onCommitFiberRoot == "function")
    try {
      lc.onCommitFiberRoot(kc, s, void 0, (s.current.flags & 128) === 128)
    } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc,
  pc = Math.log,
  qc = Math.LN2
function nc(s) {
  return (s >>>= 0), s === 0 ? 32 : (31 - ((pc(s) / qc) | 0)) | 0
}
var rc = 64,
  sc = 4194304
function tc(s) {
  switch (s & -s) {
    case 1:
      return 1
    case 2:
      return 2
    case 4:
      return 4
    case 8:
      return 8
    case 16:
      return 16
    case 32:
      return 32
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return s & 4194240
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return s & 130023424
    case 134217728:
      return 134217728
    case 268435456:
      return 268435456
    case 536870912:
      return 536870912
    case 1073741824:
      return 1073741824
    default:
      return s
  }
}
function uc(s, e) {
  var a = s.pendingLanes
  if (a === 0) return 0
  var o = 0,
    c = s.suspendedLanes,
    d = s.pingedLanes,
    g = a & 268435455
  if (g !== 0) {
    var _ = g & ~c
    _ !== 0 ? (o = tc(_)) : ((d &= g), d !== 0 && (o = tc(d)))
  } else (g = a & ~c), g !== 0 ? (o = tc(g)) : d !== 0 && (o = tc(d))
  if (o === 0) return 0
  if (
    e !== 0 &&
    e !== o &&
    !(e & c) &&
    ((c = o & -o), (d = e & -e), c >= d || (c === 16 && (d & 4194240) !== 0))
  )
    return e
  if ((o & 4 && (o |= a & 16), (e = s.entangledLanes), e !== 0))
    for (s = s.entanglements, e &= o; 0 < e; )
      (a = 31 - oc(e)), (c = 1 << a), (o |= s[a]), (e &= ~c)
  return o
}
function vc(s, e) {
  switch (s) {
    case 1:
    case 2:
    case 4:
      return e + 250
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1
    default:
      return -1
  }
}
function wc(s, e) {
  for (
    var a = s.suspendedLanes,
      o = s.pingedLanes,
      c = s.expirationTimes,
      d = s.pendingLanes;
    0 < d;

  ) {
    var g = 31 - oc(d),
      _ = 1 << g,
      b = c[g]
    b === -1
      ? (!(_ & a) || _ & o) && (c[g] = vc(_, e))
      : b <= e && (s.expiredLanes |= _),
      (d &= ~_)
  }
}
function xc(s) {
  return (
    (s = s.pendingLanes & -1073741825),
    s !== 0 ? s : s & 1073741824 ? 1073741824 : 0
  )
}
function yc() {
  var s = rc
  return (rc <<= 1), !(rc & 4194240) && (rc = 64), s
}
function zc(s) {
  for (var e = [], a = 0; 31 > a; a++) e.push(s)
  return e
}
function Ac(s, e, a) {
  ;(s.pendingLanes |= e),
    e !== 536870912 && ((s.suspendedLanes = 0), (s.pingedLanes = 0)),
    (s = s.eventTimes),
    (e = 31 - oc(e)),
    (s[e] = a)
}
function Bc(s, e) {
  var a = s.pendingLanes & ~e
  ;(s.pendingLanes = e),
    (s.suspendedLanes = 0),
    (s.pingedLanes = 0),
    (s.expiredLanes &= e),
    (s.mutableReadLanes &= e),
    (s.entangledLanes &= e),
    (e = s.entanglements)
  var o = s.eventTimes
  for (s = s.expirationTimes; 0 < a; ) {
    var c = 31 - oc(a),
      d = 1 << c
    ;(e[c] = 0), (o[c] = -1), (s[c] = -1), (a &= ~d)
  }
}
function Cc(s, e) {
  var a = (s.entangledLanes |= e)
  for (s = s.entanglements; a; ) {
    var o = 31 - oc(a),
      c = 1 << o
    ;(c & e) | (s[o] & e) && (s[o] |= e), (a &= ~c)
  }
}
var C = 0
function Dc(s) {
  return (s &= -s), 1 < s ? (4 < s ? (s & 268435455 ? 16 : 536870912) : 4) : 1
}
var Ec,
  Fc,
  Gc,
  Hc,
  Ic,
  Jc = !1,
  Kc = [],
  Lc = null,
  Mc = null,
  Nc = null,
  Oc = new Map(),
  Pc = new Map(),
  Qc = [],
  Rc =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    )
function Sc(s, e) {
  switch (s) {
    case "focusin":
    case "focusout":
      Lc = null
      break
    case "dragenter":
    case "dragleave":
      Mc = null
      break
    case "mouseover":
    case "mouseout":
      Nc = null
      break
    case "pointerover":
    case "pointerout":
      Oc.delete(e.pointerId)
      break
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(e.pointerId)
  }
}
function Tc(s, e, a, o, c, d) {
  return s === null || s.nativeEvent !== d
    ? ((s = {
        blockedOn: e,
        domEventName: a,
        eventSystemFlags: o,
        nativeEvent: d,
        targetContainers: [c],
      }),
      e !== null && ((e = Cb(e)), e !== null && Fc(e)),
      s)
    : ((s.eventSystemFlags |= o),
      (e = s.targetContainers),
      c !== null && e.indexOf(c) === -1 && e.push(c),
      s)
}
function Uc(s, e, a, o, c) {
  switch (e) {
    case "focusin":
      return (Lc = Tc(Lc, s, e, a, o, c)), !0
    case "dragenter":
      return (Mc = Tc(Mc, s, e, a, o, c)), !0
    case "mouseover":
      return (Nc = Tc(Nc, s, e, a, o, c)), !0
    case "pointerover":
      var d = c.pointerId
      return Oc.set(d, Tc(Oc.get(d) || null, s, e, a, o, c)), !0
    case "gotpointercapture":
      return (
        (d = c.pointerId), Pc.set(d, Tc(Pc.get(d) || null, s, e, a, o, c)), !0
      )
  }
  return !1
}
function Vc(s) {
  var e = Wc(s.target)
  if (e !== null) {
    var a = Vb(e)
    if (a !== null) {
      if (((e = a.tag), e === 13)) {
        if (((e = Wb(a)), e !== null)) {
          ;(s.blockedOn = e),
            Ic(s.priority, function () {
              Gc(a)
            })
          return
        }
      } else if (e === 3 && a.stateNode.current.memoizedState.isDehydrated) {
        s.blockedOn = a.tag === 3 ? a.stateNode.containerInfo : null
        return
      }
    }
  }
  s.blockedOn = null
}
function Xc(s) {
  if (s.blockedOn !== null) return !1
  for (var e = s.targetContainers; 0 < e.length; ) {
    var a = Yc(s.domEventName, s.eventSystemFlags, e[0], s.nativeEvent)
    if (a === null) {
      a = s.nativeEvent
      var o = new a.constructor(a.type, a)
      ;(wb = o), a.target.dispatchEvent(o), (wb = null)
    } else return (e = Cb(a)), e !== null && Fc(e), (s.blockedOn = a), !1
    e.shift()
  }
  return !0
}
function Zc(s, e, a) {
  Xc(s) && a.delete(e)
}
function $c() {
  ;(Jc = !1),
    Lc !== null && Xc(Lc) && (Lc = null),
    Mc !== null && Xc(Mc) && (Mc = null),
    Nc !== null && Xc(Nc) && (Nc = null),
    Oc.forEach(Zc),
    Pc.forEach(Zc)
}
function ad(s, e) {
  s.blockedOn === e &&
    ((s.blockedOn = null),
    Jc ||
      ((Jc = !0), ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
}
function bd(s) {
  function e(c) {
    return ad(c, s)
  }
  if (0 < Kc.length) {
    ad(Kc[0], s)
    for (var a = 1; a < Kc.length; a++) {
      var o = Kc[a]
      o.blockedOn === s && (o.blockedOn = null)
    }
  }
  for (
    Lc !== null && ad(Lc, s),
      Mc !== null && ad(Mc, s),
      Nc !== null && ad(Nc, s),
      Oc.forEach(e),
      Pc.forEach(e),
      a = 0;
    a < Qc.length;
    a++
  )
    (o = Qc[a]), o.blockedOn === s && (o.blockedOn = null)
  for (; 0 < Qc.length && ((a = Qc[0]), a.blockedOn === null); )
    Vc(a), a.blockedOn === null && Qc.shift()
}
var cd = ua.ReactCurrentBatchConfig,
  dd = !0
function ed(s, e, a, o) {
  var c = C,
    d = cd.transition
  cd.transition = null
  try {
    ;(C = 1), fd$1(s, e, a, o)
  } finally {
    ;(C = c), (cd.transition = d)
  }
}
function gd(s, e, a, o) {
  var c = C,
    d = cd.transition
  cd.transition = null
  try {
    ;(C = 4), fd$1(s, e, a, o)
  } finally {
    ;(C = c), (cd.transition = d)
  }
}
function fd$1(s, e, a, o) {
  if (dd) {
    var c = Yc(s, e, a, o)
    if (c === null) hd(s, e, o, id$2, a), Sc(s, o)
    else if (Uc(c, s, e, a, o)) o.stopPropagation()
    else if ((Sc(s, o), e & 4 && -1 < Rc.indexOf(s))) {
      for (; c !== null; ) {
        var d = Cb(c)
        if (
          (d !== null && Ec(d),
          (d = Yc(s, e, a, o)),
          d === null && hd(s, e, o, id$2, a),
          d === c)
        )
          break
        c = d
      }
      c !== null && o.stopPropagation()
    } else hd(s, e, o, null, a)
  }
}
var id$2 = null
function Yc(s, e, a, o) {
  if (((id$2 = null), (s = xb(o)), (s = Wc(s)), s !== null))
    if (((e = Vb(s)), e === null)) s = null
    else if (((a = e.tag), a === 13)) {
      if (((s = Wb(e)), s !== null)) return s
      s = null
    } else if (a === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null
      s = null
    } else e !== s && (s = null)
  return (id$2 = s), null
}
function jd(s) {
  switch (s) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4
    case "message":
      switch (ec()) {
        case fc:
          return 1
        case gc:
          return 4
        case hc:
        case ic:
          return 16
        case jc:
          return 536870912
        default:
          return 16
      }
    default:
      return 16
  }
}
var kd = null,
  ld = null,
  md = null
function nd() {
  if (md) return md
  var s,
    e = ld,
    a = e.length,
    o,
    c = "value" in kd ? kd.value : kd.textContent,
    d = c.length
  for (s = 0; s < a && e[s] === c[s]; s++);
  var g = a - s
  for (o = 1; o <= g && e[a - o] === c[d - o]; o++);
  return (md = c.slice(s, 1 < o ? 1 - o : void 0))
}
function od(s) {
  var e = s.keyCode
  return (
    "charCode" in s
      ? ((s = s.charCode), s === 0 && e === 13 && (s = 13))
      : (s = e),
    s === 10 && (s = 13),
    32 <= s || s === 13 ? s : 0
  )
}
function pd() {
  return !0
}
function qd() {
  return !1
}
function rd(s) {
  function e(a, o, c, d, g) {
    ;(this._reactName = a),
      (this._targetInst = c),
      (this.type = o),
      (this.nativeEvent = d),
      (this.target = g),
      (this.currentTarget = null)
    for (var _ in s)
      s.hasOwnProperty(_) && ((a = s[_]), (this[_] = a ? a(d) : d[_]))
    return (
      (this.isDefaultPrevented = (
        d.defaultPrevented != null ? d.defaultPrevented : d.returnValue === !1
      )
        ? pd
        : qd),
      (this.isPropagationStopped = qd),
      this
    )
  }
  return (
    A(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0
        var a = this.nativeEvent
        a &&
          (a.preventDefault
            ? a.preventDefault()
            : typeof a.returnValue != "unknown" && (a.returnValue = !1),
          (this.isDefaultPrevented = pd))
      },
      stopPropagation: function () {
        var a = this.nativeEvent
        a &&
          (a.stopPropagation
            ? a.stopPropagation()
            : typeof a.cancelBubble != "unknown" && (a.cancelBubble = !0),
          (this.isPropagationStopped = pd))
      },
      persist: function () {},
      isPersistent: pd,
    }),
    e
  )
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (s) {
      return s.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  td$1 = rd(sd),
  ud = A({}, sd, { view: 0, detail: 0 }),
  vd = rd(ud),
  wd,
  xd,
  yd,
  Ad = A({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function (s) {
      return s.relatedTarget === void 0
        ? s.fromElement === s.srcElement
          ? s.toElement
          : s.fromElement
        : s.relatedTarget
    },
    movementX: function (s) {
      return "movementX" in s
        ? s.movementX
        : (s !== yd &&
            (yd && s.type === "mousemove"
              ? ((wd = s.screenX - yd.screenX), (xd = s.screenY - yd.screenY))
              : (xd = wd = 0),
            (yd = s)),
          wd)
    },
    movementY: function (s) {
      return "movementY" in s ? s.movementY : xd
    },
  }),
  Bd = rd(Ad),
  Cd = A({}, Ad, { dataTransfer: 0 }),
  Dd = rd(Cd),
  Ed = A({}, ud, { relatedTarget: 0 }),
  Fd = rd(Ed),
  Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Hd = rd(Gd),
  Id = A({}, sd, {
    clipboardData: function (s) {
      return "clipboardData" in s ? s.clipboardData : window.clipboardData
    },
  }),
  Jd = rd(Id),
  Kd = A({}, sd, { data: 0 }),
  Ld = rd(Kd),
  Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }
function Pd(s) {
  var e = this.nativeEvent
  return e.getModifierState ? e.getModifierState(s) : (s = Od[s]) ? !!e[s] : !1
}
function zd() {
  return Pd
}
var Qd = A({}, ud, {
    key: function (s) {
      if (s.key) {
        var e = Md[s.key] || s.key
        if (e !== "Unidentified") return e
      }
      return s.type === "keypress"
        ? ((s = od(s)), s === 13 ? "Enter" : String.fromCharCode(s))
        : s.type === "keydown" || s.type === "keyup"
        ? Nd[s.keyCode] || "Unidentified"
        : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function (s) {
      return s.type === "keypress" ? od(s) : 0
    },
    keyCode: function (s) {
      return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0
    },
    which: function (s) {
      return s.type === "keypress"
        ? od(s)
        : s.type === "keydown" || s.type === "keyup"
        ? s.keyCode
        : 0
    },
  }),
  Rd = rd(Qd),
  Sd = A({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  Td = rd(Sd),
  Ud = A({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd,
  }),
  Vd = rd(Ud),
  Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Xd = rd(Wd),
  Yd = A({}, Ad, {
    deltaX: function (s) {
      return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0
    },
    deltaY: function (s) {
      return "deltaY" in s
        ? s.deltaY
        : "wheelDeltaY" in s
        ? -s.wheelDeltaY
        : "wheelDelta" in s
        ? -s.wheelDelta
        : 0
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  Zd = rd(Yd),
  $d = [9, 13, 27, 32],
  ae = ia && "CompositionEvent" in window,
  be = null
ia && "documentMode" in document && (be = document.documentMode)
var ce = ia && "TextEvent" in window && !be,
  de = ia && (!ae || (be && 8 < be && 11 >= be)),
  ee = String.fromCharCode(32),
  fe = !1
function ge(s, e) {
  switch (s) {
    case "keyup":
      return $d.indexOf(e.keyCode) !== -1
    case "keydown":
      return e.keyCode !== 229
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0
    default:
      return !1
  }
}
function he(s) {
  return (s = s.detail), typeof s == "object" && "data" in s ? s.data : null
}
var ie = !1
function je(s, e) {
  switch (s) {
    case "compositionend":
      return he(e)
    case "keypress":
      return e.which !== 32 ? null : ((fe = !0), ee)
    case "textInput":
      return (s = e.data), s === ee && fe ? null : s
    default:
      return null
  }
}
function ke(s, e) {
  if (ie)
    return s === "compositionend" || (!ae && ge(s, e))
      ? ((s = nd()), (md = ld = kd = null), (ie = !1), s)
      : null
  switch (s) {
    case "paste":
      return null
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char
        if (e.which) return String.fromCharCode(e.which)
      }
      return null
    case "compositionend":
      return de && e.locale !== "ko" ? null : e.data
    default:
      return null
  }
}
var le = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
}
function me(s) {
  var e = s && s.nodeName && s.nodeName.toLowerCase()
  return e === "input" ? !!le[s.type] : e === "textarea"
}
function ne(s, e, a, o) {
  Eb(o),
    (e = oe(e, "onChange")),
    0 < e.length &&
      ((a = new td$1("onChange", "change", null, a, o)),
      s.push({ event: a, listeners: e }))
}
var pe = null,
  qe = null
function re(s) {
  se(s, 0)
}
function te(s) {
  var e = ue(s)
  if (Wa(e)) return s
}
function ve(s, e) {
  if (s === "change") return e
}
var we = !1
if (ia) {
  var xe
  if (ia) {
    var ye = "oninput" in document
    if (!ye) {
      var ze = document.createElement("div")
      ze.setAttribute("oninput", "return;"),
        (ye = typeof ze.oninput == "function")
    }
    xe = ye
  } else xe = !1
  we = xe && (!document.documentMode || 9 < document.documentMode)
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), (qe = pe = null))
}
function Be(s) {
  if (s.propertyName === "value" && te(qe)) {
    var e = []
    ne(e, qe, s, xb(s)), Jb(re, e)
  }
}
function Ce(s, e, a) {
  s === "focusin"
    ? (Ae(), (pe = e), (qe = a), pe.attachEvent("onpropertychange", Be))
    : s === "focusout" && Ae()
}
function De(s) {
  if (s === "selectionchange" || s === "keyup" || s === "keydown") return te(qe)
}
function Ee(s, e) {
  if (s === "click") return te(e)
}
function Fe(s, e) {
  if (s === "input" || s === "change") return te(e)
}
function Ge(s, e) {
  return (s === e && (s !== 0 || 1 / s === 1 / e)) || (s !== s && e !== e)
}
var He = typeof Object.is == "function" ? Object.is : Ge
function Ie(s, e) {
  if (He(s, e)) return !0
  if (typeof s != "object" || s === null || typeof e != "object" || e === null)
    return !1
  var a = Object.keys(s),
    o = Object.keys(e)
  if (a.length !== o.length) return !1
  for (o = 0; o < a.length; o++) {
    var c = a[o]
    if (!ja.call(e, c) || !He(s[c], e[c])) return !1
  }
  return !0
}
function Je(s) {
  for (; s && s.firstChild; ) s = s.firstChild
  return s
}
function Ke(s, e) {
  var a = Je(s)
  s = 0
  for (var o; a; ) {
    if (a.nodeType === 3) {
      if (((o = s + a.textContent.length), s <= e && o >= e))
        return { node: a, offset: e - s }
      s = o
    }
    e: {
      for (; a; ) {
        if (a.nextSibling) {
          a = a.nextSibling
          break e
        }
        a = a.parentNode
      }
      a = void 0
    }
    a = Je(a)
  }
}
function Le(s, e) {
  return s && e
    ? s === e
      ? !0
      : s && s.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? Le(s, e.parentNode)
      : "contains" in s
      ? s.contains(e)
      : s.compareDocumentPosition
      ? !!(s.compareDocumentPosition(e) & 16)
      : !1
    : !1
}
function Me() {
  for (var s = window, e = Xa(); e instanceof s.HTMLIFrameElement; ) {
    try {
      var a = typeof e.contentWindow.location.href == "string"
    } catch {
      a = !1
    }
    if (a) s = e.contentWindow
    else break
    e = Xa(s.document)
  }
  return e
}
function Ne(s) {
  var e = s && s.nodeName && s.nodeName.toLowerCase()
  return (
    e &&
    ((e === "input" &&
      (s.type === "text" ||
        s.type === "search" ||
        s.type === "tel" ||
        s.type === "url" ||
        s.type === "password")) ||
      e === "textarea" ||
      s.contentEditable === "true")
  )
}
function Oe(s) {
  var e = Me(),
    a = s.focusedElem,
    o = s.selectionRange
  if (
    e !== a &&
    a &&
    a.ownerDocument &&
    Le(a.ownerDocument.documentElement, a)
  ) {
    if (o !== null && Ne(a)) {
      if (
        ((e = o.start),
        (s = o.end),
        s === void 0 && (s = e),
        "selectionStart" in a)
      )
        (a.selectionStart = e), (a.selectionEnd = Math.min(s, a.value.length))
      else if (
        ((s = ((e = a.ownerDocument || document) && e.defaultView) || window),
        s.getSelection)
      ) {
        s = s.getSelection()
        var c = a.textContent.length,
          d = Math.min(o.start, c)
        ;(o = o.end === void 0 ? d : Math.min(o.end, c)),
          !s.extend && d > o && ((c = o), (o = d), (d = c)),
          (c = Ke(a, d))
        var g = Ke(a, o)
        c &&
          g &&
          (s.rangeCount !== 1 ||
            s.anchorNode !== c.node ||
            s.anchorOffset !== c.offset ||
            s.focusNode !== g.node ||
            s.focusOffset !== g.offset) &&
          ((e = e.createRange()),
          e.setStart(c.node, c.offset),
          s.removeAllRanges(),
          d > o
            ? (s.addRange(e), s.extend(g.node, g.offset))
            : (e.setEnd(g.node, g.offset), s.addRange(e)))
      }
    }
    for (e = [], s = a; (s = s.parentNode); )
      s.nodeType === 1 &&
        e.push({ element: s, left: s.scrollLeft, top: s.scrollTop })
    for (typeof a.focus == "function" && a.focus(), a = 0; a < e.length; a++)
      (s = e[a]), (s.element.scrollLeft = s.left), (s.element.scrollTop = s.top)
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
  Qe = null,
  Re = null,
  Se = null,
  Te = !1
function Ue(s, e, a) {
  var o = a.window === a ? a.document : a.nodeType === 9 ? a : a.ownerDocument
  Te ||
    Qe == null ||
    Qe !== Xa(o) ||
    ((o = Qe),
    "selectionStart" in o && Ne(o)
      ? (o = { start: o.selectionStart, end: o.selectionEnd })
      : ((o = (
          (o.ownerDocument && o.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (o = {
          anchorNode: o.anchorNode,
          anchorOffset: o.anchorOffset,
          focusNode: o.focusNode,
          focusOffset: o.focusOffset,
        })),
    (Se && Ie(Se, o)) ||
      ((Se = o),
      (o = oe(Re, "onSelect")),
      0 < o.length &&
        ((e = new td$1("onSelect", "select", null, e, a)),
        s.push({ event: e, listeners: o }),
        (e.target = Qe))))
}
function Ve(s, e) {
  var a = {}
  return (
    (a[s.toLowerCase()] = e.toLowerCase()),
    (a["Webkit" + s] = "webkit" + e),
    (a["Moz" + s] = "moz" + e),
    a
  )
}
var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd"),
  },
  Xe = {},
  Ye = {}
ia &&
  ((Ye = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete We.animationend.animation,
    delete We.animationiteration.animation,
    delete We.animationstart.animation),
  "TransitionEvent" in window || delete We.transitionend.transition)
function Ze(s) {
  if (Xe[s]) return Xe[s]
  if (!We[s]) return s
  var e = We[s],
    a
  for (a in e) if (e.hasOwnProperty(a) && a in Ye) return (Xe[s] = e[a])
  return s
}
var $e = Ze("animationend"),
  af = Ze("animationiteration"),
  bf = Ze("animationstart"),
  cf = Ze("transitionend"),
  df = new Map(),
  ef =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    )
function ff(s, e) {
  df.set(s, e), fa(e, [s])
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf],
    jf = hf.toLowerCase(),
    kf = hf[0].toUpperCase() + hf.slice(1)
  ff(jf, "on" + kf)
}
ff($e, "onAnimationEnd")
ff(af, "onAnimationIteration")
ff(bf, "onAnimationStart")
ff("dblclick", "onDoubleClick")
ff("focusin", "onFocus")
ff("focusout", "onBlur")
ff(cf, "onTransitionEnd")
ha("onMouseEnter", ["mouseout", "mouseover"])
ha("onMouseLeave", ["mouseout", "mouseover"])
ha("onPointerEnter", ["pointerout", "pointerover"])
ha("onPointerLeave", ["pointerout", "pointerover"])
fa(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
)
fa(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
)
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"])
fa(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
)
fa(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
)
fa(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
)
var lf =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf))
function nf(s, e, a) {
  var o = s.type || "unknown-event"
  ;(s.currentTarget = a), Ub(o, e, void 0, s), (s.currentTarget = null)
}
function se(s, e) {
  e = (e & 4) !== 0
  for (var a = 0; a < s.length; a++) {
    var o = s[a],
      c = o.event
    o = o.listeners
    e: {
      var d = void 0
      if (e)
        for (var g = o.length - 1; 0 <= g; g--) {
          var _ = o[g],
            b = _.instance,
            j = _.currentTarget
          if (((_ = _.listener), b !== d && c.isPropagationStopped())) break e
          nf(c, _, j), (d = b)
        }
      else
        for (g = 0; g < o.length; g++) {
          if (
            ((_ = o[g]),
            (b = _.instance),
            (j = _.currentTarget),
            (_ = _.listener),
            b !== d && c.isPropagationStopped())
          )
            break e
          nf(c, _, j), (d = b)
        }
    }
  }
  if (Qb) throw ((s = Rb), (Qb = !1), (Rb = null), s)
}
function D(s, e) {
  var a = e[of]
  a === void 0 && (a = e[of] = new Set())
  var o = s + "__bubble"
  a.has(o) || (pf(e, s, 2, !1), a.add(o))
}
function qf(s, e, a) {
  var o = 0
  e && (o |= 4), pf(a, s, o, e)
}
var rf = "_reactListening" + Math.random().toString(36).slice(2)
function sf(s) {
  if (!s[rf]) {
    ;(s[rf] = !0),
      da.forEach(function (a) {
        a !== "selectionchange" && (mf.has(a) || qf(a, !1, s), qf(a, !0, s))
      })
    var e = s.nodeType === 9 ? s : s.ownerDocument
    e === null || e[rf] || ((e[rf] = !0), qf("selectionchange", !1, e))
  }
}
function pf(s, e, a, o) {
  switch (jd(e)) {
    case 1:
      var c = ed
      break
    case 4:
      c = gd
      break
    default:
      c = fd$1
  }
  ;(a = c.bind(null, e, a, s)),
    (c = void 0),
    !Lb ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (c = !0),
    o
      ? c !== void 0
        ? s.addEventListener(e, a, { capture: !0, passive: c })
        : s.addEventListener(e, a, !0)
      : c !== void 0
      ? s.addEventListener(e, a, { passive: c })
      : s.addEventListener(e, a, !1)
}
function hd(s, e, a, o, c) {
  var d = o
  if (!(e & 1) && !(e & 2) && o !== null)
    e: for (;;) {
      if (o === null) return
      var g = o.tag
      if (g === 3 || g === 4) {
        var _ = o.stateNode.containerInfo
        if (_ === c || (_.nodeType === 8 && _.parentNode === c)) break
        if (g === 4)
          for (g = o.return; g !== null; ) {
            var b = g.tag
            if (
              (b === 3 || b === 4) &&
              ((b = g.stateNode.containerInfo),
              b === c || (b.nodeType === 8 && b.parentNode === c))
            )
              return
            g = g.return
          }
        for (; _ !== null; ) {
          if (((g = Wc(_)), g === null)) return
          if (((b = g.tag), b === 5 || b === 6)) {
            o = d = g
            continue e
          }
          _ = _.parentNode
        }
      }
      o = o.return
    }
  Jb(function () {
    var j = d,
      $ = xb(a),
      _e = []
    e: {
      var tt = df.get(s)
      if (tt !== void 0) {
        var st = td$1,
          at = s
        switch (s) {
          case "keypress":
            if (od(a) === 0) break e
          case "keydown":
          case "keyup":
            st = Rd
            break
          case "focusin":
            ;(at = "focus"), (st = Fd)
            break
          case "focusout":
            ;(at = "blur"), (st = Fd)
            break
          case "beforeblur":
          case "afterblur":
            st = Fd
            break
          case "click":
            if (a.button === 2) break e
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            st = Bd
            break
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            st = Dd
            break
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            st = Vd
            break
          case $e:
          case af:
          case bf:
            st = Hd
            break
          case cf:
            st = Xd
            break
          case "scroll":
            st = vd
            break
          case "wheel":
            st = Zd
            break
          case "copy":
          case "cut":
          case "paste":
            st = Jd
            break
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            st = Td
        }
        var ot = (e & 4) !== 0,
          ut = !ot && s === "scroll",
          it = ot ? (tt !== null ? tt + "Capture" : null) : tt
        ot = []
        for (var ct = j, lt; ct !== null; ) {
          lt = ct
          var ht = lt.stateNode
          if (
            (lt.tag === 5 &&
              ht !== null &&
              ((lt = ht),
              it !== null &&
                ((ht = Kb(ct, it)), ht != null && ot.push(tf(ct, ht, lt)))),
            ut)
          )
            break
          ct = ct.return
        }
        0 < ot.length &&
          ((tt = new st(tt, at, null, a, $)),
          _e.push({ event: tt, listeners: ot }))
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((tt = s === "mouseover" || s === "pointerover"),
          (st = s === "mouseout" || s === "pointerout"),
          tt &&
            a !== wb &&
            (at = a.relatedTarget || a.fromElement) &&
            (Wc(at) || at[uf]))
        )
          break e
        if (
          (st || tt) &&
          ((tt =
            $.window === $
              ? $
              : (tt = $.ownerDocument)
              ? tt.defaultView || tt.parentWindow
              : window),
          st
            ? ((at = a.relatedTarget || a.toElement),
              (st = j),
              (at = at ? Wc(at) : null),
              at !== null &&
                ((ut = Vb(at)), at !== ut || (at.tag !== 5 && at.tag !== 6)) &&
                (at = null))
            : ((st = null), (at = j)),
          st !== at)
        ) {
          if (
            ((ot = Bd),
            (ht = "onMouseLeave"),
            (it = "onMouseEnter"),
            (ct = "mouse"),
            (s === "pointerout" || s === "pointerover") &&
              ((ot = Td),
              (ht = "onPointerLeave"),
              (it = "onPointerEnter"),
              (ct = "pointer")),
            (ut = st == null ? tt : ue(st)),
            (lt = at == null ? tt : ue(at)),
            (tt = new ot(ht, ct + "leave", st, a, $)),
            (tt.target = ut),
            (tt.relatedTarget = lt),
            (ht = null),
            Wc($) === j &&
              ((ot = new ot(it, ct + "enter", at, a, $)),
              (ot.target = lt),
              (ot.relatedTarget = ut),
              (ht = ot)),
            (ut = ht),
            st && at)
          )
            t: {
              for (ot = st, it = at, ct = 0, lt = ot; lt; lt = vf(lt)) ct++
              for (lt = 0, ht = it; ht; ht = vf(ht)) lt++
              for (; 0 < ct - lt; ) (ot = vf(ot)), ct--
              for (; 0 < lt - ct; ) (it = vf(it)), lt--
              for (; ct--; ) {
                if (ot === it || (it !== null && ot === it.alternate)) break t
                ;(ot = vf(ot)), (it = vf(it))
              }
              ot = null
            }
          else ot = null
          st !== null && wf(_e, tt, st, ot, !1),
            at !== null && ut !== null && wf(_e, ut, at, ot, !0)
        }
      }
      e: {
        if (
          ((tt = j ? ue(j) : window),
          (st = tt.nodeName && tt.nodeName.toLowerCase()),
          st === "select" || (st === "input" && tt.type === "file"))
        )
          var dt = ve
        else if (me(tt))
          if (we) dt = Fe
          else {
            dt = De
            var pt = Ce
          }
        else
          (st = tt.nodeName) &&
            st.toLowerCase() === "input" &&
            (tt.type === "checkbox" || tt.type === "radio") &&
            (dt = Ee)
        if (dt && (dt = dt(s, j))) {
          ne(_e, dt, a, $)
          break e
        }
        pt && pt(s, tt, j),
          s === "focusout" &&
            (pt = tt._wrapperState) &&
            pt.controlled &&
            tt.type === "number" &&
            cb(tt, "number", tt.value)
      }
      switch (((pt = j ? ue(j) : window), s)) {
        case "focusin":
          ;(me(pt) || pt.contentEditable === "true") &&
            ((Qe = pt), (Re = j), (Se = null))
          break
        case "focusout":
          Se = Re = Qe = null
          break
        case "mousedown":
          Te = !0
          break
        case "contextmenu":
        case "mouseup":
        case "dragend":
          ;(Te = !1), Ue(_e, a, $)
          break
        case "selectionchange":
          if (Pe) break
        case "keydown":
        case "keyup":
          Ue(_e, a, $)
      }
      var vt
      if (ae)
        e: {
          switch (s) {
            case "compositionstart":
              var _t = "onCompositionStart"
              break e
            case "compositionend":
              _t = "onCompositionEnd"
              break e
            case "compositionupdate":
              _t = "onCompositionUpdate"
              break e
          }
          _t = void 0
        }
      else
        ie
          ? ge(s, a) && (_t = "onCompositionEnd")
          : s === "keydown" && a.keyCode === 229 && (_t = "onCompositionStart")
      _t &&
        (de &&
          a.locale !== "ko" &&
          (ie || _t !== "onCompositionStart"
            ? _t === "onCompositionEnd" && ie && (vt = nd())
            : ((kd = $),
              (ld = "value" in kd ? kd.value : kd.textContent),
              (ie = !0))),
        (pt = oe(j, _t)),
        0 < pt.length &&
          ((_t = new Ld(_t, s, null, a, $)),
          _e.push({ event: _t, listeners: pt }),
          vt ? (_t.data = vt) : ((vt = he(a)), vt !== null && (_t.data = vt)))),
        (vt = ce ? je(s, a) : ke(s, a)) &&
          ((j = oe(j, "onBeforeInput")),
          0 < j.length &&
            (($ = new Ld("onBeforeInput", "beforeinput", null, a, $)),
            _e.push({ event: $, listeners: j }),
            ($.data = vt)))
    }
    se(_e, e)
  })
}
function tf(s, e, a) {
  return { instance: s, listener: e, currentTarget: a }
}
function oe(s, e) {
  for (var a = e + "Capture", o = []; s !== null; ) {
    var c = s,
      d = c.stateNode
    c.tag === 5 &&
      d !== null &&
      ((c = d),
      (d = Kb(s, a)),
      d != null && o.unshift(tf(s, d, c)),
      (d = Kb(s, e)),
      d != null && o.push(tf(s, d, c))),
      (s = s.return)
  }
  return o
}
function vf(s) {
  if (s === null) return null
  do s = s.return
  while (s && s.tag !== 5)
  return s || null
}
function wf(s, e, a, o, c) {
  for (var d = e._reactName, g = []; a !== null && a !== o; ) {
    var _ = a,
      b = _.alternate,
      j = _.stateNode
    if (b !== null && b === o) break
    _.tag === 5 &&
      j !== null &&
      ((_ = j),
      c
        ? ((b = Kb(a, d)), b != null && g.unshift(tf(a, b, _)))
        : c || ((b = Kb(a, d)), b != null && g.push(tf(a, b, _)))),
      (a = a.return)
  }
  g.length !== 0 && s.push({ event: e, listeners: g })
}
var xf = /\r\n?/g,
  yf = /\u0000|\uFFFD/g
function zf(s) {
  return (typeof s == "string" ? s : "" + s)
    .replace(
      xf,
      `
`
    )
    .replace(yf, "")
}
function Af(s, e, a) {
  if (((e = zf(e)), zf(s) !== e && a)) throw Error(p$1(425))
}
function Bf() {}
var Cf = null,
  Df = null
function Ef(s, e) {
  return (
    s === "textarea" ||
    s === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  )
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0,
  Gf = typeof clearTimeout == "function" ? clearTimeout : void 0,
  Hf = typeof Promise == "function" ? Promise : void 0,
  Jf =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof Hf < "u"
      ? function (s) {
          return Hf.resolve(null).then(s).catch(If)
        }
      : Ff
function If(s) {
  setTimeout(function () {
    throw s
  })
}
function Kf(s, e) {
  var a = e,
    o = 0
  do {
    var c = a.nextSibling
    if ((s.removeChild(a), c && c.nodeType === 8))
      if (((a = c.data), a === "/$")) {
        if (o === 0) {
          s.removeChild(c), bd(e)
          return
        }
        o--
      } else (a !== "$" && a !== "$?" && a !== "$!") || o++
    a = c
  } while (a)
  bd(e)
}
function Lf(s) {
  for (; s != null; s = s.nextSibling) {
    var e = s.nodeType
    if (e === 1 || e === 3) break
    if (e === 8) {
      if (((e = s.data), e === "$" || e === "$!" || e === "$?")) break
      if (e === "/$") return null
    }
  }
  return s
}
function Mf(s) {
  s = s.previousSibling
  for (var e = 0; s; ) {
    if (s.nodeType === 8) {
      var a = s.data
      if (a === "$" || a === "$!" || a === "$?") {
        if (e === 0) return s
        e--
      } else a === "/$" && e++
    }
    s = s.previousSibling
  }
  return null
}
var Nf = Math.random().toString(36).slice(2),
  Of = "__reactFiber$" + Nf,
  Pf = "__reactProps$" + Nf,
  uf = "__reactContainer$" + Nf,
  of = "__reactEvents$" + Nf,
  Qf = "__reactListeners$" + Nf,
  Rf = "__reactHandles$" + Nf
function Wc(s) {
  var e = s[Of]
  if (e) return e
  for (var a = s.parentNode; a; ) {
    if ((e = a[uf] || a[Of])) {
      if (
        ((a = e.alternate),
        e.child !== null || (a !== null && a.child !== null))
      )
        for (s = Mf(s); s !== null; ) {
          if ((a = s[Of])) return a
          s = Mf(s)
        }
      return e
    }
    ;(s = a), (a = s.parentNode)
  }
  return null
}
function Cb(s) {
  return (
    (s = s[Of] || s[uf]),
    !s || (s.tag !== 5 && s.tag !== 6 && s.tag !== 13 && s.tag !== 3) ? null : s
  )
}
function ue(s) {
  if (s.tag === 5 || s.tag === 6) return s.stateNode
  throw Error(p$1(33))
}
function Db(s) {
  return s[Pf] || null
}
var Sf = [],
  Tf = -1
function Uf(s) {
  return { current: s }
}
function E(s) {
  0 > Tf || ((s.current = Sf[Tf]), (Sf[Tf] = null), Tf--)
}
function G(s, e) {
  Tf++, (Sf[Tf] = s.current), (s.current = e)
}
var Vf = {},
  H = Uf(Vf),
  Wf = Uf(!1),
  Xf = Vf
function Yf(s, e) {
  var a = s.type.contextTypes
  if (!a) return Vf
  var o = s.stateNode
  if (o && o.__reactInternalMemoizedUnmaskedChildContext === e)
    return o.__reactInternalMemoizedMaskedChildContext
  var c = {},
    d
  for (d in a) c[d] = e[d]
  return (
    o &&
      ((s = s.stateNode),
      (s.__reactInternalMemoizedUnmaskedChildContext = e),
      (s.__reactInternalMemoizedMaskedChildContext = c)),
    c
  )
}
function Zf(s) {
  return (s = s.childContextTypes), s != null
}
function $f() {
  E(Wf), E(H)
}
function ag(s, e, a) {
  if (H.current !== Vf) throw Error(p$1(168))
  G(H, e), G(Wf, a)
}
function bg(s, e, a) {
  var o = s.stateNode
  if (((e = e.childContextTypes), typeof o.getChildContext != "function"))
    return a
  o = o.getChildContext()
  for (var c in o) if (!(c in e)) throw Error(p$1(108, Ra(s) || "Unknown", c))
  return A({}, a, o)
}
function cg(s) {
  return (
    (s =
      ((s = s.stateNode) && s.__reactInternalMemoizedMergedChildContext) || Vf),
    (Xf = H.current),
    G(H, s),
    G(Wf, Wf.current),
    !0
  )
}
function dg(s, e, a) {
  var o = s.stateNode
  if (!o) throw Error(p$1(169))
  a
    ? ((s = bg(s, e, Xf)),
      (o.__reactInternalMemoizedMergedChildContext = s),
      E(Wf),
      E(H),
      G(H, s))
    : E(Wf),
    G(Wf, a)
}
var eg = null,
  fg = !1,
  gg = !1
function hg(s) {
  eg === null ? (eg = [s]) : eg.push(s)
}
function ig(s) {
  ;(fg = !0), hg(s)
}
function jg() {
  if (!gg && eg !== null) {
    gg = !0
    var s = 0,
      e = C
    try {
      var a = eg
      for (C = 1; s < a.length; s++) {
        var o = a[s]
        do o = o(!0)
        while (o !== null)
      }
      ;(eg = null), (fg = !1)
    } catch (c) {
      throw (eg !== null && (eg = eg.slice(s + 1)), ac(fc, jg), c)
    } finally {
      ;(C = e), (gg = !1)
    }
  }
  return null
}
var kg = [],
  lg = 0,
  mg = null,
  ng = 0,
  og = [],
  pg = 0,
  qg = null,
  rg = 1,
  sg = ""
function tg(s, e) {
  ;(kg[lg++] = ng), (kg[lg++] = mg), (mg = s), (ng = e)
}
function ug(s, e, a) {
  ;(og[pg++] = rg), (og[pg++] = sg), (og[pg++] = qg), (qg = s)
  var o = rg
  s = sg
  var c = 32 - oc(o) - 1
  ;(o &= ~(1 << c)), (a += 1)
  var d = 32 - oc(e) + c
  if (30 < d) {
    var g = c - (c % 5)
    ;(d = (o & ((1 << g) - 1)).toString(32)),
      (o >>= g),
      (c -= g),
      (rg = (1 << (32 - oc(e) + c)) | (a << c) | o),
      (sg = d + s)
  } else (rg = (1 << d) | (a << c) | o), (sg = s)
}
function vg(s) {
  s.return !== null && (tg(s, 1), ug(s, 1, 0))
}
function wg(s) {
  for (; s === mg; )
    (mg = kg[--lg]), (kg[lg] = null), (ng = kg[--lg]), (kg[lg] = null)
  for (; s === qg; )
    (qg = og[--pg]),
      (og[pg] = null),
      (sg = og[--pg]),
      (og[pg] = null),
      (rg = og[--pg]),
      (og[pg] = null)
}
var xg = null,
  yg = null,
  I = !1,
  zg = null
function Ag(s, e) {
  var a = Bg(5, null, null, 0)
  ;(a.elementType = "DELETED"),
    (a.stateNode = e),
    (a.return = s),
    (e = s.deletions),
    e === null ? ((s.deletions = [a]), (s.flags |= 16)) : e.push(a)
}
function Cg(s, e) {
  switch (s.tag) {
    case 5:
      var a = s.type
      return (
        (e =
          e.nodeType !== 1 || a.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((s.stateNode = e), (xg = s), (yg = Lf(e.firstChild)), !0)
          : !1
      )
    case 6:
      return (
        (e = s.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((s.stateNode = e), (xg = s), (yg = null), !0) : !1
      )
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((a = qg !== null ? { id: rg, overflow: sg } : null),
            (s.memoizedState = {
              dehydrated: e,
              treeContext: a,
              retryLane: 1073741824,
            }),
            (a = Bg(18, null, null, 0)),
            (a.stateNode = e),
            (a.return = s),
            (s.child = a),
            (xg = s),
            (yg = null),
            !0)
          : !1
      )
    default:
      return !1
  }
}
function Dg(s) {
  return (s.mode & 1) !== 0 && (s.flags & 128) === 0
}
function Eg(s) {
  if (I) {
    var e = yg
    if (e) {
      var a = e
      if (!Cg(s, e)) {
        if (Dg(s)) throw Error(p$1(418))
        e = Lf(a.nextSibling)
        var o = xg
        e && Cg(s, e)
          ? Ag(o, a)
          : ((s.flags = (s.flags & -4097) | 2), (I = !1), (xg = s))
      }
    } else {
      if (Dg(s)) throw Error(p$1(418))
      ;(s.flags = (s.flags & -4097) | 2), (I = !1), (xg = s)
    }
  }
}
function Fg(s) {
  for (s = s.return; s !== null && s.tag !== 5 && s.tag !== 3 && s.tag !== 13; )
    s = s.return
  xg = s
}
function Gg(s) {
  if (s !== xg) return !1
  if (!I) return Fg(s), (I = !0), !1
  var e
  if (
    ((e = s.tag !== 3) &&
      !(e = s.tag !== 5) &&
      ((e = s.type),
      (e = e !== "head" && e !== "body" && !Ef(s.type, s.memoizedProps))),
    e && (e = yg))
  ) {
    if (Dg(s)) throw (Hg(), Error(p$1(418)))
    for (; e; ) Ag(s, e), (e = Lf(e.nextSibling))
  }
  if ((Fg(s), s.tag === 13)) {
    if (((s = s.memoizedState), (s = s !== null ? s.dehydrated : null), !s))
      throw Error(p$1(317))
    e: {
      for (s = s.nextSibling, e = 0; s; ) {
        if (s.nodeType === 8) {
          var a = s.data
          if (a === "/$") {
            if (e === 0) {
              yg = Lf(s.nextSibling)
              break e
            }
            e--
          } else (a !== "$" && a !== "$!" && a !== "$?") || e++
        }
        s = s.nextSibling
      }
      yg = null
    }
  } else yg = xg ? Lf(s.stateNode.nextSibling) : null
  return !0
}
function Hg() {
  for (var s = yg; s; ) s = Lf(s.nextSibling)
}
function Ig() {
  ;(yg = xg = null), (I = !1)
}
function Jg(s) {
  zg === null ? (zg = [s]) : zg.push(s)
}
var Kg = ua.ReactCurrentBatchConfig
function Lg(s, e) {
  if (s && s.defaultProps) {
    ;(e = A({}, e)), (s = s.defaultProps)
    for (var a in s) e[a] === void 0 && (e[a] = s[a])
    return e
  }
  return e
}
var Mg = Uf(null),
  Ng = null,
  Og = null,
  Pg = null
function Qg() {
  Pg = Og = Ng = null
}
function Rg(s) {
  var e = Mg.current
  E(Mg), (s._currentValue = e)
}
function Sg(s, e, a) {
  for (; s !== null; ) {
    var o = s.alternate
    if (
      ((s.childLanes & e) !== e
        ? ((s.childLanes |= e), o !== null && (o.childLanes |= e))
        : o !== null && (o.childLanes & e) !== e && (o.childLanes |= e),
      s === a)
    )
      break
    s = s.return
  }
}
function Tg(s, e) {
  ;(Ng = s),
    (Pg = Og = null),
    (s = s.dependencies),
    s !== null &&
      s.firstContext !== null &&
      (s.lanes & e && (Ug = !0), (s.firstContext = null))
}
function Vg(s) {
  var e = s._currentValue
  if (Pg !== s)
    if (((s = { context: s, memoizedValue: e, next: null }), Og === null)) {
      if (Ng === null) throw Error(p$1(308))
      ;(Og = s), (Ng.dependencies = { lanes: 0, firstContext: s })
    } else Og = Og.next = s
  return e
}
var Wg = null
function Xg(s) {
  Wg === null ? (Wg = [s]) : Wg.push(s)
}
function Yg(s, e, a, o) {
  var c = e.interleaved
  return (
    c === null ? ((a.next = a), Xg(e)) : ((a.next = c.next), (c.next = a)),
    (e.interleaved = a),
    Zg(s, o)
  )
}
function Zg(s, e) {
  s.lanes |= e
  var a = s.alternate
  for (a !== null && (a.lanes |= e), a = s, s = s.return; s !== null; )
    (s.childLanes |= e),
      (a = s.alternate),
      a !== null && (a.childLanes |= e),
      (a = s),
      (s = s.return)
  return a.tag === 3 ? a.stateNode : null
}
var $g = !1
function ah(s) {
  s.updateQueue = {
    baseState: s.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  }
}
function bh(s, e) {
  ;(s = s.updateQueue),
    e.updateQueue === s &&
      (e.updateQueue = {
        baseState: s.baseState,
        firstBaseUpdate: s.firstBaseUpdate,
        lastBaseUpdate: s.lastBaseUpdate,
        shared: s.shared,
        effects: s.effects,
      })
}
function ch(s, e) {
  return {
    eventTime: s,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  }
}
function dh(s, e, a) {
  var o = s.updateQueue
  if (o === null) return null
  if (((o = o.shared), K & 2)) {
    var c = o.pending
    return (
      c === null ? (e.next = e) : ((e.next = c.next), (c.next = e)),
      (o.pending = e),
      Zg(s, a)
    )
  }
  return (
    (c = o.interleaved),
    c === null ? ((e.next = e), Xg(o)) : ((e.next = c.next), (c.next = e)),
    (o.interleaved = e),
    Zg(s, a)
  )
}
function eh(s, e, a) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (a & 4194240) !== 0))
  ) {
    var o = e.lanes
    ;(o &= s.pendingLanes), (a |= o), (e.lanes = a), Cc(s, a)
  }
}
function fh(s, e) {
  var a = s.updateQueue,
    o = s.alternate
  if (o !== null && ((o = o.updateQueue), a === o)) {
    var c = null,
      d = null
    if (((a = a.firstBaseUpdate), a !== null)) {
      do {
        var g = {
          eventTime: a.eventTime,
          lane: a.lane,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }
        d === null ? (c = d = g) : (d = d.next = g), (a = a.next)
      } while (a !== null)
      d === null ? (c = d = e) : (d = d.next = e)
    } else c = d = e
    ;(a = {
      baseState: o.baseState,
      firstBaseUpdate: c,
      lastBaseUpdate: d,
      shared: o.shared,
      effects: o.effects,
    }),
      (s.updateQueue = a)
    return
  }
  ;(s = a.lastBaseUpdate),
    s === null ? (a.firstBaseUpdate = e) : (s.next = e),
    (a.lastBaseUpdate = e)
}
function gh(s, e, a, o) {
  var c = s.updateQueue
  $g = !1
  var d = c.firstBaseUpdate,
    g = c.lastBaseUpdate,
    _ = c.shared.pending
  if (_ !== null) {
    c.shared.pending = null
    var b = _,
      j = b.next
    ;(b.next = null), g === null ? (d = j) : (g.next = j), (g = b)
    var $ = s.alternate
    $ !== null &&
      (($ = $.updateQueue),
      (_ = $.lastBaseUpdate),
      _ !== g &&
        (_ === null ? ($.firstBaseUpdate = j) : (_.next = j),
        ($.lastBaseUpdate = b)))
  }
  if (d !== null) {
    var _e = c.baseState
    ;(g = 0), ($ = j = b = null), (_ = d)
    do {
      var tt = _.lane,
        st = _.eventTime
      if ((o & tt) === tt) {
        $ !== null &&
          ($ = $.next =
            {
              eventTime: st,
              lane: 0,
              tag: _.tag,
              payload: _.payload,
              callback: _.callback,
              next: null,
            })
        e: {
          var at = s,
            ot = _
          switch (((tt = e), (st = a), ot.tag)) {
            case 1:
              if (((at = ot.payload), typeof at == "function")) {
                _e = at.call(st, _e, tt)
                break e
              }
              _e = at
              break e
            case 3:
              at.flags = (at.flags & -65537) | 128
            case 0:
              if (
                ((at = ot.payload),
                (tt = typeof at == "function" ? at.call(st, _e, tt) : at),
                tt == null)
              )
                break e
              _e = A({}, _e, tt)
              break e
            case 2:
              $g = !0
          }
        }
        _.callback !== null &&
          _.lane !== 0 &&
          ((s.flags |= 64),
          (tt = c.effects),
          tt === null ? (c.effects = [_]) : tt.push(_))
      } else
        (st = {
          eventTime: st,
          lane: tt,
          tag: _.tag,
          payload: _.payload,
          callback: _.callback,
          next: null,
        }),
          $ === null ? ((j = $ = st), (b = _e)) : ($ = $.next = st),
          (g |= tt)
      if (((_ = _.next), _ === null)) {
        if (((_ = c.shared.pending), _ === null)) break
        ;(tt = _),
          (_ = tt.next),
          (tt.next = null),
          (c.lastBaseUpdate = tt),
          (c.shared.pending = null)
      }
    } while (1)
    if (
      ($ === null && (b = _e),
      (c.baseState = b),
      (c.firstBaseUpdate = j),
      (c.lastBaseUpdate = $),
      (e = c.shared.interleaved),
      e !== null)
    ) {
      c = e
      do (g |= c.lane), (c = c.next)
      while (c !== e)
    } else d === null && (c.shared.lanes = 0)
    ;(hh |= g), (s.lanes = g), (s.memoizedState = _e)
  }
}
function ih(s, e, a) {
  if (((s = e.effects), (e.effects = null), s !== null))
    for (e = 0; e < s.length; e++) {
      var o = s[e],
        c = o.callback
      if (c !== null) {
        if (((o.callback = null), (o = a), typeof c != "function"))
          throw Error(p$1(191, c))
        c.call(o)
      }
    }
}
var jh = new aa.Component().refs
function kh(s, e, a, o) {
  ;(e = s.memoizedState),
    (a = a(o, e)),
    (a = a == null ? e : A({}, e, a)),
    (s.memoizedState = a),
    s.lanes === 0 && (s.updateQueue.baseState = a)
}
var nh = {
  isMounted: function (s) {
    return (s = s._reactInternals) ? Vb(s) === s : !1
  },
  enqueueSetState: function (s, e, a) {
    s = s._reactInternals
    var o = L(),
      c = lh(s),
      d = ch(o, c)
    ;(d.payload = e),
      a != null && (d.callback = a),
      (e = dh(s, d, c)),
      e !== null && (mh(e, s, c, o), eh(e, s, c))
  },
  enqueueReplaceState: function (s, e, a) {
    s = s._reactInternals
    var o = L(),
      c = lh(s),
      d = ch(o, c)
    ;(d.tag = 1),
      (d.payload = e),
      a != null && (d.callback = a),
      (e = dh(s, d, c)),
      e !== null && (mh(e, s, c, o), eh(e, s, c))
  },
  enqueueForceUpdate: function (s, e) {
    s = s._reactInternals
    var a = L(),
      o = lh(s),
      c = ch(a, o)
    ;(c.tag = 2),
      e != null && (c.callback = e),
      (e = dh(s, c, o)),
      e !== null && (mh(e, s, o, a), eh(e, s, o))
  },
}
function oh(s, e, a, o, c, d, g) {
  return (
    (s = s.stateNode),
    typeof s.shouldComponentUpdate == "function"
      ? s.shouldComponentUpdate(o, d, g)
      : e.prototype && e.prototype.isPureReactComponent
      ? !Ie(a, o) || !Ie(c, d)
      : !0
  )
}
function ph(s, e, a) {
  var o = !1,
    c = Vf,
    d = e.contextType
  return (
    typeof d == "object" && d !== null
      ? (d = Vg(d))
      : ((c = Zf(e) ? Xf : H.current),
        (o = e.contextTypes),
        (d = (o = o != null) ? Yf(s, c) : Vf)),
    (e = new e(a, d)),
    (s.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = nh),
    (s.stateNode = e),
    (e._reactInternals = s),
    o &&
      ((s = s.stateNode),
      (s.__reactInternalMemoizedUnmaskedChildContext = c),
      (s.__reactInternalMemoizedMaskedChildContext = d)),
    e
  )
}
function qh(s, e, a, o) {
  ;(s = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(a, o),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(a, o),
    e.state !== s && nh.enqueueReplaceState(e, e.state, null)
}
function rh(s, e, a, o) {
  var c = s.stateNode
  ;(c.props = a), (c.state = s.memoizedState), (c.refs = jh), ah(s)
  var d = e.contextType
  typeof d == "object" && d !== null
    ? (c.context = Vg(d))
    : ((d = Zf(e) ? Xf : H.current), (c.context = Yf(s, d))),
    (c.state = s.memoizedState),
    (d = e.getDerivedStateFromProps),
    typeof d == "function" && (kh(s, e, d, a), (c.state = s.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof c.getSnapshotBeforeUpdate == "function" ||
      (typeof c.UNSAFE_componentWillMount != "function" &&
        typeof c.componentWillMount != "function") ||
      ((e = c.state),
      typeof c.componentWillMount == "function" && c.componentWillMount(),
      typeof c.UNSAFE_componentWillMount == "function" &&
        c.UNSAFE_componentWillMount(),
      e !== c.state && nh.enqueueReplaceState(c, c.state, null),
      gh(s, a, c, o),
      (c.state = s.memoizedState)),
    typeof c.componentDidMount == "function" && (s.flags |= 4194308)
}
function sh(s, e, a) {
  if (
    ((s = a.ref), s !== null && typeof s != "function" && typeof s != "object")
  ) {
    if (a._owner) {
      if (((a = a._owner), a)) {
        if (a.tag !== 1) throw Error(p$1(309))
        var o = a.stateNode
      }
      if (!o) throw Error(p$1(147, s))
      var c = o,
        d = "" + s
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === d
        ? e.ref
        : ((e = function (g) {
            var _ = c.refs
            _ === jh && (_ = c.refs = {}), g === null ? delete _[d] : (_[d] = g)
          }),
          (e._stringRef = d),
          e)
    }
    if (typeof s != "string") throw Error(p$1(284))
    if (!a._owner) throw Error(p$1(290, s))
  }
  return s
}
function th(s, e) {
  throw (
    ((s = Object.prototype.toString.call(e)),
    Error(
      p$1(
        31,
        s === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : s
      )
    ))
  )
}
function uh(s) {
  var e = s._init
  return e(s._payload)
}
function vh$1(s) {
  function e(it, ct) {
    if (s) {
      var lt = it.deletions
      lt === null ? ((it.deletions = [ct]), (it.flags |= 16)) : lt.push(ct)
    }
  }
  function a(it, ct) {
    if (!s) return null
    for (; ct !== null; ) e(it, ct), (ct = ct.sibling)
    return null
  }
  function o(it, ct) {
    for (it = new Map(); ct !== null; )
      ct.key !== null ? it.set(ct.key, ct) : it.set(ct.index, ct),
        (ct = ct.sibling)
    return it
  }
  function c(it, ct) {
    return (it = wh(it, ct)), (it.index = 0), (it.sibling = null), it
  }
  function d(it, ct, lt) {
    return (
      (it.index = lt),
      s
        ? ((lt = it.alternate),
          lt !== null
            ? ((lt = lt.index), lt < ct ? ((it.flags |= 2), ct) : lt)
            : ((it.flags |= 2), ct))
        : ((it.flags |= 1048576), ct)
    )
  }
  function g(it) {
    return s && it.alternate === null && (it.flags |= 2), it
  }
  function _(it, ct, lt, ht) {
    return ct === null || ct.tag !== 6
      ? ((ct = xh(lt, it.mode, ht)), (ct.return = it), ct)
      : ((ct = c(ct, lt)), (ct.return = it), ct)
  }
  function b(it, ct, lt, ht) {
    var dt = lt.type
    return dt === ya
      ? $(it, ct, lt.props.children, ht, lt.key)
      : ct !== null &&
        (ct.elementType === dt ||
          (typeof dt == "object" &&
            dt !== null &&
            dt.$$typeof === Ha &&
            uh(dt) === ct.type))
      ? ((ht = c(ct, lt.props)),
        (ht.ref = sh(it, ct, lt)),
        (ht.return = it),
        ht)
      : ((ht = yh(lt.type, lt.key, lt.props, null, it.mode, ht)),
        (ht.ref = sh(it, ct, lt)),
        (ht.return = it),
        ht)
  }
  function j(it, ct, lt, ht) {
    return ct === null ||
      ct.tag !== 4 ||
      ct.stateNode.containerInfo !== lt.containerInfo ||
      ct.stateNode.implementation !== lt.implementation
      ? ((ct = zh(lt, it.mode, ht)), (ct.return = it), ct)
      : ((ct = c(ct, lt.children || [])), (ct.return = it), ct)
  }
  function $(it, ct, lt, ht, dt) {
    return ct === null || ct.tag !== 7
      ? ((ct = Ah(lt, it.mode, ht, dt)), (ct.return = it), ct)
      : ((ct = c(ct, lt)), (ct.return = it), ct)
  }
  function _e(it, ct, lt) {
    if ((typeof ct == "string" && ct !== "") || typeof ct == "number")
      return (ct = xh("" + ct, it.mode, lt)), (ct.return = it), ct
    if (typeof ct == "object" && ct !== null) {
      switch (ct.$$typeof) {
        case va:
          return (
            (lt = yh(ct.type, ct.key, ct.props, null, it.mode, lt)),
            (lt.ref = sh(it, null, ct)),
            (lt.return = it),
            lt
          )
        case wa:
          return (ct = zh(ct, it.mode, lt)), (ct.return = it), ct
        case Ha:
          var ht = ct._init
          return _e(it, ht(ct._payload), lt)
      }
      if (eb(ct) || Ka(ct))
        return (ct = Ah(ct, it.mode, lt, null)), (ct.return = it), ct
      th(it, ct)
    }
    return null
  }
  function tt(it, ct, lt, ht) {
    var dt = ct !== null ? ct.key : null
    if ((typeof lt == "string" && lt !== "") || typeof lt == "number")
      return dt !== null ? null : _(it, ct, "" + lt, ht)
    if (typeof lt == "object" && lt !== null) {
      switch (lt.$$typeof) {
        case va:
          return lt.key === dt ? b(it, ct, lt, ht) : null
        case wa:
          return lt.key === dt ? j(it, ct, lt, ht) : null
        case Ha:
          return (dt = lt._init), tt(it, ct, dt(lt._payload), ht)
      }
      if (eb(lt) || Ka(lt)) return dt !== null ? null : $(it, ct, lt, ht, null)
      th(it, lt)
    }
    return null
  }
  function st(it, ct, lt, ht, dt) {
    if ((typeof ht == "string" && ht !== "") || typeof ht == "number")
      return (it = it.get(lt) || null), _(ct, it, "" + ht, dt)
    if (typeof ht == "object" && ht !== null) {
      switch (ht.$$typeof) {
        case va:
          return (
            (it = it.get(ht.key === null ? lt : ht.key) || null),
            b(ct, it, ht, dt)
          )
        case wa:
          return (
            (it = it.get(ht.key === null ? lt : ht.key) || null),
            j(ct, it, ht, dt)
          )
        case Ha:
          var pt = ht._init
          return st(it, ct, lt, pt(ht._payload), dt)
      }
      if (eb(ht) || Ka(ht))
        return (it = it.get(lt) || null), $(ct, it, ht, dt, null)
      th(ct, ht)
    }
    return null
  }
  function at(it, ct, lt, ht) {
    for (
      var dt = null, pt = null, vt = ct, _t = (ct = 0), yt = null;
      vt !== null && _t < lt.length;
      _t++
    ) {
      vt.index > _t ? ((yt = vt), (vt = null)) : (yt = vt.sibling)
      var Et = tt(it, vt, lt[_t], ht)
      if (Et === null) {
        vt === null && (vt = yt)
        break
      }
      s && vt && Et.alternate === null && e(it, vt),
        (ct = d(Et, ct, _t)),
        pt === null ? (dt = Et) : (pt.sibling = Et),
        (pt = Et),
        (vt = yt)
    }
    if (_t === lt.length) return a(it, vt), I && tg(it, _t), dt
    if (vt === null) {
      for (; _t < lt.length; _t++)
        (vt = _e(it, lt[_t], ht)),
          vt !== null &&
            ((ct = d(vt, ct, _t)),
            pt === null ? (dt = vt) : (pt.sibling = vt),
            (pt = vt))
      return I && tg(it, _t), dt
    }
    for (vt = o(it, vt); _t < lt.length; _t++)
      (yt = st(vt, it, _t, lt[_t], ht)),
        yt !== null &&
          (s &&
            yt.alternate !== null &&
            vt.delete(yt.key === null ? _t : yt.key),
          (ct = d(yt, ct, _t)),
          pt === null ? (dt = yt) : (pt.sibling = yt),
          (pt = yt))
    return (
      s &&
        vt.forEach(function (Rt) {
          return e(it, Rt)
        }),
      I && tg(it, _t),
      dt
    )
  }
  function ot(it, ct, lt, ht) {
    var dt = Ka(lt)
    if (typeof dt != "function") throw Error(p$1(150))
    if (((lt = dt.call(lt)), lt == null)) throw Error(p$1(151))
    for (
      var pt = (dt = null), vt = ct, _t = (ct = 0), yt = null, Et = lt.next();
      vt !== null && !Et.done;
      _t++, Et = lt.next()
    ) {
      vt.index > _t ? ((yt = vt), (vt = null)) : (yt = vt.sibling)
      var Rt = tt(it, vt, Et.value, ht)
      if (Rt === null) {
        vt === null && (vt = yt)
        break
      }
      s && vt && Rt.alternate === null && e(it, vt),
        (ct = d(Rt, ct, _t)),
        pt === null ? (dt = Rt) : (pt.sibling = Rt),
        (pt = Rt),
        (vt = yt)
    }
    if (Et.done) return a(it, vt), I && tg(it, _t), dt
    if (vt === null) {
      for (; !Et.done; _t++, Et = lt.next())
        (Et = _e(it, Et.value, ht)),
          Et !== null &&
            ((ct = d(Et, ct, _t)),
            pt === null ? (dt = Et) : (pt.sibling = Et),
            (pt = Et))
      return I && tg(it, _t), dt
    }
    for (vt = o(it, vt); !Et.done; _t++, Et = lt.next())
      (Et = st(vt, it, _t, Et.value, ht)),
        Et !== null &&
          (s &&
            Et.alternate !== null &&
            vt.delete(Et.key === null ? _t : Et.key),
          (ct = d(Et, ct, _t)),
          pt === null ? (dt = Et) : (pt.sibling = Et),
          (pt = Et))
    return (
      s &&
        vt.forEach(function (Ft) {
          return e(it, Ft)
        }),
      I && tg(it, _t),
      dt
    )
  }
  function ut(it, ct, lt, ht) {
    if (
      (typeof lt == "object" &&
        lt !== null &&
        lt.type === ya &&
        lt.key === null &&
        (lt = lt.props.children),
      typeof lt == "object" && lt !== null)
    ) {
      switch (lt.$$typeof) {
        case va:
          e: {
            for (var dt = lt.key, pt = ct; pt !== null; ) {
              if (pt.key === dt) {
                if (((dt = lt.type), dt === ya)) {
                  if (pt.tag === 7) {
                    a(it, pt.sibling),
                      (ct = c(pt, lt.props.children)),
                      (ct.return = it),
                      (it = ct)
                    break e
                  }
                } else if (
                  pt.elementType === dt ||
                  (typeof dt == "object" &&
                    dt !== null &&
                    dt.$$typeof === Ha &&
                    uh(dt) === pt.type)
                ) {
                  a(it, pt.sibling),
                    (ct = c(pt, lt.props)),
                    (ct.ref = sh(it, pt, lt)),
                    (ct.return = it),
                    (it = ct)
                  break e
                }
                a(it, pt)
                break
              } else e(it, pt)
              pt = pt.sibling
            }
            lt.type === ya
              ? ((ct = Ah(lt.props.children, it.mode, ht, lt.key)),
                (ct.return = it),
                (it = ct))
              : ((ht = yh(lt.type, lt.key, lt.props, null, it.mode, ht)),
                (ht.ref = sh(it, ct, lt)),
                (ht.return = it),
                (it = ht))
          }
          return g(it)
        case wa:
          e: {
            for (pt = lt.key; ct !== null; ) {
              if (ct.key === pt)
                if (
                  ct.tag === 4 &&
                  ct.stateNode.containerInfo === lt.containerInfo &&
                  ct.stateNode.implementation === lt.implementation
                ) {
                  a(it, ct.sibling),
                    (ct = c(ct, lt.children || [])),
                    (ct.return = it),
                    (it = ct)
                  break e
                } else {
                  a(it, ct)
                  break
                }
              else e(it, ct)
              ct = ct.sibling
            }
            ;(ct = zh(lt, it.mode, ht)), (ct.return = it), (it = ct)
          }
          return g(it)
        case Ha:
          return (pt = lt._init), ut(it, ct, pt(lt._payload), ht)
      }
      if (eb(lt)) return at(it, ct, lt, ht)
      if (Ka(lt)) return ot(it, ct, lt, ht)
      th(it, lt)
    }
    return (typeof lt == "string" && lt !== "") || typeof lt == "number"
      ? ((lt = "" + lt),
        ct !== null && ct.tag === 6
          ? (a(it, ct.sibling), (ct = c(ct, lt)), (ct.return = it), (it = ct))
          : (a(it, ct),
            (ct = xh(lt, it.mode, ht)),
            (ct.return = it),
            (it = ct)),
        g(it))
      : a(it, ct)
  }
  return ut
}
var Bh = vh$1(!0),
  Ch = vh$1(!1),
  Dh = {},
  Eh = Uf(Dh),
  Fh = Uf(Dh),
  Gh = Uf(Dh)
function Hh(s) {
  if (s === Dh) throw Error(p$1(174))
  return s
}
function Ih(s, e) {
  switch ((G(Gh, e), G(Fh, s), G(Eh, Dh), (s = e.nodeType), s)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : lb(null, "")
      break
    default:
      ;(s = s === 8 ? e.parentNode : e),
        (e = s.namespaceURI || null),
        (s = s.tagName),
        (e = lb(e, s))
  }
  E(Eh), G(Eh, e)
}
function Jh() {
  E(Eh), E(Fh), E(Gh)
}
function Kh(s) {
  Hh(Gh.current)
  var e = Hh(Eh.current),
    a = lb(e, s.type)
  e !== a && (G(Fh, s), G(Eh, a))
}
function Lh(s) {
  Fh.current === s && (E(Eh), E(Fh))
}
var M = Uf(0)
function Mh(s) {
  for (var e = s; e !== null; ) {
    if (e.tag === 13) {
      var a = e.memoizedState
      if (
        a !== null &&
        ((a = a.dehydrated), a === null || a.data === "$?" || a.data === "$!")
      )
        return e
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e
    } else if (e.child !== null) {
      ;(e.child.return = e), (e = e.child)
      continue
    }
    if (e === s) break
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === s) return null
      e = e.return
    }
    ;(e.sibling.return = e.return), (e = e.sibling)
  }
  return null
}
var Nh = []
function Oh() {
  for (var s = 0; s < Nh.length; s++) Nh[s]._workInProgressVersionPrimary = null
  Nh.length = 0
}
var Ph = ua.ReactCurrentDispatcher,
  Qh = ua.ReactCurrentBatchConfig,
  Rh = 0,
  N = null,
  O = null,
  P = null,
  Sh = !1,
  Th = !1,
  Uh = 0,
  Vh = 0
function Q() {
  throw Error(p$1(321))
}
function Wh(s, e) {
  if (e === null) return !1
  for (var a = 0; a < e.length && a < s.length; a++)
    if (!He(s[a], e[a])) return !1
  return !0
}
function Xh(s, e, a, o, c, d) {
  if (
    ((Rh = d),
    (N = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Ph.current = s === null || s.memoizedState === null ? Yh : Zh),
    (s = a(o, c)),
    Th)
  ) {
    d = 0
    do {
      if (((Th = !1), (Uh = 0), 25 <= d)) throw Error(p$1(301))
      ;(d += 1),
        (P = O = null),
        (e.updateQueue = null),
        (Ph.current = $h),
        (s = a(o, c))
    } while (Th)
  }
  if (
    ((Ph.current = ai),
    (e = O !== null && O.next !== null),
    (Rh = 0),
    (P = O = N = null),
    (Sh = !1),
    e)
  )
    throw Error(p$1(300))
  return s
}
function bi() {
  var s = Uh !== 0
  return (Uh = 0), s
}
function ci() {
  var s = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  }
  return P === null ? (N.memoizedState = P = s) : (P = P.next = s), P
}
function di() {
  if (O === null) {
    var s = N.alternate
    s = s !== null ? s.memoizedState : null
  } else s = O.next
  var e = P === null ? N.memoizedState : P.next
  if (e !== null) (P = e), (O = s)
  else {
    if (s === null) throw Error(p$1(310))
    ;(O = s),
      (s = {
        memoizedState: O.memoizedState,
        baseState: O.baseState,
        baseQueue: O.baseQueue,
        queue: O.queue,
        next: null,
      }),
      P === null ? (N.memoizedState = P = s) : (P = P.next = s)
  }
  return P
}
function ei(s, e) {
  return typeof e == "function" ? e(s) : e
}
function fi(s) {
  var e = di(),
    a = e.queue
  if (a === null) throw Error(p$1(311))
  a.lastRenderedReducer = s
  var o = O,
    c = o.baseQueue,
    d = a.pending
  if (d !== null) {
    if (c !== null) {
      var g = c.next
      ;(c.next = d.next), (d.next = g)
    }
    ;(o.baseQueue = c = d), (a.pending = null)
  }
  if (c !== null) {
    ;(d = c.next), (o = o.baseState)
    var _ = (g = null),
      b = null,
      j = d
    do {
      var $ = j.lane
      if ((Rh & $) === $)
        b !== null &&
          (b = b.next =
            {
              lane: 0,
              action: j.action,
              hasEagerState: j.hasEagerState,
              eagerState: j.eagerState,
              next: null,
            }),
          (o = j.hasEagerState ? j.eagerState : s(o, j.action))
      else {
        var _e = {
          lane: $,
          action: j.action,
          hasEagerState: j.hasEagerState,
          eagerState: j.eagerState,
          next: null,
        }
        b === null ? ((_ = b = _e), (g = o)) : (b = b.next = _e),
          (N.lanes |= $),
          (hh |= $)
      }
      j = j.next
    } while (j !== null && j !== d)
    b === null ? (g = o) : (b.next = _),
      He(o, e.memoizedState) || (Ug = !0),
      (e.memoizedState = o),
      (e.baseState = g),
      (e.baseQueue = b),
      (a.lastRenderedState = o)
  }
  if (((s = a.interleaved), s !== null)) {
    c = s
    do (d = c.lane), (N.lanes |= d), (hh |= d), (c = c.next)
    while (c !== s)
  } else c === null && (a.lanes = 0)
  return [e.memoizedState, a.dispatch]
}
function gi(s) {
  var e = di(),
    a = e.queue
  if (a === null) throw Error(p$1(311))
  a.lastRenderedReducer = s
  var o = a.dispatch,
    c = a.pending,
    d = e.memoizedState
  if (c !== null) {
    a.pending = null
    var g = (c = c.next)
    do (d = s(d, g.action)), (g = g.next)
    while (g !== c)
    He(d, e.memoizedState) || (Ug = !0),
      (e.memoizedState = d),
      e.baseQueue === null && (e.baseState = d),
      (a.lastRenderedState = d)
  }
  return [d, o]
}
function hi() {}
function ii(s, e) {
  var a = N,
    o = di(),
    c = e(),
    d = !He(o.memoizedState, c)
  if (
    (d && ((o.memoizedState = c), (Ug = !0)),
    (o = o.queue),
    ji(ki.bind(null, a, o, s), [s]),
    o.getSnapshot !== e || d || (P !== null && P.memoizedState.tag & 1))
  ) {
    if (
      ((a.flags |= 2048),
      li(9, mi.bind(null, a, o, c, e), void 0, null),
      R === null)
    )
      throw Error(p$1(349))
    Rh & 30 || ni(a, e, c)
  }
  return c
}
function ni(s, e, a) {
  ;(s.flags |= 16384),
    (s = { getSnapshot: e, value: a }),
    (e = N.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (N.updateQueue = e),
        (e.stores = [s]))
      : ((a = e.stores), a === null ? (e.stores = [s]) : a.push(s))
}
function mi(s, e, a, o) {
  ;(e.value = a), (e.getSnapshot = o), oi(e) && pi(s)
}
function ki(s, e, a) {
  return a(function () {
    oi(e) && pi(s)
  })
}
function oi(s) {
  var e = s.getSnapshot
  s = s.value
  try {
    var a = e()
    return !He(s, a)
  } catch {
    return !0
  }
}
function pi(s) {
  var e = Zg(s, 1)
  e !== null && mh(e, s, 1, -1)
}
function qi(s) {
  var e = ci()
  return (
    typeof s == "function" && (s = s()),
    (e.memoizedState = e.baseState = s),
    (s = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: ei,
      lastRenderedState: s,
    }),
    (e.queue = s),
    (s = s.dispatch = ri.bind(null, N, s)),
    [e.memoizedState, s]
  )
}
function li(s, e, a, o) {
  return (
    (s = { tag: s, create: e, destroy: a, deps: o, next: null }),
    (e = N.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (N.updateQueue = e),
        (e.lastEffect = s.next = s))
      : ((a = e.lastEffect),
        a === null
          ? (e.lastEffect = s.next = s)
          : ((o = a.next), (a.next = s), (s.next = o), (e.lastEffect = s))),
    s
  )
}
function si() {
  return di().memoizedState
}
function ti(s, e, a, o) {
  var c = ci()
  ;(N.flags |= s),
    (c.memoizedState = li(1 | e, a, void 0, o === void 0 ? null : o))
}
function ui(s, e, a, o) {
  var c = di()
  o = o === void 0 ? null : o
  var d = void 0
  if (O !== null) {
    var g = O.memoizedState
    if (((d = g.destroy), o !== null && Wh(o, g.deps))) {
      c.memoizedState = li(e, a, d, o)
      return
    }
  }
  ;(N.flags |= s), (c.memoizedState = li(1 | e, a, d, o))
}
function vi(s, e) {
  return ti(8390656, 8, s, e)
}
function ji(s, e) {
  return ui(2048, 8, s, e)
}
function wi(s, e) {
  return ui(4, 2, s, e)
}
function xi(s, e) {
  return ui(4, 4, s, e)
}
function yi(s, e) {
  if (typeof e == "function")
    return (
      (s = s()),
      e(s),
      function () {
        e(null)
      }
    )
  if (e != null)
    return (
      (s = s()),
      (e.current = s),
      function () {
        e.current = null
      }
    )
}
function zi(s, e, a) {
  return (
    (a = a != null ? a.concat([s]) : null), ui(4, 4, yi.bind(null, e, s), a)
  )
}
function Ai() {}
function Bi(s, e) {
  var a = di()
  e = e === void 0 ? null : e
  var o = a.memoizedState
  return o !== null && e !== null && Wh(e, o[1])
    ? o[0]
    : ((a.memoizedState = [s, e]), s)
}
function Ci(s, e) {
  var a = di()
  e = e === void 0 ? null : e
  var o = a.memoizedState
  return o !== null && e !== null && Wh(e, o[1])
    ? o[0]
    : ((s = s()), (a.memoizedState = [s, e]), s)
}
function Di(s, e, a) {
  return Rh & 21
    ? (He(a, e) || ((a = yc()), (N.lanes |= a), (hh |= a), (s.baseState = !0)),
      e)
    : (s.baseState && ((s.baseState = !1), (Ug = !0)), (s.memoizedState = a))
}
function Ei(s, e) {
  var a = C
  ;(C = a !== 0 && 4 > a ? a : 4), s(!0)
  var o = Qh.transition
  Qh.transition = {}
  try {
    s(!1), e()
  } finally {
    ;(C = a), (Qh.transition = o)
  }
}
function Fi() {
  return di().memoizedState
}
function Gi(s, e, a) {
  var o = lh(s)
  if (
    ((a = {
      lane: o,
      action: a,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    Hi(s))
  )
    Ii(e, a)
  else if (((a = Yg(s, e, a, o)), a !== null)) {
    var c = L()
    mh(a, s, o, c), Ji(a, e, o)
  }
}
function ri(s, e, a) {
  var o = lh(s),
    c = { lane: o, action: a, hasEagerState: !1, eagerState: null, next: null }
  if (Hi(s)) Ii(e, c)
  else {
    var d = s.alternate
    if (
      s.lanes === 0 &&
      (d === null || d.lanes === 0) &&
      ((d = e.lastRenderedReducer), d !== null)
    )
      try {
        var g = e.lastRenderedState,
          _ = d(g, a)
        if (((c.hasEagerState = !0), (c.eagerState = _), He(_, g))) {
          var b = e.interleaved
          b === null
            ? ((c.next = c), Xg(e))
            : ((c.next = b.next), (b.next = c)),
            (e.interleaved = c)
          return
        }
      } catch {
      } finally {
      }
    ;(a = Yg(s, e, c, o)),
      a !== null && ((c = L()), mh(a, s, o, c), Ji(a, e, o))
  }
}
function Hi(s) {
  var e = s.alternate
  return s === N || (e !== null && e === N)
}
function Ii(s, e) {
  Th = Sh = !0
  var a = s.pending
  a === null ? (e.next = e) : ((e.next = a.next), (a.next = e)), (s.pending = e)
}
function Ji(s, e, a) {
  if (a & 4194240) {
    var o = e.lanes
    ;(o &= s.pendingLanes), (a |= o), (e.lanes = a), Cc(s, a)
  }
}
var ai = {
    readContext: Vg,
    useCallback: Q,
    useContext: Q,
    useEffect: Q,
    useImperativeHandle: Q,
    useInsertionEffect: Q,
    useLayoutEffect: Q,
    useMemo: Q,
    useReducer: Q,
    useRef: Q,
    useState: Q,
    useDebugValue: Q,
    useDeferredValue: Q,
    useTransition: Q,
    useMutableSource: Q,
    useSyncExternalStore: Q,
    useId: Q,
    unstable_isNewReconciler: !1,
  },
  Yh = {
    readContext: Vg,
    useCallback: function (s, e) {
      return (ci().memoizedState = [s, e === void 0 ? null : e]), s
    },
    useContext: Vg,
    useEffect: vi,
    useImperativeHandle: function (s, e, a) {
      return (
        (a = a != null ? a.concat([s]) : null),
        ti(4194308, 4, yi.bind(null, e, s), a)
      )
    },
    useLayoutEffect: function (s, e) {
      return ti(4194308, 4, s, e)
    },
    useInsertionEffect: function (s, e) {
      return ti(4, 2, s, e)
    },
    useMemo: function (s, e) {
      var a = ci()
      return (
        (e = e === void 0 ? null : e), (s = s()), (a.memoizedState = [s, e]), s
      )
    },
    useReducer: function (s, e, a) {
      var o = ci()
      return (
        (e = a !== void 0 ? a(e) : e),
        (o.memoizedState = o.baseState = e),
        (s = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: s,
          lastRenderedState: e,
        }),
        (o.queue = s),
        (s = s.dispatch = Gi.bind(null, N, s)),
        [o.memoizedState, s]
      )
    },
    useRef: function (s) {
      var e = ci()
      return (s = { current: s }), (e.memoizedState = s)
    },
    useState: qi,
    useDebugValue: Ai,
    useDeferredValue: function (s) {
      return (ci().memoizedState = s)
    },
    useTransition: function () {
      var s = qi(!1),
        e = s[0]
      return (s = Ei.bind(null, s[1])), (ci().memoizedState = s), [e, s]
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (s, e, a) {
      var o = N,
        c = ci()
      if (I) {
        if (a === void 0) throw Error(p$1(407))
        a = a()
      } else {
        if (((a = e()), R === null)) throw Error(p$1(349))
        Rh & 30 || ni(o, e, a)
      }
      c.memoizedState = a
      var d = { value: a, getSnapshot: e }
      return (
        (c.queue = d),
        vi(ki.bind(null, o, d, s), [s]),
        (o.flags |= 2048),
        li(9, mi.bind(null, o, d, a, e), void 0, null),
        a
      )
    },
    useId: function () {
      var s = ci(),
        e = R.identifierPrefix
      if (I) {
        var a = sg,
          o = rg
        ;(a = (o & ~(1 << (32 - oc(o) - 1))).toString(32) + a),
          (e = ":" + e + "R" + a),
          (a = Uh++),
          0 < a && (e += "H" + a.toString(32)),
          (e += ":")
      } else (a = Vh++), (e = ":" + e + "r" + a.toString(32) + ":")
      return (s.memoizedState = e)
    },
    unstable_isNewReconciler: !1,
  },
  Zh = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: fi,
    useRef: si,
    useState: function () {
      return fi(ei)
    },
    useDebugValue: Ai,
    useDeferredValue: function (s) {
      var e = di()
      return Di(e, O.memoizedState, s)
    },
    useTransition: function () {
      var s = fi(ei)[0],
        e = di().memoizedState
      return [s, e]
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1,
  },
  $h = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: gi,
    useRef: si,
    useState: function () {
      return gi(ei)
    },
    useDebugValue: Ai,
    useDeferredValue: function (s) {
      var e = di()
      return O === null ? (e.memoizedState = s) : Di(e, O.memoizedState, s)
    },
    useTransition: function () {
      var s = gi(ei)[0],
        e = di().memoizedState
      return [s, e]
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1,
  }
function Ki(s, e) {
  try {
    var a = "",
      o = e
    do (a += Pa(o)), (o = o.return)
    while (o)
    var c = a
  } catch (d) {
    c =
      `
Error generating stack: ` +
      d.message +
      `
` +
      d.stack
  }
  return { value: s, source: e, stack: c, digest: null }
}
function Li(s, e, a) {
  return { value: s, source: null, stack: a ?? null, digest: e ?? null }
}
function Mi(s, e) {
  try {
    console.error(e.value)
  } catch (a) {
    setTimeout(function () {
      throw a
    })
  }
}
var Ni = typeof WeakMap == "function" ? WeakMap : Map
function Oi(s, e, a) {
  ;(a = ch(-1, a)), (a.tag = 3), (a.payload = { element: null })
  var o = e.value
  return (
    (a.callback = function () {
      Pi || ((Pi = !0), (Qi = o)), Mi(s, e)
    }),
    a
  )
}
function Ri(s, e, a) {
  ;(a = ch(-1, a)), (a.tag = 3)
  var o = s.type.getDerivedStateFromError
  if (typeof o == "function") {
    var c = e.value
    ;(a.payload = function () {
      return o(c)
    }),
      (a.callback = function () {
        Mi(s, e)
      })
  }
  var d = s.stateNode
  return (
    d !== null &&
      typeof d.componentDidCatch == "function" &&
      (a.callback = function () {
        Mi(s, e),
          typeof o != "function" &&
            (Si === null ? (Si = new Set([this])) : Si.add(this))
        var g = e.stack
        this.componentDidCatch(e.value, { componentStack: g !== null ? g : "" })
      }),
    a
  )
}
function Ti(s, e, a) {
  var o = s.pingCache
  if (o === null) {
    o = s.pingCache = new Ni()
    var c = new Set()
    o.set(e, c)
  } else (c = o.get(e)), c === void 0 && ((c = new Set()), o.set(e, c))
  c.has(a) || (c.add(a), (s = Ui.bind(null, s, e, a)), e.then(s, s))
}
function Vi(s) {
  do {
    var e
    if (
      ((e = s.tag === 13) &&
        ((e = s.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return s
    s = s.return
  } while (s !== null)
  return null
}
function Wi(s, e, a, o, c) {
  return s.mode & 1
    ? ((s.flags |= 65536), (s.lanes = c), s)
    : (s === e
        ? (s.flags |= 65536)
        : ((s.flags |= 128),
          (a.flags |= 131072),
          (a.flags &= -52805),
          a.tag === 1 &&
            (a.alternate === null
              ? (a.tag = 17)
              : ((e = ch(-1, 1)), (e.tag = 2), dh(a, e, 1))),
          (a.lanes |= 1)),
      s)
}
var Xi = ua.ReactCurrentOwner,
  Ug = !1
function Yi(s, e, a, o) {
  e.child = s === null ? Ch(e, null, a, o) : Bh(e, s.child, a, o)
}
function Zi(s, e, a, o, c) {
  a = a.render
  var d = e.ref
  return (
    Tg(e, c),
    (o = Xh(s, e, a, o, d, c)),
    (a = bi()),
    s !== null && !Ug
      ? ((e.updateQueue = s.updateQueue),
        (e.flags &= -2053),
        (s.lanes &= ~c),
        $i(s, e, c))
      : (I && a && vg(e), (e.flags |= 1), Yi(s, e, o, c), e.child)
  )
}
function aj(s, e, a, o, c) {
  if (s === null) {
    var d = a.type
    return typeof d == "function" &&
      !bj(d) &&
      d.defaultProps === void 0 &&
      a.compare === null &&
      a.defaultProps === void 0
      ? ((e.tag = 15), (e.type = d), cj(s, e, d, o, c))
      : ((s = yh(a.type, null, o, e, e.mode, c)),
        (s.ref = e.ref),
        (s.return = e),
        (e.child = s))
  }
  if (((d = s.child), !(s.lanes & c))) {
    var g = d.memoizedProps
    if (
      ((a = a.compare), (a = a !== null ? a : Ie), a(g, o) && s.ref === e.ref)
    )
      return $i(s, e, c)
  }
  return (
    (e.flags |= 1),
    (s = wh(d, o)),
    (s.ref = e.ref),
    (s.return = e),
    (e.child = s)
  )
}
function cj(s, e, a, o, c) {
  if (s !== null) {
    var d = s.memoizedProps
    if (Ie(d, o) && s.ref === e.ref)
      if (((Ug = !1), (e.pendingProps = o = d), (s.lanes & c) !== 0))
        s.flags & 131072 && (Ug = !0)
      else return (e.lanes = s.lanes), $i(s, e, c)
  }
  return dj(s, e, a, o, c)
}
function ej(s, e, a) {
  var o = e.pendingProps,
    c = o.children,
    d = s !== null ? s.memoizedState : null
  if (o.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        G(fj, gj),
        (gj |= a)
    else {
      if (!(a & 1073741824))
        return (
          (s = d !== null ? d.baseLanes | a : a),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: s,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          G(fj, gj),
          (gj |= s),
          null
        )
      ;(e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (o = d !== null ? d.baseLanes : a),
        G(fj, gj),
        (gj |= o)
    }
  else
    d !== null ? ((o = d.baseLanes | a), (e.memoizedState = null)) : (o = a),
      G(fj, gj),
      (gj |= o)
  return Yi(s, e, c, a), e.child
}
function hj(s, e) {
  var a = e.ref
  ;((s === null && a !== null) || (s !== null && s.ref !== a)) &&
    ((e.flags |= 512), (e.flags |= 2097152))
}
function dj(s, e, a, o, c) {
  var d = Zf(a) ? Xf : H.current
  return (
    (d = Yf(e, d)),
    Tg(e, c),
    (a = Xh(s, e, a, o, d, c)),
    (o = bi()),
    s !== null && !Ug
      ? ((e.updateQueue = s.updateQueue),
        (e.flags &= -2053),
        (s.lanes &= ~c),
        $i(s, e, c))
      : (I && o && vg(e), (e.flags |= 1), Yi(s, e, a, c), e.child)
  )
}
function ij(s, e, a, o, c) {
  if (Zf(a)) {
    var d = !0
    cg(e)
  } else d = !1
  if ((Tg(e, c), e.stateNode === null))
    jj(s, e), ph(e, a, o), rh(e, a, o, c), (o = !0)
  else if (s === null) {
    var g = e.stateNode,
      _ = e.memoizedProps
    g.props = _
    var b = g.context,
      j = a.contextType
    typeof j == "object" && j !== null
      ? (j = Vg(j))
      : ((j = Zf(a) ? Xf : H.current), (j = Yf(e, j)))
    var $ = a.getDerivedStateFromProps,
      _e =
        typeof $ == "function" || typeof g.getSnapshotBeforeUpdate == "function"
    _e ||
      (typeof g.UNSAFE_componentWillReceiveProps != "function" &&
        typeof g.componentWillReceiveProps != "function") ||
      ((_ !== o || b !== j) && qh(e, g, o, j)),
      ($g = !1)
    var tt = e.memoizedState
    ;(g.state = tt),
      gh(e, o, g, c),
      (b = e.memoizedState),
      _ !== o || tt !== b || Wf.current || $g
        ? (typeof $ == "function" && (kh(e, a, $, o), (b = e.memoizedState)),
          (_ = $g || oh(e, a, _, o, tt, b, j))
            ? (_e ||
                (typeof g.UNSAFE_componentWillMount != "function" &&
                  typeof g.componentWillMount != "function") ||
                (typeof g.componentWillMount == "function" &&
                  g.componentWillMount(),
                typeof g.UNSAFE_componentWillMount == "function" &&
                  g.UNSAFE_componentWillMount()),
              typeof g.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof g.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = o),
              (e.memoizedState = b)),
          (g.props = o),
          (g.state = b),
          (g.context = j),
          (o = _))
        : (typeof g.componentDidMount == "function" && (e.flags |= 4194308),
          (o = !1))
  } else {
    ;(g = e.stateNode),
      bh(s, e),
      (_ = e.memoizedProps),
      (j = e.type === e.elementType ? _ : Lg(e.type, _)),
      (g.props = j),
      (_e = e.pendingProps),
      (tt = g.context),
      (b = a.contextType),
      typeof b == "object" && b !== null
        ? (b = Vg(b))
        : ((b = Zf(a) ? Xf : H.current), (b = Yf(e, b)))
    var st = a.getDerivedStateFromProps
    ;($ =
      typeof st == "function" ||
      typeof g.getSnapshotBeforeUpdate == "function") ||
      (typeof g.UNSAFE_componentWillReceiveProps != "function" &&
        typeof g.componentWillReceiveProps != "function") ||
      ((_ !== _e || tt !== b) && qh(e, g, o, b)),
      ($g = !1),
      (tt = e.memoizedState),
      (g.state = tt),
      gh(e, o, g, c)
    var at = e.memoizedState
    _ !== _e || tt !== at || Wf.current || $g
      ? (typeof st == "function" && (kh(e, a, st, o), (at = e.memoizedState)),
        (j = $g || oh(e, a, j, o, tt, at, b) || !1)
          ? ($ ||
              (typeof g.UNSAFE_componentWillUpdate != "function" &&
                typeof g.componentWillUpdate != "function") ||
              (typeof g.componentWillUpdate == "function" &&
                g.componentWillUpdate(o, at, b),
              typeof g.UNSAFE_componentWillUpdate == "function" &&
                g.UNSAFE_componentWillUpdate(o, at, b)),
            typeof g.componentDidUpdate == "function" && (e.flags |= 4),
            typeof g.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof g.componentDidUpdate != "function" ||
              (_ === s.memoizedProps && tt === s.memoizedState) ||
              (e.flags |= 4),
            typeof g.getSnapshotBeforeUpdate != "function" ||
              (_ === s.memoizedProps && tt === s.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = o),
            (e.memoizedState = at)),
        (g.props = o),
        (g.state = at),
        (g.context = b),
        (o = j))
      : (typeof g.componentDidUpdate != "function" ||
          (_ === s.memoizedProps && tt === s.memoizedState) ||
          (e.flags |= 4),
        typeof g.getSnapshotBeforeUpdate != "function" ||
          (_ === s.memoizedProps && tt === s.memoizedState) ||
          (e.flags |= 1024),
        (o = !1))
  }
  return kj(s, e, a, o, d, c)
}
function kj(s, e, a, o, c, d) {
  hj(s, e)
  var g = (e.flags & 128) !== 0
  if (!o && !g) return c && dg(e, a, !1), $i(s, e, d)
  ;(o = e.stateNode), (Xi.current = e)
  var _ =
    g && typeof a.getDerivedStateFromError != "function" ? null : o.render()
  return (
    (e.flags |= 1),
    s !== null && g
      ? ((e.child = Bh(e, s.child, null, d)), (e.child = Bh(e, null, _, d)))
      : Yi(s, e, _, d),
    (e.memoizedState = o.state),
    c && dg(e, a, !0),
    e.child
  )
}
function lj(s) {
  var e = s.stateNode
  e.pendingContext
    ? ag(s, e.pendingContext, e.pendingContext !== e.context)
    : e.context && ag(s, e.context, !1),
    Ih(s, e.containerInfo)
}
function mj(s, e, a, o, c) {
  return Ig(), Jg(c), (e.flags |= 256), Yi(s, e, a, o), e.child
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 }
function oj(s) {
  return { baseLanes: s, cachePool: null, transitions: null }
}
function pj(s, e, a) {
  var o = e.pendingProps,
    c = M.current,
    d = !1,
    g = (e.flags & 128) !== 0,
    _
  if (
    ((_ = g) ||
      (_ = s !== null && s.memoizedState === null ? !1 : (c & 2) !== 0),
    _
      ? ((d = !0), (e.flags &= -129))
      : (s === null || s.memoizedState !== null) && (c |= 1),
    G(M, c & 1),
    s === null)
  )
    return (
      Eg(e),
      (s = e.memoizedState),
      s !== null && ((s = s.dehydrated), s !== null)
        ? (e.mode & 1
            ? s.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((g = o.children),
          (s = o.fallback),
          d
            ? ((o = e.mode),
              (d = e.child),
              (g = { mode: "hidden", children: g }),
              !(o & 1) && d !== null
                ? ((d.childLanes = 0), (d.pendingProps = g))
                : (d = qj(g, o, 0, null)),
              (s = Ah(s, o, a, null)),
              (d.return = e),
              (s.return = e),
              (d.sibling = s),
              (e.child = d),
              (e.child.memoizedState = oj(a)),
              (e.memoizedState = nj),
              s)
            : rj(e, g))
    )
  if (((c = s.memoizedState), c !== null && ((_ = c.dehydrated), _ !== null)))
    return sj(s, e, g, o, _, c, a)
  if (d) {
    ;(d = o.fallback), (g = e.mode), (c = s.child), (_ = c.sibling)
    var b = { mode: "hidden", children: o.children }
    return (
      !(g & 1) && e.child !== c
        ? ((o = e.child),
          (o.childLanes = 0),
          (o.pendingProps = b),
          (e.deletions = null))
        : ((o = wh(c, b)), (o.subtreeFlags = c.subtreeFlags & 14680064)),
      _ !== null ? (d = wh(_, d)) : ((d = Ah(d, g, a, null)), (d.flags |= 2)),
      (d.return = e),
      (o.return = e),
      (o.sibling = d),
      (e.child = o),
      (o = d),
      (d = e.child),
      (g = s.child.memoizedState),
      (g =
        g === null
          ? oj(a)
          : {
              baseLanes: g.baseLanes | a,
              cachePool: null,
              transitions: g.transitions,
            }),
      (d.memoizedState = g),
      (d.childLanes = s.childLanes & ~a),
      (e.memoizedState = nj),
      o
    )
  }
  return (
    (d = s.child),
    (s = d.sibling),
    (o = wh(d, { mode: "visible", children: o.children })),
    !(e.mode & 1) && (o.lanes = a),
    (o.return = e),
    (o.sibling = null),
    s !== null &&
      ((a = e.deletions),
      a === null ? ((e.deletions = [s]), (e.flags |= 16)) : a.push(s)),
    (e.child = o),
    (e.memoizedState = null),
    o
  )
}
function rj(s, e) {
  return (
    (e = qj({ mode: "visible", children: e }, s.mode, 0, null)),
    (e.return = s),
    (s.child = e)
  )
}
function tj(s, e, a, o) {
  return (
    o !== null && Jg(o),
    Bh(e, s.child, null, a),
    (s = rj(e, e.pendingProps.children)),
    (s.flags |= 2),
    (e.memoizedState = null),
    s
  )
}
function sj(s, e, a, o, c, d, g) {
  if (a)
    return e.flags & 256
      ? ((e.flags &= -257), (o = Li(Error(p$1(422)))), tj(s, e, g, o))
      : e.memoizedState !== null
      ? ((e.child = s.child), (e.flags |= 128), null)
      : ((d = o.fallback),
        (c = e.mode),
        (o = qj({ mode: "visible", children: o.children }, c, 0, null)),
        (d = Ah(d, c, g, null)),
        (d.flags |= 2),
        (o.return = e),
        (d.return = e),
        (o.sibling = d),
        (e.child = o),
        e.mode & 1 && Bh(e, s.child, null, g),
        (e.child.memoizedState = oj(g)),
        (e.memoizedState = nj),
        d)
  if (!(e.mode & 1)) return tj(s, e, g, null)
  if (c.data === "$!") {
    if (((o = c.nextSibling && c.nextSibling.dataset), o)) var _ = o.dgst
    return (
      (o = _), (d = Error(p$1(419))), (o = Li(d, o, void 0)), tj(s, e, g, o)
    )
  }
  if (((_ = (g & s.childLanes) !== 0), Ug || _)) {
    if (((o = R), o !== null)) {
      switch (g & -g) {
        case 4:
          c = 2
          break
        case 16:
          c = 8
          break
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          c = 32
          break
        case 536870912:
          c = 268435456
          break
        default:
          c = 0
      }
      ;(c = c & (o.suspendedLanes | g) ? 0 : c),
        c !== 0 &&
          c !== d.retryLane &&
          ((d.retryLane = c), Zg(s, c), mh(o, s, c, -1))
    }
    return uj(), (o = Li(Error(p$1(421)))), tj(s, e, g, o)
  }
  return c.data === "$?"
    ? ((e.flags |= 128),
      (e.child = s.child),
      (e = vj.bind(null, s)),
      (c._reactRetry = e),
      null)
    : ((s = d.treeContext),
      (yg = Lf(c.nextSibling)),
      (xg = e),
      (I = !0),
      (zg = null),
      s !== null &&
        ((og[pg++] = rg),
        (og[pg++] = sg),
        (og[pg++] = qg),
        (rg = s.id),
        (sg = s.overflow),
        (qg = e)),
      (e = rj(e, o.children)),
      (e.flags |= 4096),
      e)
}
function wj(s, e, a) {
  s.lanes |= e
  var o = s.alternate
  o !== null && (o.lanes |= e), Sg(s.return, e, a)
}
function xj(s, e, a, o, c) {
  var d = s.memoizedState
  d === null
    ? (s.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: o,
        tail: a,
        tailMode: c,
      })
    : ((d.isBackwards = e),
      (d.rendering = null),
      (d.renderingStartTime = 0),
      (d.last = o),
      (d.tail = a),
      (d.tailMode = c))
}
function yj(s, e, a) {
  var o = e.pendingProps,
    c = o.revealOrder,
    d = o.tail
  if ((Yi(s, e, o.children, a), (o = M.current), o & 2))
    (o = (o & 1) | 2), (e.flags |= 128)
  else {
    if (s !== null && s.flags & 128)
      e: for (s = e.child; s !== null; ) {
        if (s.tag === 13) s.memoizedState !== null && wj(s, a, e)
        else if (s.tag === 19) wj(s, a, e)
        else if (s.child !== null) {
          ;(s.child.return = s), (s = s.child)
          continue
        }
        if (s === e) break e
        for (; s.sibling === null; ) {
          if (s.return === null || s.return === e) break e
          s = s.return
        }
        ;(s.sibling.return = s.return), (s = s.sibling)
      }
    o &= 1
  }
  if ((G(M, o), !(e.mode & 1))) e.memoizedState = null
  else
    switch (c) {
      case "forwards":
        for (a = e.child, c = null; a !== null; )
          (s = a.alternate),
            s !== null && Mh(s) === null && (c = a),
            (a = a.sibling)
        ;(a = c),
          a === null
            ? ((c = e.child), (e.child = null))
            : ((c = a.sibling), (a.sibling = null)),
          xj(e, !1, c, a, d)
        break
      case "backwards":
        for (a = null, c = e.child, e.child = null; c !== null; ) {
          if (((s = c.alternate), s !== null && Mh(s) === null)) {
            e.child = c
            break
          }
          ;(s = c.sibling), (c.sibling = a), (a = c), (c = s)
        }
        xj(e, !0, a, null, d)
        break
      case "together":
        xj(e, !1, null, null, void 0)
        break
      default:
        e.memoizedState = null
    }
  return e.child
}
function jj(s, e) {
  !(e.mode & 1) &&
    s !== null &&
    ((s.alternate = null), (e.alternate = null), (e.flags |= 2))
}
function $i(s, e, a) {
  if (
    (s !== null && (e.dependencies = s.dependencies),
    (hh |= e.lanes),
    !(a & e.childLanes))
  )
    return null
  if (s !== null && e.child !== s.child) throw Error(p$1(153))
  if (e.child !== null) {
    for (
      s = e.child, a = wh(s, s.pendingProps), e.child = a, a.return = e;
      s.sibling !== null;

    )
      (s = s.sibling), (a = a.sibling = wh(s, s.pendingProps)), (a.return = e)
    a.sibling = null
  }
  return e.child
}
function zj(s, e, a) {
  switch (e.tag) {
    case 3:
      lj(e), Ig()
      break
    case 5:
      Kh(e)
      break
    case 1:
      Zf(e.type) && cg(e)
      break
    case 4:
      Ih(e, e.stateNode.containerInfo)
      break
    case 10:
      var o = e.type._context,
        c = e.memoizedProps.value
      G(Mg, o._currentValue), (o._currentValue = c)
      break
    case 13:
      if (((o = e.memoizedState), o !== null))
        return o.dehydrated !== null
          ? (G(M, M.current & 1), (e.flags |= 128), null)
          : a & e.child.childLanes
          ? pj(s, e, a)
          : (G(M, M.current & 1),
            (s = $i(s, e, a)),
            s !== null ? s.sibling : null)
      G(M, M.current & 1)
      break
    case 19:
      if (((o = (a & e.childLanes) !== 0), s.flags & 128)) {
        if (o) return yj(s, e, a)
        e.flags |= 128
      }
      if (
        ((c = e.memoizedState),
        c !== null &&
          ((c.rendering = null), (c.tail = null), (c.lastEffect = null)),
        G(M, M.current),
        o)
      )
        break
      return null
    case 22:
    case 23:
      return (e.lanes = 0), ej(s, e, a)
  }
  return $i(s, e, a)
}
var Aj, Bj, Cj, Dj
Aj = function (s, e) {
  for (var a = e.child; a !== null; ) {
    if (a.tag === 5 || a.tag === 6) s.appendChild(a.stateNode)
    else if (a.tag !== 4 && a.child !== null) {
      ;(a.child.return = a), (a = a.child)
      continue
    }
    if (a === e) break
    for (; a.sibling === null; ) {
      if (a.return === null || a.return === e) return
      a = a.return
    }
    ;(a.sibling.return = a.return), (a = a.sibling)
  }
}
Bj = function () {}
Cj = function (s, e, a, o) {
  var c = s.memoizedProps
  if (c !== o) {
    ;(s = e.stateNode), Hh(Eh.current)
    var d = null
    switch (a) {
      case "input":
        ;(c = Ya(s, c)), (o = Ya(s, o)), (d = [])
        break
      case "select":
        ;(c = A({}, c, { value: void 0 })),
          (o = A({}, o, { value: void 0 })),
          (d = [])
        break
      case "textarea":
        ;(c = gb(s, c)), (o = gb(s, o)), (d = [])
        break
      default:
        typeof c.onClick != "function" &&
          typeof o.onClick == "function" &&
          (s.onclick = Bf)
    }
    ub(a, o)
    var g
    a = null
    for (j in c)
      if (!o.hasOwnProperty(j) && c.hasOwnProperty(j) && c[j] != null)
        if (j === "style") {
          var _ = c[j]
          for (g in _) _.hasOwnProperty(g) && (a || (a = {}), (a[g] = ""))
        } else
          j !== "dangerouslySetInnerHTML" &&
            j !== "children" &&
            j !== "suppressContentEditableWarning" &&
            j !== "suppressHydrationWarning" &&
            j !== "autoFocus" &&
            (ea.hasOwnProperty(j) ? d || (d = []) : (d = d || []).push(j, null))
    for (j in o) {
      var b = o[j]
      if (
        ((_ = c != null ? c[j] : void 0),
        o.hasOwnProperty(j) && b !== _ && (b != null || _ != null))
      )
        if (j === "style")
          if (_) {
            for (g in _)
              !_.hasOwnProperty(g) ||
                (b && b.hasOwnProperty(g)) ||
                (a || (a = {}), (a[g] = ""))
            for (g in b)
              b.hasOwnProperty(g) &&
                _[g] !== b[g] &&
                (a || (a = {}), (a[g] = b[g]))
          } else a || (d || (d = []), d.push(j, a)), (a = b)
        else
          j === "dangerouslySetInnerHTML"
            ? ((b = b ? b.__html : void 0),
              (_ = _ ? _.__html : void 0),
              b != null && _ !== b && (d = d || []).push(j, b))
            : j === "children"
            ? (typeof b != "string" && typeof b != "number") ||
              (d = d || []).push(j, "" + b)
            : j !== "suppressContentEditableWarning" &&
              j !== "suppressHydrationWarning" &&
              (ea.hasOwnProperty(j)
                ? (b != null && j === "onScroll" && D("scroll", s),
                  d || _ === b || (d = []))
                : (d = d || []).push(j, b))
    }
    a && (d = d || []).push("style", a)
    var j = d
    ;(e.updateQueue = j) && (e.flags |= 4)
  }
}
Dj = function (s, e, a, o) {
  a !== o && (e.flags |= 4)
}
function Ej(s, e) {
  if (!I)
    switch (s.tailMode) {
      case "hidden":
        e = s.tail
        for (var a = null; e !== null; )
          e.alternate !== null && (a = e), (e = e.sibling)
        a === null ? (s.tail = null) : (a.sibling = null)
        break
      case "collapsed":
        a = s.tail
        for (var o = null; a !== null; )
          a.alternate !== null && (o = a), (a = a.sibling)
        o === null
          ? e || s.tail === null
            ? (s.tail = null)
            : (s.tail.sibling = null)
          : (o.sibling = null)
    }
}
function S(s) {
  var e = s.alternate !== null && s.alternate.child === s.child,
    a = 0,
    o = 0
  if (e)
    for (var c = s.child; c !== null; )
      (a |= c.lanes | c.childLanes),
        (o |= c.subtreeFlags & 14680064),
        (o |= c.flags & 14680064),
        (c.return = s),
        (c = c.sibling)
  else
    for (c = s.child; c !== null; )
      (a |= c.lanes | c.childLanes),
        (o |= c.subtreeFlags),
        (o |= c.flags),
        (c.return = s),
        (c = c.sibling)
  return (s.subtreeFlags |= o), (s.childLanes = a), e
}
function Fj(s, e, a) {
  var o = e.pendingProps
  switch ((wg(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(e), null
    case 1:
      return Zf(e.type) && $f(), S(e), null
    case 3:
      return (
        (o = e.stateNode),
        Jh(),
        E(Wf),
        E(H),
        Oh(),
        o.pendingContext &&
          ((o.context = o.pendingContext), (o.pendingContext = null)),
        (s === null || s.child === null) &&
          (Gg(e)
            ? (e.flags |= 4)
            : s === null ||
              (s.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), zg !== null && (Gj(zg), (zg = null)))),
        Bj(s, e),
        S(e),
        null
      )
    case 5:
      Lh(e)
      var c = Hh(Gh.current)
      if (((a = e.type), s !== null && e.stateNode != null))
        Cj(s, e, a, o, c),
          s.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152))
      else {
        if (!o) {
          if (e.stateNode === null) throw Error(p$1(166))
          return S(e), null
        }
        if (((s = Hh(Eh.current)), Gg(e))) {
          ;(o = e.stateNode), (a = e.type)
          var d = e.memoizedProps
          switch (((o[Of] = e), (o[Pf] = d), (s = (e.mode & 1) !== 0), a)) {
            case "dialog":
              D("cancel", o), D("close", o)
              break
            case "iframe":
            case "object":
            case "embed":
              D("load", o)
              break
            case "video":
            case "audio":
              for (c = 0; c < lf.length; c++) D(lf[c], o)
              break
            case "source":
              D("error", o)
              break
            case "img":
            case "image":
            case "link":
              D("error", o), D("load", o)
              break
            case "details":
              D("toggle", o)
              break
            case "input":
              Za(o, d), D("invalid", o)
              break
            case "select":
              ;(o._wrapperState = { wasMultiple: !!d.multiple }),
                D("invalid", o)
              break
            case "textarea":
              hb(o, d), D("invalid", o)
          }
          ub(a, d), (c = null)
          for (var g in d)
            if (d.hasOwnProperty(g)) {
              var _ = d[g]
              g === "children"
                ? typeof _ == "string"
                  ? o.textContent !== _ &&
                    (d.suppressHydrationWarning !== !0 &&
                      Af(o.textContent, _, s),
                    (c = ["children", _]))
                  : typeof _ == "number" &&
                    o.textContent !== "" + _ &&
                    (d.suppressHydrationWarning !== !0 &&
                      Af(o.textContent, _, s),
                    (c = ["children", "" + _]))
                : ea.hasOwnProperty(g) &&
                  _ != null &&
                  g === "onScroll" &&
                  D("scroll", o)
            }
          switch (a) {
            case "input":
              Va(o), db(o, d, !0)
              break
            case "textarea":
              Va(o), jb(o)
              break
            case "select":
            case "option":
              break
            default:
              typeof d.onClick == "function" && (o.onclick = Bf)
          }
          ;(o = c), (e.updateQueue = o), o !== null && (e.flags |= 4)
        } else {
          ;(g = c.nodeType === 9 ? c : c.ownerDocument),
            s === "http://www.w3.org/1999/xhtml" && (s = kb(a)),
            s === "http://www.w3.org/1999/xhtml"
              ? a === "script"
                ? ((s = g.createElement("div")),
                  (s.innerHTML = "<script></script>"),
                  (s = s.removeChild(s.firstChild)))
                : typeof o.is == "string"
                ? (s = g.createElement(a, { is: o.is }))
                : ((s = g.createElement(a)),
                  a === "select" &&
                    ((g = s),
                    o.multiple
                      ? (g.multiple = !0)
                      : o.size && (g.size = o.size)))
              : (s = g.createElementNS(s, a)),
            (s[Of] = e),
            (s[Pf] = o),
            Aj(s, e, !1, !1),
            (e.stateNode = s)
          e: {
            switch (((g = vb(a, o)), a)) {
              case "dialog":
                D("cancel", s), D("close", s), (c = o)
                break
              case "iframe":
              case "object":
              case "embed":
                D("load", s), (c = o)
                break
              case "video":
              case "audio":
                for (c = 0; c < lf.length; c++) D(lf[c], s)
                c = o
                break
              case "source":
                D("error", s), (c = o)
                break
              case "img":
              case "image":
              case "link":
                D("error", s), D("load", s), (c = o)
                break
              case "details":
                D("toggle", s), (c = o)
                break
              case "input":
                Za(s, o), (c = Ya(s, o)), D("invalid", s)
                break
              case "option":
                c = o
                break
              case "select":
                ;(s._wrapperState = { wasMultiple: !!o.multiple }),
                  (c = A({}, o, { value: void 0 })),
                  D("invalid", s)
                break
              case "textarea":
                hb(s, o), (c = gb(s, o)), D("invalid", s)
                break
              default:
                c = o
            }
            ub(a, c), (_ = c)
            for (d in _)
              if (_.hasOwnProperty(d)) {
                var b = _[d]
                d === "style"
                  ? sb(s, b)
                  : d === "dangerouslySetInnerHTML"
                  ? ((b = b ? b.__html : void 0), b != null && nb(s, b))
                  : d === "children"
                  ? typeof b == "string"
                    ? (a !== "textarea" || b !== "") && ob(s, b)
                    : typeof b == "number" && ob(s, "" + b)
                  : d !== "suppressContentEditableWarning" &&
                    d !== "suppressHydrationWarning" &&
                    d !== "autoFocus" &&
                    (ea.hasOwnProperty(d)
                      ? b != null && d === "onScroll" && D("scroll", s)
                      : b != null && ta(s, d, b, g))
              }
            switch (a) {
              case "input":
                Va(s), db(s, o, !1)
                break
              case "textarea":
                Va(s), jb(s)
                break
              case "option":
                o.value != null && s.setAttribute("value", "" + Sa(o.value))
                break
              case "select":
                ;(s.multiple = !!o.multiple),
                  (d = o.value),
                  d != null
                    ? fb(s, !!o.multiple, d, !1)
                    : o.defaultValue != null &&
                      fb(s, !!o.multiple, o.defaultValue, !0)
                break
              default:
                typeof c.onClick == "function" && (s.onclick = Bf)
            }
            switch (a) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                o = !!o.autoFocus
                break e
              case "img":
                o = !0
                break e
              default:
                o = !1
            }
          }
          o && (e.flags |= 4)
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152))
      }
      return S(e), null
    case 6:
      if (s && e.stateNode != null) Dj(s, e, s.memoizedProps, o)
      else {
        if (typeof o != "string" && e.stateNode === null) throw Error(p$1(166))
        if (((a = Hh(Gh.current)), Hh(Eh.current), Gg(e))) {
          if (
            ((o = e.stateNode),
            (a = e.memoizedProps),
            (o[Of] = e),
            (d = o.nodeValue !== a) && ((s = xg), s !== null))
          )
            switch (s.tag) {
              case 3:
                Af(o.nodeValue, a, (s.mode & 1) !== 0)
                break
              case 5:
                s.memoizedProps.suppressHydrationWarning !== !0 &&
                  Af(o.nodeValue, a, (s.mode & 1) !== 0)
            }
          d && (e.flags |= 4)
        } else
          (o = (a.nodeType === 9 ? a : a.ownerDocument).createTextNode(o)),
            (o[Of] = e),
            (e.stateNode = o)
      }
      return S(e), null
    case 13:
      if (
        (E(M),
        (o = e.memoizedState),
        s === null ||
          (s.memoizedState !== null && s.memoizedState.dehydrated !== null))
      ) {
        if (I && yg !== null && e.mode & 1 && !(e.flags & 128))
          Hg(), Ig(), (e.flags |= 98560), (d = !1)
        else if (((d = Gg(e)), o !== null && o.dehydrated !== null)) {
          if (s === null) {
            if (!d) throw Error(p$1(318))
            if (
              ((d = e.memoizedState),
              (d = d !== null ? d.dehydrated : null),
              !d)
            )
              throw Error(p$1(317))
            d[Of] = e
          } else
            Ig(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4)
          S(e), (d = !1)
        } else zg !== null && (Gj(zg), (zg = null)), (d = !0)
        if (!d) return e.flags & 65536 ? e : null
      }
      return e.flags & 128
        ? ((e.lanes = a), e)
        : ((o = o !== null),
          o !== (s !== null && s.memoizedState !== null) &&
            o &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (s === null || M.current & 1 ? T === 0 && (T = 3) : uj())),
          e.updateQueue !== null && (e.flags |= 4),
          S(e),
          null)
    case 4:
      return (
        Jh(), Bj(s, e), s === null && sf(e.stateNode.containerInfo), S(e), null
      )
    case 10:
      return Rg(e.type._context), S(e), null
    case 17:
      return Zf(e.type) && $f(), S(e), null
    case 19:
      if ((E(M), (d = e.memoizedState), d === null)) return S(e), null
      if (((o = (e.flags & 128) !== 0), (g = d.rendering), g === null))
        if (o) Ej(d, !1)
        else {
          if (T !== 0 || (s !== null && s.flags & 128))
            for (s = e.child; s !== null; ) {
              if (((g = Mh(s)), g !== null)) {
                for (
                  e.flags |= 128,
                    Ej(d, !1),
                    o = g.updateQueue,
                    o !== null && ((e.updateQueue = o), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    o = a,
                    a = e.child;
                  a !== null;

                )
                  (d = a),
                    (s = o),
                    (d.flags &= 14680066),
                    (g = d.alternate),
                    g === null
                      ? ((d.childLanes = 0),
                        (d.lanes = s),
                        (d.child = null),
                        (d.subtreeFlags = 0),
                        (d.memoizedProps = null),
                        (d.memoizedState = null),
                        (d.updateQueue = null),
                        (d.dependencies = null),
                        (d.stateNode = null))
                      : ((d.childLanes = g.childLanes),
                        (d.lanes = g.lanes),
                        (d.child = g.child),
                        (d.subtreeFlags = 0),
                        (d.deletions = null),
                        (d.memoizedProps = g.memoizedProps),
                        (d.memoizedState = g.memoizedState),
                        (d.updateQueue = g.updateQueue),
                        (d.type = g.type),
                        (s = g.dependencies),
                        (d.dependencies =
                          s === null
                            ? null
                            : {
                                lanes: s.lanes,
                                firstContext: s.firstContext,
                              })),
                    (a = a.sibling)
                return G(M, (M.current & 1) | 2), e.child
              }
              s = s.sibling
            }
          d.tail !== null &&
            B() > Hj &&
            ((e.flags |= 128), (o = !0), Ej(d, !1), (e.lanes = 4194304))
        }
      else {
        if (!o)
          if (((s = Mh(g)), s !== null)) {
            if (
              ((e.flags |= 128),
              (o = !0),
              (a = s.updateQueue),
              a !== null && ((e.updateQueue = a), (e.flags |= 4)),
              Ej(d, !0),
              d.tail === null && d.tailMode === "hidden" && !g.alternate && !I)
            )
              return S(e), null
          } else
            2 * B() - d.renderingStartTime > Hj &&
              a !== 1073741824 &&
              ((e.flags |= 128), (o = !0), Ej(d, !1), (e.lanes = 4194304))
        d.isBackwards
          ? ((g.sibling = e.child), (e.child = g))
          : ((a = d.last),
            a !== null ? (a.sibling = g) : (e.child = g),
            (d.last = g))
      }
      return d.tail !== null
        ? ((e = d.tail),
          (d.rendering = e),
          (d.tail = e.sibling),
          (d.renderingStartTime = B()),
          (e.sibling = null),
          (a = M.current),
          G(M, o ? (a & 1) | 2 : a & 1),
          e)
        : (S(e), null)
    case 22:
    case 23:
      return (
        Ij(),
        (o = e.memoizedState !== null),
        s !== null && (s.memoizedState !== null) !== o && (e.flags |= 8192),
        o && e.mode & 1
          ? gj & 1073741824 && (S(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : S(e),
        null
      )
    case 24:
      return null
    case 25:
      return null
  }
  throw Error(p$1(156, e.tag))
}
function Jj(s, e) {
  switch ((wg(e), e.tag)) {
    case 1:
      return (
        Zf(e.type) && $f(),
        (s = e.flags),
        s & 65536 ? ((e.flags = (s & -65537) | 128), e) : null
      )
    case 3:
      return (
        Jh(),
        E(Wf),
        E(H),
        Oh(),
        (s = e.flags),
        s & 65536 && !(s & 128) ? ((e.flags = (s & -65537) | 128), e) : null
      )
    case 5:
      return Lh(e), null
    case 13:
      if ((E(M), (s = e.memoizedState), s !== null && s.dehydrated !== null)) {
        if (e.alternate === null) throw Error(p$1(340))
        Ig()
      }
      return (
        (s = e.flags), s & 65536 ? ((e.flags = (s & -65537) | 128), e) : null
      )
    case 19:
      return E(M), null
    case 4:
      return Jh(), null
    case 10:
      return Rg(e.type._context), null
    case 22:
    case 23:
      return Ij(), null
    case 24:
      return null
    default:
      return null
  }
}
var Kj = !1,
  U = !1,
  Lj = typeof WeakSet == "function" ? WeakSet : Set,
  V = null
function Mj(s, e) {
  var a = s.ref
  if (a !== null)
    if (typeof a == "function")
      try {
        a(null)
      } catch (o) {
        W(s, e, o)
      }
    else a.current = null
}
function Nj(s, e, a) {
  try {
    a()
  } catch (o) {
    W(s, e, o)
  }
}
var Oj = !1
function Pj(s, e) {
  if (((Cf = dd), (s = Me()), Ne(s))) {
    if ("selectionStart" in s)
      var a = { start: s.selectionStart, end: s.selectionEnd }
    else
      e: {
        a = ((a = s.ownerDocument) && a.defaultView) || window
        var o = a.getSelection && a.getSelection()
        if (o && o.rangeCount !== 0) {
          a = o.anchorNode
          var c = o.anchorOffset,
            d = o.focusNode
          o = o.focusOffset
          try {
            a.nodeType, d.nodeType
          } catch {
            a = null
            break e
          }
          var g = 0,
            _ = -1,
            b = -1,
            j = 0,
            $ = 0,
            _e = s,
            tt = null
          t: for (;;) {
            for (
              var st;
              _e !== a || (c !== 0 && _e.nodeType !== 3) || (_ = g + c),
                _e !== d || (o !== 0 && _e.nodeType !== 3) || (b = g + o),
                _e.nodeType === 3 && (g += _e.nodeValue.length),
                (st = _e.firstChild) !== null;

            )
              (tt = _e), (_e = st)
            for (;;) {
              if (_e === s) break t
              if (
                (tt === a && ++j === c && (_ = g),
                tt === d && ++$ === o && (b = g),
                (st = _e.nextSibling) !== null)
              )
                break
              ;(_e = tt), (tt = _e.parentNode)
            }
            _e = st
          }
          a = _ === -1 || b === -1 ? null : { start: _, end: b }
        } else a = null
      }
    a = a || { start: 0, end: 0 }
  } else a = null
  for (Df = { focusedElem: s, selectionRange: a }, dd = !1, V = e; V !== null; )
    if (((e = V), (s = e.child), (e.subtreeFlags & 1028) !== 0 && s !== null))
      (s.return = e), (V = s)
    else
      for (; V !== null; ) {
        e = V
        try {
          var at = e.alternate
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break
              case 1:
                if (at !== null) {
                  var ot = at.memoizedProps,
                    ut = at.memoizedState,
                    it = e.stateNode,
                    ct = it.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? ot : Lg(e.type, ot),
                      ut
                    )
                  it.__reactInternalSnapshotBeforeUpdate = ct
                }
                break
              case 3:
                var lt = e.stateNode.containerInfo
                lt.nodeType === 1
                  ? (lt.textContent = "")
                  : lt.nodeType === 9 &&
                    lt.documentElement &&
                    lt.removeChild(lt.documentElement)
                break
              case 5:
              case 6:
              case 4:
              case 17:
                break
              default:
                throw Error(p$1(163))
            }
        } catch (ht) {
          W(e, e.return, ht)
        }
        if (((s = e.sibling), s !== null)) {
          ;(s.return = e.return), (V = s)
          break
        }
        V = e.return
      }
  return (at = Oj), (Oj = !1), at
}
function Qj(s, e, a) {
  var o = e.updateQueue
  if (((o = o !== null ? o.lastEffect : null), o !== null)) {
    var c = (o = o.next)
    do {
      if ((c.tag & s) === s) {
        var d = c.destroy
        ;(c.destroy = void 0), d !== void 0 && Nj(e, a, d)
      }
      c = c.next
    } while (c !== o)
  }
}
function Rj(s, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var a = (e = e.next)
    do {
      if ((a.tag & s) === s) {
        var o = a.create
        a.destroy = o()
      }
      a = a.next
    } while (a !== e)
  }
}
function Sj(s) {
  var e = s.ref
  if (e !== null) {
    var a = s.stateNode
    switch (s.tag) {
      case 5:
        s = a
        break
      default:
        s = a
    }
    typeof e == "function" ? e(s) : (e.current = s)
  }
}
function Tj(s) {
  var e = s.alternate
  e !== null && ((s.alternate = null), Tj(e)),
    (s.child = null),
    (s.deletions = null),
    (s.sibling = null),
    s.tag === 5 &&
      ((e = s.stateNode),
      e !== null &&
        (delete e[Of], delete e[Pf], delete e[of], delete e[Qf], delete e[Rf])),
    (s.stateNode = null),
    (s.return = null),
    (s.dependencies = null),
    (s.memoizedProps = null),
    (s.memoizedState = null),
    (s.pendingProps = null),
    (s.stateNode = null),
    (s.updateQueue = null)
}
function Uj(s) {
  return s.tag === 5 || s.tag === 3 || s.tag === 4
}
function Vj(s) {
  e: for (;;) {
    for (; s.sibling === null; ) {
      if (s.return === null || Uj(s.return)) return null
      s = s.return
    }
    for (
      s.sibling.return = s.return, s = s.sibling;
      s.tag !== 5 && s.tag !== 6 && s.tag !== 18;

    ) {
      if (s.flags & 2 || s.child === null || s.tag === 4) continue e
      ;(s.child.return = s), (s = s.child)
    }
    if (!(s.flags & 2)) return s.stateNode
  }
}
function Wj(s, e, a) {
  var o = s.tag
  if (o === 5 || o === 6)
    (s = s.stateNode),
      e
        ? a.nodeType === 8
          ? a.parentNode.insertBefore(s, e)
          : a.insertBefore(s, e)
        : (a.nodeType === 8
            ? ((e = a.parentNode), e.insertBefore(s, a))
            : ((e = a), e.appendChild(s)),
          (a = a._reactRootContainer),
          a != null || e.onclick !== null || (e.onclick = Bf))
  else if (o !== 4 && ((s = s.child), s !== null))
    for (Wj(s, e, a), s = s.sibling; s !== null; ) Wj(s, e, a), (s = s.sibling)
}
function Xj(s, e, a) {
  var o = s.tag
  if (o === 5 || o === 6)
    (s = s.stateNode), e ? a.insertBefore(s, e) : a.appendChild(s)
  else if (o !== 4 && ((s = s.child), s !== null))
    for (Xj(s, e, a), s = s.sibling; s !== null; ) Xj(s, e, a), (s = s.sibling)
}
var X = null,
  Yj = !1
function Zj(s, e, a) {
  for (a = a.child; a !== null; ) ak(s, e, a), (a = a.sibling)
}
function ak(s, e, a) {
  if (lc && typeof lc.onCommitFiberUnmount == "function")
    try {
      lc.onCommitFiberUnmount(kc, a)
    } catch {}
  switch (a.tag) {
    case 5:
      U || Mj(a, e)
    case 6:
      var o = X,
        c = Yj
      ;(X = null),
        Zj(s, e, a),
        (X = o),
        (Yj = c),
        X !== null &&
          (Yj
            ? ((s = X),
              (a = a.stateNode),
              s.nodeType === 8 ? s.parentNode.removeChild(a) : s.removeChild(a))
            : X.removeChild(a.stateNode))
      break
    case 18:
      X !== null &&
        (Yj
          ? ((s = X),
            (a = a.stateNode),
            s.nodeType === 8
              ? Kf(s.parentNode, a)
              : s.nodeType === 1 && Kf(s, a),
            bd(s))
          : Kf(X, a.stateNode))
      break
    case 4:
      ;(o = X),
        (c = Yj),
        (X = a.stateNode.containerInfo),
        (Yj = !0),
        Zj(s, e, a),
        (X = o),
        (Yj = c)
      break
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !U &&
        ((o = a.updateQueue), o !== null && ((o = o.lastEffect), o !== null))
      ) {
        c = o = o.next
        do {
          var d = c,
            g = d.destroy
          ;(d = d.tag),
            g !== void 0 && (d & 2 || d & 4) && Nj(a, e, g),
            (c = c.next)
        } while (c !== o)
      }
      Zj(s, e, a)
      break
    case 1:
      if (
        !U &&
        (Mj(a, e),
        (o = a.stateNode),
        typeof o.componentWillUnmount == "function")
      )
        try {
          ;(o.props = a.memoizedProps),
            (o.state = a.memoizedState),
            o.componentWillUnmount()
        } catch (_) {
          W(a, e, _)
        }
      Zj(s, e, a)
      break
    case 21:
      Zj(s, e, a)
      break
    case 22:
      a.mode & 1
        ? ((U = (o = U) || a.memoizedState !== null), Zj(s, e, a), (U = o))
        : Zj(s, e, a)
      break
    default:
      Zj(s, e, a)
  }
}
function bk(s) {
  var e = s.updateQueue
  if (e !== null) {
    s.updateQueue = null
    var a = s.stateNode
    a === null && (a = s.stateNode = new Lj()),
      e.forEach(function (o) {
        var c = ck.bind(null, s, o)
        a.has(o) || (a.add(o), o.then(c, c))
      })
  }
}
function dk(s, e) {
  var a = e.deletions
  if (a !== null)
    for (var o = 0; o < a.length; o++) {
      var c = a[o]
      try {
        var d = s,
          g = e,
          _ = g
        e: for (; _ !== null; ) {
          switch (_.tag) {
            case 5:
              ;(X = _.stateNode), (Yj = !1)
              break e
            case 3:
              ;(X = _.stateNode.containerInfo), (Yj = !0)
              break e
            case 4:
              ;(X = _.stateNode.containerInfo), (Yj = !0)
              break e
          }
          _ = _.return
        }
        if (X === null) throw Error(p$1(160))
        ak(d, g, c), (X = null), (Yj = !1)
        var b = c.alternate
        b !== null && (b.return = null), (c.return = null)
      } catch (j) {
        W(c, e, j)
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) ek(e, s), (e = e.sibling)
}
function ek(s, e) {
  var a = s.alternate,
    o = s.flags
  switch (s.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((dk(e, s), fk(s), o & 4)) {
        try {
          Qj(3, s, s.return), Rj(3, s)
        } catch (ot) {
          W(s, s.return, ot)
        }
        try {
          Qj(5, s, s.return)
        } catch (ot) {
          W(s, s.return, ot)
        }
      }
      break
    case 1:
      dk(e, s), fk(s), o & 512 && a !== null && Mj(a, a.return)
      break
    case 5:
      if (
        (dk(e, s),
        fk(s),
        o & 512 && a !== null && Mj(a, a.return),
        s.flags & 32)
      ) {
        var c = s.stateNode
        try {
          ob(c, "")
        } catch (ot) {
          W(s, s.return, ot)
        }
      }
      if (o & 4 && ((c = s.stateNode), c != null)) {
        var d = s.memoizedProps,
          g = a !== null ? a.memoizedProps : d,
          _ = s.type,
          b = s.updateQueue
        if (((s.updateQueue = null), b !== null))
          try {
            _ === "input" && d.type === "radio" && d.name != null && ab(c, d),
              vb(_, g)
            var j = vb(_, d)
            for (g = 0; g < b.length; g += 2) {
              var $ = b[g],
                _e = b[g + 1]
              $ === "style"
                ? sb(c, _e)
                : $ === "dangerouslySetInnerHTML"
                ? nb(c, _e)
                : $ === "children"
                ? ob(c, _e)
                : ta(c, $, _e, j)
            }
            switch (_) {
              case "input":
                bb(c, d)
                break
              case "textarea":
                ib(c, d)
                break
              case "select":
                var tt = c._wrapperState.wasMultiple
                c._wrapperState.wasMultiple = !!d.multiple
                var st = d.value
                st != null
                  ? fb(c, !!d.multiple, st, !1)
                  : tt !== !!d.multiple &&
                    (d.defaultValue != null
                      ? fb(c, !!d.multiple, d.defaultValue, !0)
                      : fb(c, !!d.multiple, d.multiple ? [] : "", !1))
            }
            c[Pf] = d
          } catch (ot) {
            W(s, s.return, ot)
          }
      }
      break
    case 6:
      if ((dk(e, s), fk(s), o & 4)) {
        if (s.stateNode === null) throw Error(p$1(162))
        ;(c = s.stateNode), (d = s.memoizedProps)
        try {
          c.nodeValue = d
        } catch (ot) {
          W(s, s.return, ot)
        }
      }
      break
    case 3:
      if (
        (dk(e, s), fk(s), o & 4 && a !== null && a.memoizedState.isDehydrated)
      )
        try {
          bd(e.containerInfo)
        } catch (ot) {
          W(s, s.return, ot)
        }
      break
    case 4:
      dk(e, s), fk(s)
      break
    case 13:
      dk(e, s),
        fk(s),
        (c = s.child),
        c.flags & 8192 &&
          ((d = c.memoizedState !== null),
          (c.stateNode.isHidden = d),
          !d ||
            (c.alternate !== null && c.alternate.memoizedState !== null) ||
            (gk = B())),
        o & 4 && bk(s)
      break
    case 22:
      if (
        (($ = a !== null && a.memoizedState !== null),
        s.mode & 1 ? ((U = (j = U) || $), dk(e, s), (U = j)) : dk(e, s),
        fk(s),
        o & 8192)
      ) {
        if (
          ((j = s.memoizedState !== null),
          (s.stateNode.isHidden = j) && !$ && s.mode & 1)
        )
          for (V = s, $ = s.child; $ !== null; ) {
            for (_e = V = $; V !== null; ) {
              switch (((tt = V), (st = tt.child), tt.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, tt, tt.return)
                  break
                case 1:
                  Mj(tt, tt.return)
                  var at = tt.stateNode
                  if (typeof at.componentWillUnmount == "function") {
                    ;(o = tt), (a = tt.return)
                    try {
                      ;(e = o),
                        (at.props = e.memoizedProps),
                        (at.state = e.memoizedState),
                        at.componentWillUnmount()
                    } catch (ot) {
                      W(o, a, ot)
                    }
                  }
                  break
                case 5:
                  Mj(tt, tt.return)
                  break
                case 22:
                  if (tt.memoizedState !== null) {
                    hk(_e)
                    continue
                  }
              }
              st !== null ? ((st.return = tt), (V = st)) : hk(_e)
            }
            $ = $.sibling
          }
        e: for ($ = null, _e = s; ; ) {
          if (_e.tag === 5) {
            if ($ === null) {
              $ = _e
              try {
                ;(c = _e.stateNode),
                  j
                    ? ((d = c.style),
                      typeof d.setProperty == "function"
                        ? d.setProperty("display", "none", "important")
                        : (d.display = "none"))
                    : ((_ = _e.stateNode),
                      (b = _e.memoizedProps.style),
                      (g =
                        b != null && b.hasOwnProperty("display")
                          ? b.display
                          : null),
                      (_.style.display = rb("display", g)))
              } catch (ot) {
                W(s, s.return, ot)
              }
            }
          } else if (_e.tag === 6) {
            if ($ === null)
              try {
                _e.stateNode.nodeValue = j ? "" : _e.memoizedProps
              } catch (ot) {
                W(s, s.return, ot)
              }
          } else if (
            ((_e.tag !== 22 && _e.tag !== 23) ||
              _e.memoizedState === null ||
              _e === s) &&
            _e.child !== null
          ) {
            ;(_e.child.return = _e), (_e = _e.child)
            continue
          }
          if (_e === s) break e
          for (; _e.sibling === null; ) {
            if (_e.return === null || _e.return === s) break e
            $ === _e && ($ = null), (_e = _e.return)
          }
          $ === _e && ($ = null),
            (_e.sibling.return = _e.return),
            (_e = _e.sibling)
        }
      }
      break
    case 19:
      dk(e, s), fk(s), o & 4 && bk(s)
      break
    case 21:
      break
    default:
      dk(e, s), fk(s)
  }
}
function fk(s) {
  var e = s.flags
  if (e & 2) {
    try {
      e: {
        for (var a = s.return; a !== null; ) {
          if (Uj(a)) {
            var o = a
            break e
          }
          a = a.return
        }
        throw Error(p$1(160))
      }
      switch (o.tag) {
        case 5:
          var c = o.stateNode
          o.flags & 32 && (ob(c, ""), (o.flags &= -33))
          var d = Vj(s)
          Xj(s, d, c)
          break
        case 3:
        case 4:
          var g = o.stateNode.containerInfo,
            _ = Vj(s)
          Wj(s, _, g)
          break
        default:
          throw Error(p$1(161))
      }
    } catch (b) {
      W(s, s.return, b)
    }
    s.flags &= -3
  }
  e & 4096 && (s.flags &= -4097)
}
function ik(s, e, a) {
  ;(V = s), jk(s)
}
function jk(s, e, a) {
  for (var o = (s.mode & 1) !== 0; V !== null; ) {
    var c = V,
      d = c.child
    if (c.tag === 22 && o) {
      var g = c.memoizedState !== null || Kj
      if (!g) {
        var _ = c.alternate,
          b = (_ !== null && _.memoizedState !== null) || U
        _ = Kj
        var j = U
        if (((Kj = g), (U = b) && !j))
          for (V = c; V !== null; )
            (g = V),
              (b = g.child),
              g.tag === 22 && g.memoizedState !== null
                ? kk(c)
                : b !== null
                ? ((b.return = g), (V = b))
                : kk(c)
        for (; d !== null; ) (V = d), jk(d), (d = d.sibling)
        ;(V = c), (Kj = _), (U = j)
      }
      lk(s)
    } else
      c.subtreeFlags & 8772 && d !== null ? ((d.return = c), (V = d)) : lk(s)
  }
}
function lk(s) {
  for (; V !== null; ) {
    var e = V
    if (e.flags & 8772) {
      var a = e.alternate
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              U || Rj(5, e)
              break
            case 1:
              var o = e.stateNode
              if (e.flags & 4 && !U)
                if (a === null) o.componentDidMount()
                else {
                  var c =
                    e.elementType === e.type
                      ? a.memoizedProps
                      : Lg(e.type, a.memoizedProps)
                  o.componentDidUpdate(
                    c,
                    a.memoizedState,
                    o.__reactInternalSnapshotBeforeUpdate
                  )
                }
              var d = e.updateQueue
              d !== null && ih(e, d, o)
              break
            case 3:
              var g = e.updateQueue
              if (g !== null) {
                if (((a = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      a = e.child.stateNode
                      break
                    case 1:
                      a = e.child.stateNode
                  }
                ih(e, g, a)
              }
              break
            case 5:
              var _ = e.stateNode
              if (a === null && e.flags & 4) {
                a = _
                var b = e.memoizedProps
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    b.autoFocus && a.focus()
                    break
                  case "img":
                    b.src && (a.src = b.src)
                }
              }
              break
            case 6:
              break
            case 4:
              break
            case 12:
              break
            case 13:
              if (e.memoizedState === null) {
                var j = e.alternate
                if (j !== null) {
                  var $ = j.memoizedState
                  if ($ !== null) {
                    var _e = $.dehydrated
                    _e !== null && bd(_e)
                  }
                }
              }
              break
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break
            default:
              throw Error(p$1(163))
          }
        U || (e.flags & 512 && Sj(e))
      } catch (tt) {
        W(e, e.return, tt)
      }
    }
    if (e === s) {
      V = null
      break
    }
    if (((a = e.sibling), a !== null)) {
      ;(a.return = e.return), (V = a)
      break
    }
    V = e.return
  }
}
function hk(s) {
  for (; V !== null; ) {
    var e = V
    if (e === s) {
      V = null
      break
    }
    var a = e.sibling
    if (a !== null) {
      ;(a.return = e.return), (V = a)
      break
    }
    V = e.return
  }
}
function kk(s) {
  for (; V !== null; ) {
    var e = V
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var a = e.return
          try {
            Rj(4, e)
          } catch (b) {
            W(e, a, b)
          }
          break
        case 1:
          var o = e.stateNode
          if (typeof o.componentDidMount == "function") {
            var c = e.return
            try {
              o.componentDidMount()
            } catch (b) {
              W(e, c, b)
            }
          }
          var d = e.return
          try {
            Sj(e)
          } catch (b) {
            W(e, d, b)
          }
          break
        case 5:
          var g = e.return
          try {
            Sj(e)
          } catch (b) {
            W(e, g, b)
          }
      }
    } catch (b) {
      W(e, e.return, b)
    }
    if (e === s) {
      V = null
      break
    }
    var _ = e.sibling
    if (_ !== null) {
      ;(_.return = e.return), (V = _)
      break
    }
    V = e.return
  }
}
var mk = Math.ceil,
  nk = ua.ReactCurrentDispatcher,
  ok = ua.ReactCurrentOwner,
  pk = ua.ReactCurrentBatchConfig,
  K = 0,
  R = null,
  Y = null,
  Z = 0,
  gj = 0,
  fj = Uf(0),
  T = 0,
  qk = null,
  hh = 0,
  rk = 0,
  sk = 0,
  tk = null,
  uk = null,
  gk = 0,
  Hj = 1 / 0,
  vk = null,
  Pi = !1,
  Qi = null,
  Si = null,
  wk = !1,
  xk = null,
  yk = 0,
  zk = 0,
  Ak = null,
  Bk = -1,
  Ck = 0
function L() {
  return K & 6 ? B() : Bk !== -1 ? Bk : (Bk = B())
}
function lh(s) {
  return s.mode & 1
    ? K & 2 && Z !== 0
      ? Z & -Z
      : Kg.transition !== null
      ? (Ck === 0 && (Ck = yc()), Ck)
      : ((s = C),
        s !== 0 || ((s = window.event), (s = s === void 0 ? 16 : jd(s.type))),
        s)
    : 1
}
function mh(s, e, a, o) {
  if (50 < zk) throw ((zk = 0), (Ak = null), Error(p$1(185)))
  Ac(s, a, o),
    (!(K & 2) || s !== R) &&
      (s === R && (!(K & 2) && (rk |= a), T === 4 && Dk(s, Z)),
      Ek(s, o),
      a === 1 && K === 0 && !(e.mode & 1) && ((Hj = B() + 500), fg && jg()))
}
function Ek(s, e) {
  var a = s.callbackNode
  wc(s, e)
  var o = uc(s, s === R ? Z : 0)
  if (o === 0)
    a !== null && bc(a), (s.callbackNode = null), (s.callbackPriority = 0)
  else if (((e = o & -o), s.callbackPriority !== e)) {
    if ((a != null && bc(a), e === 1))
      s.tag === 0 ? ig(Fk.bind(null, s)) : hg(Fk.bind(null, s)),
        Jf(function () {
          !(K & 6) && jg()
        }),
        (a = null)
    else {
      switch (Dc(o)) {
        case 1:
          a = fc
          break
        case 4:
          a = gc
          break
        case 16:
          a = hc
          break
        case 536870912:
          a = jc
          break
        default:
          a = hc
      }
      a = Gk(a, Hk.bind(null, s))
    }
    ;(s.callbackPriority = e), (s.callbackNode = a)
  }
}
function Hk(s, e) {
  if (((Bk = -1), (Ck = 0), K & 6)) throw Error(p$1(327))
  var a = s.callbackNode
  if (Ik() && s.callbackNode !== a) return null
  var o = uc(s, s === R ? Z : 0)
  if (o === 0) return null
  if (o & 30 || o & s.expiredLanes || e) e = Jk(s, o)
  else {
    e = o
    var c = K
    K |= 2
    var d = Kk()
    ;(R !== s || Z !== e) && ((vk = null), (Hj = B() + 500), Lk(s, e))
    do
      try {
        Mk()
        break
      } catch (_) {
        Nk(s, _)
      }
    while (1)
    Qg(),
      (nk.current = d),
      (K = c),
      Y !== null ? (e = 0) : ((R = null), (Z = 0), (e = T))
  }
  if (e !== 0) {
    if (
      (e === 2 && ((c = xc(s)), c !== 0 && ((o = c), (e = Ok(s, c)))), e === 1)
    )
      throw ((a = qk), Lk(s, 0), Dk(s, o), Ek(s, B()), a)
    if (e === 6) Dk(s, o)
    else {
      if (
        ((c = s.current.alternate),
        !(o & 30) &&
          !Pk(c) &&
          ((e = Jk(s, o)),
          e === 2 && ((d = xc(s)), d !== 0 && ((o = d), (e = Ok(s, d)))),
          e === 1))
      )
        throw ((a = qk), Lk(s, 0), Dk(s, o), Ek(s, B()), a)
      switch (((s.finishedWork = c), (s.finishedLanes = o), e)) {
        case 0:
        case 1:
          throw Error(p$1(345))
        case 2:
          Qk(s, uk, vk)
          break
        case 3:
          if (
            (Dk(s, o), (o & 130023424) === o && ((e = gk + 500 - B()), 10 < e))
          ) {
            if (uc(s, 0) !== 0) break
            if (((c = s.suspendedLanes), (c & o) !== o)) {
              L(), (s.pingedLanes |= s.suspendedLanes & c)
              break
            }
            s.timeoutHandle = Ff(Qk.bind(null, s, uk, vk), e)
            break
          }
          Qk(s, uk, vk)
          break
        case 4:
          if ((Dk(s, o), (o & 4194240) === o)) break
          for (e = s.eventTimes, c = -1; 0 < o; ) {
            var g = 31 - oc(o)
            ;(d = 1 << g), (g = e[g]), g > c && (c = g), (o &= ~d)
          }
          if (
            ((o = c),
            (o = B() - o),
            (o =
              (120 > o
                ? 120
                : 480 > o
                ? 480
                : 1080 > o
                ? 1080
                : 1920 > o
                ? 1920
                : 3e3 > o
                ? 3e3
                : 4320 > o
                ? 4320
                : 1960 * mk(o / 1960)) - o),
            10 < o)
          ) {
            s.timeoutHandle = Ff(Qk.bind(null, s, uk, vk), o)
            break
          }
          Qk(s, uk, vk)
          break
        case 5:
          Qk(s, uk, vk)
          break
        default:
          throw Error(p$1(329))
      }
    }
  }
  return Ek(s, B()), s.callbackNode === a ? Hk.bind(null, s) : null
}
function Ok(s, e) {
  var a = tk
  return (
    s.current.memoizedState.isDehydrated && (Lk(s, e).flags |= 256),
    (s = Jk(s, e)),
    s !== 2 && ((e = uk), (uk = a), e !== null && Gj(e)),
    s
  )
}
function Gj(s) {
  uk === null ? (uk = s) : uk.push.apply(uk, s)
}
function Pk(s) {
  for (var e = s; ; ) {
    if (e.flags & 16384) {
      var a = e.updateQueue
      if (a !== null && ((a = a.stores), a !== null))
        for (var o = 0; o < a.length; o++) {
          var c = a[o],
            d = c.getSnapshot
          c = c.value
          try {
            if (!He(d(), c)) return !1
          } catch {
            return !1
          }
        }
    }
    if (((a = e.child), e.subtreeFlags & 16384 && a !== null))
      (a.return = e), (e = a)
    else {
      if (e === s) break
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === s) return !0
        e = e.return
      }
      ;(e.sibling.return = e.return), (e = e.sibling)
    }
  }
  return !0
}
function Dk(s, e) {
  for (
    e &= ~sk,
      e &= ~rk,
      s.suspendedLanes |= e,
      s.pingedLanes &= ~e,
      s = s.expirationTimes;
    0 < e;

  ) {
    var a = 31 - oc(e),
      o = 1 << a
    ;(s[a] = -1), (e &= ~o)
  }
}
function Fk(s) {
  if (K & 6) throw Error(p$1(327))
  Ik()
  var e = uc(s, 0)
  if (!(e & 1)) return Ek(s, B()), null
  var a = Jk(s, e)
  if (s.tag !== 0 && a === 2) {
    var o = xc(s)
    o !== 0 && ((e = o), (a = Ok(s, o)))
  }
  if (a === 1) throw ((a = qk), Lk(s, 0), Dk(s, e), Ek(s, B()), a)
  if (a === 6) throw Error(p$1(345))
  return (
    (s.finishedWork = s.current.alternate),
    (s.finishedLanes = e),
    Qk(s, uk, vk),
    Ek(s, B()),
    null
  )
}
function Rk(s, e) {
  var a = K
  K |= 1
  try {
    return s(e)
  } finally {
    ;(K = a), K === 0 && ((Hj = B() + 500), fg && jg())
  }
}
function Sk(s) {
  xk !== null && xk.tag === 0 && !(K & 6) && Ik()
  var e = K
  K |= 1
  var a = pk.transition,
    o = C
  try {
    if (((pk.transition = null), (C = 1), s)) return s()
  } finally {
    ;(C = o), (pk.transition = a), (K = e), !(K & 6) && jg()
  }
}
function Ij() {
  ;(gj = fj.current), E(fj)
}
function Lk(s, e) {
  ;(s.finishedWork = null), (s.finishedLanes = 0)
  var a = s.timeoutHandle
  if ((a !== -1 && ((s.timeoutHandle = -1), Gf(a)), Y !== null))
    for (a = Y.return; a !== null; ) {
      var o = a
      switch ((wg(o), o.tag)) {
        case 1:
          ;(o = o.type.childContextTypes), o != null && $f()
          break
        case 3:
          Jh(), E(Wf), E(H), Oh()
          break
        case 5:
          Lh(o)
          break
        case 4:
          Jh()
          break
        case 13:
          E(M)
          break
        case 19:
          E(M)
          break
        case 10:
          Rg(o.type._context)
          break
        case 22:
        case 23:
          Ij()
      }
      a = a.return
    }
  if (
    ((R = s),
    (Y = s = wh(s.current, null)),
    (Z = gj = e),
    (T = 0),
    (qk = null),
    (sk = rk = hh = 0),
    (uk = tk = null),
    Wg !== null)
  ) {
    for (e = 0; e < Wg.length; e++)
      if (((a = Wg[e]), (o = a.interleaved), o !== null)) {
        a.interleaved = null
        var c = o.next,
          d = a.pending
        if (d !== null) {
          var g = d.next
          ;(d.next = c), (o.next = g)
        }
        a.pending = o
      }
    Wg = null
  }
  return s
}
function Nk(s, e) {
  do {
    var a = Y
    try {
      if ((Qg(), (Ph.current = ai), Sh)) {
        for (var o = N.memoizedState; o !== null; ) {
          var c = o.queue
          c !== null && (c.pending = null), (o = o.next)
        }
        Sh = !1
      }
      if (
        ((Rh = 0),
        (P = O = N = null),
        (Th = !1),
        (Uh = 0),
        (ok.current = null),
        a === null || a.return === null)
      ) {
        ;(T = 1), (qk = e), (Y = null)
        break
      }
      e: {
        var d = s,
          g = a.return,
          _ = a,
          b = e
        if (
          ((e = Z),
          (_.flags |= 32768),
          b !== null && typeof b == "object" && typeof b.then == "function")
        ) {
          var j = b,
            $ = _,
            _e = $.tag
          if (!($.mode & 1) && (_e === 0 || _e === 11 || _e === 15)) {
            var tt = $.alternate
            tt
              ? (($.updateQueue = tt.updateQueue),
                ($.memoizedState = tt.memoizedState),
                ($.lanes = tt.lanes))
              : (($.updateQueue = null), ($.memoizedState = null))
          }
          var st = Vi(g)
          if (st !== null) {
            ;(st.flags &= -257),
              Wi(st, g, _, d, e),
              st.mode & 1 && Ti(d, j, e),
              (e = st),
              (b = j)
            var at = e.updateQueue
            if (at === null) {
              var ot = new Set()
              ot.add(b), (e.updateQueue = ot)
            } else at.add(b)
            break e
          } else {
            if (!(e & 1)) {
              Ti(d, j, e), uj()
              break e
            }
            b = Error(p$1(426))
          }
        } else if (I && _.mode & 1) {
          var ut = Vi(g)
          if (ut !== null) {
            !(ut.flags & 65536) && (ut.flags |= 256),
              Wi(ut, g, _, d, e),
              Jg(Ki(b, _))
            break e
          }
        }
        ;(d = b = Ki(b, _)),
          T !== 4 && (T = 2),
          tk === null ? (tk = [d]) : tk.push(d),
          (d = g)
        do {
          switch (d.tag) {
            case 3:
              ;(d.flags |= 65536), (e &= -e), (d.lanes |= e)
              var it = Oi(d, b, e)
              fh(d, it)
              break e
            case 1:
              _ = b
              var ct = d.type,
                lt = d.stateNode
              if (
                !(d.flags & 128) &&
                (typeof ct.getDerivedStateFromError == "function" ||
                  (lt !== null &&
                    typeof lt.componentDidCatch == "function" &&
                    (Si === null || !Si.has(lt))))
              ) {
                ;(d.flags |= 65536), (e &= -e), (d.lanes |= e)
                var ht = Ri(d, _, e)
                fh(d, ht)
                break e
              }
          }
          d = d.return
        } while (d !== null)
      }
      Tk(a)
    } catch (dt) {
      ;(e = dt), Y === a && a !== null && (Y = a = a.return)
      continue
    }
    break
  } while (1)
}
function Kk() {
  var s = nk.current
  return (nk.current = ai), s === null ? ai : s
}
function uj() {
  ;(T === 0 || T === 3 || T === 2) && (T = 4),
    R === null || (!(hh & 268435455) && !(rk & 268435455)) || Dk(R, Z)
}
function Jk(s, e) {
  var a = K
  K |= 2
  var o = Kk()
  ;(R !== s || Z !== e) && ((vk = null), Lk(s, e))
  do
    try {
      Uk()
      break
    } catch (c) {
      Nk(s, c)
    }
  while (1)
  if ((Qg(), (K = a), (nk.current = o), Y !== null)) throw Error(p$1(261))
  return (R = null), (Z = 0), T
}
function Uk() {
  for (; Y !== null; ) Vk(Y)
}
function Mk() {
  for (; Y !== null && !cc(); ) Vk(Y)
}
function Vk(s) {
  var e = Wk(s.alternate, s, gj)
  ;(s.memoizedProps = s.pendingProps),
    e === null ? Tk(s) : (Y = e),
    (ok.current = null)
}
function Tk(s) {
  var e = s
  do {
    var a = e.alternate
    if (((s = e.return), e.flags & 32768)) {
      if (((a = Jj(a, e)), a !== null)) {
        ;(a.flags &= 32767), (Y = a)
        return
      }
      if (s !== null)
        (s.flags |= 32768), (s.subtreeFlags = 0), (s.deletions = null)
      else {
        ;(T = 6), (Y = null)
        return
      }
    } else if (((a = Fj(a, e, gj)), a !== null)) {
      Y = a
      return
    }
    if (((e = e.sibling), e !== null)) {
      Y = e
      return
    }
    Y = e = s
  } while (e !== null)
  T === 0 && (T = 5)
}
function Qk(s, e, a) {
  var o = C,
    c = pk.transition
  try {
    ;(pk.transition = null), (C = 1), Xk(s, e, a, o)
  } finally {
    ;(pk.transition = c), (C = o)
  }
  return null
}
function Xk(s, e, a, o) {
  do Ik()
  while (xk !== null)
  if (K & 6) throw Error(p$1(327))
  a = s.finishedWork
  var c = s.finishedLanes
  if (a === null) return null
  if (((s.finishedWork = null), (s.finishedLanes = 0), a === s.current))
    throw Error(p$1(177))
  ;(s.callbackNode = null), (s.callbackPriority = 0)
  var d = a.lanes | a.childLanes
  if (
    (Bc(s, d),
    s === R && ((Y = R = null), (Z = 0)),
    (!(a.subtreeFlags & 2064) && !(a.flags & 2064)) ||
      wk ||
      ((wk = !0),
      Gk(hc, function () {
        return Ik(), null
      })),
    (d = (a.flags & 15990) !== 0),
    a.subtreeFlags & 15990 || d)
  ) {
    ;(d = pk.transition), (pk.transition = null)
    var g = C
    C = 1
    var _ = K
    ;(K |= 4),
      (ok.current = null),
      Pj(s, a),
      ek(a, s),
      Oe(Df),
      (dd = !!Cf),
      (Df = Cf = null),
      (s.current = a),
      ik(a),
      dc(),
      (K = _),
      (C = g),
      (pk.transition = d)
  } else s.current = a
  if (
    (wk && ((wk = !1), (xk = s), (yk = c)),
    (d = s.pendingLanes),
    d === 0 && (Si = null),
    mc(a.stateNode),
    Ek(s, B()),
    e !== null)
  )
    for (o = s.onRecoverableError, a = 0; a < e.length; a++)
      (c = e[a]), o(c.value, { componentStack: c.stack, digest: c.digest })
  if (Pi) throw ((Pi = !1), (s = Qi), (Qi = null), s)
  return (
    yk & 1 && s.tag !== 0 && Ik(),
    (d = s.pendingLanes),
    d & 1 ? (s === Ak ? zk++ : ((zk = 0), (Ak = s))) : (zk = 0),
    jg(),
    null
  )
}
function Ik() {
  if (xk !== null) {
    var s = Dc(yk),
      e = pk.transition,
      a = C
    try {
      if (((pk.transition = null), (C = 16 > s ? 16 : s), xk === null))
        var o = !1
      else {
        if (((s = xk), (xk = null), (yk = 0), K & 6)) throw Error(p$1(331))
        var c = K
        for (K |= 4, V = s.current; V !== null; ) {
          var d = V,
            g = d.child
          if (V.flags & 16) {
            var _ = d.deletions
            if (_ !== null) {
              for (var b = 0; b < _.length; b++) {
                var j = _[b]
                for (V = j; V !== null; ) {
                  var $ = V
                  switch ($.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, $, d)
                  }
                  var _e = $.child
                  if (_e !== null) (_e.return = $), (V = _e)
                  else
                    for (; V !== null; ) {
                      $ = V
                      var tt = $.sibling,
                        st = $.return
                      if ((Tj($), $ === j)) {
                        V = null
                        break
                      }
                      if (tt !== null) {
                        ;(tt.return = st), (V = tt)
                        break
                      }
                      V = st
                    }
                }
              }
              var at = d.alternate
              if (at !== null) {
                var ot = at.child
                if (ot !== null) {
                  at.child = null
                  do {
                    var ut = ot.sibling
                    ;(ot.sibling = null), (ot = ut)
                  } while (ot !== null)
                }
              }
              V = d
            }
          }
          if (d.subtreeFlags & 2064 && g !== null) (g.return = d), (V = g)
          else
            e: for (; V !== null; ) {
              if (((d = V), d.flags & 2048))
                switch (d.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, d, d.return)
                }
              var it = d.sibling
              if (it !== null) {
                ;(it.return = d.return), (V = it)
                break e
              }
              V = d.return
            }
        }
        var ct = s.current
        for (V = ct; V !== null; ) {
          g = V
          var lt = g.child
          if (g.subtreeFlags & 2064 && lt !== null) (lt.return = g), (V = lt)
          else
            e: for (g = ct; V !== null; ) {
              if (((_ = V), _.flags & 2048))
                try {
                  switch (_.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Rj(9, _)
                  }
                } catch (dt) {
                  W(_, _.return, dt)
                }
              if (_ === g) {
                V = null
                break e
              }
              var ht = _.sibling
              if (ht !== null) {
                ;(ht.return = _.return), (V = ht)
                break e
              }
              V = _.return
            }
        }
        if (
          ((K = c), jg(), lc && typeof lc.onPostCommitFiberRoot == "function")
        )
          try {
            lc.onPostCommitFiberRoot(kc, s)
          } catch {}
        o = !0
      }
      return o
    } finally {
      ;(C = a), (pk.transition = e)
    }
  }
  return !1
}
function Yk(s, e, a) {
  ;(e = Ki(a, e)),
    (e = Oi(s, e, 1)),
    (s = dh(s, e, 1)),
    (e = L()),
    s !== null && (Ac(s, 1, e), Ek(s, e))
}
function W(s, e, a) {
  if (s.tag === 3) Yk(s, s, a)
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        Yk(e, s, a)
        break
      } else if (e.tag === 1) {
        var o = e.stateNode
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof o.componentDidCatch == "function" &&
            (Si === null || !Si.has(o)))
        ) {
          ;(s = Ki(a, s)),
            (s = Ri(e, s, 1)),
            (e = dh(e, s, 1)),
            (s = L()),
            e !== null && (Ac(e, 1, s), Ek(e, s))
          break
        }
      }
      e = e.return
    }
}
function Ui(s, e, a) {
  var o = s.pingCache
  o !== null && o.delete(e),
    (e = L()),
    (s.pingedLanes |= s.suspendedLanes & a),
    R === s &&
      (Z & a) === a &&
      (T === 4 || (T === 3 && (Z & 130023424) === Z && 500 > B() - gk)
        ? Lk(s, 0)
        : (sk |= a)),
    Ek(s, e)
}
function Zk(s, e) {
  e === 0 &&
    (s.mode & 1
      ? ((e = sc), (sc <<= 1), !(sc & 130023424) && (sc = 4194304))
      : (e = 1))
  var a = L()
  ;(s = Zg(s, e)), s !== null && (Ac(s, e, a), Ek(s, a))
}
function vj(s) {
  var e = s.memoizedState,
    a = 0
  e !== null && (a = e.retryLane), Zk(s, a)
}
function ck(s, e) {
  var a = 0
  switch (s.tag) {
    case 13:
      var o = s.stateNode,
        c = s.memoizedState
      c !== null && (a = c.retryLane)
      break
    case 19:
      o = s.stateNode
      break
    default:
      throw Error(p$1(314))
  }
  o !== null && o.delete(e), Zk(s, a)
}
var Wk
Wk = function (s, e, a) {
  if (s !== null)
    if (s.memoizedProps !== e.pendingProps || Wf.current) Ug = !0
    else {
      if (!(s.lanes & a) && !(e.flags & 128)) return (Ug = !1), zj(s, e, a)
      Ug = !!(s.flags & 131072)
    }
  else (Ug = !1), I && e.flags & 1048576 && ug(e, ng, e.index)
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var o = e.type
      jj(s, e), (s = e.pendingProps)
      var c = Yf(e, H.current)
      Tg(e, a), (c = Xh(null, e, o, s, c, a))
      var d = bi()
      return (
        (e.flags |= 1),
        typeof c == "object" &&
        c !== null &&
        typeof c.render == "function" &&
        c.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Zf(o) ? ((d = !0), cg(e)) : (d = !1),
            (e.memoizedState =
              c.state !== null && c.state !== void 0 ? c.state : null),
            ah(e),
            (c.updater = nh),
            (e.stateNode = c),
            (c._reactInternals = e),
            rh(e, o, s, a),
            (e = kj(null, e, o, !0, d, a)))
          : ((e.tag = 0), I && d && vg(e), Yi(null, e, c, a), (e = e.child)),
        e
      )
    case 16:
      o = e.elementType
      e: {
        switch (
          (jj(s, e),
          (s = e.pendingProps),
          (c = o._init),
          (o = c(o._payload)),
          (e.type = o),
          (c = e.tag = $k(o)),
          (s = Lg(o, s)),
          c)
        ) {
          case 0:
            e = dj(null, e, o, s, a)
            break e
          case 1:
            e = ij(null, e, o, s, a)
            break e
          case 11:
            e = Zi(null, e, o, s, a)
            break e
          case 14:
            e = aj(null, e, o, Lg(o.type, s), a)
            break e
        }
        throw Error(p$1(306, o, ""))
      }
      return e
    case 0:
      return (
        (o = e.type),
        (c = e.pendingProps),
        (c = e.elementType === o ? c : Lg(o, c)),
        dj(s, e, o, c, a)
      )
    case 1:
      return (
        (o = e.type),
        (c = e.pendingProps),
        (c = e.elementType === o ? c : Lg(o, c)),
        ij(s, e, o, c, a)
      )
    case 3:
      e: {
        if ((lj(e), s === null)) throw Error(p$1(387))
        ;(o = e.pendingProps),
          (d = e.memoizedState),
          (c = d.element),
          bh(s, e),
          gh(e, o, null, a)
        var g = e.memoizedState
        if (((o = g.element), d.isDehydrated))
          if (
            ((d = {
              element: o,
              isDehydrated: !1,
              cache: g.cache,
              pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
              transitions: g.transitions,
            }),
            (e.updateQueue.baseState = d),
            (e.memoizedState = d),
            e.flags & 256)
          ) {
            ;(c = Ki(Error(p$1(423)), e)), (e = mj(s, e, o, a, c))
            break e
          } else if (o !== c) {
            ;(c = Ki(Error(p$1(424)), e)), (e = mj(s, e, o, a, c))
            break e
          } else
            for (
              yg = Lf(e.stateNode.containerInfo.firstChild),
                xg = e,
                I = !0,
                zg = null,
                a = Ch(e, null, o, a),
                e.child = a;
              a;

            )
              (a.flags = (a.flags & -3) | 4096), (a = a.sibling)
        else {
          if ((Ig(), o === c)) {
            e = $i(s, e, a)
            break e
          }
          Yi(s, e, o, a)
        }
        e = e.child
      }
      return e
    case 5:
      return (
        Kh(e),
        s === null && Eg(e),
        (o = e.type),
        (c = e.pendingProps),
        (d = s !== null ? s.memoizedProps : null),
        (g = c.children),
        Ef(o, c) ? (g = null) : d !== null && Ef(o, d) && (e.flags |= 32),
        hj(s, e),
        Yi(s, e, g, a),
        e.child
      )
    case 6:
      return s === null && Eg(e), null
    case 13:
      return pj(s, e, a)
    case 4:
      return (
        Ih(e, e.stateNode.containerInfo),
        (o = e.pendingProps),
        s === null ? (e.child = Bh(e, null, o, a)) : Yi(s, e, o, a),
        e.child
      )
    case 11:
      return (
        (o = e.type),
        (c = e.pendingProps),
        (c = e.elementType === o ? c : Lg(o, c)),
        Zi(s, e, o, c, a)
      )
    case 7:
      return Yi(s, e, e.pendingProps, a), e.child
    case 8:
      return Yi(s, e, e.pendingProps.children, a), e.child
    case 12:
      return Yi(s, e, e.pendingProps.children, a), e.child
    case 10:
      e: {
        if (
          ((o = e.type._context),
          (c = e.pendingProps),
          (d = e.memoizedProps),
          (g = c.value),
          G(Mg, o._currentValue),
          (o._currentValue = g),
          d !== null)
        )
          if (He(d.value, g)) {
            if (d.children === c.children && !Wf.current) {
              e = $i(s, e, a)
              break e
            }
          } else
            for (d = e.child, d !== null && (d.return = e); d !== null; ) {
              var _ = d.dependencies
              if (_ !== null) {
                g = d.child
                for (var b = _.firstContext; b !== null; ) {
                  if (b.context === o) {
                    if (d.tag === 1) {
                      ;(b = ch(-1, a & -a)), (b.tag = 2)
                      var j = d.updateQueue
                      if (j !== null) {
                        j = j.shared
                        var $ = j.pending
                        $ === null
                          ? (b.next = b)
                          : ((b.next = $.next), ($.next = b)),
                          (j.pending = b)
                      }
                    }
                    ;(d.lanes |= a),
                      (b = d.alternate),
                      b !== null && (b.lanes |= a),
                      Sg(d.return, a, e),
                      (_.lanes |= a)
                    break
                  }
                  b = b.next
                }
              } else if (d.tag === 10) g = d.type === e.type ? null : d.child
              else if (d.tag === 18) {
                if (((g = d.return), g === null)) throw Error(p$1(341))
                ;(g.lanes |= a),
                  (_ = g.alternate),
                  _ !== null && (_.lanes |= a),
                  Sg(g, a, e),
                  (g = d.sibling)
              } else g = d.child
              if (g !== null) g.return = d
              else
                for (g = d; g !== null; ) {
                  if (g === e) {
                    g = null
                    break
                  }
                  if (((d = g.sibling), d !== null)) {
                    ;(d.return = g.return), (g = d)
                    break
                  }
                  g = g.return
                }
              d = g
            }
        Yi(s, e, c.children, a), (e = e.child)
      }
      return e
    case 9:
      return (
        (c = e.type),
        (o = e.pendingProps.children),
        Tg(e, a),
        (c = Vg(c)),
        (o = o(c)),
        (e.flags |= 1),
        Yi(s, e, o, a),
        e.child
      )
    case 14:
      return (
        (o = e.type),
        (c = Lg(o, e.pendingProps)),
        (c = Lg(o.type, c)),
        aj(s, e, o, c, a)
      )
    case 15:
      return cj(s, e, e.type, e.pendingProps, a)
    case 17:
      return (
        (o = e.type),
        (c = e.pendingProps),
        (c = e.elementType === o ? c : Lg(o, c)),
        jj(s, e),
        (e.tag = 1),
        Zf(o) ? ((s = !0), cg(e)) : (s = !1),
        Tg(e, a),
        ph(e, o, c),
        rh(e, o, c, a),
        kj(null, e, o, !0, s, a)
      )
    case 19:
      return yj(s, e, a)
    case 22:
      return ej(s, e, a)
  }
  throw Error(p$1(156, e.tag))
}
function Gk(s, e) {
  return ac(s, e)
}
function al(s, e, a, o) {
  ;(this.tag = s),
    (this.key = a),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = o),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null)
}
function Bg(s, e, a, o) {
  return new al(s, e, a, o)
}
function bj(s) {
  return (s = s.prototype), !(!s || !s.isReactComponent)
}
function $k(s) {
  if (typeof s == "function") return bj(s) ? 1 : 0
  if (s != null) {
    if (((s = s.$$typeof), s === Da)) return 11
    if (s === Ga) return 14
  }
  return 2
}
function wh(s, e) {
  var a = s.alternate
  return (
    a === null
      ? ((a = Bg(s.tag, e, s.key, s.mode)),
        (a.elementType = s.elementType),
        (a.type = s.type),
        (a.stateNode = s.stateNode),
        (a.alternate = s),
        (s.alternate = a))
      : ((a.pendingProps = e),
        (a.type = s.type),
        (a.flags = 0),
        (a.subtreeFlags = 0),
        (a.deletions = null)),
    (a.flags = s.flags & 14680064),
    (a.childLanes = s.childLanes),
    (a.lanes = s.lanes),
    (a.child = s.child),
    (a.memoizedProps = s.memoizedProps),
    (a.memoizedState = s.memoizedState),
    (a.updateQueue = s.updateQueue),
    (e = s.dependencies),
    (a.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (a.sibling = s.sibling),
    (a.index = s.index),
    (a.ref = s.ref),
    a
  )
}
function yh(s, e, a, o, c, d) {
  var g = 2
  if (((o = s), typeof s == "function")) bj(s) && (g = 1)
  else if (typeof s == "string") g = 5
  else
    e: switch (s) {
      case ya:
        return Ah(a.children, c, d, e)
      case za:
        ;(g = 8), (c |= 8)
        break
      case Aa:
        return (s = Bg(12, a, e, c | 2)), (s.elementType = Aa), (s.lanes = d), s
      case Ea:
        return (s = Bg(13, a, e, c)), (s.elementType = Ea), (s.lanes = d), s
      case Fa:
        return (s = Bg(19, a, e, c)), (s.elementType = Fa), (s.lanes = d), s
      case Ia:
        return qj(a, c, d, e)
      default:
        if (typeof s == "object" && s !== null)
          switch (s.$$typeof) {
            case Ba:
              g = 10
              break e
            case Ca:
              g = 9
              break e
            case Da:
              g = 11
              break e
            case Ga:
              g = 14
              break e
            case Ha:
              ;(g = 16), (o = null)
              break e
          }
        throw Error(p$1(130, s == null ? s : typeof s, ""))
    }
  return (
    (e = Bg(g, a, e, c)), (e.elementType = s), (e.type = o), (e.lanes = d), e
  )
}
function Ah(s, e, a, o) {
  return (s = Bg(7, s, o, e)), (s.lanes = a), s
}
function qj(s, e, a, o) {
  return (
    (s = Bg(22, s, o, e)),
    (s.elementType = Ia),
    (s.lanes = a),
    (s.stateNode = { isHidden: !1 }),
    s
  )
}
function xh(s, e, a) {
  return (s = Bg(6, s, null, e)), (s.lanes = a), s
}
function zh(s, e, a) {
  return (
    (e = Bg(4, s.children !== null ? s.children : [], s.key, e)),
    (e.lanes = a),
    (e.stateNode = {
      containerInfo: s.containerInfo,
      pendingChildren: null,
      implementation: s.implementation,
    }),
    e
  )
}
function bl(s, e, a, o, c) {
  ;(this.tag = e),
    (this.containerInfo = s),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = zc(0)),
    (this.expirationTimes = zc(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = zc(0)),
    (this.identifierPrefix = o),
    (this.onRecoverableError = c),
    (this.mutableSourceEagerHydrationData = null)
}
function cl(s, e, a, o, c, d, g, _, b) {
  return (
    (s = new bl(s, e, a, _, b)),
    e === 1 ? ((e = 1), d === !0 && (e |= 8)) : (e = 0),
    (d = Bg(3, null, null, e)),
    (s.current = d),
    (d.stateNode = s),
    (d.memoizedState = {
      element: o,
      isDehydrated: a,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    ah(d),
    s
  )
}
function dl(s, e, a) {
  var o = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
  return {
    $$typeof: wa,
    key: o == null ? null : "" + o,
    children: s,
    containerInfo: e,
    implementation: a,
  }
}
function el(s) {
  if (!s) return Vf
  s = s._reactInternals
  e: {
    if (Vb(s) !== s || s.tag !== 1) throw Error(p$1(170))
    var e = s
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context
          break e
        case 1:
          if (Zf(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext
            break e
          }
      }
      e = e.return
    } while (e !== null)
    throw Error(p$1(171))
  }
  if (s.tag === 1) {
    var a = s.type
    if (Zf(a)) return bg(s, a, e)
  }
  return e
}
function fl$1(s, e, a, o, c, d, g, _, b) {
  return (
    (s = cl(a, o, !0, s, c, d, g, _, b)),
    (s.context = el(null)),
    (a = s.current),
    (o = L()),
    (c = lh(a)),
    (d = ch(o, c)),
    (d.callback = e ?? null),
    dh(a, d, c),
    (s.current.lanes = c),
    Ac(s, c, o),
    Ek(s, o),
    s
  )
}
function gl(s, e, a, o) {
  var c = e.current,
    d = L(),
    g = lh(c)
  return (
    (a = el(a)),
    e.context === null ? (e.context = a) : (e.pendingContext = a),
    (e = ch(d, g)),
    (e.payload = { element: s }),
    (o = o === void 0 ? null : o),
    o !== null && (e.callback = o),
    (s = dh(c, e, g)),
    s !== null && (mh(s, c, g, d), eh(s, c, g)),
    g
  )
}
function hl(s) {
  if (((s = s.current), !s.child)) return null
  switch (s.child.tag) {
    case 5:
      return s.child.stateNode
    default:
      return s.child.stateNode
  }
}
function il(s, e) {
  if (((s = s.memoizedState), s !== null && s.dehydrated !== null)) {
    var a = s.retryLane
    s.retryLane = a !== 0 && a < e ? a : e
  }
}
function jl(s, e) {
  il(s, e), (s = s.alternate) && il(s, e)
}
function kl() {
  return null
}
var ll =
  typeof reportError == "function"
    ? reportError
    : function (s) {
        console.error(s)
      }
function ml(s) {
  this._internalRoot = s
}
nl.prototype.render = ml.prototype.render = function (s) {
  var e = this._internalRoot
  if (e === null) throw Error(p$1(409))
  gl(s, e, null, null)
}
nl.prototype.unmount = ml.prototype.unmount = function () {
  var s = this._internalRoot
  if (s !== null) {
    this._internalRoot = null
    var e = s.containerInfo
    Sk(function () {
      gl(null, s, null, null)
    }),
      (e[uf] = null)
  }
}
function nl(s) {
  this._internalRoot = s
}
nl.prototype.unstable_scheduleHydration = function (s) {
  if (s) {
    var e = Hc()
    s = { blockedOn: null, target: s, priority: e }
    for (var a = 0; a < Qc.length && e !== 0 && e < Qc[a].priority; a++);
    Qc.splice(a, 0, s), a === 0 && Vc(s)
  }
}
function ol(s) {
  return !(!s || (s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11))
}
function pl(s) {
  return !(
    !s ||
    (s.nodeType !== 1 &&
      s.nodeType !== 9 &&
      s.nodeType !== 11 &&
      (s.nodeType !== 8 || s.nodeValue !== " react-mount-point-unstable "))
  )
}
function ql() {}
function rl(s, e, a, o, c) {
  if (c) {
    if (typeof o == "function") {
      var d = o
      o = function () {
        var j = hl(g)
        d.call(j)
      }
    }
    var g = fl$1(e, o, s, 0, null, !1, !1, "", ql)
    return (
      (s._reactRootContainer = g),
      (s[uf] = g.current),
      sf(s.nodeType === 8 ? s.parentNode : s),
      Sk(),
      g
    )
  }
  for (; (c = s.lastChild); ) s.removeChild(c)
  if (typeof o == "function") {
    var _ = o
    o = function () {
      var j = hl(b)
      _.call(j)
    }
  }
  var b = cl(s, 0, !1, null, null, !1, !1, "", ql)
  return (
    (s._reactRootContainer = b),
    (s[uf] = b.current),
    sf(s.nodeType === 8 ? s.parentNode : s),
    Sk(function () {
      gl(e, b, a, o)
    }),
    b
  )
}
function sl(s, e, a, o, c) {
  var d = a._reactRootContainer
  if (d) {
    var g = d
    if (typeof c == "function") {
      var _ = c
      c = function () {
        var b = hl(g)
        _.call(b)
      }
    }
    gl(e, g, s, c)
  } else g = rl(a, e, s, c, o)
  return hl(g)
}
Ec = function (s) {
  switch (s.tag) {
    case 3:
      var e = s.stateNode
      if (e.current.memoizedState.isDehydrated) {
        var a = tc(e.pendingLanes)
        a !== 0 &&
          (Cc(e, a | 1), Ek(e, B()), !(K & 6) && ((Hj = B() + 500), jg()))
      }
      break
    case 13:
      Sk(function () {
        var o = Zg(s, 1)
        if (o !== null) {
          var c = L()
          mh(o, s, 1, c)
        }
      }),
        jl(s, 1)
  }
}
Fc = function (s) {
  if (s.tag === 13) {
    var e = Zg(s, 134217728)
    if (e !== null) {
      var a = L()
      mh(e, s, 134217728, a)
    }
    jl(s, 134217728)
  }
}
Gc = function (s) {
  if (s.tag === 13) {
    var e = lh(s),
      a = Zg(s, e)
    if (a !== null) {
      var o = L()
      mh(a, s, e, o)
    }
    jl(s, e)
  }
}
Hc = function () {
  return C
}
Ic = function (s, e) {
  var a = C
  try {
    return (C = s), e()
  } finally {
    C = a
  }
}
yb = function (s, e, a) {
  switch (e) {
    case "input":
      if ((bb(s, a), (e = a.name), a.type === "radio" && e != null)) {
        for (a = s; a.parentNode; ) a = a.parentNode
        for (
          a = a.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < a.length;
          e++
        ) {
          var o = a[e]
          if (o !== s && o.form === s.form) {
            var c = Db(o)
            if (!c) throw Error(p$1(90))
            Wa(o), bb(o, c)
          }
        }
      }
      break
    case "textarea":
      ib(s, a)
      break
    case "select":
      ;(e = a.value), e != null && fb(s, !!a.multiple, e, !1)
  }
}
Gb = Rk
Hb = Sk
var tl = { usingClientEntryPoint: !1, Events: [Cb, ue, Db, Eb, Fb, Rk] },
  ul = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  vl = {
    bundleType: ul.bundleType,
    version: ul.version,
    rendererPackageName: ul.rendererPackageName,
    rendererConfig: ul.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (s) {
      return (s = Zb(s)), s === null ? null : s.stateNode
    },
    findFiberByHostInstance: ul.findFiberByHostInstance || kl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  }
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      ;(kc = wl.inject(vl)), (lc = wl)
    } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl
reactDom_production_min.createPortal = function (s, e) {
  var a = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
  if (!ol(e)) throw Error(p$1(200))
  return dl(s, e, null, a)
}
reactDom_production_min.createRoot = function (s, e) {
  if (!ol(s)) throw Error(p$1(299))
  var a = !1,
    o = "",
    c = ll
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (a = !0),
      e.identifierPrefix !== void 0 && (o = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (c = e.onRecoverableError)),
    (e = cl(s, 1, !1, null, null, a, !1, o, c)),
    (s[uf] = e.current),
    sf(s.nodeType === 8 ? s.parentNode : s),
    new ml(e)
  )
}
reactDom_production_min.findDOMNode = function (s) {
  if (s == null) return null
  if (s.nodeType === 1) return s
  var e = s._reactInternals
  if (e === void 0)
    throw typeof s.render == "function"
      ? Error(p$1(188))
      : ((s = Object.keys(s).join(",")), Error(p$1(268, s)))
  return (s = Zb(e)), (s = s === null ? null : s.stateNode), s
}
reactDom_production_min.flushSync = function (s) {
  return Sk(s)
}
reactDom_production_min.hydrate = function (s, e, a) {
  if (!pl(e)) throw Error(p$1(200))
  return sl(null, s, e, !0, a)
}
reactDom_production_min.hydrateRoot = function (s, e, a) {
  if (!ol(s)) throw Error(p$1(405))
  var o = (a != null && a.hydratedSources) || null,
    c = !1,
    d = "",
    g = ll
  if (
    (a != null &&
      (a.unstable_strictMode === !0 && (c = !0),
      a.identifierPrefix !== void 0 && (d = a.identifierPrefix),
      a.onRecoverableError !== void 0 && (g = a.onRecoverableError)),
    (e = fl$1(e, null, s, 1, a ?? null, c, !1, d, g)),
    (s[uf] = e.current),
    sf(s),
    o)
  )
    for (s = 0; s < o.length; s++)
      (a = o[s]),
        (c = a._getVersion),
        (c = c(a._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [a, c])
          : e.mutableSourceEagerHydrationData.push(a, c)
  return new nl(e)
}
reactDom_production_min.render = function (s, e, a) {
  if (!pl(e)) throw Error(p$1(200))
  return sl(null, s, e, !1, a)
}
reactDom_production_min.unmountComponentAtNode = function (s) {
  if (!pl(s)) throw Error(p$1(40))
  return s._reactRootContainer
    ? (Sk(function () {
        sl(null, null, s, !1, function () {
          ;(s._reactRootContainer = null), (s[uf] = null)
        })
      }),
      !0)
    : !1
}
reactDom_production_min.unstable_batchedUpdates = Rk
reactDom_production_min.unstable_renderSubtreeIntoContainer = function (
  s,
  e,
  a,
  o
) {
  if (!pl(a)) throw Error(p$1(200))
  if (s == null || s._reactInternals === void 0) throw Error(p$1(38))
  return sl(s, e, a, !1, o)
}
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608"
function checkDCE() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
    } catch (s) {
      console.error(s)
    }
}
checkDCE(), (reactDom.exports = reactDom_production_min)
var reactDomExports = reactDom.exports,
  createRoot$1,
  m = reactDomExports
;(createRoot$1 = client.createRoot = m.createRoot),
  (client.hydrateRoot = m.hydrateRoot)
/**
 * @remix-run/router v1.9.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function _extends$4() {
  return (
    (_extends$4 = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var a = arguments[e]
            for (var o in a)
              Object.prototype.hasOwnProperty.call(a, o) && (s[o] = a[o])
          }
          return s
        }),
    _extends$4.apply(this, arguments)
  )
}
var Action
;(function (s) {
  ;(s.Pop = "POP"), (s.Push = "PUSH"), (s.Replace = "REPLACE")
})(Action || (Action = {}))
const PopStateEventType = "popstate"
function createBrowserHistory(s) {
  s === void 0 && (s = {})
  function e(o, c) {
    let { pathname: d, search: g, hash: _ } = o.location
    return createLocation(
      "",
      { pathname: d, search: g, hash: _ },
      (c.state && c.state.usr) || null,
      (c.state && c.state.key) || "default"
    )
  }
  function a(o, c) {
    return typeof c == "string" ? c : createPath(c)
  }
  return getUrlBasedHistory(e, a, null, s)
}
function invariant$1(s, e) {
  if (s === !1 || s === null || typeof s > "u") throw new Error(e)
}
function createKey() {
  return Math.random().toString(36).substr(2, 8)
}
function getHistoryState(s, e) {
  return { usr: s.state, key: s.key, idx: e }
}
function createLocation(s, e, a, o) {
  return (
    a === void 0 && (a = null),
    _extends$4(
      { pathname: typeof s == "string" ? s : s.pathname, search: "", hash: "" },
      typeof e == "string" ? parsePath(e) : e,
      { state: a, key: (e && e.key) || o || createKey() }
    )
  )
}
function createPath(s) {
  let { pathname: e = "/", search: a = "", hash: o = "" } = s
  return (
    a && a !== "?" && (e += a.charAt(0) === "?" ? a : "?" + a),
    o && o !== "#" && (e += o.charAt(0) === "#" ? o : "#" + o),
    e
  )
}
function parsePath(s) {
  let e = {}
  if (s) {
    let a = s.indexOf("#")
    a >= 0 && ((e.hash = s.substr(a)), (s = s.substr(0, a)))
    let o = s.indexOf("?")
    o >= 0 && ((e.search = s.substr(o)), (s = s.substr(0, o))),
      s && (e.pathname = s)
  }
  return e
}
function getUrlBasedHistory(s, e, a, o) {
  o === void 0 && (o = {})
  let { window: c = document.defaultView, v5Compat: d = !1 } = o,
    g = c.history,
    _ = Action.Pop,
    b = null,
    j = $()
  j == null &&
    ((j = 0), g.replaceState(_extends$4({}, g.state, { idx: j }), ""))
  function $() {
    return (g.state || { idx: null }).idx
  }
  function _e() {
    _ = Action.Pop
    let ut = $(),
      it = ut == null ? null : ut - j
    ;(j = ut), b && b({ action: _, location: ot.location, delta: it })
  }
  function tt(ut, it) {
    _ = Action.Push
    let ct = createLocation(ot.location, ut, it)
    a && a(ct, ut), (j = $() + 1)
    let lt = getHistoryState(ct, j),
      ht = ot.createHref(ct)
    try {
      g.pushState(lt, "", ht)
    } catch (dt) {
      if (dt instanceof DOMException && dt.name === "DataCloneError") throw dt
      c.location.assign(ht)
    }
    d && b && b({ action: _, location: ot.location, delta: 1 })
  }
  function st(ut, it) {
    _ = Action.Replace
    let ct = createLocation(ot.location, ut, it)
    a && a(ct, ut), (j = $())
    let lt = getHistoryState(ct, j),
      ht = ot.createHref(ct)
    g.replaceState(lt, "", ht),
      d && b && b({ action: _, location: ot.location, delta: 0 })
  }
  function at(ut) {
    let it = c.location.origin !== "null" ? c.location.origin : c.location.href,
      ct = typeof ut == "string" ? ut : createPath(ut)
    return (
      invariant$1(
        it,
        "No window.location.(origin|href) available to create URL for href: " +
          ct
      ),
      new URL(ct, it)
    )
  }
  let ot = {
    get action() {
      return _
    },
    get location() {
      return s(c, g)
    },
    listen(ut) {
      if (b) throw new Error("A history only accepts one active listener")
      return (
        c.addEventListener(PopStateEventType, _e),
        (b = ut),
        () => {
          c.removeEventListener(PopStateEventType, _e), (b = null)
        }
      )
    },
    createHref(ut) {
      return e(c, ut)
    },
    createURL: at,
    encodeLocation(ut) {
      let it = at(ut)
      return { pathname: it.pathname, search: it.search, hash: it.hash }
    },
    push: tt,
    replace: st,
    go(ut) {
      return g.go(ut)
    },
  }
  return ot
}
var ResultType
;(function (s) {
  ;(s.data = "data"),
    (s.deferred = "deferred"),
    (s.redirect = "redirect"),
    (s.error = "error")
})(ResultType || (ResultType = {}))
function stripBasename(s, e) {
  if (e === "/") return s
  if (!s.toLowerCase().startsWith(e.toLowerCase())) return null
  let a = e.endsWith("/") ? e.length - 1 : e.length,
    o = s.charAt(a)
  return o && o !== "/" ? null : s.slice(a) || "/"
}
function resolvePath(s, e) {
  e === void 0 && (e = "/")
  let {
    pathname: a,
    search: o = "",
    hash: c = "",
  } = typeof s == "string" ? parsePath(s) : s
  return {
    pathname: a ? (a.startsWith("/") ? a : resolvePathname(a, e)) : e,
    search: normalizeSearch(o),
    hash: normalizeHash(c),
  }
}
function resolvePathname(s, e) {
  let a = e.replace(/\/+$/, "").split("/")
  return (
    s.split("/").forEach((c) => {
      c === ".." ? a.length > 1 && a.pop() : c !== "." && a.push(c)
    }),
    a.length > 1 ? a.join("/") : "/"
  )
}
function getInvalidPathError(s, e, a, o) {
  return (
    "Cannot include a '" +
    s +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(o) +
      "].  Please separate it out to the ") +
    ("`to." + a + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  )
}
function getPathContributingMatches(s) {
  return s.filter(
    (e, a) => a === 0 || (e.route.path && e.route.path.length > 0)
  )
}
function resolveTo(s, e, a, o) {
  o === void 0 && (o = !1)
  let c
  typeof s == "string"
    ? (c = parsePath(s))
    : ((c = _extends$4({}, s)),
      invariant$1(
        !c.pathname || !c.pathname.includes("?"),
        getInvalidPathError("?", "pathname", "search", c)
      ),
      invariant$1(
        !c.pathname || !c.pathname.includes("#"),
        getInvalidPathError("#", "pathname", "hash", c)
      ),
      invariant$1(
        !c.search || !c.search.includes("#"),
        getInvalidPathError("#", "search", "hash", c)
      ))
  let d = s === "" || c.pathname === "",
    g = d ? "/" : c.pathname,
    _
  if (o || g == null) _ = a
  else {
    let _e = e.length - 1
    if (g.startsWith("..")) {
      let tt = g.split("/")
      for (; tt[0] === ".."; ) tt.shift(), (_e -= 1)
      c.pathname = tt.join("/")
    }
    _ = _e >= 0 ? e[_e] : "/"
  }
  let b = resolvePath(c, _),
    j = g && g !== "/" && g.endsWith("/"),
    $ = (d || g === ".") && a.endsWith("/")
  return !b.pathname.endsWith("/") && (j || $) && (b.pathname += "/"), b
}
const joinPaths = (s) => s.join("/").replace(/\/\/+/g, "/"),
  normalizeSearch = (s) =>
    !s || s === "?" ? "" : s.startsWith("?") ? s : "?" + s,
  normalizeHash = (s) =>
    !s || s === "#" ? "" : s.startsWith("#") ? s : "#" + s,
  validMutationMethodsArr = ["post", "put", "patch", "delete"]
new Set(validMutationMethodsArr)
const validRequestMethodsArr = ["get", ...validMutationMethodsArr]
new Set(validRequestMethodsArr)
/**
 * React Router v6.16.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function _extends$3() {
  return (
    (_extends$3 = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var a = arguments[e]
            for (var o in a)
              Object.prototype.hasOwnProperty.call(a, o) && (s[o] = a[o])
          }
          return s
        }),
    _extends$3.apply(this, arguments)
  )
}
const DataRouterContext = reactExports.createContext(null),
  NavigationContext = reactExports.createContext(null),
  LocationContext = reactExports.createContext(null),
  RouteContext = reactExports.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1,
  })
function useHref(s, e) {
  let { relative: a } = e === void 0 ? {} : e
  useInRouterContext() || invariant$1(!1)
  let { basename: o, navigator: c } =
      reactExports.useContext(NavigationContext),
    { hash: d, pathname: g, search: _ } = useResolvedPath(s, { relative: a }),
    b = g
  return (
    o !== "/" && (b = g === "/" ? o : joinPaths([o, g])),
    c.createHref({ pathname: b, search: _, hash: d })
  )
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null
}
function useLocation() {
  return (
    useInRouterContext() || invariant$1(!1),
    reactExports.useContext(LocationContext).location
  )
}
function useIsomorphicLayoutEffect$3(s) {
  reactExports.useContext(NavigationContext).static ||
    reactExports.useLayoutEffect(s)
}
function useNavigate() {
  let { isDataRoute: s } = reactExports.useContext(RouteContext)
  return s ? useNavigateStable() : useNavigateUnstable()
}
function useNavigateUnstable() {
  useInRouterContext() || invariant$1(!1)
  let s = reactExports.useContext(DataRouterContext),
    { basename: e, navigator: a } = reactExports.useContext(NavigationContext),
    { matches: o } = reactExports.useContext(RouteContext),
    { pathname: c } = useLocation(),
    d = JSON.stringify(
      getPathContributingMatches(o).map((b) => b.pathnameBase)
    ),
    g = reactExports.useRef(!1)
  return (
    useIsomorphicLayoutEffect$3(() => {
      g.current = !0
    }),
    reactExports.useCallback(
      function (b, j) {
        if ((j === void 0 && (j = {}), !g.current)) return
        if (typeof b == "number") {
          a.go(b)
          return
        }
        let $ = resolveTo(b, JSON.parse(d), c, j.relative === "path")
        s == null &&
          e !== "/" &&
          ($.pathname = $.pathname === "/" ? e : joinPaths([e, $.pathname])),
          (j.replace ? a.replace : a.push)($, j.state, j)
      },
      [e, a, d, c, s]
    )
  )
}
function useResolvedPath(s, e) {
  let { relative: a } = e === void 0 ? {} : e,
    { matches: o } = reactExports.useContext(RouteContext),
    { pathname: c } = useLocation(),
    d = JSON.stringify(getPathContributingMatches(o).map((g) => g.pathnameBase))
  return reactExports.useMemo(
    () => resolveTo(s, JSON.parse(d), c, a === "path"),
    [s, d, c, a]
  )
}
var DataRouterHook$1 = (function (s) {
    return (
      (s.UseBlocker = "useBlocker"),
      (s.UseRevalidator = "useRevalidator"),
      (s.UseNavigateStable = "useNavigate"),
      s
    )
  })(DataRouterHook$1 || {}),
  DataRouterStateHook$1 = (function (s) {
    return (
      (s.UseBlocker = "useBlocker"),
      (s.UseLoaderData = "useLoaderData"),
      (s.UseActionData = "useActionData"),
      (s.UseRouteError = "useRouteError"),
      (s.UseNavigation = "useNavigation"),
      (s.UseRouteLoaderData = "useRouteLoaderData"),
      (s.UseMatches = "useMatches"),
      (s.UseRevalidator = "useRevalidator"),
      (s.UseNavigateStable = "useNavigate"),
      (s.UseRouteId = "useRouteId"),
      s
    )
  })(DataRouterStateHook$1 || {})
function useDataRouterContext(s) {
  let e = reactExports.useContext(DataRouterContext)
  return e || invariant$1(!1), e
}
function useRouteContext(s) {
  let e = reactExports.useContext(RouteContext)
  return e || invariant$1(!1), e
}
function useCurrentRouteId(s) {
  let e = useRouteContext(),
    a = e.matches[e.matches.length - 1]
  return a.route.id || invariant$1(!1), a.route.id
}
function useNavigateStable() {
  let { router: s } = useDataRouterContext(DataRouterHook$1.UseNavigateStable),
    e = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable),
    a = reactExports.useRef(!1)
  return (
    useIsomorphicLayoutEffect$3(() => {
      a.current = !0
    }),
    reactExports.useCallback(
      function (c, d) {
        d === void 0 && (d = {}),
          a.current &&
            (typeof c == "number"
              ? s.navigate(c)
              : s.navigate(c, _extends$3({ fromRouteId: e }, d)))
      },
      [s, e]
    )
  )
}
function Router(s) {
  let {
    basename: e = "/",
    children: a = null,
    location: o,
    navigationType: c = Action.Pop,
    navigator: d,
    static: g = !1,
  } = s
  useInRouterContext() && invariant$1(!1)
  let _ = e.replace(/^\/*/, "/"),
    b = reactExports.useMemo(
      () => ({ basename: _, navigator: d, static: g }),
      [_, d, g]
    )
  typeof o == "string" && (o = parsePath(o))
  let {
      pathname: j = "/",
      search: $ = "",
      hash: _e = "",
      state: tt = null,
      key: st = "default",
    } = o,
    at = reactExports.useMemo(() => {
      let ot = stripBasename(j, _)
      return ot == null
        ? null
        : {
            location: { pathname: ot, search: $, hash: _e, state: tt, key: st },
            navigationType: c,
          }
    }, [_, j, $, _e, tt, st, c])
  return at == null
    ? null
    : reactExports.createElement(
        NavigationContext.Provider,
        { value: b },
        reactExports.createElement(LocationContext.Provider, {
          children: a,
          value: at,
        })
      )
}
new Promise(() => {})
/**
 * React Router DOM v6.16.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function _extends$2() {
  return (
    (_extends$2 = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var a = arguments[e]
            for (var o in a)
              Object.prototype.hasOwnProperty.call(a, o) && (s[o] = a[o])
          }
          return s
        }),
    _extends$2.apply(this, arguments)
  )
}
function _objectWithoutPropertiesLoose$2(s, e) {
  if (s == null) return {}
  var a = {},
    o = Object.keys(s),
    c,
    d
  for (d = 0; d < o.length; d++)
    (c = o[d]), !(e.indexOf(c) >= 0) && (a[c] = s[c])
  return a
}
function isModifiedEvent(s) {
  return !!(s.metaKey || s.altKey || s.ctrlKey || s.shiftKey)
}
function shouldProcessLinkClick(s, e) {
  return s.button === 0 && (!e || e === "_self") && !isModifiedEvent(s)
}
const _excluded$3 = [
    "onClick",
    "relative",
    "reloadDocument",
    "replace",
    "state",
    "target",
    "to",
    "preventScrollReset",
  ],
  START_TRANSITION = "startTransition",
  startTransitionImpl = React$1[START_TRANSITION]
function BrowserRouter(s) {
  let { basename: e, children: a, future: o, window: c } = s,
    d = reactExports.useRef()
  d.current == null &&
    (d.current = createBrowserHistory({ window: c, v5Compat: !0 }))
  let g = d.current,
    [_, b] = reactExports.useState({ action: g.action, location: g.location }),
    { v7_startTransition: j } = o || {},
    $ = reactExports.useCallback(
      (_e) => {
        j && startTransitionImpl ? startTransitionImpl(() => b(_e)) : b(_e)
      },
      [b, j]
    )
  return (
    reactExports.useLayoutEffect(() => g.listen($), [g, $]),
    reactExports.createElement(Router, {
      basename: e,
      children: a,
      location: _.location,
      navigationType: _.action,
      navigator: g,
    })
  )
}
const isBrowser$1 =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  Link = reactExports.forwardRef(function (e, a) {
    let {
        onClick: o,
        relative: c,
        reloadDocument: d,
        replace: g,
        state: _,
        target: b,
        to: j,
        preventScrollReset: $,
      } = e,
      _e = _objectWithoutPropertiesLoose$2(e, _excluded$3),
      { basename: tt } = reactExports.useContext(NavigationContext),
      st,
      at = !1
    if (
      typeof j == "string" &&
      ABSOLUTE_URL_REGEX.test(j) &&
      ((st = j), isBrowser$1)
    )
      try {
        let ct = new URL(window.location.href),
          lt = j.startsWith("//") ? new URL(ct.protocol + j) : new URL(j),
          ht = stripBasename(lt.pathname, tt)
        lt.origin === ct.origin && ht != null
          ? (j = ht + lt.search + lt.hash)
          : (at = !0)
      } catch {}
    let ot = useHref(j, { relative: c }),
      ut = useLinkClickHandler(j, {
        replace: g,
        state: _,
        target: b,
        preventScrollReset: $,
        relative: c,
      })
    function it(ct) {
      o && o(ct), ct.defaultPrevented || ut(ct)
    }
    return reactExports.createElement(
      "a",
      _extends$2({}, _e, {
        href: st || ot,
        onClick: at || d ? o : it,
        ref: a,
        target: b,
      })
    )
  })
var DataRouterHook
;(function (s) {
  ;(s.UseScrollRestoration = "useScrollRestoration"),
    (s.UseSubmit = "useSubmit"),
    (s.UseSubmitFetcher = "useSubmitFetcher"),
    (s.UseFetcher = "useFetcher")
})(DataRouterHook || (DataRouterHook = {}))
var DataRouterStateHook
;(function (s) {
  ;(s.UseFetchers = "useFetchers"),
    (s.UseScrollRestoration = "useScrollRestoration")
})(DataRouterStateHook || (DataRouterStateHook = {}))
function useLinkClickHandler(s, e) {
  let {
      target: a,
      replace: o,
      state: c,
      preventScrollReset: d,
      relative: g,
    } = e === void 0 ? {} : e,
    _ = useNavigate(),
    b = useLocation(),
    j = useResolvedPath(s, { relative: g })
  return reactExports.useCallback(
    ($) => {
      if (shouldProcessLinkClick($, a)) {
        $.preventDefault()
        let _e = o !== void 0 ? o : createPath(b) === createPath(j)
        _(s, { replace: _e, state: c, preventScrollReset: d, relative: g })
      }
    },
    [b, _, j, o, c, a, s, d, g]
  )
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const REVISION = "156",
  MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  CullFaceNone = 0,
  CullFaceBack = 1,
  CullFaceFront = 2,
  CullFaceFrontBack = 3,
  BasicShadowMap = 0,
  PCFShadowMap = 1,
  PCFSoftShadowMap = 2,
  VSMShadowMap = 3,
  FrontSide = 0,
  BackSide = 1,
  DoubleSide = 2,
  TwoPassDoubleSide = 2,
  NoBlending = 0,
  NormalBlending = 1,
  AdditiveBlending = 2,
  SubtractiveBlending = 3,
  MultiplyBlending = 4,
  CustomBlending = 5,
  AddEquation = 100,
  SubtractEquation = 101,
  ReverseSubtractEquation = 102,
  MinEquation = 103,
  MaxEquation = 104,
  ZeroFactor = 200,
  OneFactor = 201,
  SrcColorFactor = 202,
  OneMinusSrcColorFactor = 203,
  SrcAlphaFactor = 204,
  OneMinusSrcAlphaFactor = 205,
  DstAlphaFactor = 206,
  OneMinusDstAlphaFactor = 207,
  DstColorFactor = 208,
  OneMinusDstColorFactor = 209,
  SrcAlphaSaturateFactor = 210,
  NeverDepth = 0,
  AlwaysDepth = 1,
  LessDepth = 2,
  LessEqualDepth = 3,
  EqualDepth = 4,
  GreaterEqualDepth = 5,
  GreaterDepth = 6,
  NotEqualDepth = 7,
  MultiplyOperation = 0,
  MixOperation = 1,
  AddOperation = 2,
  NoToneMapping = 0,
  LinearToneMapping = 1,
  ReinhardToneMapping = 2,
  CineonToneMapping = 3,
  ACESFilmicToneMapping = 4,
  CustomToneMapping = 5,
  UVMapping = 300,
  CubeReflectionMapping = 301,
  CubeRefractionMapping = 302,
  EquirectangularReflectionMapping = 303,
  EquirectangularRefractionMapping = 304,
  CubeUVReflectionMapping = 306,
  RepeatWrapping = 1e3,
  ClampToEdgeWrapping = 1001,
  MirroredRepeatWrapping = 1002,
  NearestFilter = 1003,
  NearestMipmapNearestFilter = 1004,
  NearestMipMapNearestFilter = 1004,
  NearestMipmapLinearFilter = 1005,
  NearestMipMapLinearFilter = 1005,
  LinearFilter = 1006,
  LinearMipmapNearestFilter = 1007,
  LinearMipMapNearestFilter = 1007,
  LinearMipmapLinearFilter = 1008,
  LinearMipMapLinearFilter = 1008,
  UnsignedByteType = 1009,
  ByteType = 1010,
  ShortType = 1011,
  UnsignedShortType = 1012,
  IntType = 1013,
  UnsignedIntType = 1014,
  FloatType = 1015,
  HalfFloatType = 1016,
  UnsignedShort4444Type = 1017,
  UnsignedShort5551Type = 1018,
  UnsignedInt248Type = 1020,
  AlphaFormat = 1021,
  RGBAFormat = 1023,
  LuminanceFormat = 1024,
  LuminanceAlphaFormat = 1025,
  DepthFormat = 1026,
  DepthStencilFormat = 1027,
  RedFormat = 1028,
  RedIntegerFormat = 1029,
  RGFormat = 1030,
  RGIntegerFormat = 1031,
  RGBAIntegerFormat = 1033,
  RGB_S3TC_DXT1_Format = 33776,
  RGBA_S3TC_DXT1_Format = 33777,
  RGBA_S3TC_DXT3_Format = 33778,
  RGBA_S3TC_DXT5_Format = 33779,
  RGB_PVRTC_4BPPV1_Format = 35840,
  RGB_PVRTC_2BPPV1_Format = 35841,
  RGBA_PVRTC_4BPPV1_Format = 35842,
  RGBA_PVRTC_2BPPV1_Format = 35843,
  RGB_ETC1_Format = 36196,
  RGB_ETC2_Format = 37492,
  RGBA_ETC2_EAC_Format = 37496,
  RGBA_ASTC_4x4_Format = 37808,
  RGBA_ASTC_5x4_Format = 37809,
  RGBA_ASTC_5x5_Format = 37810,
  RGBA_ASTC_6x5_Format = 37811,
  RGBA_ASTC_6x6_Format = 37812,
  RGBA_ASTC_8x5_Format = 37813,
  RGBA_ASTC_8x6_Format = 37814,
  RGBA_ASTC_8x8_Format = 37815,
  RGBA_ASTC_10x5_Format = 37816,
  RGBA_ASTC_10x6_Format = 37817,
  RGBA_ASTC_10x8_Format = 37818,
  RGBA_ASTC_10x10_Format = 37819,
  RGBA_ASTC_12x10_Format = 37820,
  RGBA_ASTC_12x12_Format = 37821,
  RGBA_BPTC_Format = 36492,
  RGB_BPTC_SIGNED_Format = 36494,
  RGB_BPTC_UNSIGNED_Format = 36495,
  RED_RGTC1_Format = 36283,
  SIGNED_RED_RGTC1_Format = 36284,
  RED_GREEN_RGTC2_Format = 36285,
  SIGNED_RED_GREEN_RGTC2_Format = 36286,
  LoopOnce = 2200,
  LoopRepeat = 2201,
  LoopPingPong = 2202,
  InterpolateDiscrete = 2300,
  InterpolateLinear = 2301,
  InterpolateSmooth = 2302,
  ZeroCurvatureEnding = 2400,
  ZeroSlopeEnding = 2401,
  WrapAroundEnding = 2402,
  NormalAnimationBlendMode = 2500,
  AdditiveAnimationBlendMode = 2501,
  TrianglesDrawMode = 0,
  TriangleStripDrawMode = 1,
  TriangleFanDrawMode = 2,
  LinearEncoding = 3e3,
  sRGBEncoding = 3001,
  BasicDepthPacking = 3200,
  RGBADepthPacking = 3201,
  TangentSpaceNormalMap = 0,
  ObjectSpaceNormalMap = 1,
  NoColorSpace = "",
  SRGBColorSpace = "srgb",
  LinearSRGBColorSpace = "srgb-linear",
  DisplayP3ColorSpace = "display-p3",
  LinearDisplayP3ColorSpace = "display-p3-linear",
  ZeroStencilOp = 0,
  KeepStencilOp = 7680,
  ReplaceStencilOp = 7681,
  IncrementStencilOp = 7682,
  DecrementStencilOp = 7683,
  IncrementWrapStencilOp = 34055,
  DecrementWrapStencilOp = 34056,
  InvertStencilOp = 5386,
  NeverStencilFunc = 512,
  LessStencilFunc = 513,
  EqualStencilFunc = 514,
  LessEqualStencilFunc = 515,
  GreaterStencilFunc = 516,
  NotEqualStencilFunc = 517,
  GreaterEqualStencilFunc = 518,
  AlwaysStencilFunc = 519,
  NeverCompare = 512,
  LessCompare = 513,
  EqualCompare = 514,
  LessEqualCompare = 515,
  GreaterCompare = 516,
  NotEqualCompare = 517,
  GreaterEqualCompare = 518,
  AlwaysCompare = 519,
  StaticDrawUsage = 35044,
  DynamicDrawUsage = 35048,
  StreamDrawUsage = 35040,
  StaticReadUsage = 35045,
  DynamicReadUsage = 35049,
  StreamReadUsage = 35041,
  StaticCopyUsage = 35046,
  DynamicCopyUsage = 35050,
  StreamCopyUsage = 35042,
  GLSL1 = "100",
  GLSL3 = "300 es",
  _SRGBAFormat = 1035,
  WebGLCoordinateSystem = 2e3,
  WebGPUCoordinateSystem = 2001
class EventDispatcher {
  addEventListener(e, a) {
    this._listeners === void 0 && (this._listeners = {})
    const o = this._listeners
    o[e] === void 0 && (o[e] = []), o[e].indexOf(a) === -1 && o[e].push(a)
  }
  hasEventListener(e, a) {
    if (this._listeners === void 0) return !1
    const o = this._listeners
    return o[e] !== void 0 && o[e].indexOf(a) !== -1
  }
  removeEventListener(e, a) {
    if (this._listeners === void 0) return
    const c = this._listeners[e]
    if (c !== void 0) {
      const d = c.indexOf(a)
      d !== -1 && c.splice(d, 1)
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return
    const o = this._listeners[e.type]
    if (o !== void 0) {
      e.target = this
      const c = o.slice(0)
      for (let d = 0, g = c.length; d < g; d++) c[d].call(this, e)
      e.target = null
    }
  }
}
const _lut = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
]
let _seed = 1234567
const DEG2RAD = Math.PI / 180,
  RAD2DEG = 180 / Math.PI
function generateUUID() {
  const s = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    a = (Math.random() * 4294967295) | 0,
    o = (Math.random() * 4294967295) | 0
  return (
    _lut[s & 255] +
    _lut[(s >> 8) & 255] +
    _lut[(s >> 16) & 255] +
    _lut[(s >> 24) & 255] +
    "-" +
    _lut[e & 255] +
    _lut[(e >> 8) & 255] +
    "-" +
    _lut[((e >> 16) & 15) | 64] +
    _lut[(e >> 24) & 255] +
    "-" +
    _lut[(a & 63) | 128] +
    _lut[(a >> 8) & 255] +
    "-" +
    _lut[(a >> 16) & 255] +
    _lut[(a >> 24) & 255] +
    _lut[o & 255] +
    _lut[(o >> 8) & 255] +
    _lut[(o >> 16) & 255] +
    _lut[(o >> 24) & 255]
  ).toLowerCase()
}
function clamp$2(s, e, a) {
  return Math.max(e, Math.min(a, s))
}
function euclideanModulo(s, e) {
  return ((s % e) + e) % e
}
function mapLinear(s, e, a, o, c) {
  return o + ((s - e) * (c - o)) / (a - e)
}
function inverseLerp(s, e, a) {
  return s !== e ? (a - s) / (e - s) : 0
}
function lerp(s, e, a) {
  return (1 - a) * s + a * e
}
function damp(s, e, a, o) {
  return lerp(s, e, 1 - Math.exp(-a * o))
}
function pingpong(s, e = 1) {
  return e - Math.abs(euclideanModulo(s, e * 2) - e)
}
function smoothstep(s, e, a) {
  return s <= e
    ? 0
    : s >= a
    ? 1
    : ((s = (s - e) / (a - e)), s * s * (3 - 2 * s))
}
function smootherstep(s, e, a) {
  return s <= e
    ? 0
    : s >= a
    ? 1
    : ((s = (s - e) / (a - e)), s * s * s * (s * (s * 6 - 15) + 10))
}
function randInt(s, e) {
  return s + Math.floor(Math.random() * (e - s + 1))
}
function randFloat(s, e) {
  return s + Math.random() * (e - s)
}
function randFloatSpread(s) {
  return s * (0.5 - Math.random())
}
function seededRandom(s) {
  s !== void 0 && (_seed = s)
  let e = (_seed += 1831565813)
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  )
}
function degToRad(s) {
  return s * DEG2RAD
}
function radToDeg(s) {
  return s * RAD2DEG
}
function isPowerOfTwo(s) {
  return (s & (s - 1)) === 0 && s !== 0
}
function ceilPowerOfTwo(s) {
  return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2))
}
function floorPowerOfTwo(s) {
  return Math.pow(2, Math.floor(Math.log(s) / Math.LN2))
}
function setQuaternionFromProperEuler(s, e, a, o, c) {
  const d = Math.cos,
    g = Math.sin,
    _ = d(a / 2),
    b = g(a / 2),
    j = d((e + o) / 2),
    $ = g((e + o) / 2),
    _e = d((e - o) / 2),
    tt = g((e - o) / 2),
    st = d((o - e) / 2),
    at = g((o - e) / 2)
  switch (c) {
    case "XYX":
      s.set(_ * $, b * _e, b * tt, _ * j)
      break
    case "YZY":
      s.set(b * tt, _ * $, b * _e, _ * j)
      break
    case "ZXZ":
      s.set(b * _e, b * tt, _ * $, _ * j)
      break
    case "XZX":
      s.set(_ * $, b * at, b * st, _ * j)
      break
    case "YXY":
      s.set(b * st, _ * $, b * at, _ * j)
      break
    case "ZYZ":
      s.set(b * at, b * st, _ * $, _ * j)
      break
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          c
      )
  }
}
function denormalize(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s
    case Uint32Array:
      return s / 4294967295
    case Uint16Array:
      return s / 65535
    case Uint8Array:
      return s / 255
    case Int32Array:
      return Math.max(s / 2147483647, -1)
    case Int16Array:
      return Math.max(s / 32767, -1)
    case Int8Array:
      return Math.max(s / 127, -1)
    default:
      throw new Error("Invalid component type.")
  }
}
function normalize$1(s, e) {
  switch (e.constructor) {
    case Float32Array:
      return s
    case Uint32Array:
      return Math.round(s * 4294967295)
    case Uint16Array:
      return Math.round(s * 65535)
    case Uint8Array:
      return Math.round(s * 255)
    case Int32Array:
      return Math.round(s * 2147483647)
    case Int16Array:
      return Math.round(s * 32767)
    case Int8Array:
      return Math.round(s * 127)
    default:
      throw new Error("Invalid component type.")
  }
}
const MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp: clamp$2,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize: normalize$1,
  denormalize,
}
class Vector2 {
  constructor(e = 0, a = 0) {
    ;(Vector2.prototype.isVector2 = !0), (this.x = e), (this.y = a)
  }
  get width() {
    return this.x
  }
  set width(e) {
    this.x = e
  }
  get height() {
    return this.y
  }
  set height(e) {
    this.y = e
  }
  set(e, a) {
    return (this.x = e), (this.y = a), this
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this
  }
  setX(e) {
    return (this.x = e), this
  }
  setY(e) {
    return (this.y = e), this
  }
  setComponent(e, a) {
    switch (e) {
      case 0:
        this.x = a
        break
      case 1:
        this.y = a
        break
      default:
        throw new Error("index is out of range: " + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      default:
        throw new Error("index is out of range: " + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y)
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this
  }
  addVectors(e, a) {
    return (this.x = e.x + a.x), (this.y = e.y + a.y), this
  }
  addScaledVector(e, a) {
    return (this.x += e.x * a), (this.y += e.y * a), this
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this
  }
  subVectors(e, a) {
    return (this.x = e.x - a.x), (this.y = e.y - a.y), this
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  applyMatrix3(e) {
    const a = this.x,
      o = this.y,
      c = e.elements
    return (
      (this.x = c[0] * a + c[3] * o + c[6]),
      (this.y = c[1] * a + c[4] * o + c[7]),
      this
    )
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    )
  }
  clamp(e, a) {
    return (
      (this.x = Math.max(e.x, Math.min(a.x, this.x))),
      (this.y = Math.max(e.y, Math.min(a.y, this.y))),
      this
    )
  }
  clampScalar(e, a) {
    return (
      (this.x = Math.max(e, Math.min(a, this.x))),
      (this.y = Math.max(e, Math.min(a, this.y))),
      this
    )
  }
  clampLength(e, a) {
    const o = this.length()
    return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(a, o)))
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this
  }
  dot(e) {
    return this.x * e.x + this.y * e.y
  }
  cross(e) {
    return this.x * e.y - this.y * e.x
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI
  }
  angleTo(e) {
    const a = Math.sqrt(this.lengthSq() * e.lengthSq())
    if (a === 0) return Math.PI / 2
    const o = this.dot(e) / a
    return Math.acos(clamp$2(o, -1, 1))
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e))
  }
  distanceToSquared(e) {
    const a = this.x - e.x,
      o = this.y - e.y
    return a * a + o * o
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, a) {
    return (this.x += (e.x - this.x) * a), (this.y += (e.y - this.y) * a), this
  }
  lerpVectors(e, a, o) {
    return (
      (this.x = e.x + (a.x - e.x) * o), (this.y = e.y + (a.y - e.y) * o), this
    )
  }
  equals(e) {
    return e.x === this.x && e.y === this.y
  }
  fromArray(e, a = 0) {
    return (this.x = e[a]), (this.y = e[a + 1]), this
  }
  toArray(e = [], a = 0) {
    return (e[a] = this.x), (e[a + 1] = this.y), e
  }
  fromBufferAttribute(e, a) {
    return (this.x = e.getX(a)), (this.y = e.getY(a)), this
  }
  rotateAround(e, a) {
    const o = Math.cos(a),
      c = Math.sin(a),
      d = this.x - e.x,
      g = this.y - e.y
    return (this.x = d * o - g * c + e.x), (this.y = d * c + g * o + e.y), this
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y
  }
}
class Matrix3 {
  constructor(e, a, o, c, d, g, _, b, j) {
    ;(Matrix3.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, a, o, c, d, g, _, b, j)
  }
  set(e, a, o, c, d, g, _, b, j) {
    const $ = this.elements
    return (
      ($[0] = e),
      ($[1] = c),
      ($[2] = _),
      ($[3] = a),
      ($[4] = d),
      ($[5] = b),
      ($[6] = o),
      ($[7] = g),
      ($[8] = j),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
  }
  copy(e) {
    const a = this.elements,
      o = e.elements
    return (
      (a[0] = o[0]),
      (a[1] = o[1]),
      (a[2] = o[2]),
      (a[3] = o[3]),
      (a[4] = o[4]),
      (a[5] = o[5]),
      (a[6] = o[6]),
      (a[7] = o[7]),
      (a[8] = o[8]),
      this
    )
  }
  extractBasis(e, a, o) {
    return (
      e.setFromMatrix3Column(this, 0),
      a.setFromMatrix3Column(this, 1),
      o.setFromMatrix3Column(this, 2),
      this
    )
  }
  setFromMatrix4(e) {
    const a = e.elements
    return this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]), this
  }
  multiply(e) {
    return this.multiplyMatrices(this, e)
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this)
  }
  multiplyMatrices(e, a) {
    const o = e.elements,
      c = a.elements,
      d = this.elements,
      g = o[0],
      _ = o[3],
      b = o[6],
      j = o[1],
      $ = o[4],
      _e = o[7],
      tt = o[2],
      st = o[5],
      at = o[8],
      ot = c[0],
      ut = c[3],
      it = c[6],
      ct = c[1],
      lt = c[4],
      ht = c[7],
      dt = c[2],
      pt = c[5],
      vt = c[8]
    return (
      (d[0] = g * ot + _ * ct + b * dt),
      (d[3] = g * ut + _ * lt + b * pt),
      (d[6] = g * it + _ * ht + b * vt),
      (d[1] = j * ot + $ * ct + _e * dt),
      (d[4] = j * ut + $ * lt + _e * pt),
      (d[7] = j * it + $ * ht + _e * vt),
      (d[2] = tt * ot + st * ct + at * dt),
      (d[5] = tt * ut + st * lt + at * pt),
      (d[8] = tt * it + st * ht + at * vt),
      this
    )
  }
  multiplyScalar(e) {
    const a = this.elements
    return (
      (a[0] *= e),
      (a[3] *= e),
      (a[6] *= e),
      (a[1] *= e),
      (a[4] *= e),
      (a[7] *= e),
      (a[2] *= e),
      (a[5] *= e),
      (a[8] *= e),
      this
    )
  }
  determinant() {
    const e = this.elements,
      a = e[0],
      o = e[1],
      c = e[2],
      d = e[3],
      g = e[4],
      _ = e[5],
      b = e[6],
      j = e[7],
      $ = e[8]
    return a * g * $ - a * _ * j - o * d * $ + o * _ * b + c * d * j - c * g * b
  }
  invert() {
    const e = this.elements,
      a = e[0],
      o = e[1],
      c = e[2],
      d = e[3],
      g = e[4],
      _ = e[5],
      b = e[6],
      j = e[7],
      $ = e[8],
      _e = $ * g - _ * j,
      tt = _ * b - $ * d,
      st = j * d - g * b,
      at = a * _e + o * tt + c * st
    if (at === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
    const ot = 1 / at
    return (
      (e[0] = _e * ot),
      (e[1] = (c * j - $ * o) * ot),
      (e[2] = (_ * o - c * g) * ot),
      (e[3] = tt * ot),
      (e[4] = ($ * a - c * b) * ot),
      (e[5] = (c * d - _ * a) * ot),
      (e[6] = st * ot),
      (e[7] = (o * b - j * a) * ot),
      (e[8] = (g * a - o * d) * ot),
      this
    )
  }
  transpose() {
    let e
    const a = this.elements
    return (
      (e = a[1]),
      (a[1] = a[3]),
      (a[3] = e),
      (e = a[2]),
      (a[2] = a[6]),
      (a[6] = e),
      (e = a[5]),
      (a[5] = a[7]),
      (a[7] = e),
      this
    )
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose()
  }
  transposeIntoArray(e) {
    const a = this.elements
    return (
      (e[0] = a[0]),
      (e[1] = a[3]),
      (e[2] = a[6]),
      (e[3] = a[1]),
      (e[4] = a[4]),
      (e[5] = a[7]),
      (e[6] = a[2]),
      (e[7] = a[5]),
      (e[8] = a[8]),
      this
    )
  }
  setUvTransform(e, a, o, c, d, g, _) {
    const b = Math.cos(d),
      j = Math.sin(d)
    return (
      this.set(
        o * b,
        o * j,
        -o * (b * g + j * _) + g + e,
        -c * j,
        c * b,
        -c * (-j * g + b * _) + _ + a,
        0,
        0,
        1
      ),
      this
    )
  }
  scale(e, a) {
    return this.premultiply(_m3.makeScale(e, a)), this
  }
  rotate(e) {
    return this.premultiply(_m3.makeRotation(-e)), this
  }
  translate(e, a) {
    return this.premultiply(_m3.makeTranslation(e, a)), this
  }
  makeTranslation(e, a) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, a, 0, 0, 1),
      this
    )
  }
  makeRotation(e) {
    const a = Math.cos(e),
      o = Math.sin(e)
    return this.set(a, -o, 0, o, a, 0, 0, 0, 1), this
  }
  makeScale(e, a) {
    return this.set(e, 0, 0, 0, a, 0, 0, 0, 1), this
  }
  equals(e) {
    const a = this.elements,
      o = e.elements
    for (let c = 0; c < 9; c++) if (a[c] !== o[c]) return !1
    return !0
  }
  fromArray(e, a = 0) {
    for (let o = 0; o < 9; o++) this.elements[o] = e[o + a]
    return this
  }
  toArray(e = [], a = 0) {
    const o = this.elements
    return (
      (e[a] = o[0]),
      (e[a + 1] = o[1]),
      (e[a + 2] = o[2]),
      (e[a + 3] = o[3]),
      (e[a + 4] = o[4]),
      (e[a + 5] = o[5]),
      (e[a + 6] = o[6]),
      (e[a + 7] = o[7]),
      (e[a + 8] = o[8]),
      e
    )
  }
  clone() {
    return new this.constructor().fromArray(this.elements)
  }
}
const _m3 = new Matrix3()
function arrayNeedsUint32(s) {
  for (let e = s.length - 1; e >= 0; --e) if (s[e] >= 65535) return !0
  return !1
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
}
function getTypedArray(s, e) {
  return new TYPED_ARRAYS[s](e)
}
function createElementNS(s) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", s)
}
function createCanvasElement() {
  const s = createElementNS("canvas")
  return (s.style.display = "block"), s
}
const _cache = {}
function warnOnce(s) {
  s in _cache || ((_cache[s] = !0), console.warn(s))
}
function SRGBToLinear(s) {
  return s < 0.04045
    ? s * 0.0773993808
    : Math.pow(s * 0.9478672986 + 0.0521327014, 2.4)
}
function LinearToSRGB(s) {
  return s < 0.0031308 ? s * 12.92 : 1.055 * Math.pow(s, 0.41666) - 0.055
}
const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199,
  ]),
  LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735,
  ])
function DisplayP3ToLinearSRGB(s) {
  return s.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB)
}
function LinearSRGBToDisplayP3(s) {
  return s.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
}
const TO_LINEAR = {
    [LinearSRGBColorSpace]: (s) => s,
    [SRGBColorSpace]: (s) => s.convertSRGBToLinear(),
    [DisplayP3ColorSpace]: DisplayP3ToLinearSRGB,
  },
  FROM_LINEAR = {
    [LinearSRGBColorSpace]: (s) => s,
    [SRGBColorSpace]: (s) => s.convertLinearToSRGB(),
    [DisplayP3ColorSpace]: LinearSRGBToDisplayP3,
  },
  ColorManagement = {
    enabled: !0,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      )
    },
    set legacyMode(s) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !s)
    },
    get workingColorSpace() {
      return LinearSRGBColorSpace
    },
    set workingColorSpace(s) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
    },
    convert: function (s, e, a) {
      if (this.enabled === !1 || e === a || !e || !a) return s
      const o = TO_LINEAR[e],
        c = FROM_LINEAR[a]
      if (o === void 0 || c === void 0)
        throw new Error(`Unsupported color space conversion, "${e}" to "${a}".`)
      return c(o(s))
    },
    fromWorkingColorSpace: function (s, e) {
      return this.convert(s, this.workingColorSpace, e)
    },
    toWorkingColorSpace: function (s, e) {
      return this.convert(s, e, this.workingColorSpace)
    },
  }
let _canvas
class ImageUtils {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src
    let a
    if (e instanceof HTMLCanvasElement) a = e
    else {
      _canvas === void 0 && (_canvas = createElementNS("canvas")),
        (_canvas.width = e.width),
        (_canvas.height = e.height)
      const o = _canvas.getContext("2d")
      e instanceof ImageData
        ? o.putImageData(e, 0, 0)
        : o.drawImage(e, 0, 0, e.width, e.height),
        (a = _canvas)
    }
    return a.width > 2048 || a.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        a.toDataURL("image/jpeg", 0.6))
      : a.toDataURL("image/png")
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const a = createElementNS("canvas")
      ;(a.width = e.width), (a.height = e.height)
      const o = a.getContext("2d")
      o.drawImage(e, 0, 0, e.width, e.height)
      const c = o.getImageData(0, 0, e.width, e.height),
        d = c.data
      for (let g = 0; g < d.length; g++) d[g] = SRGBToLinear(d[g] / 255) * 255
      return o.putImageData(c, 0, 0), a
    } else if (e.data) {
      const a = e.data.slice(0)
      for (let o = 0; o < a.length; o++)
        a instanceof Uint8Array || a instanceof Uint8ClampedArray
          ? (a[o] = Math.floor(SRGBToLinear(a[o] / 255) * 255))
          : (a[o] = SRGBToLinear(a[o]))
      return { data: a, width: e.width, height: e.height }
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      )
  }
}
let sourceId = 0
class Source {
  constructor(e = null) {
    ;(this.isSource = !0),
      Object.defineProperty(this, "id", { value: sourceId++ }),
      (this.uuid = generateUUID()),
      (this.data = e),
      (this.version = 0)
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  toJSON(e) {
    const a = e === void 0 || typeof e == "string"
    if (!a && e.images[this.uuid] !== void 0) return e.images[this.uuid]
    const o = { uuid: this.uuid, url: "" },
      c = this.data
    if (c !== null) {
      let d
      if (Array.isArray(c)) {
        d = []
        for (let g = 0, _ = c.length; g < _; g++)
          c[g].isDataTexture
            ? d.push(serializeImage(c[g].image))
            : d.push(serializeImage(c[g]))
      } else d = serializeImage(c)
      o.url = d
    }
    return a || (e.images[this.uuid] = o), o
  }
}
function serializeImage(s) {
  return (typeof HTMLImageElement < "u" && s instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && s instanceof ImageBitmap)
    ? ImageUtils.getDataURL(s)
    : s.data
    ? {
        data: Array.from(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let _textureId = 0
class Texture extends EventDispatcher {
  constructor(
    e = Texture.DEFAULT_IMAGE,
    a = Texture.DEFAULT_MAPPING,
    o = ClampToEdgeWrapping,
    c = ClampToEdgeWrapping,
    d = LinearFilter,
    g = LinearMipmapLinearFilter,
    _ = RGBAFormat,
    b = UnsignedByteType,
    j = Texture.DEFAULT_ANISOTROPY,
    $ = NoColorSpace
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: _textureId++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.source = new Source(e)),
      (this.mipmaps = []),
      (this.mapping = a),
      (this.channel = 0),
      (this.wrapS = o),
      (this.wrapT = c),
      (this.magFilter = d),
      (this.minFilter = g),
      (this.anisotropy = j),
      (this.format = _),
      (this.internalFormat = null),
      (this.type = b),
      (this.offset = new Vector2(0, 0)),
      (this.repeat = new Vector2(1, 1)),
      (this.center = new Vector2(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new Matrix3()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof $ == "string"
        ? (this.colorSpace = $)
        : (warnOnce(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace =
            $ === sRGBEncoding ? SRGBColorSpace : NoColorSpace)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1)
  }
  get image() {
    return this.source.data
  }
  set image(e = null) {
    this.source.data = e
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    )
  }
  toJSON(e) {
    const a = e === void 0 || typeof e == "string"
    if (!a && e.textures[this.uuid] !== void 0) return e.textures[this.uuid]
    const o = {
      metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    }
    return (
      Object.keys(this.userData).length > 0 && (o.userData = this.userData),
      a || (e.textures[this.uuid] = o),
      o
    )
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" })
  }
  transformUv(e) {
    if (this.mapping !== UVMapping) return e
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case RepeatWrapping:
          e.x = e.x - Math.floor(e.x)
          break
        case ClampToEdgeWrapping:
          e.x = e.x < 0 ? 0 : 1
          break
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x))
          break
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case RepeatWrapping:
          e.y = e.y - Math.floor(e.y)
          break
        case ClampToEdgeWrapping:
          e.y = e.y < 0 ? 0 : 1
          break
        case MirroredRepeatWrapping:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y))
          break
      }
    return this.flipY && (e.y = 1 - e.y), e
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0))
  }
  get encoding() {
    return (
      warnOnce(
        "THREE.Texture: Property .encoding has been replaced by .colorSpace."
      ),
      this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding
    )
  }
  set encoding(e) {
    warnOnce(
      "THREE.Texture: Property .encoding has been replaced by .colorSpace."
    ),
      (this.colorSpace = e === sRGBEncoding ? SRGBColorSpace : NoColorSpace)
  }
}
Texture.DEFAULT_IMAGE = null
Texture.DEFAULT_MAPPING = UVMapping
Texture.DEFAULT_ANISOTROPY = 1
class Vector4 {
  constructor(e = 0, a = 0, o = 0, c = 1) {
    ;(Vector4.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = a),
      (this.z = o),
      (this.w = c)
  }
  get width() {
    return this.z
  }
  set width(e) {
    this.z = e
  }
  get height() {
    return this.w
  }
  set height(e) {
    this.w = e
  }
  set(e, a, o, c) {
    return (this.x = e), (this.y = a), (this.z = o), (this.w = c), this
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this
  }
  setX(e) {
    return (this.x = e), this
  }
  setY(e) {
    return (this.y = e), this
  }
  setZ(e) {
    return (this.z = e), this
  }
  setW(e) {
    return (this.w = e), this
  }
  setComponent(e, a) {
    switch (e) {
      case 0:
        this.x = a
        break
      case 1:
        this.y = a
        break
      case 2:
        this.z = a
        break
      case 3:
        this.w = a
        break
      default:
        throw new Error("index is out of range: " + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      case 3:
        return this.w
      default:
        throw new Error("index is out of range: " + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w)
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    )
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    )
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
  }
  addVectors(e, a) {
    return (
      (this.x = e.x + a.x),
      (this.y = e.y + a.y),
      (this.z = e.z + a.z),
      (this.w = e.w + a.w),
      this
    )
  }
  addScaledVector(e, a) {
    return (
      (this.x += e.x * a),
      (this.y += e.y * a),
      (this.z += e.z * a),
      (this.w += e.w * a),
      this
    )
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    )
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
  }
  subVectors(e, a) {
    return (
      (this.x = e.x - a.x),
      (this.y = e.y - a.y),
      (this.z = e.z - a.z),
      (this.w = e.w - a.w),
      this
    )
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    )
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
  }
  applyMatrix4(e) {
    const a = this.x,
      o = this.y,
      c = this.z,
      d = this.w,
      g = e.elements
    return (
      (this.x = g[0] * a + g[4] * o + g[8] * c + g[12] * d),
      (this.y = g[1] * a + g[5] * o + g[9] * c + g[13] * d),
      (this.z = g[2] * a + g[6] * o + g[10] * c + g[14] * d),
      (this.w = g[3] * a + g[7] * o + g[11] * c + g[15] * d),
      this
    )
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w)
    const a = Math.sqrt(1 - e.w * e.w)
    return (
      a < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / a), (this.y = e.y / a), (this.z = e.z / a)),
      this
    )
  }
  setAxisAngleFromRotationMatrix(e) {
    let a, o, c, d
    const b = e.elements,
      j = b[0],
      $ = b[4],
      _e = b[8],
      tt = b[1],
      st = b[5],
      at = b[9],
      ot = b[2],
      ut = b[6],
      it = b[10]
    if (
      Math.abs($ - tt) < 0.01 &&
      Math.abs(_e - ot) < 0.01 &&
      Math.abs(at - ut) < 0.01
    ) {
      if (
        Math.abs($ + tt) < 0.1 &&
        Math.abs(_e + ot) < 0.1 &&
        Math.abs(at + ut) < 0.1 &&
        Math.abs(j + st + it - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this
      a = Math.PI
      const lt = (j + 1) / 2,
        ht = (st + 1) / 2,
        dt = (it + 1) / 2,
        pt = ($ + tt) / 4,
        vt = (_e + ot) / 4,
        _t = (at + ut) / 4
      return (
        lt > ht && lt > dt
          ? lt < 0.01
            ? ((o = 0), (c = 0.707106781), (d = 0.707106781))
            : ((o = Math.sqrt(lt)), (c = pt / o), (d = vt / o))
          : ht > dt
          ? ht < 0.01
            ? ((o = 0.707106781), (c = 0), (d = 0.707106781))
            : ((c = Math.sqrt(ht)), (o = pt / c), (d = _t / c))
          : dt < 0.01
          ? ((o = 0.707106781), (c = 0.707106781), (d = 0))
          : ((d = Math.sqrt(dt)), (o = vt / d), (c = _t / d)),
        this.set(o, c, d, a),
        this
      )
    }
    let ct = Math.sqrt(
      (ut - at) * (ut - at) + (_e - ot) * (_e - ot) + (tt - $) * (tt - $)
    )
    return (
      Math.abs(ct) < 0.001 && (ct = 1),
      (this.x = (ut - at) / ct),
      (this.y = (_e - ot) / ct),
      (this.z = (tt - $) / ct),
      (this.w = Math.acos((j + st + it - 1) / 2)),
      this
    )
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    )
  }
  clamp(e, a) {
    return (
      (this.x = Math.max(e.x, Math.min(a.x, this.x))),
      (this.y = Math.max(e.y, Math.min(a.y, this.y))),
      (this.z = Math.max(e.z, Math.min(a.z, this.z))),
      (this.w = Math.max(e.w, Math.min(a.w, this.w))),
      this
    )
  }
  clampScalar(e, a) {
    return (
      (this.x = Math.max(e, Math.min(a, this.x))),
      (this.y = Math.max(e, Math.min(a, this.y))),
      (this.z = Math.max(e, Math.min(a, this.z))),
      (this.w = Math.max(e, Math.min(a, this.w))),
      this
    )
  }
  clampLength(e, a) {
    const o = this.length()
    return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(a, o)))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    )
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    )
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    )
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    )
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, a) {
    return (
      (this.x += (e.x - this.x) * a),
      (this.y += (e.y - this.y) * a),
      (this.z += (e.z - this.z) * a),
      (this.w += (e.w - this.w) * a),
      this
    )
  }
  lerpVectors(e, a, o) {
    return (
      (this.x = e.x + (a.x - e.x) * o),
      (this.y = e.y + (a.y - e.y) * o),
      (this.z = e.z + (a.z - e.z) * o),
      (this.w = e.w + (a.w - e.w) * o),
      this
    )
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
  }
  fromArray(e, a = 0) {
    return (
      (this.x = e[a]),
      (this.y = e[a + 1]),
      (this.z = e[a + 2]),
      (this.w = e[a + 3]),
      this
    )
  }
  toArray(e = [], a = 0) {
    return (
      (e[a] = this.x),
      (e[a + 1] = this.y),
      (e[a + 2] = this.z),
      (e[a + 3] = this.w),
      e
    )
  }
  fromBufferAttribute(e, a) {
    return (
      (this.x = e.getX(a)),
      (this.y = e.getY(a)),
      (this.z = e.getZ(a)),
      (this.w = e.getW(a)),
      this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w
  }
}
class RenderTarget extends EventDispatcher {
  constructor(e = 1, a = 1, o = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = a),
      (this.depth = 1),
      (this.scissor = new Vector4(0, 0, e, a)),
      (this.scissorTest = !1),
      (this.viewport = new Vector4(0, 0, e, a))
    const c = { width: e, height: a, depth: 1 }
    o.encoding !== void 0 &&
      (warnOnce(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (o.colorSpace =
        o.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace)),
      (this.texture = new Texture(
        c,
        o.mapping,
        o.wrapS,
        o.wrapT,
        o.magFilter,
        o.minFilter,
        o.format,
        o.type,
        o.anisotropy,
        o.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        o.generateMipmaps !== void 0 ? o.generateMipmaps : !1),
      (this.texture.internalFormat =
        o.internalFormat !== void 0 ? o.internalFormat : null),
      (this.texture.minFilter =
        o.minFilter !== void 0 ? o.minFilter : LinearFilter),
      (this.depthBuffer = o.depthBuffer !== void 0 ? o.depthBuffer : !0),
      (this.stencilBuffer = o.stencilBuffer !== void 0 ? o.stencilBuffer : !1),
      (this.depthTexture = o.depthTexture !== void 0 ? o.depthTexture : null),
      (this.samples = o.samples !== void 0 ? o.samples : 0)
  }
  setSize(e, a, o = 1) {
    ;(this.width !== e || this.height !== a || this.depth !== o) &&
      ((this.width = e),
      (this.height = a),
      (this.depth = o),
      (this.texture.image.width = e),
      (this.texture.image.height = a),
      (this.texture.image.depth = o),
      this.dispose()),
      this.viewport.set(0, 0, e, a),
      this.scissor.set(0, 0, e, a)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;(this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0)
    const a = Object.assign({}, e.texture.image)
    return (
      (this.texture.source = new Source(a)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" })
  }
}
class WebGLRenderTarget extends RenderTarget {
  constructor(e = 1, a = 1, o = {}) {
    super(e, a, o), (this.isWebGLRenderTarget = !0)
  }
}
class DataArrayTexture extends Texture {
  constructor(e = null, a = 1, o = 1, c = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: a, height: o, depth: c }),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.wrapR = ClampToEdgeWrapping),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
class WebGLArrayRenderTarget extends WebGLRenderTarget {
  constructor(e = 1, a = 1, o = 1) {
    super(e, a),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = o),
      (this.texture = new DataArrayTexture(null, e, a, o)),
      (this.texture.isRenderTargetTexture = !0)
  }
}
class Data3DTexture extends Texture {
  constructor(e = null, a = 1, o = 1, c = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: a, height: o, depth: c }),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.wrapR = ClampToEdgeWrapping),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
class WebGL3DRenderTarget extends WebGLRenderTarget {
  constructor(e = 1, a = 1, o = 1) {
    super(e, a),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = o),
      (this.texture = new Data3DTexture(null, e, a, o)),
      (this.texture.isRenderTargetTexture = !0)
  }
}
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(e = 1, a = 1, o = 1, c = {}) {
    super(e, a, c), (this.isWebGLMultipleRenderTargets = !0)
    const d = this.texture
    this.texture = []
    for (let g = 0; g < o; g++)
      (this.texture[g] = d.clone()),
        (this.texture[g].isRenderTargetTexture = !0)
  }
  setSize(e, a, o = 1) {
    if (this.width !== e || this.height !== a || this.depth !== o) {
      ;(this.width = e), (this.height = a), (this.depth = o)
      for (let c = 0, d = this.texture.length; c < d; c++)
        (this.texture[c].image.width = e),
          (this.texture[c].image.height = a),
          (this.texture[c].image.depth = o)
      this.dispose()
    }
    this.viewport.set(0, 0, e, a), this.scissor.set(0, 0, e, a)
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0)
    for (let a = 0, o = e.texture.length; a < o; a++)
      (this.texture[a] = e.texture[a].clone()),
        (this.texture[a].isRenderTargetTexture = !0)
    return this
  }
}
class Quaternion {
  constructor(e = 0, a = 0, o = 0, c = 1) {
    ;(this.isQuaternion = !0),
      (this._x = e),
      (this._y = a),
      (this._z = o),
      (this._w = c)
  }
  static slerpFlat(e, a, o, c, d, g, _) {
    let b = o[c + 0],
      j = o[c + 1],
      $ = o[c + 2],
      _e = o[c + 3]
    const tt = d[g + 0],
      st = d[g + 1],
      at = d[g + 2],
      ot = d[g + 3]
    if (_ === 0) {
      ;(e[a + 0] = b), (e[a + 1] = j), (e[a + 2] = $), (e[a + 3] = _e)
      return
    }
    if (_ === 1) {
      ;(e[a + 0] = tt), (e[a + 1] = st), (e[a + 2] = at), (e[a + 3] = ot)
      return
    }
    if (_e !== ot || b !== tt || j !== st || $ !== at) {
      let ut = 1 - _
      const it = b * tt + j * st + $ * at + _e * ot,
        ct = it >= 0 ? 1 : -1,
        lt = 1 - it * it
      if (lt > Number.EPSILON) {
        const dt = Math.sqrt(lt),
          pt = Math.atan2(dt, it * ct)
        ;(ut = Math.sin(ut * pt) / dt), (_ = Math.sin(_ * pt) / dt)
      }
      const ht = _ * ct
      if (
        ((b = b * ut + tt * ht),
        (j = j * ut + st * ht),
        ($ = $ * ut + at * ht),
        (_e = _e * ut + ot * ht),
        ut === 1 - _)
      ) {
        const dt = 1 / Math.sqrt(b * b + j * j + $ * $ + _e * _e)
        ;(b *= dt), (j *= dt), ($ *= dt), (_e *= dt)
      }
    }
    ;(e[a] = b), (e[a + 1] = j), (e[a + 2] = $), (e[a + 3] = _e)
  }
  static multiplyQuaternionsFlat(e, a, o, c, d, g) {
    const _ = o[c],
      b = o[c + 1],
      j = o[c + 2],
      $ = o[c + 3],
      _e = d[g],
      tt = d[g + 1],
      st = d[g + 2],
      at = d[g + 3]
    return (
      (e[a] = _ * at + $ * _e + b * st - j * tt),
      (e[a + 1] = b * at + $ * tt + j * _e - _ * st),
      (e[a + 2] = j * at + $ * st + _ * tt - b * _e),
      (e[a + 3] = $ * at - _ * _e - b * tt - j * st),
      e
    )
  }
  get x() {
    return this._x
  }
  set x(e) {
    ;(this._x = e), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(e) {
    ;(this._y = e), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(e) {
    ;(this._z = e), this._onChangeCallback()
  }
  get w() {
    return this._w
  }
  set w(e) {
    ;(this._w = e), this._onChangeCallback()
  }
  set(e, a, o, c) {
    return (
      (this._x = e),
      (this._y = a),
      (this._z = o),
      (this._w = c),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w)
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    )
  }
  setFromEuler(e, a) {
    const o = e._x,
      c = e._y,
      d = e._z,
      g = e._order,
      _ = Math.cos,
      b = Math.sin,
      j = _(o / 2),
      $ = _(c / 2),
      _e = _(d / 2),
      tt = b(o / 2),
      st = b(c / 2),
      at = b(d / 2)
    switch (g) {
      case "XYZ":
        ;(this._x = tt * $ * _e + j * st * at),
          (this._y = j * st * _e - tt * $ * at),
          (this._z = j * $ * at + tt * st * _e),
          (this._w = j * $ * _e - tt * st * at)
        break
      case "YXZ":
        ;(this._x = tt * $ * _e + j * st * at),
          (this._y = j * st * _e - tt * $ * at),
          (this._z = j * $ * at - tt * st * _e),
          (this._w = j * $ * _e + tt * st * at)
        break
      case "ZXY":
        ;(this._x = tt * $ * _e - j * st * at),
          (this._y = j * st * _e + tt * $ * at),
          (this._z = j * $ * at + tt * st * _e),
          (this._w = j * $ * _e - tt * st * at)
        break
      case "ZYX":
        ;(this._x = tt * $ * _e - j * st * at),
          (this._y = j * st * _e + tt * $ * at),
          (this._z = j * $ * at - tt * st * _e),
          (this._w = j * $ * _e + tt * st * at)
        break
      case "YZX":
        ;(this._x = tt * $ * _e + j * st * at),
          (this._y = j * st * _e + tt * $ * at),
          (this._z = j * $ * at - tt * st * _e),
          (this._w = j * $ * _e - tt * st * at)
        break
      case "XZY":
        ;(this._x = tt * $ * _e - j * st * at),
          (this._y = j * st * _e - tt * $ * at),
          (this._z = j * $ * at + tt * st * _e),
          (this._w = j * $ * _e + tt * st * at)
        break
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + g
        )
    }
    return a !== !1 && this._onChangeCallback(), this
  }
  setFromAxisAngle(e, a) {
    const o = a / 2,
      c = Math.sin(o)
    return (
      (this._x = e.x * c),
      (this._y = e.y * c),
      (this._z = e.z * c),
      (this._w = Math.cos(o)),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(e) {
    const a = e.elements,
      o = a[0],
      c = a[4],
      d = a[8],
      g = a[1],
      _ = a[5],
      b = a[9],
      j = a[2],
      $ = a[6],
      _e = a[10],
      tt = o + _ + _e
    if (tt > 0) {
      const st = 0.5 / Math.sqrt(tt + 1)
      ;(this._w = 0.25 / st),
        (this._x = ($ - b) * st),
        (this._y = (d - j) * st),
        (this._z = (g - c) * st)
    } else if (o > _ && o > _e) {
      const st = 2 * Math.sqrt(1 + o - _ - _e)
      ;(this._w = ($ - b) / st),
        (this._x = 0.25 * st),
        (this._y = (c + g) / st),
        (this._z = (d + j) / st)
    } else if (_ > _e) {
      const st = 2 * Math.sqrt(1 + _ - o - _e)
      ;(this._w = (d - j) / st),
        (this._x = (c + g) / st),
        (this._y = 0.25 * st),
        (this._z = (b + $) / st)
    } else {
      const st = 2 * Math.sqrt(1 + _e - o - _)
      ;(this._w = (g - c) / st),
        (this._x = (d + j) / st),
        (this._y = (b + $) / st),
        (this._z = 0.25 * st)
    }
    return this._onChangeCallback(), this
  }
  setFromUnitVectors(e, a) {
    let o = e.dot(a) + 1
    return (
      o < Number.EPSILON
        ? ((o = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = o))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = o)))
        : ((this._x = e.y * a.z - e.z * a.y),
          (this._y = e.z * a.x - e.x * a.z),
          (this._z = e.x * a.y - e.y * a.x),
          (this._w = o)),
      this.normalize()
    )
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(clamp$2(this.dot(e), -1, 1)))
  }
  rotateTowards(e, a) {
    const o = this.angleTo(e)
    if (o === 0) return this
    const c = Math.min(1, a / o)
    return this.slerp(e, c), this
  }
  identity() {
    return this.set(0, 0, 0, 1)
  }
  invert() {
    return this.conjugate()
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    )
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    )
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    )
  }
  normalize() {
    let e = this.length()
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    )
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e)
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this)
  }
  multiplyQuaternions(e, a) {
    const o = e._x,
      c = e._y,
      d = e._z,
      g = e._w,
      _ = a._x,
      b = a._y,
      j = a._z,
      $ = a._w
    return (
      (this._x = o * $ + g * _ + c * j - d * b),
      (this._y = c * $ + g * b + d * _ - o * j),
      (this._z = d * $ + g * j + o * b - c * _),
      (this._w = g * $ - o * _ - c * b - d * j),
      this._onChangeCallback(),
      this
    )
  }
  slerp(e, a) {
    if (a === 0) return this
    if (a === 1) return this.copy(e)
    const o = this._x,
      c = this._y,
      d = this._z,
      g = this._w
    let _ = g * e._w + o * e._x + c * e._y + d * e._z
    if (
      (_ < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (_ = -_))
        : this.copy(e),
      _ >= 1)
    )
      return (this._w = g), (this._x = o), (this._y = c), (this._z = d), this
    const b = 1 - _ * _
    if (b <= Number.EPSILON) {
      const st = 1 - a
      return (
        (this._w = st * g + a * this._w),
        (this._x = st * o + a * this._x),
        (this._y = st * c + a * this._y),
        (this._z = st * d + a * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      )
    }
    const j = Math.sqrt(b),
      $ = Math.atan2(j, _),
      _e = Math.sin((1 - a) * $) / j,
      tt = Math.sin(a * $) / j
    return (
      (this._w = g * _e + this._w * tt),
      (this._x = o * _e + this._x * tt),
      (this._y = c * _e + this._y * tt),
      (this._z = d * _e + this._z * tt),
      this._onChangeCallback(),
      this
    )
  }
  slerpQuaternions(e, a, o) {
    return this.copy(e).slerp(a, o)
  }
  random() {
    const e = Math.random(),
      a = Math.sqrt(1 - e),
      o = Math.sqrt(e),
      c = 2 * Math.PI * Math.random(),
      d = 2 * Math.PI * Math.random()
    return this.set(
      a * Math.cos(c),
      o * Math.sin(d),
      o * Math.cos(d),
      a * Math.sin(c)
    )
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    )
  }
  fromArray(e, a = 0) {
    return (
      (this._x = e[a]),
      (this._y = e[a + 1]),
      (this._z = e[a + 2]),
      (this._w = e[a + 3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(e = [], a = 0) {
    return (
      (e[a] = this._x),
      (e[a + 1] = this._y),
      (e[a + 2] = this._z),
      (e[a + 3] = this._w),
      e
    )
  }
  fromBufferAttribute(e, a) {
    return (
      (this._x = e.getX(a)),
      (this._y = e.getY(a)),
      (this._z = e.getZ(a)),
      (this._w = e.getW(a)),
      this
    )
  }
  toJSON() {
    return this.toArray()
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w
  }
}
class Vector3 {
  constructor(e = 0, a = 0, o = 0) {
    ;(Vector3.prototype.isVector3 = !0),
      (this.x = e),
      (this.y = a),
      (this.z = o)
  }
  set(e, a, o) {
    return (
      o === void 0 && (o = this.z),
      (this.x = e),
      (this.y = a),
      (this.z = o),
      this
    )
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this
  }
  setX(e) {
    return (this.x = e), this
  }
  setY(e) {
    return (this.y = e), this
  }
  setZ(e) {
    return (this.z = e), this
  }
  setComponent(e, a) {
    switch (e) {
      case 0:
        this.x = a
        break
      case 1:
        this.y = a
        break
      case 2:
        this.z = a
        break
      default:
        throw new Error("index is out of range: " + e)
    }
    return this
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      default:
        throw new Error("index is out of range: " + e)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z)
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this
  }
  addVectors(e, a) {
    return (
      (this.x = e.x + a.x), (this.y = e.y + a.y), (this.z = e.z + a.z), this
    )
  }
  addScaledVector(e, a) {
    return (this.x += e.x * a), (this.y += e.y * a), (this.z += e.z * a), this
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this
  }
  subVectors(e, a) {
    return (
      (this.x = e.x - a.x), (this.y = e.y - a.y), (this.z = e.z - a.z), this
    )
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this
  }
  multiplyVectors(e, a) {
    return (
      (this.x = e.x * a.x), (this.y = e.y * a.y), (this.z = e.z * a.z), this
    )
  }
  applyEuler(e) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(e))
  }
  applyAxisAngle(e, a) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(e, a))
  }
  applyMatrix3(e) {
    const a = this.x,
      o = this.y,
      c = this.z,
      d = e.elements
    return (
      (this.x = d[0] * a + d[3] * o + d[6] * c),
      (this.y = d[1] * a + d[4] * o + d[7] * c),
      (this.z = d[2] * a + d[5] * o + d[8] * c),
      this
    )
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize()
  }
  applyMatrix4(e) {
    const a = this.x,
      o = this.y,
      c = this.z,
      d = e.elements,
      g = 1 / (d[3] * a + d[7] * o + d[11] * c + d[15])
    return (
      (this.x = (d[0] * a + d[4] * o + d[8] * c + d[12]) * g),
      (this.y = (d[1] * a + d[5] * o + d[9] * c + d[13]) * g),
      (this.z = (d[2] * a + d[6] * o + d[10] * c + d[14]) * g),
      this
    )
  }
  applyQuaternion(e) {
    const a = this.x,
      o = this.y,
      c = this.z,
      d = e.x,
      g = e.y,
      _ = e.z,
      b = e.w,
      j = b * a + g * c - _ * o,
      $ = b * o + _ * a - d * c,
      _e = b * c + d * o - g * a,
      tt = -d * a - g * o - _ * c
    return (
      (this.x = j * b + tt * -d + $ * -_ - _e * -g),
      (this.y = $ * b + tt * -g + _e * -d - j * -_),
      (this.z = _e * b + tt * -_ + j * -g - $ * -d),
      this
    )
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    )
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    )
  }
  transformDirection(e) {
    const a = this.x,
      o = this.y,
      c = this.z,
      d = e.elements
    return (
      (this.x = d[0] * a + d[4] * o + d[8] * c),
      (this.y = d[1] * a + d[5] * o + d[9] * c),
      (this.z = d[2] * a + d[6] * o + d[10] * c),
      this.normalize()
    )
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e)
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    )
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    )
  }
  clamp(e, a) {
    return (
      (this.x = Math.max(e.x, Math.min(a.x, this.x))),
      (this.y = Math.max(e.y, Math.min(a.y, this.y))),
      (this.z = Math.max(e.z, Math.min(a.z, this.z))),
      this
    )
  }
  clampScalar(e, a) {
    return (
      (this.x = Math.max(e, Math.min(a, this.x))),
      (this.y = Math.max(e, Math.min(a, this.y))),
      (this.z = Math.max(e, Math.min(a, this.z))),
      this
    )
  }
  clampLength(e, a) {
    const o = this.length()
    return this.divideScalar(o || 1).multiplyScalar(Math.max(e, Math.min(a, o)))
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    )
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    )
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    )
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    )
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e)
  }
  lerp(e, a) {
    return (
      (this.x += (e.x - this.x) * a),
      (this.y += (e.y - this.y) * a),
      (this.z += (e.z - this.z) * a),
      this
    )
  }
  lerpVectors(e, a, o) {
    return (
      (this.x = e.x + (a.x - e.x) * o),
      (this.y = e.y + (a.y - e.y) * o),
      (this.z = e.z + (a.z - e.z) * o),
      this
    )
  }
  cross(e) {
    return this.crossVectors(this, e)
  }
  crossVectors(e, a) {
    const o = e.x,
      c = e.y,
      d = e.z,
      g = a.x,
      _ = a.y,
      b = a.z
    return (
      (this.x = c * b - d * _),
      (this.y = d * g - o * b),
      (this.z = o * _ - c * g),
      this
    )
  }
  projectOnVector(e) {
    const a = e.lengthSq()
    if (a === 0) return this.set(0, 0, 0)
    const o = e.dot(this) / a
    return this.copy(e).multiplyScalar(o)
  }
  projectOnPlane(e) {
    return _vector$b.copy(this).projectOnVector(e), this.sub(_vector$b)
  }
  reflect(e) {
    return this.sub(_vector$b.copy(e).multiplyScalar(2 * this.dot(e)))
  }
  angleTo(e) {
    const a = Math.sqrt(this.lengthSq() * e.lengthSq())
    if (a === 0) return Math.PI / 2
    const o = this.dot(e) / a
    return Math.acos(clamp$2(o, -1, 1))
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e))
  }
  distanceToSquared(e) {
    const a = this.x - e.x,
      o = this.y - e.y,
      c = this.z - e.z
    return a * a + o * o + c * c
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    )
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
  }
  setFromSphericalCoords(e, a, o) {
    const c = Math.sin(a) * e
    return (
      (this.x = c * Math.sin(o)),
      (this.y = Math.cos(a) * e),
      (this.z = c * Math.cos(o)),
      this
    )
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
  }
  setFromCylindricalCoords(e, a, o) {
    return (
      (this.x = e * Math.sin(a)), (this.y = o), (this.z = e * Math.cos(a)), this
    )
  }
  setFromMatrixPosition(e) {
    const a = e.elements
    return (this.x = a[12]), (this.y = a[13]), (this.z = a[14]), this
  }
  setFromMatrixScale(e) {
    const a = this.setFromMatrixColumn(e, 0).length(),
      o = this.setFromMatrixColumn(e, 1).length(),
      c = this.setFromMatrixColumn(e, 2).length()
    return (this.x = a), (this.y = o), (this.z = c), this
  }
  setFromMatrixColumn(e, a) {
    return this.fromArray(e.elements, a * 4)
  }
  setFromMatrix3Column(e, a) {
    return this.fromArray(e.elements, a * 3)
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z
  }
  fromArray(e, a = 0) {
    return (this.x = e[a]), (this.y = e[a + 1]), (this.z = e[a + 2]), this
  }
  toArray(e = [], a = 0) {
    return (e[a] = this.x), (e[a + 1] = this.y), (e[a + 2] = this.z), e
  }
  fromBufferAttribute(e, a) {
    return (
      (this.x = e.getX(a)), (this.y = e.getY(a)), (this.z = e.getZ(a)), this
    )
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    )
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      a = Math.random() * Math.PI * 2,
      o = Math.sqrt(1 - e ** 2)
    return (
      (this.x = o * Math.cos(a)), (this.y = o * Math.sin(a)), (this.z = e), this
    )
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z
  }
}
const _vector$b = new Vector3(),
  _quaternion$4 = new Quaternion()
class Box3 {
  constructor(
    e = new Vector3(1 / 0, 1 / 0, 1 / 0),
    a = new Vector3(-1 / 0, -1 / 0, -1 / 0)
  ) {
    ;(this.isBox3 = !0), (this.min = e), (this.max = a)
  }
  set(e, a) {
    return this.min.copy(e), this.max.copy(a), this
  }
  setFromArray(e) {
    this.makeEmpty()
    for (let a = 0, o = e.length; a < o; a += 3)
      this.expandByPoint(_vector$a.fromArray(e, a))
    return this
  }
  setFromBufferAttribute(e) {
    this.makeEmpty()
    for (let a = 0, o = e.count; a < o; a++)
      this.expandByPoint(_vector$a.fromBufferAttribute(e, a))
    return this
  }
  setFromPoints(e) {
    this.makeEmpty()
    for (let a = 0, o = e.length; a < o; a++) this.expandByPoint(e[a])
    return this
  }
  setFromCenterAndSize(e, a) {
    const o = _vector$a.copy(a).multiplyScalar(0.5)
    return this.min.copy(e).sub(o), this.max.copy(e).add(o), this
  }
  setFromObject(e, a = !1) {
    return this.makeEmpty(), this.expandByObject(e, a)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    )
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    )
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this
  }
  expandByObject(e, a = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      e.boundingBox === null && e.computeBoundingBox(),
        _box$3.copy(e.boundingBox),
        _box$3.applyMatrix4(e.matrixWorld),
        this.union(_box$3)
    else {
      const c = e.geometry
      if (c !== void 0)
        if (a && c.attributes !== void 0 && c.attributes.position !== void 0) {
          const d = c.attributes.position
          for (let g = 0, _ = d.count; g < _; g++)
            _vector$a.fromBufferAttribute(d, g).applyMatrix4(e.matrixWorld),
              this.expandByPoint(_vector$a)
        } else
          c.boundingBox === null && c.computeBoundingBox(),
            _box$3.copy(c.boundingBox),
            _box$3.applyMatrix4(e.matrixWorld),
            this.union(_box$3)
    }
    const o = e.children
    for (let c = 0, d = o.length; c < d; c++) this.expandByObject(o[c], a)
    return this
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    )
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    )
  }
  getParameter(e, a) {
    return a.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    )
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    )
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, _vector$a),
      _vector$a.distanceToSquared(e.center) <= e.radius * e.radius
    )
  }
  intersectsPlane(e) {
    let a, o
    return (
      e.normal.x > 0
        ? ((a = e.normal.x * this.min.x), (o = e.normal.x * this.max.x))
        : ((a = e.normal.x * this.max.x), (o = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((a += e.normal.y * this.min.y), (o += e.normal.y * this.max.y))
        : ((a += e.normal.y * this.max.y), (o += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((a += e.normal.z * this.min.z), (o += e.normal.z * this.max.z))
        : ((a += e.normal.z * this.max.z), (o += e.normal.z * this.min.z)),
      a <= -e.constant && o >= -e.constant
    )
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1
    this.getCenter(_center),
      _extents.subVectors(this.max, _center),
      _v0$2.subVectors(e.a, _center),
      _v1$7.subVectors(e.b, _center),
      _v2$4.subVectors(e.c, _center),
      _f0.subVectors(_v1$7, _v0$2),
      _f1.subVectors(_v2$4, _v1$7),
      _f2.subVectors(_v0$2, _v2$4)
    let a = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0,
    ]
    return !satForAxes(a, _v0$2, _v1$7, _v2$4, _extents) ||
      ((a = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !satForAxes(a, _v0$2, _v1$7, _v2$4, _extents))
      ? !1
      : (_triangleNormal.crossVectors(_f0, _f1),
        (a = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z]),
        satForAxes(a, _v0$2, _v1$7, _v2$4, _extents))
  }
  clampPoint(e, a) {
    return a.copy(e).clamp(this.min, this.max)
  }
  distanceToPoint(e) {
    return this.clampPoint(e, _vector$a).distanceTo(e)
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(_vector$a).length() * 0.5)),
      e
    )
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    )
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(_points),
        this)
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max)
  }
}
const _points = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
  ],
  _vector$a = new Vector3(),
  _box$3 = new Box3(),
  _v0$2 = new Vector3(),
  _v1$7 = new Vector3(),
  _v2$4 = new Vector3(),
  _f0 = new Vector3(),
  _f1 = new Vector3(),
  _f2 = new Vector3(),
  _center = new Vector3(),
  _extents = new Vector3(),
  _triangleNormal = new Vector3(),
  _testAxis = new Vector3()
function satForAxes(s, e, a, o, c) {
  for (let d = 0, g = s.length - 3; d <= g; d += 3) {
    _testAxis.fromArray(s, d)
    const _ =
        c.x * Math.abs(_testAxis.x) +
        c.y * Math.abs(_testAxis.y) +
        c.z * Math.abs(_testAxis.z),
      b = e.dot(_testAxis),
      j = a.dot(_testAxis),
      $ = o.dot(_testAxis)
    if (Math.max(-Math.max(b, j, $), Math.min(b, j, $)) > _) return !1
  }
  return !0
}
const _box$2 = new Box3(),
  _v1$6 = new Vector3(),
  _v2$3 = new Vector3()
class Sphere {
  constructor(e = new Vector3(), a = -1) {
    ;(this.center = e), (this.radius = a)
  }
  set(e, a) {
    return this.center.copy(e), (this.radius = a), this
  }
  setFromPoints(e, a) {
    const o = this.center
    a !== void 0 ? o.copy(a) : _box$2.setFromPoints(e).getCenter(o)
    let c = 0
    for (let d = 0, g = e.length; d < g; d++)
      c = Math.max(c, o.distanceToSquared(e[d]))
    return (this.radius = Math.sqrt(c)), this
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this
  }
  isEmpty() {
    return this.radius < 0
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius
  }
  intersectsSphere(e) {
    const a = this.radius + e.radius
    return e.center.distanceToSquared(this.center) <= a * a
  }
  intersectsBox(e) {
    return e.intersectsSphere(this)
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius
  }
  clampPoint(e, a) {
    const o = this.center.distanceToSquared(e)
    return (
      a.copy(e),
      o > this.radius * this.radius &&
        (a.sub(this.center).normalize(),
        a.multiplyScalar(this.radius).add(this.center)),
      a
    )
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    )
  }
  translate(e) {
    return this.center.add(e), this
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this
    _v1$6.subVectors(e, this.center)
    const a = _v1$6.lengthSq()
    if (a > this.radius * this.radius) {
      const o = Math.sqrt(a),
        c = (o - this.radius) * 0.5
      this.center.addScaledVector(_v1$6, c / o), (this.radius += c)
    }
    return this
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (_v2$3.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(_v1$6.copy(e.center).add(_v2$3)),
            this.expandByPoint(_v1$6.copy(e.center).sub(_v2$3))),
        this)
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const _vector$9 = new Vector3(),
  _segCenter = new Vector3(),
  _segDir = new Vector3(),
  _diff = new Vector3(),
  _edge1 = new Vector3(),
  _edge2 = new Vector3(),
  _normal$1 = new Vector3()
class Ray {
  constructor(e = new Vector3(), a = new Vector3(0, 0, -1)) {
    ;(this.origin = e), (this.direction = a)
  }
  set(e, a) {
    return this.origin.copy(e), this.direction.copy(a), this
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
  }
  at(e, a) {
    return a.copy(this.origin).addScaledVector(this.direction, e)
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this
  }
  recast(e) {
    return this.origin.copy(this.at(e, _vector$9)), this
  }
  closestPointToPoint(e, a) {
    a.subVectors(e, this.origin)
    const o = a.dot(this.direction)
    return o < 0
      ? a.copy(this.origin)
      : a.copy(this.origin).addScaledVector(this.direction, o)
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e))
  }
  distanceSqToPoint(e) {
    const a = _vector$9.subVectors(e, this.origin).dot(this.direction)
    return a < 0
      ? this.origin.distanceToSquared(e)
      : (_vector$9.copy(this.origin).addScaledVector(this.direction, a),
        _vector$9.distanceToSquared(e))
  }
  distanceSqToSegment(e, a, o, c) {
    _segCenter.copy(e).add(a).multiplyScalar(0.5),
      _segDir.copy(a).sub(e).normalize(),
      _diff.copy(this.origin).sub(_segCenter)
    const d = e.distanceTo(a) * 0.5,
      g = -this.direction.dot(_segDir),
      _ = _diff.dot(this.direction),
      b = -_diff.dot(_segDir),
      j = _diff.lengthSq(),
      $ = Math.abs(1 - g * g)
    let _e, tt, st, at
    if ($ > 0)
      if (((_e = g * b - _), (tt = g * _ - b), (at = d * $), _e >= 0))
        if (tt >= -at)
          if (tt <= at) {
            const ot = 1 / $
            ;(_e *= ot),
              (tt *= ot),
              (st = _e * (_e + g * tt + 2 * _) + tt * (g * _e + tt + 2 * b) + j)
          } else
            (tt = d),
              (_e = Math.max(0, -(g * tt + _))),
              (st = -_e * _e + tt * (tt + 2 * b) + j)
        else
          (tt = -d),
            (_e = Math.max(0, -(g * tt + _))),
            (st = -_e * _e + tt * (tt + 2 * b) + j)
      else
        tt <= -at
          ? ((_e = Math.max(0, -(-g * d + _))),
            (tt = _e > 0 ? -d : Math.min(Math.max(-d, -b), d)),
            (st = -_e * _e + tt * (tt + 2 * b) + j))
          : tt <= at
          ? ((_e = 0),
            (tt = Math.min(Math.max(-d, -b), d)),
            (st = tt * (tt + 2 * b) + j))
          : ((_e = Math.max(0, -(g * d + _))),
            (tt = _e > 0 ? d : Math.min(Math.max(-d, -b), d)),
            (st = -_e * _e + tt * (tt + 2 * b) + j))
    else
      (tt = g > 0 ? -d : d),
        (_e = Math.max(0, -(g * tt + _))),
        (st = -_e * _e + tt * (tt + 2 * b) + j)
    return (
      o && o.copy(this.origin).addScaledVector(this.direction, _e),
      c && c.copy(_segCenter).addScaledVector(_segDir, tt),
      st
    )
  }
  intersectSphere(e, a) {
    _vector$9.subVectors(e.center, this.origin)
    const o = _vector$9.dot(this.direction),
      c = _vector$9.dot(_vector$9) - o * o,
      d = e.radius * e.radius
    if (c > d) return null
    const g = Math.sqrt(d - c),
      _ = o - g,
      b = o + g
    return b < 0 ? null : _ < 0 ? this.at(b, a) : this.at(_, a)
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius
  }
  distanceToPlane(e) {
    const a = e.normal.dot(this.direction)
    if (a === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null
    const o = -(this.origin.dot(e.normal) + e.constant) / a
    return o >= 0 ? o : null
  }
  intersectPlane(e, a) {
    const o = this.distanceToPlane(e)
    return o === null ? null : this.at(o, a)
  }
  intersectsPlane(e) {
    const a = e.distanceToPoint(this.origin)
    return a === 0 || e.normal.dot(this.direction) * a < 0
  }
  intersectBox(e, a) {
    let o, c, d, g, _, b
    const j = 1 / this.direction.x,
      $ = 1 / this.direction.y,
      _e = 1 / this.direction.z,
      tt = this.origin
    return (
      j >= 0
        ? ((o = (e.min.x - tt.x) * j), (c = (e.max.x - tt.x) * j))
        : ((o = (e.max.x - tt.x) * j), (c = (e.min.x - tt.x) * j)),
      $ >= 0
        ? ((d = (e.min.y - tt.y) * $), (g = (e.max.y - tt.y) * $))
        : ((d = (e.max.y - tt.y) * $), (g = (e.min.y - tt.y) * $)),
      o > g ||
      d > c ||
      ((d > o || isNaN(o)) && (o = d),
      (g < c || isNaN(c)) && (c = g),
      _e >= 0
        ? ((_ = (e.min.z - tt.z) * _e), (b = (e.max.z - tt.z) * _e))
        : ((_ = (e.max.z - tt.z) * _e), (b = (e.min.z - tt.z) * _e)),
      o > b || _ > c) ||
      ((_ > o || o !== o) && (o = _), (b < c || c !== c) && (c = b), c < 0)
        ? null
        : this.at(o >= 0 ? o : c, a)
    )
  }
  intersectsBox(e) {
    return this.intersectBox(e, _vector$9) !== null
  }
  intersectTriangle(e, a, o, c, d) {
    _edge1.subVectors(a, e),
      _edge2.subVectors(o, e),
      _normal$1.crossVectors(_edge1, _edge2)
    let g = this.direction.dot(_normal$1),
      _
    if (g > 0) {
      if (c) return null
      _ = 1
    } else if (g < 0) (_ = -1), (g = -g)
    else return null
    _diff.subVectors(this.origin, e)
    const b = _ * this.direction.dot(_edge2.crossVectors(_diff, _edge2))
    if (b < 0) return null
    const j = _ * this.direction.dot(_edge1.cross(_diff))
    if (j < 0 || b + j > g) return null
    const $ = -_ * _diff.dot(_normal$1)
    return $ < 0 ? null : this.at($ / g, d)
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    )
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class Matrix4 {
  constructor(e, a, o, c, d, g, _, b, j, $, _e, tt, st, at, ot, ut) {
    ;(Matrix4.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 &&
        this.set(e, a, o, c, d, g, _, b, j, $, _e, tt, st, at, ot, ut)
  }
  set(e, a, o, c, d, g, _, b, j, $, _e, tt, st, at, ot, ut) {
    const it = this.elements
    return (
      (it[0] = e),
      (it[4] = a),
      (it[8] = o),
      (it[12] = c),
      (it[1] = d),
      (it[5] = g),
      (it[9] = _),
      (it[13] = b),
      (it[2] = j),
      (it[6] = $),
      (it[10] = _e),
      (it[14] = tt),
      (it[3] = st),
      (it[7] = at),
      (it[11] = ot),
      (it[15] = ut),
      this
    )
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  clone() {
    return new Matrix4().fromArray(this.elements)
  }
  copy(e) {
    const a = this.elements,
      o = e.elements
    return (
      (a[0] = o[0]),
      (a[1] = o[1]),
      (a[2] = o[2]),
      (a[3] = o[3]),
      (a[4] = o[4]),
      (a[5] = o[5]),
      (a[6] = o[6]),
      (a[7] = o[7]),
      (a[8] = o[8]),
      (a[9] = o[9]),
      (a[10] = o[10]),
      (a[11] = o[11]),
      (a[12] = o[12]),
      (a[13] = o[13]),
      (a[14] = o[14]),
      (a[15] = o[15]),
      this
    )
  }
  copyPosition(e) {
    const a = this.elements,
      o = e.elements
    return (a[12] = o[12]), (a[13] = o[13]), (a[14] = o[14]), this
  }
  setFromMatrix3(e) {
    const a = e.elements
    return (
      this.set(
        a[0],
        a[3],
        a[6],
        0,
        a[1],
        a[4],
        a[7],
        0,
        a[2],
        a[5],
        a[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  extractBasis(e, a, o) {
    return (
      e.setFromMatrixColumn(this, 0),
      a.setFromMatrixColumn(this, 1),
      o.setFromMatrixColumn(this, 2),
      this
    )
  }
  makeBasis(e, a, o) {
    return (
      this.set(
        e.x,
        a.x,
        o.x,
        0,
        e.y,
        a.y,
        o.y,
        0,
        e.z,
        a.z,
        o.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  extractRotation(e) {
    const a = this.elements,
      o = e.elements,
      c = 1 / _v1$5.setFromMatrixColumn(e, 0).length(),
      d = 1 / _v1$5.setFromMatrixColumn(e, 1).length(),
      g = 1 / _v1$5.setFromMatrixColumn(e, 2).length()
    return (
      (a[0] = o[0] * c),
      (a[1] = o[1] * c),
      (a[2] = o[2] * c),
      (a[3] = 0),
      (a[4] = o[4] * d),
      (a[5] = o[5] * d),
      (a[6] = o[6] * d),
      (a[7] = 0),
      (a[8] = o[8] * g),
      (a[9] = o[9] * g),
      (a[10] = o[10] * g),
      (a[11] = 0),
      (a[12] = 0),
      (a[13] = 0),
      (a[14] = 0),
      (a[15] = 1),
      this
    )
  }
  makeRotationFromEuler(e) {
    const a = this.elements,
      o = e.x,
      c = e.y,
      d = e.z,
      g = Math.cos(o),
      _ = Math.sin(o),
      b = Math.cos(c),
      j = Math.sin(c),
      $ = Math.cos(d),
      _e = Math.sin(d)
    if (e.order === "XYZ") {
      const tt = g * $,
        st = g * _e,
        at = _ * $,
        ot = _ * _e
      ;(a[0] = b * $),
        (a[4] = -b * _e),
        (a[8] = j),
        (a[1] = st + at * j),
        (a[5] = tt - ot * j),
        (a[9] = -_ * b),
        (a[2] = ot - tt * j),
        (a[6] = at + st * j),
        (a[10] = g * b)
    } else if (e.order === "YXZ") {
      const tt = b * $,
        st = b * _e,
        at = j * $,
        ot = j * _e
      ;(a[0] = tt + ot * _),
        (a[4] = at * _ - st),
        (a[8] = g * j),
        (a[1] = g * _e),
        (a[5] = g * $),
        (a[9] = -_),
        (a[2] = st * _ - at),
        (a[6] = ot + tt * _),
        (a[10] = g * b)
    } else if (e.order === "ZXY") {
      const tt = b * $,
        st = b * _e,
        at = j * $,
        ot = j * _e
      ;(a[0] = tt - ot * _),
        (a[4] = -g * _e),
        (a[8] = at + st * _),
        (a[1] = st + at * _),
        (a[5] = g * $),
        (a[9] = ot - tt * _),
        (a[2] = -g * j),
        (a[6] = _),
        (a[10] = g * b)
    } else if (e.order === "ZYX") {
      const tt = g * $,
        st = g * _e,
        at = _ * $,
        ot = _ * _e
      ;(a[0] = b * $),
        (a[4] = at * j - st),
        (a[8] = tt * j + ot),
        (a[1] = b * _e),
        (a[5] = ot * j + tt),
        (a[9] = st * j - at),
        (a[2] = -j),
        (a[6] = _ * b),
        (a[10] = g * b)
    } else if (e.order === "YZX") {
      const tt = g * b,
        st = g * j,
        at = _ * b,
        ot = _ * j
      ;(a[0] = b * $),
        (a[4] = ot - tt * _e),
        (a[8] = at * _e + st),
        (a[1] = _e),
        (a[5] = g * $),
        (a[9] = -_ * $),
        (a[2] = -j * $),
        (a[6] = st * _e + at),
        (a[10] = tt - ot * _e)
    } else if (e.order === "XZY") {
      const tt = g * b,
        st = g * j,
        at = _ * b,
        ot = _ * j
      ;(a[0] = b * $),
        (a[4] = -_e),
        (a[8] = j * $),
        (a[1] = tt * _e + ot),
        (a[5] = g * $),
        (a[9] = st * _e - at),
        (a[2] = at * _e - st),
        (a[6] = _ * $),
        (a[10] = ot * _e + tt)
    }
    return (
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = 0),
      (a[12] = 0),
      (a[13] = 0),
      (a[14] = 0),
      (a[15] = 1),
      this
    )
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_zero, e, _one)
  }
  lookAt(e, a, o) {
    const c = this.elements
    return (
      _z.subVectors(e, a),
      _z.lengthSq() === 0 && (_z.z = 1),
      _z.normalize(),
      _x.crossVectors(o, _z),
      _x.lengthSq() === 0 &&
        (Math.abs(o.z) === 1 ? (_z.x += 1e-4) : (_z.z += 1e-4),
        _z.normalize(),
        _x.crossVectors(o, _z)),
      _x.normalize(),
      _y.crossVectors(_z, _x),
      (c[0] = _x.x),
      (c[4] = _y.x),
      (c[8] = _z.x),
      (c[1] = _x.y),
      (c[5] = _y.y),
      (c[9] = _z.y),
      (c[2] = _x.z),
      (c[6] = _y.z),
      (c[10] = _z.z),
      this
    )
  }
  multiply(e) {
    return this.multiplyMatrices(this, e)
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this)
  }
  multiplyMatrices(e, a) {
    const o = e.elements,
      c = a.elements,
      d = this.elements,
      g = o[0],
      _ = o[4],
      b = o[8],
      j = o[12],
      $ = o[1],
      _e = o[5],
      tt = o[9],
      st = o[13],
      at = o[2],
      ot = o[6],
      ut = o[10],
      it = o[14],
      ct = o[3],
      lt = o[7],
      ht = o[11],
      dt = o[15],
      pt = c[0],
      vt = c[4],
      _t = c[8],
      yt = c[12],
      Et = c[1],
      Rt = c[5],
      Ft = c[9],
      kt = c[13],
      Nt = c[2],
      Dt = c[6],
      Mt = c[10],
      wt = c[14],
      gt = c[3],
      At = c[7],
      bt = c[11],
      Tt = c[15]
    return (
      (d[0] = g * pt + _ * Et + b * Nt + j * gt),
      (d[4] = g * vt + _ * Rt + b * Dt + j * At),
      (d[8] = g * _t + _ * Ft + b * Mt + j * bt),
      (d[12] = g * yt + _ * kt + b * wt + j * Tt),
      (d[1] = $ * pt + _e * Et + tt * Nt + st * gt),
      (d[5] = $ * vt + _e * Rt + tt * Dt + st * At),
      (d[9] = $ * _t + _e * Ft + tt * Mt + st * bt),
      (d[13] = $ * yt + _e * kt + tt * wt + st * Tt),
      (d[2] = at * pt + ot * Et + ut * Nt + it * gt),
      (d[6] = at * vt + ot * Rt + ut * Dt + it * At),
      (d[10] = at * _t + ot * Ft + ut * Mt + it * bt),
      (d[14] = at * yt + ot * kt + ut * wt + it * Tt),
      (d[3] = ct * pt + lt * Et + ht * Nt + dt * gt),
      (d[7] = ct * vt + lt * Rt + ht * Dt + dt * At),
      (d[11] = ct * _t + lt * Ft + ht * Mt + dt * bt),
      (d[15] = ct * yt + lt * kt + ht * wt + dt * Tt),
      this
    )
  }
  multiplyScalar(e) {
    const a = this.elements
    return (
      (a[0] *= e),
      (a[4] *= e),
      (a[8] *= e),
      (a[12] *= e),
      (a[1] *= e),
      (a[5] *= e),
      (a[9] *= e),
      (a[13] *= e),
      (a[2] *= e),
      (a[6] *= e),
      (a[10] *= e),
      (a[14] *= e),
      (a[3] *= e),
      (a[7] *= e),
      (a[11] *= e),
      (a[15] *= e),
      this
    )
  }
  determinant() {
    const e = this.elements,
      a = e[0],
      o = e[4],
      c = e[8],
      d = e[12],
      g = e[1],
      _ = e[5],
      b = e[9],
      j = e[13],
      $ = e[2],
      _e = e[6],
      tt = e[10],
      st = e[14],
      at = e[3],
      ot = e[7],
      ut = e[11],
      it = e[15]
    return (
      at *
        (+d * b * _e -
          c * j * _e -
          d * _ * tt +
          o * j * tt +
          c * _ * st -
          o * b * st) +
      ot *
        (+a * b * st -
          a * j * tt +
          d * g * tt -
          c * g * st +
          c * j * $ -
          d * b * $) +
      ut *
        (+a * j * _e -
          a * _ * st -
          d * g * _e +
          o * g * st +
          d * _ * $ -
          o * j * $) +
      it *
        (-c * _ * $ -
          a * b * _e +
          a * _ * tt +
          c * g * _e -
          o * g * tt +
          o * b * $)
    )
  }
  transpose() {
    const e = this.elements
    let a
    return (
      (a = e[1]),
      (e[1] = e[4]),
      (e[4] = a),
      (a = e[2]),
      (e[2] = e[8]),
      (e[8] = a),
      (a = e[6]),
      (e[6] = e[9]),
      (e[9] = a),
      (a = e[3]),
      (e[3] = e[12]),
      (e[12] = a),
      (a = e[7]),
      (e[7] = e[13]),
      (e[13] = a),
      (a = e[11]),
      (e[11] = e[14]),
      (e[14] = a),
      this
    )
  }
  setPosition(e, a, o) {
    const c = this.elements
    return (
      e.isVector3
        ? ((c[12] = e.x), (c[13] = e.y), (c[14] = e.z))
        : ((c[12] = e), (c[13] = a), (c[14] = o)),
      this
    )
  }
  invert() {
    const e = this.elements,
      a = e[0],
      o = e[1],
      c = e[2],
      d = e[3],
      g = e[4],
      _ = e[5],
      b = e[6],
      j = e[7],
      $ = e[8],
      _e = e[9],
      tt = e[10],
      st = e[11],
      at = e[12],
      ot = e[13],
      ut = e[14],
      it = e[15],
      ct =
        _e * ut * j -
        ot * tt * j +
        ot * b * st -
        _ * ut * st -
        _e * b * it +
        _ * tt * it,
      lt =
        at * tt * j -
        $ * ut * j -
        at * b * st +
        g * ut * st +
        $ * b * it -
        g * tt * it,
      ht =
        $ * ot * j -
        at * _e * j +
        at * _ * st -
        g * ot * st -
        $ * _ * it +
        g * _e * it,
      dt =
        at * _e * b -
        $ * ot * b -
        at * _ * tt +
        g * ot * tt +
        $ * _ * ut -
        g * _e * ut,
      pt = a * ct + o * lt + c * ht + d * dt
    if (pt === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    const vt = 1 / pt
    return (
      (e[0] = ct * vt),
      (e[1] =
        (ot * tt * d -
          _e * ut * d -
          ot * c * st +
          o * ut * st +
          _e * c * it -
          o * tt * it) *
        vt),
      (e[2] =
        (_ * ut * d -
          ot * b * d +
          ot * c * j -
          o * ut * j -
          _ * c * it +
          o * b * it) *
        vt),
      (e[3] =
        (_e * b * d -
          _ * tt * d -
          _e * c * j +
          o * tt * j +
          _ * c * st -
          o * b * st) *
        vt),
      (e[4] = lt * vt),
      (e[5] =
        ($ * ut * d -
          at * tt * d +
          at * c * st -
          a * ut * st -
          $ * c * it +
          a * tt * it) *
        vt),
      (e[6] =
        (at * b * d -
          g * ut * d -
          at * c * j +
          a * ut * j +
          g * c * it -
          a * b * it) *
        vt),
      (e[7] =
        (g * tt * d -
          $ * b * d +
          $ * c * j -
          a * tt * j -
          g * c * st +
          a * b * st) *
        vt),
      (e[8] = ht * vt),
      (e[9] =
        (at * _e * d -
          $ * ot * d -
          at * o * st +
          a * ot * st +
          $ * o * it -
          a * _e * it) *
        vt),
      (e[10] =
        (g * ot * d -
          at * _ * d +
          at * o * j -
          a * ot * j -
          g * o * it +
          a * _ * it) *
        vt),
      (e[11] =
        ($ * _ * d -
          g * _e * d -
          $ * o * j +
          a * _e * j +
          g * o * st -
          a * _ * st) *
        vt),
      (e[12] = dt * vt),
      (e[13] =
        ($ * ot * c -
          at * _e * c +
          at * o * tt -
          a * ot * tt -
          $ * o * ut +
          a * _e * ut) *
        vt),
      (e[14] =
        (at * _ * c -
          g * ot * c -
          at * o * b +
          a * ot * b +
          g * o * ut -
          a * _ * ut) *
        vt),
      (e[15] =
        (g * _e * c -
          $ * _ * c +
          $ * o * b -
          a * _e * b -
          g * o * tt +
          a * _ * tt) *
        vt),
      this
    )
  }
  scale(e) {
    const a = this.elements,
      o = e.x,
      c = e.y,
      d = e.z
    return (
      (a[0] *= o),
      (a[4] *= c),
      (a[8] *= d),
      (a[1] *= o),
      (a[5] *= c),
      (a[9] *= d),
      (a[2] *= o),
      (a[6] *= c),
      (a[10] *= d),
      (a[3] *= o),
      (a[7] *= c),
      (a[11] *= d),
      this
    )
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      a = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      o = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      c = e[8] * e[8] + e[9] * e[9] + e[10] * e[10]
    return Math.sqrt(Math.max(a, o, c))
  }
  makeTranslation(e, a, o) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, a, 0, 0, 1, o, 0, 0, 0, 1),
      this
    )
  }
  makeRotationX(e) {
    const a = Math.cos(e),
      o = Math.sin(e)
    return this.set(1, 0, 0, 0, 0, a, -o, 0, 0, o, a, 0, 0, 0, 0, 1), this
  }
  makeRotationY(e) {
    const a = Math.cos(e),
      o = Math.sin(e)
    return this.set(a, 0, o, 0, 0, 1, 0, 0, -o, 0, a, 0, 0, 0, 0, 1), this
  }
  makeRotationZ(e) {
    const a = Math.cos(e),
      o = Math.sin(e)
    return this.set(a, -o, 0, 0, o, a, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
  }
  makeRotationAxis(e, a) {
    const o = Math.cos(a),
      c = Math.sin(a),
      d = 1 - o,
      g = e.x,
      _ = e.y,
      b = e.z,
      j = d * g,
      $ = d * _
    return (
      this.set(
        j * g + o,
        j * _ - c * b,
        j * b + c * _,
        0,
        j * _ + c * b,
        $ * _ + o,
        $ * b - c * g,
        0,
        j * b - c * _,
        $ * b + c * g,
        d * b * b + o,
        0,
        0,
        0,
        0,
        1
      ),
      this
    )
  }
  makeScale(e, a, o) {
    return this.set(e, 0, 0, 0, 0, a, 0, 0, 0, 0, o, 0, 0, 0, 0, 1), this
  }
  makeShear(e, a, o, c, d, g) {
    return this.set(1, o, d, 0, e, 1, g, 0, a, c, 1, 0, 0, 0, 0, 1), this
  }
  compose(e, a, o) {
    const c = this.elements,
      d = a._x,
      g = a._y,
      _ = a._z,
      b = a._w,
      j = d + d,
      $ = g + g,
      _e = _ + _,
      tt = d * j,
      st = d * $,
      at = d * _e,
      ot = g * $,
      ut = g * _e,
      it = _ * _e,
      ct = b * j,
      lt = b * $,
      ht = b * _e,
      dt = o.x,
      pt = o.y,
      vt = o.z
    return (
      (c[0] = (1 - (ot + it)) * dt),
      (c[1] = (st + ht) * dt),
      (c[2] = (at - lt) * dt),
      (c[3] = 0),
      (c[4] = (st - ht) * pt),
      (c[5] = (1 - (tt + it)) * pt),
      (c[6] = (ut + ct) * pt),
      (c[7] = 0),
      (c[8] = (at + lt) * vt),
      (c[9] = (ut - ct) * vt),
      (c[10] = (1 - (tt + ot)) * vt),
      (c[11] = 0),
      (c[12] = e.x),
      (c[13] = e.y),
      (c[14] = e.z),
      (c[15] = 1),
      this
    )
  }
  decompose(e, a, o) {
    const c = this.elements
    let d = _v1$5.set(c[0], c[1], c[2]).length()
    const g = _v1$5.set(c[4], c[5], c[6]).length(),
      _ = _v1$5.set(c[8], c[9], c[10]).length()
    this.determinant() < 0 && (d = -d),
      (e.x = c[12]),
      (e.y = c[13]),
      (e.z = c[14]),
      _m1$2.copy(this)
    const j = 1 / d,
      $ = 1 / g,
      _e = 1 / _
    return (
      (_m1$2.elements[0] *= j),
      (_m1$2.elements[1] *= j),
      (_m1$2.elements[2] *= j),
      (_m1$2.elements[4] *= $),
      (_m1$2.elements[5] *= $),
      (_m1$2.elements[6] *= $),
      (_m1$2.elements[8] *= _e),
      (_m1$2.elements[9] *= _e),
      (_m1$2.elements[10] *= _e),
      a.setFromRotationMatrix(_m1$2),
      (o.x = d),
      (o.y = g),
      (o.z = _),
      this
    )
  }
  makePerspective(e, a, o, c, d, g, _ = WebGLCoordinateSystem) {
    const b = this.elements,
      j = (2 * d) / (a - e),
      $ = (2 * d) / (o - c),
      _e = (a + e) / (a - e),
      tt = (o + c) / (o - c)
    let st, at
    if (_ === WebGLCoordinateSystem)
      (st = -(g + d) / (g - d)), (at = (-2 * g * d) / (g - d))
    else if (_ === WebGPUCoordinateSystem)
      (st = -g / (g - d)), (at = (-g * d) / (g - d))
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + _
      )
    return (
      (b[0] = j),
      (b[4] = 0),
      (b[8] = _e),
      (b[12] = 0),
      (b[1] = 0),
      (b[5] = $),
      (b[9] = tt),
      (b[13] = 0),
      (b[2] = 0),
      (b[6] = 0),
      (b[10] = st),
      (b[14] = at),
      (b[3] = 0),
      (b[7] = 0),
      (b[11] = -1),
      (b[15] = 0),
      this
    )
  }
  makeOrthographic(e, a, o, c, d, g, _ = WebGLCoordinateSystem) {
    const b = this.elements,
      j = 1 / (a - e),
      $ = 1 / (o - c),
      _e = 1 / (g - d),
      tt = (a + e) * j,
      st = (o + c) * $
    let at, ot
    if (_ === WebGLCoordinateSystem) (at = (g + d) * _e), (ot = -2 * _e)
    else if (_ === WebGPUCoordinateSystem) (at = d * _e), (ot = -1 * _e)
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + _
      )
    return (
      (b[0] = 2 * j),
      (b[4] = 0),
      (b[8] = 0),
      (b[12] = -tt),
      (b[1] = 0),
      (b[5] = 2 * $),
      (b[9] = 0),
      (b[13] = -st),
      (b[2] = 0),
      (b[6] = 0),
      (b[10] = ot),
      (b[14] = -at),
      (b[3] = 0),
      (b[7] = 0),
      (b[11] = 0),
      (b[15] = 1),
      this
    )
  }
  equals(e) {
    const a = this.elements,
      o = e.elements
    for (let c = 0; c < 16; c++) if (a[c] !== o[c]) return !1
    return !0
  }
  fromArray(e, a = 0) {
    for (let o = 0; o < 16; o++) this.elements[o] = e[o + a]
    return this
  }
  toArray(e = [], a = 0) {
    const o = this.elements
    return (
      (e[a] = o[0]),
      (e[a + 1] = o[1]),
      (e[a + 2] = o[2]),
      (e[a + 3] = o[3]),
      (e[a + 4] = o[4]),
      (e[a + 5] = o[5]),
      (e[a + 6] = o[6]),
      (e[a + 7] = o[7]),
      (e[a + 8] = o[8]),
      (e[a + 9] = o[9]),
      (e[a + 10] = o[10]),
      (e[a + 11] = o[11]),
      (e[a + 12] = o[12]),
      (e[a + 13] = o[13]),
      (e[a + 14] = o[14]),
      (e[a + 15] = o[15]),
      e
    )
  }
}
const _v1$5 = new Vector3(),
  _m1$2 = new Matrix4(),
  _zero = new Vector3(0, 0, 0),
  _one = new Vector3(1, 1, 1),
  _x = new Vector3(),
  _y = new Vector3(),
  _z = new Vector3(),
  _matrix = new Matrix4(),
  _quaternion$3 = new Quaternion()
class Euler {
  constructor(e = 0, a = 0, o = 0, c = Euler.DEFAULT_ORDER) {
    ;(this.isEuler = !0),
      (this._x = e),
      (this._y = a),
      (this._z = o),
      (this._order = c)
  }
  get x() {
    return this._x
  }
  set x(e) {
    ;(this._x = e), this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(e) {
    ;(this._y = e), this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(e) {
    ;(this._z = e), this._onChangeCallback()
  }
  get order() {
    return this._order
  }
  set order(e) {
    ;(this._order = e), this._onChangeCallback()
  }
  set(e, a, o, c = this._order) {
    return (
      (this._x = e),
      (this._y = a),
      (this._z = o),
      (this._order = c),
      this._onChangeCallback(),
      this
    )
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order)
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    )
  }
  setFromRotationMatrix(e, a = this._order, o = !0) {
    const c = e.elements,
      d = c[0],
      g = c[4],
      _ = c[8],
      b = c[1],
      j = c[5],
      $ = c[9],
      _e = c[2],
      tt = c[6],
      st = c[10]
    switch (a) {
      case "XYZ":
        ;(this._y = Math.asin(clamp$2(_, -1, 1))),
          Math.abs(_) < 0.9999999
            ? ((this._x = Math.atan2(-$, st)), (this._z = Math.atan2(-g, d)))
            : ((this._x = Math.atan2(tt, j)), (this._z = 0))
        break
      case "YXZ":
        ;(this._x = Math.asin(-clamp$2($, -1, 1))),
          Math.abs($) < 0.9999999
            ? ((this._y = Math.atan2(_, st)), (this._z = Math.atan2(b, j)))
            : ((this._y = Math.atan2(-_e, d)), (this._z = 0))
        break
      case "ZXY":
        ;(this._x = Math.asin(clamp$2(tt, -1, 1))),
          Math.abs(tt) < 0.9999999
            ? ((this._y = Math.atan2(-_e, st)), (this._z = Math.atan2(-g, j)))
            : ((this._y = 0), (this._z = Math.atan2(b, d)))
        break
      case "ZYX":
        ;(this._y = Math.asin(-clamp$2(_e, -1, 1))),
          Math.abs(_e) < 0.9999999
            ? ((this._x = Math.atan2(tt, st)), (this._z = Math.atan2(b, d)))
            : ((this._x = 0), (this._z = Math.atan2(-g, j)))
        break
      case "YZX":
        ;(this._z = Math.asin(clamp$2(b, -1, 1))),
          Math.abs(b) < 0.9999999
            ? ((this._x = Math.atan2(-$, j)), (this._y = Math.atan2(-_e, d)))
            : ((this._x = 0), (this._y = Math.atan2(_, st)))
        break
      case "XZY":
        ;(this._z = Math.asin(-clamp$2(g, -1, 1))),
          Math.abs(g) < 0.9999999
            ? ((this._x = Math.atan2(tt, j)), (this._y = Math.atan2(_, d)))
            : ((this._x = Math.atan2(-$, st)), (this._y = 0))
        break
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            a
        )
    }
    return (this._order = a), o === !0 && this._onChangeCallback(), this
  }
  setFromQuaternion(e, a, o) {
    return (
      _matrix.makeRotationFromQuaternion(e),
      this.setFromRotationMatrix(_matrix, a, o)
    )
  }
  setFromVector3(e, a = this._order) {
    return this.set(e.x, e.y, e.z, a)
  }
  reorder(e) {
    return (
      _quaternion$3.setFromEuler(this), this.setFromQuaternion(_quaternion$3, e)
    )
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    )
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    )
  }
  toArray(e = [], a = 0) {
    return (
      (e[a] = this._x),
      (e[a + 1] = this._y),
      (e[a + 2] = this._z),
      (e[a + 3] = this._order),
      e
    )
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order
  }
}
Euler.DEFAULT_ORDER = "XYZ"
class Layers {
  constructor() {
    this.mask = 1
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0
  }
  enable(e) {
    this.mask |= (1 << e) | 0
  }
  enableAll() {
    this.mask = -1
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0)
  }
  disableAll() {
    this.mask = 0
  }
  test(e) {
    return (this.mask & e.mask) !== 0
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0
  }
}
let _object3DId = 0
const _v1$4 = new Vector3(),
  _q1 = new Quaternion(),
  _m1$1 = new Matrix4(),
  _target = new Vector3(),
  _position$3 = new Vector3(),
  _scale$2 = new Vector3(),
  _quaternion$2 = new Quaternion(),
  _xAxis = new Vector3(1, 0, 0),
  _yAxis = new Vector3(0, 1, 0),
  _zAxis = new Vector3(0, 0, 1),
  _addedEvent = { type: "added" },
  _removedEvent = { type: "removed" }
class Object3D extends EventDispatcher {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: _object3DId++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Object3D.DEFAULT_UP.clone())
    const e = new Vector3(),
      a = new Euler(),
      o = new Quaternion(),
      c = new Vector3(1, 1, 1)
    function d() {
      o.setFromEuler(a, !1)
    }
    function g() {
      a.setFromQuaternion(o, void 0, !1)
    }
    a._onChange(d),
      o._onChange(g),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: a },
        quaternion: { configurable: !0, enumerable: !0, value: o },
        scale: { configurable: !0, enumerable: !0, value: c },
        modelViewMatrix: { value: new Matrix4() },
        normalMatrix: { value: new Matrix3() },
      }),
      (this.matrix = new Matrix4()),
      (this.matrixWorld = new Matrix4()),
      (this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new Layers()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {})
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale)
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this
  }
  setRotationFromAxisAngle(e, a) {
    this.quaternion.setFromAxisAngle(e, a)
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0)
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e)
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e)
  }
  rotateOnAxis(e, a) {
    return _q1.setFromAxisAngle(e, a), this.quaternion.multiply(_q1), this
  }
  rotateOnWorldAxis(e, a) {
    return _q1.setFromAxisAngle(e, a), this.quaternion.premultiply(_q1), this
  }
  rotateX(e) {
    return this.rotateOnAxis(_xAxis, e)
  }
  rotateY(e) {
    return this.rotateOnAxis(_yAxis, e)
  }
  rotateZ(e) {
    return this.rotateOnAxis(_zAxis, e)
  }
  translateOnAxis(e, a) {
    return (
      _v1$4.copy(e).applyQuaternion(this.quaternion),
      this.position.add(_v1$4.multiplyScalar(a)),
      this
    )
  }
  translateX(e) {
    return this.translateOnAxis(_xAxis, e)
  }
  translateY(e) {
    return this.translateOnAxis(_yAxis, e)
  }
  translateZ(e) {
    return this.translateOnAxis(_zAxis, e)
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(_m1$1.copy(this.matrixWorld).invert())
    )
  }
  lookAt(e, a, o) {
    e.isVector3 ? _target.copy(e) : _target.set(e, a, o)
    const c = this.parent
    this.updateWorldMatrix(!0, !1),
      _position$3.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? _m1$1.lookAt(_position$3, _target, this.up)
        : _m1$1.lookAt(_target, _position$3, this.up),
      this.quaternion.setFromRotationMatrix(_m1$1),
      c &&
        (_m1$1.extractRotation(c.matrixWorld),
        _q1.setFromRotationMatrix(_m1$1),
        this.quaternion.premultiply(_q1.invert()))
  }
  add(e) {
    if (arguments.length > 1) {
      for (let a = 0; a < arguments.length; a++) this.add(arguments[a])
      return this
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(_addedEvent))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this)
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let o = 0; o < arguments.length; o++) this.remove(arguments[o])
      return this
    }
    const a = this.children.indexOf(e)
    return (
      a !== -1 &&
        ((e.parent = null),
        this.children.splice(a, 1),
        e.dispatchEvent(_removedEvent)),
      this
    )
  }
  removeFromParent() {
    const e = this.parent
    return e !== null && e.remove(this), this
  }
  clear() {
    return this.remove(...this.children)
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      _m1$1.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1),
        _m1$1.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(_m1$1),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    )
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e)
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e)
  }
  getObjectByProperty(e, a) {
    if (this[e] === a) return this
    for (let o = 0, c = this.children.length; o < c; o++) {
      const g = this.children[o].getObjectByProperty(e, a)
      if (g !== void 0) return g
    }
  }
  getObjectsByProperty(e, a) {
    let o = []
    this[e] === a && o.push(this)
    for (let c = 0, d = this.children.length; c < d; c++) {
      const g = this.children[c].getObjectsByProperty(e, a)
      g.length > 0 && (o = o.concat(g))
    }
    return o
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    )
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(_position$3, e, _scale$2),
      e
    )
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      this.matrixWorld.decompose(_position$3, _quaternion$2, e),
      e
    )
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1)
    const a = this.matrixWorld.elements
    return e.set(a[8], a[9], a[10]).normalize()
  }
  raycast() {}
  traverse(e) {
    e(this)
    const a = this.children
    for (let o = 0, c = a.length; o < c; o++) a[o].traverse(e)
  }
  traverseVisible(e) {
    if (this.visible === !1) return
    e(this)
    const a = this.children
    for (let o = 0, c = a.length; o < c; o++) a[o].traverseVisible(e)
  }
  traverseAncestors(e) {
    const a = this.parent
    a !== null && (e(a), a.traverseAncestors(e))
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0)
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0))
    const a = this.children
    for (let o = 0, c = a.length; o < c; o++) {
      const d = a[o]
      ;(d.matrixWorldAutoUpdate === !0 || e === !0) && d.updateMatrixWorld(e)
    }
  }
  updateWorldMatrix(e, a) {
    const o = this.parent
    if (
      (e === !0 &&
        o !== null &&
        o.matrixWorldAutoUpdate === !0 &&
        o.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      a === !0)
    ) {
      const c = this.children
      for (let d = 0, g = c.length; d < g; d++) {
        const _ = c[d]
        _.matrixWorldAutoUpdate === !0 && _.updateWorldMatrix(!1, !0)
      }
    }
  }
  toJSON(e) {
    const a = e === void 0 || typeof e == "string",
      o = {}
    a &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (o.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }))
    const c = {}
    ;(c.uuid = this.uuid),
      (c.type = this.type),
      this.name !== "" && (c.name = this.name),
      this.castShadow === !0 && (c.castShadow = !0),
      this.receiveShadow === !0 && (c.receiveShadow = !0),
      this.visible === !1 && (c.visible = !1),
      this.frustumCulled === !1 && (c.frustumCulled = !1),
      this.renderOrder !== 0 && (c.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (c.userData = this.userData),
      (c.layers = this.layers.mask),
      (c.matrix = this.matrix.toArray()),
      (c.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (c.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((c.type = "InstancedMesh"),
        (c.count = this.count),
        (c.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (c.instanceColor = this.instanceColor.toJSON()))
    function d(_, b) {
      return _[b.uuid] === void 0 && (_[b.uuid] = b.toJSON(e)), b.uuid
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (c.background = this.background.toJSON())
          : this.background.isTexture &&
            (c.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (c.environment = this.environment.toJSON(e).uuid)
    else if (this.isMesh || this.isLine || this.isPoints) {
      c.geometry = d(e.geometries, this.geometry)
      const _ = this.geometry.parameters
      if (_ !== void 0 && _.shapes !== void 0) {
        const b = _.shapes
        if (Array.isArray(b))
          for (let j = 0, $ = b.length; j < $; j++) {
            const _e = b[j]
            d(e.shapes, _e)
          }
        else d(e.shapes, b)
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((c.bindMode = this.bindMode),
        (c.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (d(e.skeletons, this.skeleton), (c.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const _ = []
        for (let b = 0, j = this.material.length; b < j; b++)
          _.push(d(e.materials, this.material[b]))
        c.material = _
      } else c.material = d(e.materials, this.material)
    if (this.children.length > 0) {
      c.children = []
      for (let _ = 0; _ < this.children.length; _++)
        c.children.push(this.children[_].toJSON(e).object)
    }
    if (this.animations.length > 0) {
      c.animations = []
      for (let _ = 0; _ < this.animations.length; _++) {
        const b = this.animations[_]
        c.animations.push(d(e.animations, b))
      }
    }
    if (a) {
      const _ = g(e.geometries),
        b = g(e.materials),
        j = g(e.textures),
        $ = g(e.images),
        _e = g(e.shapes),
        tt = g(e.skeletons),
        st = g(e.animations),
        at = g(e.nodes)
      _.length > 0 && (o.geometries = _),
        b.length > 0 && (o.materials = b),
        j.length > 0 && (o.textures = j),
        $.length > 0 && (o.images = $),
        _e.length > 0 && (o.shapes = _e),
        tt.length > 0 && (o.skeletons = tt),
        st.length > 0 && (o.animations = st),
        at.length > 0 && (o.nodes = at)
    }
    return (o.object = c), o
    function g(_) {
      const b = []
      for (const j in _) {
        const $ = _[j]
        delete $.metadata, b.push($)
      }
      return b
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e)
  }
  copy(e, a = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      a === !0)
    )
      for (let o = 0; o < e.children.length; o++) {
        const c = e.children[o]
        this.add(c.clone())
      }
    return this
  }
}
Object3D.DEFAULT_UP = new Vector3(0, 1, 0)
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0
const _v0$1 = new Vector3(),
  _v1$3 = new Vector3(),
  _v2$2 = new Vector3(),
  _v3$1 = new Vector3(),
  _vab = new Vector3(),
  _vac = new Vector3(),
  _vbc = new Vector3(),
  _vap = new Vector3(),
  _vbp = new Vector3(),
  _vcp = new Vector3()
let warnedGetUV = !1
class Triangle {
  constructor(e = new Vector3(), a = new Vector3(), o = new Vector3()) {
    ;(this.a = e), (this.b = a), (this.c = o)
  }
  static getNormal(e, a, o, c) {
    c.subVectors(o, a), _v0$1.subVectors(e, a), c.cross(_v0$1)
    const d = c.lengthSq()
    return d > 0 ? c.multiplyScalar(1 / Math.sqrt(d)) : c.set(0, 0, 0)
  }
  static getBarycoord(e, a, o, c, d) {
    _v0$1.subVectors(c, a), _v1$3.subVectors(o, a), _v2$2.subVectors(e, a)
    const g = _v0$1.dot(_v0$1),
      _ = _v0$1.dot(_v1$3),
      b = _v0$1.dot(_v2$2),
      j = _v1$3.dot(_v1$3),
      $ = _v1$3.dot(_v2$2),
      _e = g * j - _ * _
    if (_e === 0) return d.set(-2, -1, -1)
    const tt = 1 / _e,
      st = (j * b - _ * $) * tt,
      at = (g * $ - _ * b) * tt
    return d.set(1 - st - at, at, st)
  }
  static containsPoint(e, a, o, c) {
    return (
      this.getBarycoord(e, a, o, c, _v3$1),
      _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1
    )
  }
  static getUV(e, a, o, c, d, g, _, b) {
    return (
      warnedGetUV === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (warnedGetUV = !0)),
      this.getInterpolation(e, a, o, c, d, g, _, b)
    )
  }
  static getInterpolation(e, a, o, c, d, g, _, b) {
    return (
      this.getBarycoord(e, a, o, c, _v3$1),
      b.setScalar(0),
      b.addScaledVector(d, _v3$1.x),
      b.addScaledVector(g, _v3$1.y),
      b.addScaledVector(_, _v3$1.z),
      b
    )
  }
  static isFrontFacing(e, a, o, c) {
    return (
      _v0$1.subVectors(o, a),
      _v1$3.subVectors(e, a),
      _v0$1.cross(_v1$3).dot(c) < 0
    )
  }
  set(e, a, o) {
    return this.a.copy(e), this.b.copy(a), this.c.copy(o), this
  }
  setFromPointsAndIndices(e, a, o, c) {
    return this.a.copy(e[a]), this.b.copy(e[o]), this.c.copy(e[c]), this
  }
  setFromAttributeAndIndices(e, a, o, c) {
    return (
      this.a.fromBufferAttribute(e, a),
      this.b.fromBufferAttribute(e, o),
      this.c.fromBufferAttribute(e, c),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
  }
  getArea() {
    return (
      _v0$1.subVectors(this.c, this.b),
      _v1$3.subVectors(this.a, this.b),
      _v0$1.cross(_v1$3).length() * 0.5
    )
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3)
  }
  getNormal(e) {
    return Triangle.getNormal(this.a, this.b, this.c, e)
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c)
  }
  getBarycoord(e, a) {
    return Triangle.getBarycoord(e, this.a, this.b, this.c, a)
  }
  getUV(e, a, o, c, d) {
    return (
      warnedGetUV === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (warnedGetUV = !0)),
      Triangle.getInterpolation(e, this.a, this.b, this.c, a, o, c, d)
    )
  }
  getInterpolation(e, a, o, c, d) {
    return Triangle.getInterpolation(e, this.a, this.b, this.c, a, o, c, d)
  }
  containsPoint(e) {
    return Triangle.containsPoint(e, this.a, this.b, this.c)
  }
  isFrontFacing(e) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, e)
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this)
  }
  closestPointToPoint(e, a) {
    const o = this.a,
      c = this.b,
      d = this.c
    let g, _
    _vab.subVectors(c, o), _vac.subVectors(d, o), _vap.subVectors(e, o)
    const b = _vab.dot(_vap),
      j = _vac.dot(_vap)
    if (b <= 0 && j <= 0) return a.copy(o)
    _vbp.subVectors(e, c)
    const $ = _vab.dot(_vbp),
      _e = _vac.dot(_vbp)
    if ($ >= 0 && _e <= $) return a.copy(c)
    const tt = b * _e - $ * j
    if (tt <= 0 && b >= 0 && $ <= 0)
      return (g = b / (b - $)), a.copy(o).addScaledVector(_vab, g)
    _vcp.subVectors(e, d)
    const st = _vab.dot(_vcp),
      at = _vac.dot(_vcp)
    if (at >= 0 && st <= at) return a.copy(d)
    const ot = st * j - b * at
    if (ot <= 0 && j >= 0 && at <= 0)
      return (_ = j / (j - at)), a.copy(o).addScaledVector(_vac, _)
    const ut = $ * at - st * _e
    if (ut <= 0 && _e - $ >= 0 && st - at >= 0)
      return (
        _vbc.subVectors(d, c),
        (_ = (_e - $) / (_e - $ + (st - at))),
        a.copy(c).addScaledVector(_vbc, _)
      )
    const it = 1 / (ut + ot + tt)
    return (
      (g = ot * it),
      (_ = tt * it),
      a.copy(o).addScaledVector(_vab, g).addScaledVector(_vac, _)
    )
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
  }
}
let _materialId = 0
class Material extends EventDispatcher {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: _materialId++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = NormalBlending),
      (this.side = FrontSide),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = SrcAlphaFactor),
      (this.blendDst = OneMinusSrcAlphaFactor),
      (this.blendEquation = AddEquation),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = LessEqualDepth),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = AlwaysStencilFunc),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = KeepStencilOp),
      (this.stencilZFail = KeepStencilOp),
      (this.stencilZPass = KeepStencilOp),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0)
  }
  get alphaTest() {
    return this._alphaTest
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e)
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString()
  }
  setValues(e) {
    if (e !== void 0)
      for (const a in e) {
        const o = e[a]
        if (o === void 0) {
          console.warn(
            `THREE.Material: parameter '${a}' has value of undefined.`
          )
          continue
        }
        const c = this[a]
        if (c === void 0) {
          console.warn(
            `THREE.Material: '${a}' is not a property of THREE.${this.type}.`
          )
          continue
        }
        c && c.isColor
          ? c.set(o)
          : c && c.isVector3 && o && o.isVector3
          ? c.copy(o)
          : (this[a] = o)
      }
  }
  toJSON(e) {
    const a = e === void 0 || typeof e == "string"
    a && (e = { textures: {}, images: {} })
    const o = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    }
    ;(o.uuid = this.uuid),
      (o.type = this.type),
      this.name !== "" && (o.name = this.name),
      this.color && this.color.isColor && (o.color = this.color.getHex()),
      this.roughness !== void 0 && (o.roughness = this.roughness),
      this.metalness !== void 0 && (o.metalness = this.metalness),
      this.sheen !== void 0 && (o.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (o.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (o.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (o.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (o.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (o.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (o.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (o.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (o.shininess = this.shininess),
      this.clearcoat !== void 0 && (o.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (o.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (o.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (o.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((o.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (o.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (o.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (o.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (o.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (o.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (o.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (o.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (o.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (o.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (o.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (o.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (o.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((o.lightMap = this.lightMap.toJSON(e).uuid),
        (o.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((o.aoMap = this.aoMap.toJSON(e).uuid),
        (o.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((o.bumpMap = this.bumpMap.toJSON(e).uuid),
        (o.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((o.normalMap = this.normalMap.toJSON(e).uuid),
        (o.normalMapType = this.normalMapType),
        (o.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((o.displacementMap = this.displacementMap.toJSON(e).uuid),
        (o.displacementScale = this.displacementScale),
        (o.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (o.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (o.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (o.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (o.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (o.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (o.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((o.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (o.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (o.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (o.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (o.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (o.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (o.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (o.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (o.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (o.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (o.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (o.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (o.size = this.size),
      this.shadowSide !== null && (o.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (o.sizeAttenuation = this.sizeAttenuation),
      this.blending !== NormalBlending && (o.blending = this.blending),
      this.side !== FrontSide && (o.side = this.side),
      this.vertexColors && (o.vertexColors = !0),
      this.opacity < 1 && (o.opacity = this.opacity),
      this.transparent === !0 && (o.transparent = this.transparent),
      (o.depthFunc = this.depthFunc),
      (o.depthTest = this.depthTest),
      (o.depthWrite = this.depthWrite),
      (o.colorWrite = this.colorWrite),
      (o.stencilWrite = this.stencilWrite),
      (o.stencilWriteMask = this.stencilWriteMask),
      (o.stencilFunc = this.stencilFunc),
      (o.stencilRef = this.stencilRef),
      (o.stencilFuncMask = this.stencilFuncMask),
      (o.stencilFail = this.stencilFail),
      (o.stencilZFail = this.stencilZFail),
      (o.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (o.rotation = this.rotation),
      this.polygonOffset === !0 && (o.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (o.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (o.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (o.linewidth = this.linewidth),
      this.dashSize !== void 0 && (o.dashSize = this.dashSize),
      this.gapSize !== void 0 && (o.gapSize = this.gapSize),
      this.scale !== void 0 && (o.scale = this.scale),
      this.dithering === !0 && (o.dithering = !0),
      this.alphaTest > 0 && (o.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (o.alphaHash = this.alphaHash),
      this.alphaToCoverage === !0 && (o.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (o.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (o.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (o.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (o.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (o.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (o.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (o.flatShading = this.flatShading),
      this.visible === !1 && (o.visible = !1),
      this.toneMapped === !1 && (o.toneMapped = !1),
      this.fog === !1 && (o.fog = !1),
      Object.keys(this.userData).length > 0 && (o.userData = this.userData)
    function c(d) {
      const g = []
      for (const _ in d) {
        const b = d[_]
        delete b.metadata, g.push(b)
      }
      return g
    }
    if (a) {
      const d = c(e.textures),
        g = c(e.images)
      d.length > 0 && (o.textures = d), g.length > 0 && (o.images = g)
    }
    return o
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;(this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite)
    const a = e.clippingPlanes
    let o = null
    if (a !== null) {
      const c = a.length
      o = new Array(c)
      for (let d = 0; d !== c; ++d) o[d] = a[d].clone()
    }
    return (
      (this.clippingPlanes = o),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" })
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
}
const _colorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  _hslA = { h: 0, s: 0, l: 0 },
  _hslB = { h: 0, s: 0, l: 0 }
function hue2rgb(s, e, a) {
  return (
    a < 0 && (a += 1),
    a > 1 && (a -= 1),
    a < 1 / 6
      ? s + (e - s) * 6 * a
      : a < 1 / 2
      ? e
      : a < 2 / 3
      ? s + (e - s) * 6 * (2 / 3 - a)
      : s
  )
}
class Color {
  constructor(e, a, o) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, a, o)
    )
  }
  set(e, a, o) {
    if (a === void 0 && o === void 0) {
      const c = e
      c && c.isColor
        ? this.copy(c)
        : typeof c == "number"
        ? this.setHex(c)
        : typeof c == "string" && this.setStyle(c)
    } else this.setRGB(e, a, o)
    return this
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this
  }
  setHex(e, a = SRGBColorSpace) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      ColorManagement.toWorkingColorSpace(this, a),
      this
    )
  }
  setRGB(e, a, o, c = ColorManagement.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = a),
      (this.b = o),
      ColorManagement.toWorkingColorSpace(this, c),
      this
    )
  }
  setHSL(e, a, o, c = ColorManagement.workingColorSpace) {
    if (
      ((e = euclideanModulo(e, 1)),
      (a = clamp$2(a, 0, 1)),
      (o = clamp$2(o, 0, 1)),
      a === 0)
    )
      this.r = this.g = this.b = o
    else {
      const d = o <= 0.5 ? o * (1 + a) : o + a - o * a,
        g = 2 * o - d
      ;(this.r = hue2rgb(g, d, e + 1 / 3)),
        (this.g = hue2rgb(g, d, e)),
        (this.b = hue2rgb(g, d, e - 1 / 3))
    }
    return ColorManagement.toWorkingColorSpace(this, c), this
  }
  setStyle(e, a = SRGBColorSpace) {
    function o(d) {
      d !== void 0 &&
        parseFloat(d) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        )
    }
    let c
    if ((c = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let d
      const g = c[1],
        _ = c[2]
      switch (g) {
        case "rgb":
        case "rgba":
          if (
            (d =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                _
              ))
          )
            return (
              o(d[4]),
              this.setRGB(
                Math.min(255, parseInt(d[1], 10)) / 255,
                Math.min(255, parseInt(d[2], 10)) / 255,
                Math.min(255, parseInt(d[3], 10)) / 255,
                a
              )
            )
          if (
            (d =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                _
              ))
          )
            return (
              o(d[4]),
              this.setRGB(
                Math.min(100, parseInt(d[1], 10)) / 100,
                Math.min(100, parseInt(d[2], 10)) / 100,
                Math.min(100, parseInt(d[3], 10)) / 100,
                a
              )
            )
          break
        case "hsl":
        case "hsla":
          if (
            (d =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                _
              ))
          )
            return (
              o(d[4]),
              this.setHSL(
                parseFloat(d[1]) / 360,
                parseFloat(d[2]) / 100,
                parseFloat(d[3]) / 100,
                a
              )
            )
          break
        default:
          console.warn("THREE.Color: Unknown color model " + e)
      }
    } else if ((c = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const d = c[1],
        g = d.length
      if (g === 3)
        return this.setRGB(
          parseInt(d.charAt(0), 16) / 15,
          parseInt(d.charAt(1), 16) / 15,
          parseInt(d.charAt(2), 16) / 15,
          a
        )
      if (g === 6) return this.setHex(parseInt(d, 16), a)
      console.warn("THREE.Color: Invalid hex color " + e)
    } else if (e && e.length > 0) return this.setColorName(e, a)
    return this
  }
  setColorName(e, a = SRGBColorSpace) {
    const o = _colorKeywords[e.toLowerCase()]
    return (
      o !== void 0
        ? this.setHex(o, a)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    )
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b)
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this
  }
  copySRGBToLinear(e) {
    return (
      (this.r = SRGBToLinear(e.r)),
      (this.g = SRGBToLinear(e.g)),
      (this.b = SRGBToLinear(e.b)),
      this
    )
  }
  copyLinearToSRGB(e) {
    return (
      (this.r = LinearToSRGB(e.r)),
      (this.g = LinearToSRGB(e.g)),
      (this.b = LinearToSRGB(e.b)),
      this
    )
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this
  }
  getHex(e = SRGBColorSpace) {
    return (
      ColorManagement.fromWorkingColorSpace(_color.copy(this), e),
      Math.round(clamp$2(_color.r * 255, 0, 255)) * 65536 +
        Math.round(clamp$2(_color.g * 255, 0, 255)) * 256 +
        Math.round(clamp$2(_color.b * 255, 0, 255))
    )
  }
  getHexString(e = SRGBColorSpace) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6)
  }
  getHSL(e, a = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), a)
    const o = _color.r,
      c = _color.g,
      d = _color.b,
      g = Math.max(o, c, d),
      _ = Math.min(o, c, d)
    let b, j
    const $ = (_ + g) / 2
    if (_ === g) (b = 0), (j = 0)
    else {
      const _e = g - _
      switch (((j = $ <= 0.5 ? _e / (g + _) : _e / (2 - g - _)), g)) {
        case o:
          b = (c - d) / _e + (c < d ? 6 : 0)
          break
        case c:
          b = (d - o) / _e + 2
          break
        case d:
          b = (o - c) / _e + 4
          break
      }
      b /= 6
    }
    return (e.h = b), (e.s = j), (e.l = $), e
  }
  getRGB(e, a = ColorManagement.workingColorSpace) {
    return (
      ColorManagement.fromWorkingColorSpace(_color.copy(this), a),
      (e.r = _color.r),
      (e.g = _color.g),
      (e.b = _color.b),
      e
    )
  }
  getStyle(e = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), e)
    const a = _color.r,
      o = _color.g,
      c = _color.b
    return e !== SRGBColorSpace
      ? `color(${e} ${a.toFixed(3)} ${o.toFixed(3)} ${c.toFixed(3)})`
      : `rgb(${Math.round(a * 255)},${Math.round(o * 255)},${Math.round(
          c * 255
        )})`
  }
  offsetHSL(e, a, o) {
    return (
      this.getHSL(_hslA),
      (_hslA.h += e),
      (_hslA.s += a),
      (_hslA.l += o),
      this.setHSL(_hslA.h, _hslA.s, _hslA.l),
      this
    )
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this
  }
  addColors(e, a) {
    return (
      (this.r = e.r + a.r), (this.g = e.g + a.g), (this.b = e.b + a.b), this
    )
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    )
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this
  }
  lerp(e, a) {
    return (
      (this.r += (e.r - this.r) * a),
      (this.g += (e.g - this.g) * a),
      (this.b += (e.b - this.b) * a),
      this
    )
  }
  lerpColors(e, a, o) {
    return (
      (this.r = e.r + (a.r - e.r) * o),
      (this.g = e.g + (a.g - e.g) * o),
      (this.b = e.b + (a.b - e.b) * o),
      this
    )
  }
  lerpHSL(e, a) {
    this.getHSL(_hslA), e.getHSL(_hslB)
    const o = lerp(_hslA.h, _hslB.h, a),
      c = lerp(_hslA.s, _hslB.s, a),
      d = lerp(_hslA.l, _hslB.l, a)
    return this.setHSL(o, c, d), this
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this
  }
  applyMatrix3(e) {
    const a = this.r,
      o = this.g,
      c = this.b,
      d = e.elements
    return (
      (this.r = d[0] * a + d[3] * o + d[6] * c),
      (this.g = d[1] * a + d[4] * o + d[7] * c),
      (this.b = d[2] * a + d[5] * o + d[8] * c),
      this
    )
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b
  }
  fromArray(e, a = 0) {
    return (this.r = e[a]), (this.g = e[a + 1]), (this.b = e[a + 2]), this
  }
  toArray(e = [], a = 0) {
    return (e[a] = this.r), (e[a + 1] = this.g), (e[a + 2] = this.b), e
  }
  fromBufferAttribute(e, a) {
    return (
      (this.r = e.getX(a)), (this.g = e.getY(a)), (this.b = e.getZ(a)), this
    )
  }
  toJSON() {
    return this.getHex()
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b
  }
}
const _color = new Color()
Color.NAMES = _colorKeywords
class MeshBasicMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    )
  }
}
const _tables = _generateTables()
function _generateTables() {
  const s = new ArrayBuffer(4),
    e = new Float32Array(s),
    a = new Uint32Array(s),
    o = new Uint32Array(512),
    c = new Uint32Array(512)
  for (let b = 0; b < 256; ++b) {
    const j = b - 127
    j < -27
      ? ((o[b] = 0), (o[b | 256] = 32768), (c[b] = 24), (c[b | 256] = 24))
      : j < -14
      ? ((o[b] = 1024 >> (-j - 14)),
        (o[b | 256] = (1024 >> (-j - 14)) | 32768),
        (c[b] = -j - 1),
        (c[b | 256] = -j - 1))
      : j <= 15
      ? ((o[b] = (j + 15) << 10),
        (o[b | 256] = ((j + 15) << 10) | 32768),
        (c[b] = 13),
        (c[b | 256] = 13))
      : j < 128
      ? ((o[b] = 31744), (o[b | 256] = 64512), (c[b] = 24), (c[b | 256] = 24))
      : ((o[b] = 31744), (o[b | 256] = 64512), (c[b] = 13), (c[b | 256] = 13))
  }
  const d = new Uint32Array(2048),
    g = new Uint32Array(64),
    _ = new Uint32Array(64)
  for (let b = 1; b < 1024; ++b) {
    let j = b << 13,
      $ = 0
    for (; !(j & 8388608); ) (j <<= 1), ($ -= 8388608)
    ;(j &= -8388609), ($ += 947912704), (d[b] = j | $)
  }
  for (let b = 1024; b < 2048; ++b) d[b] = 939524096 + ((b - 1024) << 13)
  for (let b = 1; b < 31; ++b) g[b] = b << 23
  ;(g[31] = 1199570944), (g[32] = 2147483648)
  for (let b = 33; b < 63; ++b) g[b] = 2147483648 + ((b - 32) << 23)
  g[63] = 3347054592
  for (let b = 1; b < 64; ++b) b !== 32 && (_[b] = 1024)
  return {
    floatView: e,
    uint32View: a,
    baseTable: o,
    shiftTable: c,
    mantissaTable: d,
    exponentTable: g,
    offsetTable: _,
  }
}
function toHalfFloat(s) {
  Math.abs(s) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (s = clamp$2(s, -65504, 65504)),
    (_tables.floatView[0] = s)
  const e = _tables.uint32View[0],
    a = (e >> 23) & 511
  return _tables.baseTable[a] + ((e & 8388607) >> _tables.shiftTable[a])
}
function fromHalfFloat(s) {
  const e = s >> 10
  return (
    (_tables.uint32View[0] =
      _tables.mantissaTable[_tables.offsetTable[e] + (s & 1023)] +
      _tables.exponentTable[e]),
    _tables.floatView[0]
  )
}
const DataUtils = { toHalfFloat, fromHalfFloat },
  _vector$8 = new Vector3(),
  _vector2$1 = new Vector2()
class BufferAttribute {
  constructor(e, a, o = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      )
    ;(this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = a),
      (this.count = e !== void 0 ? e.length / a : 0),
      (this.normalized = o),
      (this.usage = StaticDrawUsage),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.gpuType = FloatType),
      (this.version = 0)
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setUsage(e) {
    return (this.usage = e), this
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    )
  }
  copyAt(e, a, o) {
    ;(e *= this.itemSize), (o *= a.itemSize)
    for (let c = 0, d = this.itemSize; c < d; c++)
      this.array[e + c] = a.array[o + c]
    return this
  }
  copyArray(e) {
    return this.array.set(e), this
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let a = 0, o = this.count; a < o; a++)
        _vector2$1.fromBufferAttribute(this, a),
          _vector2$1.applyMatrix3(e),
          this.setXY(a, _vector2$1.x, _vector2$1.y)
    else if (this.itemSize === 3)
      for (let a = 0, o = this.count; a < o; a++)
        _vector$8.fromBufferAttribute(this, a),
          _vector$8.applyMatrix3(e),
          this.setXYZ(a, _vector$8.x, _vector$8.y, _vector$8.z)
    return this
  }
  applyMatrix4(e) {
    for (let a = 0, o = this.count; a < o; a++)
      _vector$8.fromBufferAttribute(this, a),
        _vector$8.applyMatrix4(e),
        this.setXYZ(a, _vector$8.x, _vector$8.y, _vector$8.z)
    return this
  }
  applyNormalMatrix(e) {
    for (let a = 0, o = this.count; a < o; a++)
      _vector$8.fromBufferAttribute(this, a),
        _vector$8.applyNormalMatrix(e),
        this.setXYZ(a, _vector$8.x, _vector$8.y, _vector$8.z)
    return this
  }
  transformDirection(e) {
    for (let a = 0, o = this.count; a < o; a++)
      _vector$8.fromBufferAttribute(this, a),
        _vector$8.transformDirection(e),
        this.setXYZ(a, _vector$8.x, _vector$8.y, _vector$8.z)
    return this
  }
  set(e, a = 0) {
    return this.array.set(e, a), this
  }
  getComponent(e, a) {
    let o = this.array[e * this.itemSize + a]
    return this.normalized && (o = denormalize(o, this.array)), o
  }
  setComponent(e, a, o) {
    return (
      this.normalized && (o = normalize$1(o, this.array)),
      (this.array[e * this.itemSize + a] = o),
      this
    )
  }
  getX(e) {
    let a = this.array[e * this.itemSize]
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  setX(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.array[e * this.itemSize] = a),
      this
    )
  }
  getY(e) {
    let a = this.array[e * this.itemSize + 1]
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  setY(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.array[e * this.itemSize + 1] = a),
      this
    )
  }
  getZ(e) {
    let a = this.array[e * this.itemSize + 2]
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  setZ(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.array[e * this.itemSize + 2] = a),
      this
    )
  }
  getW(e) {
    let a = this.array[e * this.itemSize + 3]
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  setW(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.array[e * this.itemSize + 3] = a),
      this
    )
  }
  setXY(e, a, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((a = normalize$1(a, this.array)), (o = normalize$1(o, this.array))),
      (this.array[e + 0] = a),
      (this.array[e + 1] = o),
      this
    )
  }
  setXYZ(e, a, o, c) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((a = normalize$1(a, this.array)),
        (o = normalize$1(o, this.array)),
        (c = normalize$1(c, this.array))),
      (this.array[e + 0] = a),
      (this.array[e + 1] = o),
      (this.array[e + 2] = c),
      this
    )
  }
  setXYZW(e, a, o, c, d) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((a = normalize$1(a, this.array)),
        (o = normalize$1(o, this.array)),
        (c = normalize$1(c, this.array)),
        (d = normalize$1(d, this.array))),
      (this.array[e + 0] = a),
      (this.array[e + 1] = o),
      (this.array[e + 2] = c),
      (this.array[e + 3] = d),
      this
    )
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this)
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    }
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== StaticDrawUsage && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    )
  }
}
class Int8BufferAttribute extends BufferAttribute {
  constructor(e, a, o) {
    super(new Int8Array(e), a, o)
  }
}
class Uint8BufferAttribute extends BufferAttribute {
  constructor(e, a, o) {
    super(new Uint8Array(e), a, o)
  }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(e, a, o) {
    super(new Uint8ClampedArray(e), a, o)
  }
}
class Int16BufferAttribute extends BufferAttribute {
  constructor(e, a, o) {
    super(new Int16Array(e), a, o)
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(e, a, o) {
    super(new Uint16Array(e), a, o)
  }
}
class Int32BufferAttribute extends BufferAttribute {
  constructor(e, a, o) {
    super(new Int32Array(e), a, o)
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(e, a, o) {
    super(new Uint32Array(e), a, o)
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(e, a, o) {
    super(new Uint16Array(e), a, o), (this.isFloat16BufferAttribute = !0)
  }
  getX(e) {
    let a = fromHalfFloat(this.array[e * this.itemSize])
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  setX(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.array[e * this.itemSize] = toHalfFloat(a)),
      this
    )
  }
  getY(e) {
    let a = fromHalfFloat(this.array[e * this.itemSize + 1])
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  setY(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.array[e * this.itemSize + 1] = toHalfFloat(a)),
      this
    )
  }
  getZ(e) {
    let a = fromHalfFloat(this.array[e * this.itemSize + 2])
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  setZ(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.array[e * this.itemSize + 2] = toHalfFloat(a)),
      this
    )
  }
  getW(e) {
    let a = fromHalfFloat(this.array[e * this.itemSize + 3])
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  setW(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.array[e * this.itemSize + 3] = toHalfFloat(a)),
      this
    )
  }
  setXY(e, a, o) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((a = normalize$1(a, this.array)), (o = normalize$1(o, this.array))),
      (this.array[e + 0] = toHalfFloat(a)),
      (this.array[e + 1] = toHalfFloat(o)),
      this
    )
  }
  setXYZ(e, a, o, c) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((a = normalize$1(a, this.array)),
        (o = normalize$1(o, this.array)),
        (c = normalize$1(c, this.array))),
      (this.array[e + 0] = toHalfFloat(a)),
      (this.array[e + 1] = toHalfFloat(o)),
      (this.array[e + 2] = toHalfFloat(c)),
      this
    )
  }
  setXYZW(e, a, o, c, d) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((a = normalize$1(a, this.array)),
        (o = normalize$1(o, this.array)),
        (c = normalize$1(c, this.array)),
        (d = normalize$1(d, this.array))),
      (this.array[e + 0] = toHalfFloat(a)),
      (this.array[e + 1] = toHalfFloat(o)),
      (this.array[e + 2] = toHalfFloat(c)),
      (this.array[e + 3] = toHalfFloat(d)),
      this
    )
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(e, a, o) {
    super(new Float32Array(e), a, o)
  }
}
class Float64BufferAttribute extends BufferAttribute {
  constructor(e, a, o) {
    super(new Float64Array(e), a, o)
  }
}
let _id$2 = 0
const _m1 = new Matrix4(),
  _obj = new Object3D(),
  _offset = new Vector3(),
  _box$1 = new Box3(),
  _boxMorphTargets = new Box3(),
  _vector$7 = new Vector3()
class BufferGeometry extends EventDispatcher {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: _id$2++ }),
      (this.uuid = generateUUID()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {})
  }
  getIndex() {
    return this.index
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (
            arrayNeedsUint32(e) ? Uint32BufferAttribute : Uint16BufferAttribute
          )(e, 1))
        : (this.index = e),
      this
    )
  }
  getAttribute(e) {
    return this.attributes[e]
  }
  setAttribute(e, a) {
    return (this.attributes[e] = a), this
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0
  }
  addGroup(e, a, o = 0) {
    this.groups.push({ start: e, count: a, materialIndex: o })
  }
  clearGroups() {
    this.groups = []
  }
  setDrawRange(e, a) {
    ;(this.drawRange.start = e), (this.drawRange.count = a)
  }
  applyMatrix4(e) {
    const a = this.attributes.position
    a !== void 0 && (a.applyMatrix4(e), (a.needsUpdate = !0))
    const o = this.attributes.normal
    if (o !== void 0) {
      const d = new Matrix3().getNormalMatrix(e)
      o.applyNormalMatrix(d), (o.needsUpdate = !0)
    }
    const c = this.attributes.tangent
    return (
      c !== void 0 && (c.transformDirection(e), (c.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    )
  }
  applyQuaternion(e) {
    return _m1.makeRotationFromQuaternion(e), this.applyMatrix4(_m1), this
  }
  rotateX(e) {
    return _m1.makeRotationX(e), this.applyMatrix4(_m1), this
  }
  rotateY(e) {
    return _m1.makeRotationY(e), this.applyMatrix4(_m1), this
  }
  rotateZ(e) {
    return _m1.makeRotationZ(e), this.applyMatrix4(_m1), this
  }
  translate(e, a, o) {
    return _m1.makeTranslation(e, a, o), this.applyMatrix4(_m1), this
  }
  scale(e, a, o) {
    return _m1.makeScale(e, a, o), this.applyMatrix4(_m1), this
  }
  lookAt(e) {
    return (
      _obj.lookAt(e), _obj.updateMatrix(), this.applyMatrix4(_obj.matrix), this
    )
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(_offset).negate(),
      this.translate(_offset.x, _offset.y, _offset.z),
      this
    )
  }
  setFromPoints(e) {
    const a = []
    for (let o = 0, c = e.length; o < c; o++) {
      const d = e[o]
      a.push(d.x, d.y, d.z || 0)
    }
    return this.setAttribute("position", new Float32BufferAttribute(a, 3)), this
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Box3())
    const e = this.attributes.position,
      a = this.morphAttributes.position
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new Vector3(-1 / 0, -1 / 0, -1 / 0),
          new Vector3(1 / 0, 1 / 0, 1 / 0)
        )
      return
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), a))
        for (let o = 0, c = a.length; o < c; o++) {
          const d = a[o]
          _box$1.setFromBufferAttribute(d),
            this.morphTargetsRelative
              ? (_vector$7.addVectors(this.boundingBox.min, _box$1.min),
                this.boundingBox.expandByPoint(_vector$7),
                _vector$7.addVectors(this.boundingBox.max, _box$1.max),
                this.boundingBox.expandByPoint(_vector$7))
              : (this.boundingBox.expandByPoint(_box$1.min),
                this.boundingBox.expandByPoint(_box$1.max))
        }
    } else this.boundingBox.makeEmpty()
    ;(isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      )
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Sphere())
    const e = this.attributes.position,
      a = this.morphAttributes.position
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new Vector3(), 1 / 0)
      return
    }
    if (e) {
      const o = this.boundingSphere.center
      if ((_box$1.setFromBufferAttribute(e), a))
        for (let d = 0, g = a.length; d < g; d++) {
          const _ = a[d]
          _boxMorphTargets.setFromBufferAttribute(_),
            this.morphTargetsRelative
              ? (_vector$7.addVectors(_box$1.min, _boxMorphTargets.min),
                _box$1.expandByPoint(_vector$7),
                _vector$7.addVectors(_box$1.max, _boxMorphTargets.max),
                _box$1.expandByPoint(_vector$7))
              : (_box$1.expandByPoint(_boxMorphTargets.min),
                _box$1.expandByPoint(_boxMorphTargets.max))
        }
      _box$1.getCenter(o)
      let c = 0
      for (let d = 0, g = e.count; d < g; d++)
        _vector$7.fromBufferAttribute(e, d),
          (c = Math.max(c, o.distanceToSquared(_vector$7)))
      if (a)
        for (let d = 0, g = a.length; d < g; d++) {
          const _ = a[d],
            b = this.morphTargetsRelative
          for (let j = 0, $ = _.count; j < $; j++)
            _vector$7.fromBufferAttribute(_, j),
              b && (_offset.fromBufferAttribute(e, j), _vector$7.add(_offset)),
              (c = Math.max(c, o.distanceToSquared(_vector$7)))
        }
      ;(this.boundingSphere.radius = Math.sqrt(c)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          )
    }
  }
  computeTangents() {
    const e = this.index,
      a = this.attributes
    if (
      e === null ||
      a.position === void 0 ||
      a.normal === void 0 ||
      a.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      )
      return
    }
    const o = e.array,
      c = a.position.array,
      d = a.normal.array,
      g = a.uv.array,
      _ = c.length / 3
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute(
        "tangent",
        new BufferAttribute(new Float32Array(4 * _), 4)
      )
    const b = this.getAttribute("tangent").array,
      j = [],
      $ = []
    for (let Et = 0; Et < _; Et++)
      (j[Et] = new Vector3()), ($[Et] = new Vector3())
    const _e = new Vector3(),
      tt = new Vector3(),
      st = new Vector3(),
      at = new Vector2(),
      ot = new Vector2(),
      ut = new Vector2(),
      it = new Vector3(),
      ct = new Vector3()
    function lt(Et, Rt, Ft) {
      _e.fromArray(c, Et * 3),
        tt.fromArray(c, Rt * 3),
        st.fromArray(c, Ft * 3),
        at.fromArray(g, Et * 2),
        ot.fromArray(g, Rt * 2),
        ut.fromArray(g, Ft * 2),
        tt.sub(_e),
        st.sub(_e),
        ot.sub(at),
        ut.sub(at)
      const kt = 1 / (ot.x * ut.y - ut.x * ot.y)
      isFinite(kt) &&
        (it
          .copy(tt)
          .multiplyScalar(ut.y)
          .addScaledVector(st, -ot.y)
          .multiplyScalar(kt),
        ct
          .copy(st)
          .multiplyScalar(ot.x)
          .addScaledVector(tt, -ut.x)
          .multiplyScalar(kt),
        j[Et].add(it),
        j[Rt].add(it),
        j[Ft].add(it),
        $[Et].add(ct),
        $[Rt].add(ct),
        $[Ft].add(ct))
    }
    let ht = this.groups
    ht.length === 0 && (ht = [{ start: 0, count: o.length }])
    for (let Et = 0, Rt = ht.length; Et < Rt; ++Et) {
      const Ft = ht[Et],
        kt = Ft.start,
        Nt = Ft.count
      for (let Dt = kt, Mt = kt + Nt; Dt < Mt; Dt += 3)
        lt(o[Dt + 0], o[Dt + 1], o[Dt + 2])
    }
    const dt = new Vector3(),
      pt = new Vector3(),
      vt = new Vector3(),
      _t = new Vector3()
    function yt(Et) {
      vt.fromArray(d, Et * 3), _t.copy(vt)
      const Rt = j[Et]
      dt.copy(Rt),
        dt.sub(vt.multiplyScalar(vt.dot(Rt))).normalize(),
        pt.crossVectors(_t, Rt)
      const kt = pt.dot($[Et]) < 0 ? -1 : 1
      ;(b[Et * 4] = dt.x),
        (b[Et * 4 + 1] = dt.y),
        (b[Et * 4 + 2] = dt.z),
        (b[Et * 4 + 3] = kt)
    }
    for (let Et = 0, Rt = ht.length; Et < Rt; ++Et) {
      const Ft = ht[Et],
        kt = Ft.start,
        Nt = Ft.count
      for (let Dt = kt, Mt = kt + Nt; Dt < Mt; Dt += 3)
        yt(o[Dt + 0]), yt(o[Dt + 1]), yt(o[Dt + 2])
    }
  }
  computeVertexNormals() {
    const e = this.index,
      a = this.getAttribute("position")
    if (a !== void 0) {
      let o = this.getAttribute("normal")
      if (o === void 0)
        (o = new BufferAttribute(new Float32Array(a.count * 3), 3)),
          this.setAttribute("normal", o)
      else for (let tt = 0, st = o.count; tt < st; tt++) o.setXYZ(tt, 0, 0, 0)
      const c = new Vector3(),
        d = new Vector3(),
        g = new Vector3(),
        _ = new Vector3(),
        b = new Vector3(),
        j = new Vector3(),
        $ = new Vector3(),
        _e = new Vector3()
      if (e)
        for (let tt = 0, st = e.count; tt < st; tt += 3) {
          const at = e.getX(tt + 0),
            ot = e.getX(tt + 1),
            ut = e.getX(tt + 2)
          c.fromBufferAttribute(a, at),
            d.fromBufferAttribute(a, ot),
            g.fromBufferAttribute(a, ut),
            $.subVectors(g, d),
            _e.subVectors(c, d),
            $.cross(_e),
            _.fromBufferAttribute(o, at),
            b.fromBufferAttribute(o, ot),
            j.fromBufferAttribute(o, ut),
            _.add($),
            b.add($),
            j.add($),
            o.setXYZ(at, _.x, _.y, _.z),
            o.setXYZ(ot, b.x, b.y, b.z),
            o.setXYZ(ut, j.x, j.y, j.z)
        }
      else
        for (let tt = 0, st = a.count; tt < st; tt += 3)
          c.fromBufferAttribute(a, tt + 0),
            d.fromBufferAttribute(a, tt + 1),
            g.fromBufferAttribute(a, tt + 2),
            $.subVectors(g, d),
            _e.subVectors(c, d),
            $.cross(_e),
            o.setXYZ(tt + 0, $.x, $.y, $.z),
            o.setXYZ(tt + 1, $.x, $.y, $.z),
            o.setXYZ(tt + 2, $.x, $.y, $.z)
      this.normalizeNormals(), (o.needsUpdate = !0)
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal
    for (let a = 0, o = e.count; a < o; a++)
      _vector$7.fromBufferAttribute(e, a),
        _vector$7.normalize(),
        e.setXYZ(a, _vector$7.x, _vector$7.y, _vector$7.z)
  }
  toNonIndexed() {
    function e(_, b) {
      const j = _.array,
        $ = _.itemSize,
        _e = _.normalized,
        tt = new j.constructor(b.length * $)
      let st = 0,
        at = 0
      for (let ot = 0, ut = b.length; ot < ut; ot++) {
        _.isInterleavedBufferAttribute
          ? (st = b[ot] * _.data.stride + _.offset)
          : (st = b[ot] * $)
        for (let it = 0; it < $; it++) tt[at++] = j[st++]
      }
      return new BufferAttribute(tt, $, _e)
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      )
    const a = new BufferGeometry(),
      o = this.index.array,
      c = this.attributes
    for (const _ in c) {
      const b = c[_],
        j = e(b, o)
      a.setAttribute(_, j)
    }
    const d = this.morphAttributes
    for (const _ in d) {
      const b = [],
        j = d[_]
      for (let $ = 0, _e = j.length; $ < _e; $++) {
        const tt = j[$],
          st = e(tt, o)
        b.push(st)
      }
      a.morphAttributes[_] = b
    }
    a.morphTargetsRelative = this.morphTargetsRelative
    const g = this.groups
    for (let _ = 0, b = g.length; _ < b; _++) {
      const j = g[_]
      a.addGroup(j.start, j.count, j.materialIndex)
    }
    return a
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    }
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const b = this.parameters
      for (const j in b) b[j] !== void 0 && (e[j] = b[j])
      return e
    }
    e.data = { attributes: {} }
    const a = this.index
    a !== null &&
      (e.data.index = {
        type: a.array.constructor.name,
        array: Array.prototype.slice.call(a.array),
      })
    const o = this.attributes
    for (const b in o) {
      const j = o[b]
      e.data.attributes[b] = j.toJSON(e.data)
    }
    const c = {}
    let d = !1
    for (const b in this.morphAttributes) {
      const j = this.morphAttributes[b],
        $ = []
      for (let _e = 0, tt = j.length; _e < tt; _e++) {
        const st = j[_e]
        $.push(st.toJSON(e.data))
      }
      $.length > 0 && ((c[b] = $), (d = !0))
    }
    d &&
      ((e.data.morphAttributes = c),
      (e.data.morphTargetsRelative = this.morphTargetsRelative))
    const g = this.groups
    g.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(g)))
    const _ = this.boundingSphere
    return (
      _ !== null &&
        (e.data.boundingSphere = {
          center: _.center.toArray(),
          radius: _.radius,
        }),
      e
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    ;(this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null)
    const a = {}
    this.name = e.name
    const o = e.index
    o !== null && this.setIndex(o.clone(a))
    const c = e.attributes
    for (const j in c) {
      const $ = c[j]
      this.setAttribute(j, $.clone(a))
    }
    const d = e.morphAttributes
    for (const j in d) {
      const $ = [],
        _e = d[j]
      for (let tt = 0, st = _e.length; tt < st; tt++) $.push(_e[tt].clone(a))
      this.morphAttributes[j] = $
    }
    this.morphTargetsRelative = e.morphTargetsRelative
    const g = e.groups
    for (let j = 0, $ = g.length; j < $; j++) {
      const _e = g[j]
      this.addGroup(_e.start, _e.count, _e.materialIndex)
    }
    const _ = e.boundingBox
    _ !== null && (this.boundingBox = _.clone())
    const b = e.boundingSphere
    return (
      b !== null && (this.boundingSphere = b.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    )
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" })
  }
}
const _inverseMatrix$3 = new Matrix4(),
  _ray$3 = new Ray(),
  _sphere$5 = new Sphere(),
  _sphereHitAt = new Vector3(),
  _vA$1 = new Vector3(),
  _vB$1 = new Vector3(),
  _vC$1 = new Vector3(),
  _tempA = new Vector3(),
  _morphA = new Vector3(),
  _uvA$1 = new Vector2(),
  _uvB$1 = new Vector2(),
  _uvC$1 = new Vector2(),
  _normalA = new Vector3(),
  _normalB = new Vector3(),
  _normalC = new Vector3(),
  _intersectionPoint = new Vector3(),
  _intersectionPointWorld = new Vector3()
class Mesh extends Object3D {
  constructor(e = new BufferGeometry(), a = new MeshBasicMaterial()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = a),
      this.updateMorphTargets()
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  updateMorphTargets() {
    const a = this.geometry.morphAttributes,
      o = Object.keys(a)
    if (o.length > 0) {
      const c = a[o[0]]
      if (c !== void 0) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let d = 0, g = c.length; d < g; d++) {
          const _ = c[d].name || String(d)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[_] = d)
        }
      }
    }
  }
  getVertexPosition(e, a) {
    const o = this.geometry,
      c = o.attributes.position,
      d = o.morphAttributes.position,
      g = o.morphTargetsRelative
    a.fromBufferAttribute(c, e)
    const _ = this.morphTargetInfluences
    if (d && _) {
      _morphA.set(0, 0, 0)
      for (let b = 0, j = d.length; b < j; b++) {
        const $ = _[b],
          _e = d[b]
        $ !== 0 &&
          (_tempA.fromBufferAttribute(_e, e),
          g
            ? _morphA.addScaledVector(_tempA, $)
            : _morphA.addScaledVector(_tempA.sub(a), $))
      }
      a.add(_morphA)
    }
    return a
  }
  raycast(e, a) {
    const o = this.geometry,
      c = this.material,
      d = this.matrixWorld
    c !== void 0 &&
      (o.boundingSphere === null && o.computeBoundingSphere(),
      _sphere$5.copy(o.boundingSphere),
      _sphere$5.applyMatrix4(d),
      _ray$3.copy(e.ray).recast(e.near),
      !(
        _sphere$5.containsPoint(_ray$3.origin) === !1 &&
        (_ray$3.intersectSphere(_sphere$5, _sphereHitAt) === null ||
          _ray$3.origin.distanceToSquared(_sphereHitAt) > (e.far - e.near) ** 2)
      ) &&
        (_inverseMatrix$3.copy(d).invert(),
        _ray$3.copy(e.ray).applyMatrix4(_inverseMatrix$3),
        !(
          o.boundingBox !== null && _ray$3.intersectsBox(o.boundingBox) === !1
        ) && this._computeIntersections(e, a, _ray$3)))
  }
  _computeIntersections(e, a, o) {
    let c
    const d = this.geometry,
      g = this.material,
      _ = d.index,
      b = d.attributes.position,
      j = d.attributes.uv,
      $ = d.attributes.uv1,
      _e = d.attributes.normal,
      tt = d.groups,
      st = d.drawRange
    if (_ !== null)
      if (Array.isArray(g))
        for (let at = 0, ot = tt.length; at < ot; at++) {
          const ut = tt[at],
            it = g[ut.materialIndex],
            ct = Math.max(ut.start, st.start),
            lt = Math.min(
              _.count,
              Math.min(ut.start + ut.count, st.start + st.count)
            )
          for (let ht = ct, dt = lt; ht < dt; ht += 3) {
            const pt = _.getX(ht),
              vt = _.getX(ht + 1),
              _t = _.getX(ht + 2)
            ;(c = checkGeometryIntersection(
              this,
              it,
              e,
              o,
              j,
              $,
              _e,
              pt,
              vt,
              _t
            )),
              c &&
                ((c.faceIndex = Math.floor(ht / 3)),
                (c.face.materialIndex = ut.materialIndex),
                a.push(c))
          }
        }
      else {
        const at = Math.max(0, st.start),
          ot = Math.min(_.count, st.start + st.count)
        for (let ut = at, it = ot; ut < it; ut += 3) {
          const ct = _.getX(ut),
            lt = _.getX(ut + 1),
            ht = _.getX(ut + 2)
          ;(c = checkGeometryIntersection(this, g, e, o, j, $, _e, ct, lt, ht)),
            c && ((c.faceIndex = Math.floor(ut / 3)), a.push(c))
        }
      }
    else if (b !== void 0)
      if (Array.isArray(g))
        for (let at = 0, ot = tt.length; at < ot; at++) {
          const ut = tt[at],
            it = g[ut.materialIndex],
            ct = Math.max(ut.start, st.start),
            lt = Math.min(
              b.count,
              Math.min(ut.start + ut.count, st.start + st.count)
            )
          for (let ht = ct, dt = lt; ht < dt; ht += 3) {
            const pt = ht,
              vt = ht + 1,
              _t = ht + 2
            ;(c = checkGeometryIntersection(
              this,
              it,
              e,
              o,
              j,
              $,
              _e,
              pt,
              vt,
              _t
            )),
              c &&
                ((c.faceIndex = Math.floor(ht / 3)),
                (c.face.materialIndex = ut.materialIndex),
                a.push(c))
          }
        }
      else {
        const at = Math.max(0, st.start),
          ot = Math.min(b.count, st.start + st.count)
        for (let ut = at, it = ot; ut < it; ut += 3) {
          const ct = ut,
            lt = ut + 1,
            ht = ut + 2
          ;(c = checkGeometryIntersection(this, g, e, o, j, $, _e, ct, lt, ht)),
            c && ((c.faceIndex = Math.floor(ut / 3)), a.push(c))
        }
      }
  }
}
function checkIntersection(s, e, a, o, c, d, g, _) {
  let b
  if (
    (e.side === BackSide
      ? (b = o.intersectTriangle(g, d, c, !0, _))
      : (b = o.intersectTriangle(c, d, g, e.side === FrontSide, _)),
    b === null)
  )
    return null
  _intersectionPointWorld.copy(_),
    _intersectionPointWorld.applyMatrix4(s.matrixWorld)
  const j = a.ray.origin.distanceTo(_intersectionPointWorld)
  return j < a.near || j > a.far
    ? null
    : { distance: j, point: _intersectionPointWorld.clone(), object: s }
}
function checkGeometryIntersection(s, e, a, o, c, d, g, _, b, j) {
  s.getVertexPosition(_, _vA$1),
    s.getVertexPosition(b, _vB$1),
    s.getVertexPosition(j, _vC$1)
  const $ = checkIntersection(
    s,
    e,
    a,
    o,
    _vA$1,
    _vB$1,
    _vC$1,
    _intersectionPoint
  )
  if ($) {
    c &&
      (_uvA$1.fromBufferAttribute(c, _),
      _uvB$1.fromBufferAttribute(c, b),
      _uvC$1.fromBufferAttribute(c, j),
      ($.uv = Triangle.getInterpolation(
        _intersectionPoint,
        _vA$1,
        _vB$1,
        _vC$1,
        _uvA$1,
        _uvB$1,
        _uvC$1,
        new Vector2()
      ))),
      d &&
        (_uvA$1.fromBufferAttribute(d, _),
        _uvB$1.fromBufferAttribute(d, b),
        _uvC$1.fromBufferAttribute(d, j),
        ($.uv1 = Triangle.getInterpolation(
          _intersectionPoint,
          _vA$1,
          _vB$1,
          _vC$1,
          _uvA$1,
          _uvB$1,
          _uvC$1,
          new Vector2()
        )),
        ($.uv2 = $.uv1)),
      g &&
        (_normalA.fromBufferAttribute(g, _),
        _normalB.fromBufferAttribute(g, b),
        _normalC.fromBufferAttribute(g, j),
        ($.normal = Triangle.getInterpolation(
          _intersectionPoint,
          _vA$1,
          _vB$1,
          _vC$1,
          _normalA,
          _normalB,
          _normalC,
          new Vector3()
        )),
        $.normal.dot(o.direction) > 0 && $.normal.multiplyScalar(-1))
    const _e = { a: _, b, c: j, normal: new Vector3(), materialIndex: 0 }
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, _e.normal), ($.face = _e)
  }
  return $
}
class BoxGeometry extends BufferGeometry {
  constructor(e = 1, a = 1, o = 1, c = 1, d = 1, g = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: a,
        depth: o,
        widthSegments: c,
        heightSegments: d,
        depthSegments: g,
      })
    const _ = this
    ;(c = Math.floor(c)), (d = Math.floor(d)), (g = Math.floor(g))
    const b = [],
      j = [],
      $ = [],
      _e = []
    let tt = 0,
      st = 0
    at("z", "y", "x", -1, -1, o, a, e, g, d, 0),
      at("z", "y", "x", 1, -1, o, a, -e, g, d, 1),
      at("x", "z", "y", 1, 1, e, o, a, c, g, 2),
      at("x", "z", "y", 1, -1, e, o, -a, c, g, 3),
      at("x", "y", "z", 1, -1, e, a, o, c, d, 4),
      at("x", "y", "z", -1, -1, e, a, -o, c, d, 5),
      this.setIndex(b),
      this.setAttribute("position", new Float32BufferAttribute(j, 3)),
      this.setAttribute("normal", new Float32BufferAttribute($, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(_e, 2))
    function at(ot, ut, it, ct, lt, ht, dt, pt, vt, _t, yt) {
      const Et = ht / vt,
        Rt = dt / _t,
        Ft = ht / 2,
        kt = dt / 2,
        Nt = pt / 2,
        Dt = vt + 1,
        Mt = _t + 1
      let wt = 0,
        gt = 0
      const At = new Vector3()
      for (let bt = 0; bt < Mt; bt++) {
        const Tt = bt * Rt - kt
        for (let It = 0; It < Dt; It++) {
          const $t = It * Et - Ft
          ;(At[ot] = $t * ct),
            (At[ut] = Tt * lt),
            (At[it] = Nt),
            j.push(At.x, At.y, At.z),
            (At[ot] = 0),
            (At[ut] = 0),
            (At[it] = pt > 0 ? 1 : -1),
            $.push(At.x, At.y, At.z),
            _e.push(It / vt),
            _e.push(1 - bt / _t),
            (wt += 1)
        }
      }
      for (let bt = 0; bt < _t; bt++)
        for (let Tt = 0; Tt < vt; Tt++) {
          const It = tt + Tt + Dt * bt,
            $t = tt + Tt + Dt * (bt + 1),
            Xt = tt + (Tt + 1) + Dt * (bt + 1),
            qt = tt + (Tt + 1) + Dt * bt
          b.push(It, $t, qt), b.push($t, Xt, qt), (gt += 6)
        }
      _.addGroup(st, gt, yt), (st += gt), (tt += wt)
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new BoxGeometry(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    )
  }
}
function cloneUniforms(s) {
  const e = {}
  for (const a in s) {
    e[a] = {}
    for (const o in s[a]) {
      const c = s[a][o]
      c &&
      (c.isColor ||
        c.isMatrix3 ||
        c.isMatrix4 ||
        c.isVector2 ||
        c.isVector3 ||
        c.isVector4 ||
        c.isTexture ||
        c.isQuaternion)
        ? c.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[a][o] = null))
          : (e[a][o] = c.clone())
        : Array.isArray(c)
        ? (e[a][o] = c.slice())
        : (e[a][o] = c)
    }
  }
  return e
}
function mergeUniforms(s) {
  const e = {}
  for (let a = 0; a < s.length; a++) {
    const o = cloneUniforms(s[a])
    for (const c in o) e[c] = o[c]
  }
  return e
}
function cloneUniformsGroups(s) {
  const e = []
  for (let a = 0; a < s.length; a++) e.push(s[a].clone())
  return e
}
function getUnlitUniformColorSpace(s) {
  return s.getRenderTarget() === null
    ? s.outputColorSpace
    : LinearSRGBColorSpace
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }
var default_vertex = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  default_fragment = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`
class ShaderMaterial extends Material {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = default_vertex),
      (this.fragmentShader = default_fragment),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = cloneUniforms(e.uniforms)),
      (this.uniformsGroups = cloneUniformsGroups(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    )
  }
  toJSON(e) {
    const a = super.toJSON(e)
    ;(a.glslVersion = this.glslVersion), (a.uniforms = {})
    for (const c in this.uniforms) {
      const g = this.uniforms[c].value
      g && g.isTexture
        ? (a.uniforms[c] = { type: "t", value: g.toJSON(e).uuid })
        : g && g.isColor
        ? (a.uniforms[c] = { type: "c", value: g.getHex() })
        : g && g.isVector2
        ? (a.uniforms[c] = { type: "v2", value: g.toArray() })
        : g && g.isVector3
        ? (a.uniforms[c] = { type: "v3", value: g.toArray() })
        : g && g.isVector4
        ? (a.uniforms[c] = { type: "v4", value: g.toArray() })
        : g && g.isMatrix3
        ? (a.uniforms[c] = { type: "m3", value: g.toArray() })
        : g && g.isMatrix4
        ? (a.uniforms[c] = { type: "m4", value: g.toArray() })
        : (a.uniforms[c] = { value: g })
    }
    Object.keys(this.defines).length > 0 && (a.defines = this.defines),
      (a.vertexShader = this.vertexShader),
      (a.fragmentShader = this.fragmentShader),
      (a.lights = this.lights),
      (a.clipping = this.clipping)
    const o = {}
    for (const c in this.extensions) this.extensions[c] === !0 && (o[c] = !0)
    return Object.keys(o).length > 0 && (a.extensions = o), a
  }
}
class Camera extends Object3D {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Matrix4()),
      (this.projectionMatrix = new Matrix4()),
      (this.projectionMatrixInverse = new Matrix4()),
      (this.coordinateSystem = WebGLCoordinateSystem)
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    )
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1)
    const a = this.matrixWorld.elements
    return e.set(-a[8], -a[9], -a[10]).normalize()
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  updateWorldMatrix(e, a) {
    super.updateWorldMatrix(e, a),
      this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class PerspectiveCamera extends Camera {
  constructor(e = 50, a = 1, o = 0.1, c = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = o),
      (this.far = c),
      (this.focus = 10),
      (this.aspect = a),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix()
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    )
  }
  setFocalLength(e) {
    const a = (0.5 * this.getFilmHeight()) / e
    ;(this.fov = RAD2DEG * 2 * Math.atan(a)), this.updateProjectionMatrix()
  }
  getFocalLength() {
    const e = Math.tan(DEG2RAD * 0.5 * this.fov)
    return (0.5 * this.getFilmHeight()) / e
  }
  getEffectiveFOV() {
    return (
      RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom)
    )
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1)
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1)
  }
  setViewOffset(e, a, o, c, d, g) {
    ;(this.aspect = e / a),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = a),
      (this.view.offsetX = o),
      (this.view.offsetY = c),
      (this.view.width = d),
      (this.view.height = g),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const e = this.near
    let a = (e * Math.tan(DEG2RAD * 0.5 * this.fov)) / this.zoom,
      o = 2 * a,
      c = this.aspect * o,
      d = -0.5 * c
    const g = this.view
    if (this.view !== null && this.view.enabled) {
      const b = g.fullWidth,
        j = g.fullHeight
      ;(d += (g.offsetX * c) / b),
        (a -= (g.offsetY * o) / j),
        (c *= g.width / b),
        (o *= g.height / j)
    }
    const _ = this.filmOffset
    _ !== 0 && (d += (e * _) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        d,
        d + c,
        a,
        a - o,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(e) {
    const a = super.toJSON(e)
    return (
      (a.object.fov = this.fov),
      (a.object.zoom = this.zoom),
      (a.object.near = this.near),
      (a.object.far = this.far),
      (a.object.focus = this.focus),
      (a.object.aspect = this.aspect),
      this.view !== null && (a.object.view = Object.assign({}, this.view)),
      (a.object.filmGauge = this.filmGauge),
      (a.object.filmOffset = this.filmOffset),
      a
    )
  }
}
const fov = -90,
  aspect = 1
class CubeCamera extends Object3D {
  constructor(e, a, o) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = o),
      (this.coordinateSystem = null)
    const c = new PerspectiveCamera(fov, aspect, e, a)
    ;(c.layers = this.layers), this.add(c)
    const d = new PerspectiveCamera(fov, aspect, e, a)
    ;(d.layers = this.layers), this.add(d)
    const g = new PerspectiveCamera(fov, aspect, e, a)
    ;(g.layers = this.layers), this.add(g)
    const _ = new PerspectiveCamera(fov, aspect, e, a)
    ;(_.layers = this.layers), this.add(_)
    const b = new PerspectiveCamera(fov, aspect, e, a)
    ;(b.layers = this.layers), this.add(b)
    const j = new PerspectiveCamera(fov, aspect, e, a)
    ;(j.layers = this.layers), this.add(j)
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      a = this.children.concat(),
      [o, c, d, g, _, b] = a
    for (const j of a) this.remove(j)
    if (e === WebGLCoordinateSystem)
      o.up.set(0, 1, 0),
        o.lookAt(1, 0, 0),
        c.up.set(0, 1, 0),
        c.lookAt(-1, 0, 0),
        d.up.set(0, 0, -1),
        d.lookAt(0, 1, 0),
        g.up.set(0, 0, 1),
        g.lookAt(0, -1, 0),
        _.up.set(0, 1, 0),
        _.lookAt(0, 0, 1),
        b.up.set(0, 1, 0),
        b.lookAt(0, 0, -1)
    else if (e === WebGPUCoordinateSystem)
      o.up.set(0, -1, 0),
        o.lookAt(-1, 0, 0),
        c.up.set(0, -1, 0),
        c.lookAt(1, 0, 0),
        d.up.set(0, 0, 1),
        d.lookAt(0, 1, 0),
        g.up.set(0, 0, -1),
        g.lookAt(0, -1, 0),
        _.up.set(0, -1, 0),
        _.lookAt(0, 0, 1),
        b.up.set(0, -1, 0),
        b.lookAt(0, 0, -1)
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      )
    for (const j of a) this.add(j), j.updateMatrixWorld()
  }
  update(e, a) {
    this.parent === null && this.updateMatrixWorld()
    const o = this.renderTarget
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem())
    const [c, d, g, _, b, j] = this.children,
      $ = e.getRenderTarget(),
      _e = e.xr.enabled
    e.xr.enabled = !1
    const tt = o.texture.generateMipmaps
    ;(o.texture.generateMipmaps = !1),
      e.setRenderTarget(o, 0),
      e.render(a, c),
      e.setRenderTarget(o, 1),
      e.render(a, d),
      e.setRenderTarget(o, 2),
      e.render(a, g),
      e.setRenderTarget(o, 3),
      e.render(a, _),
      e.setRenderTarget(o, 4),
      e.render(a, b),
      (o.texture.generateMipmaps = tt),
      e.setRenderTarget(o, 5),
      e.render(a, j),
      e.setRenderTarget($),
      (e.xr.enabled = _e),
      (o.texture.needsPMREMUpdate = !0)
  }
}
class CubeTexture extends Texture {
  constructor(e, a, o, c, d, g, _, b, j, $) {
    ;(e = e !== void 0 ? e : []),
      (a = a !== void 0 ? a : CubeReflectionMapping),
      super(e, a, o, c, d, g, _, b, j, $),
      (this.isCubeTexture = !0),
      (this.flipY = !1)
  }
  get images() {
    return this.image
  }
  set images(e) {
    this.image = e
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(e = 1, a = {}) {
    super(e, e, a), (this.isWebGLCubeRenderTarget = !0)
    const o = { width: e, height: e, depth: 1 },
      c = [o, o, o, o, o, o]
    a.encoding !== void 0 &&
      (warnOnce(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (a.colorSpace =
        a.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace)),
      (this.texture = new CubeTexture(
        c,
        a.mapping,
        a.wrapS,
        a.wrapT,
        a.magFilter,
        a.minFilter,
        a.format,
        a.type,
        a.anisotropy,
        a.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        a.generateMipmaps !== void 0 ? a.generateMipmaps : !1),
      (this.texture.minFilter =
        a.minFilter !== void 0 ? a.minFilter : LinearFilter)
  }
  fromEquirectangularTexture(e, a) {
    ;(this.texture.type = a.type),
      (this.texture.colorSpace = a.colorSpace),
      (this.texture.generateMipmaps = a.generateMipmaps),
      (this.texture.minFilter = a.minFilter),
      (this.texture.magFilter = a.magFilter)
    const o = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      c = new BoxGeometry(5, 5, 5),
      d = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: cloneUniforms(o.uniforms),
        vertexShader: o.vertexShader,
        fragmentShader: o.fragmentShader,
        side: BackSide,
        blending: NoBlending,
      })
    d.uniforms.tEquirect.value = a
    const g = new Mesh(c, d),
      _ = a.minFilter
    return (
      a.minFilter === LinearMipmapLinearFilter && (a.minFilter = LinearFilter),
      new CubeCamera(1, 10, this).update(e, g),
      (a.minFilter = _),
      g.geometry.dispose(),
      g.material.dispose(),
      this
    )
  }
  clear(e, a, o, c) {
    const d = e.getRenderTarget()
    for (let g = 0; g < 6; g++) e.setRenderTarget(this, g), e.clear(a, o, c)
    e.setRenderTarget(d)
  }
}
const _vector1 = new Vector3(),
  _vector2 = new Vector3(),
  _normalMatrix = new Matrix3()
class Plane {
  constructor(e = new Vector3(1, 0, 0), a = 0) {
    ;(this.isPlane = !0), (this.normal = e), (this.constant = a)
  }
  set(e, a) {
    return this.normal.copy(e), (this.constant = a), this
  }
  setComponents(e, a, o, c) {
    return this.normal.set(e, a, o), (this.constant = c), this
  }
  setFromNormalAndCoplanarPoint(e, a) {
    return this.normal.copy(e), (this.constant = -a.dot(this.normal)), this
  }
  setFromCoplanarPoints(e, a, o) {
    const c = _vector1
      .subVectors(o, a)
      .cross(_vector2.subVectors(e, a))
      .normalize()
    return this.setFromNormalAndCoplanarPoint(c, e), this
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this
  }
  normalize() {
    const e = 1 / this.normal.length()
    return this.normal.multiplyScalar(e), (this.constant *= e), this
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius
  }
  projectPoint(e, a) {
    return a.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
  }
  intersectLine(e, a) {
    const o = e.delta(_vector1),
      c = this.normal.dot(o)
    if (c === 0)
      return this.distanceToPoint(e.start) === 0 ? a.copy(e.start) : null
    const d = -(e.start.dot(this.normal) + this.constant) / c
    return d < 0 || d > 1 ? null : a.copy(e.start).addScaledVector(o, d)
  }
  intersectsLine(e) {
    const a = this.distanceToPoint(e.start),
      o = this.distanceToPoint(e.end)
    return (a < 0 && o > 0) || (o < 0 && a > 0)
  }
  intersectsBox(e) {
    return e.intersectsPlane(this)
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this)
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant)
  }
  applyMatrix4(e, a) {
    const o = a || _normalMatrix.getNormalMatrix(e),
      c = this.coplanarPoint(_vector1).applyMatrix4(e),
      d = this.normal.applyMatrix3(o).normalize()
    return (this.constant = -c.dot(d)), this
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const _sphere$4 = new Sphere(),
  _vector$6 = new Vector3()
class Frustum {
  constructor(
    e = new Plane(),
    a = new Plane(),
    o = new Plane(),
    c = new Plane(),
    d = new Plane(),
    g = new Plane()
  ) {
    this.planes = [e, a, o, c, d, g]
  }
  set(e, a, o, c, d, g) {
    const _ = this.planes
    return (
      _[0].copy(e),
      _[1].copy(a),
      _[2].copy(o),
      _[3].copy(c),
      _[4].copy(d),
      _[5].copy(g),
      this
    )
  }
  copy(e) {
    const a = this.planes
    for (let o = 0; o < 6; o++) a[o].copy(e.planes[o])
    return this
  }
  setFromProjectionMatrix(e, a = WebGLCoordinateSystem) {
    const o = this.planes,
      c = e.elements,
      d = c[0],
      g = c[1],
      _ = c[2],
      b = c[3],
      j = c[4],
      $ = c[5],
      _e = c[6],
      tt = c[7],
      st = c[8],
      at = c[9],
      ot = c[10],
      ut = c[11],
      it = c[12],
      ct = c[13],
      lt = c[14],
      ht = c[15]
    if (
      (o[0].setComponents(b - d, tt - j, ut - st, ht - it).normalize(),
      o[1].setComponents(b + d, tt + j, ut + st, ht + it).normalize(),
      o[2].setComponents(b + g, tt + $, ut + at, ht + ct).normalize(),
      o[3].setComponents(b - g, tt - $, ut - at, ht - ct).normalize(),
      o[4].setComponents(b - _, tt - _e, ut - ot, ht - lt).normalize(),
      a === WebGLCoordinateSystem)
    )
      o[5].setComponents(b + _, tt + _e, ut + ot, ht + lt).normalize()
    else if (a === WebGPUCoordinateSystem)
      o[5].setComponents(_, _e, ot, lt).normalize()
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          a
      )
    return this
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        _sphere$4.copy(e.boundingSphere).applyMatrix4(e.matrixWorld)
    else {
      const a = e.geometry
      a.boundingSphere === null && a.computeBoundingSphere(),
        _sphere$4.copy(a.boundingSphere).applyMatrix4(e.matrixWorld)
    }
    return this.intersectsSphere(_sphere$4)
  }
  intersectsSprite(e) {
    return (
      _sphere$4.center.set(0, 0, 0),
      (_sphere$4.radius = 0.7071067811865476),
      _sphere$4.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(_sphere$4)
    )
  }
  intersectsSphere(e) {
    const a = this.planes,
      o = e.center,
      c = -e.radius
    for (let d = 0; d < 6; d++) if (a[d].distanceToPoint(o) < c) return !1
    return !0
  }
  intersectsBox(e) {
    const a = this.planes
    for (let o = 0; o < 6; o++) {
      const c = a[o]
      if (
        ((_vector$6.x = c.normal.x > 0 ? e.max.x : e.min.x),
        (_vector$6.y = c.normal.y > 0 ? e.max.y : e.min.y),
        (_vector$6.z = c.normal.z > 0 ? e.max.z : e.min.z),
        c.distanceToPoint(_vector$6) < 0)
      )
        return !1
    }
    return !0
  }
  containsPoint(e) {
    const a = this.planes
    for (let o = 0; o < 6; o++) if (a[o].distanceToPoint(e) < 0) return !1
    return !0
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
function WebGLAnimation() {
  let s = null,
    e = !1,
    a = null,
    o = null
  function c(d, g) {
    a(d, g), (o = s.requestAnimationFrame(c))
  }
  return {
    start: function () {
      e !== !0 && a !== null && ((o = s.requestAnimationFrame(c)), (e = !0))
    },
    stop: function () {
      s.cancelAnimationFrame(o), (e = !1)
    },
    setAnimationLoop: function (d) {
      a = d
    },
    setContext: function (d) {
      s = d
    },
  }
}
function WebGLAttributes(s, e) {
  const a = e.isWebGL2,
    o = new WeakMap()
  function c(j, $) {
    const _e = j.array,
      tt = j.usage,
      st = s.createBuffer()
    s.bindBuffer($, st), s.bufferData($, _e, tt), j.onUploadCallback()
    let at
    if (_e instanceof Float32Array) at = s.FLOAT
    else if (_e instanceof Uint16Array)
      if (j.isFloat16BufferAttribute)
        if (a) at = s.HALF_FLOAT
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          )
      else at = s.UNSIGNED_SHORT
    else if (_e instanceof Int16Array) at = s.SHORT
    else if (_e instanceof Uint32Array) at = s.UNSIGNED_INT
    else if (_e instanceof Int32Array) at = s.INT
    else if (_e instanceof Int8Array) at = s.BYTE
    else if (_e instanceof Uint8Array) at = s.UNSIGNED_BYTE
    else if (_e instanceof Uint8ClampedArray) at = s.UNSIGNED_BYTE
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + _e
      )
    return {
      buffer: st,
      type: at,
      bytesPerElement: _e.BYTES_PER_ELEMENT,
      version: j.version,
    }
  }
  function d(j, $, _e) {
    const tt = $.array,
      st = $.updateRange
    s.bindBuffer(_e, j),
      st.count === -1
        ? s.bufferSubData(_e, 0, tt)
        : (a
            ? s.bufferSubData(
                _e,
                st.offset * tt.BYTES_PER_ELEMENT,
                tt,
                st.offset,
                st.count
              )
            : s.bufferSubData(
                _e,
                st.offset * tt.BYTES_PER_ELEMENT,
                tt.subarray(st.offset, st.offset + st.count)
              ),
          (st.count = -1)),
      $.onUploadCallback()
  }
  function g(j) {
    return j.isInterleavedBufferAttribute && (j = j.data), o.get(j)
  }
  function _(j) {
    j.isInterleavedBufferAttribute && (j = j.data)
    const $ = o.get(j)
    $ && (s.deleteBuffer($.buffer), o.delete(j))
  }
  function b(j, $) {
    if (j.isGLBufferAttribute) {
      const tt = o.get(j)
      ;(!tt || tt.version < j.version) &&
        o.set(j, {
          buffer: j.buffer,
          type: j.type,
          bytesPerElement: j.elementSize,
          version: j.version,
        })
      return
    }
    j.isInterleavedBufferAttribute && (j = j.data)
    const _e = o.get(j)
    _e === void 0
      ? o.set(j, c(j, $))
      : _e.version < j.version && (d(_e.buffer, j, $), (_e.version = j.version))
  }
  return { get: g, remove: _, update: b }
}
class PlaneGeometry extends BufferGeometry {
  constructor(e = 1, a = 1, o = 1, c = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: a,
        widthSegments: o,
        heightSegments: c,
      })
    const d = e / 2,
      g = a / 2,
      _ = Math.floor(o),
      b = Math.floor(c),
      j = _ + 1,
      $ = b + 1,
      _e = e / _,
      tt = a / b,
      st = [],
      at = [],
      ot = [],
      ut = []
    for (let it = 0; it < $; it++) {
      const ct = it * tt - g
      for (let lt = 0; lt < j; lt++) {
        const ht = lt * _e - d
        at.push(ht, -ct, 0),
          ot.push(0, 0, 1),
          ut.push(lt / _),
          ut.push(1 - it / b)
      }
    }
    for (let it = 0; it < b; it++)
      for (let ct = 0; ct < _; ct++) {
        const lt = ct + j * it,
          ht = ct + j * (it + 1),
          dt = ct + 1 + j * (it + 1),
          pt = ct + 1 + j * it
        st.push(lt, ht, pt), st.push(ht, dt, pt)
      }
    this.setIndex(st),
      this.setAttribute("position", new Float32BufferAttribute(at, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(ot, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ut, 2))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new PlaneGeometry(
      e.width,
      e.height,
      e.widthSegments,
      e.heightSegments
    )
  }
}
var alphahash_fragment = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  alphahash_pars_fragment = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  alphamap_fragment = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  alphamap_pars_fragment = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  alphatest_fragment = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  alphatest_pars_fragment = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  aomap_fragment = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  aomap_pars_fragment = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  begin_vertex = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  beginnormal_vertex = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  bsdfs = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  iridescence_fragment = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  bumpmap_pars_fragment = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  clipping_planes_fragment = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  clipping_planes_pars_fragment = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  clipping_planes_pars_vertex = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  clipping_planes_vertex = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  color_fragment = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  color_pars_fragment = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  color_pars_vertex = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  color_vertex = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  common = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  cube_uv_reflection_fragment = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  defaultnormal_vertex = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  displacementmap_pars_vertex = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  displacementmap_vertex = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  emissivemap_fragment = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  emissivemap_pars_fragment = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  colorspace_pars_fragment = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  envmap_fragment = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  envmap_common_pars_fragment = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  envmap_pars_fragment = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  envmap_pars_vertex = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  envmap_vertex = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  fog_vertex = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  fog_pars_vertex = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  fog_fragment = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  fog_pars_fragment = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  gradientmap_pars_fragment = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  lightmap_fragment = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  lightmap_pars_fragment = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  lights_lambert_fragment = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  lights_lambert_pars_fragment = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  lights_pars_begin = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  envmap_physical_pars_fragment = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  lights_toon_fragment = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  lights_toon_pars_fragment = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  lights_phong_fragment = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  lights_phong_pars_fragment = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  lights_physical_fragment = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,
  lights_physical_pars_fragment = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  lights_fragment_begin = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  lights_fragment_maps = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  lights_fragment_end = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  logdepthbuf_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  logdepthbuf_pars_fragment = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  logdepthbuf_pars_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  logdepthbuf_vertex = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  map_fragment = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  map_pars_fragment = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  map_particle_fragment = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  map_particle_pars_fragment = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  metalnessmap_fragment = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  metalnessmap_pars_fragment = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  morphcolor_vertex = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  morphnormal_vertex = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  morphtarget_pars_vertex = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  morphtarget_vertex = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  normal_fragment_begin = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  normal_fragment_maps = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  normal_pars_fragment = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  normal_pars_vertex = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  normal_vertex = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  normalmap_pars_fragment = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  clearcoat_normal_fragment_begin = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  clearcoat_normal_fragment_maps = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  clearcoat_pars_fragment = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  iridescence_pars_fragment = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  opaque_fragment$1 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  packing = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  premultiplied_alpha_fragment = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  project_vertex = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  dithering_fragment = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  dithering_pars_fragment = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  roughnessmap_fragment = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  roughnessmap_pars_fragment = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  shadowmap_pars_fragment = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  shadowmap_pars_vertex = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  shadowmap_vertex = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  shadowmask_pars_fragment = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  skinbase_vertex = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  skinning_pars_vertex = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  skinning_vertex = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  skinnormal_vertex = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  specularmap_fragment = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  specularmap_pars_fragment = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  tonemapping_fragment = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  tonemapping_pars_fragment = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  transmission_fragment = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  transmission_pars_fragment = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  uv_pars_fragment = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uv_pars_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uv_vertex = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  worldpos_vertex = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`
const vertex$h = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  fragment$h = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$g = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fragment$g = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$f = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fragment$f = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$e = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  fragment$e = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  vertex$d = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  fragment$d = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  vertex$c = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  fragment$c = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  vertex$b = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  fragment$b = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vertex$a = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  fragment$a = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$9 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$9 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$8 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  fragment$8 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  fragment$7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  vertex$6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$5 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  fragment$5 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$4 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$4 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vertex$3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  fragment$3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  vertex$2 = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  fragment$2 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  vertex$1 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  fragment$1 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  ShaderChunk = {
    alphahash_fragment,
    alphahash_pars_fragment,
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    alphatest_pars_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    iridescence_fragment,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    colorspace_fragment,
    colorspace_pars_fragment,
    envmap_fragment,
    envmap_common_pars_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_fragment,
    lights_lambert_pars_fragment,
    lights_pars_begin,
    lights_toon_fragment,
    lights_toon_pars_fragment,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphcolor_vertex,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normal_pars_fragment,
    normal_pars_vertex,
    normal_vertex,
    normalmap_pars_fragment,
    clearcoat_normal_fragment_begin,
    clearcoat_normal_fragment_maps,
    clearcoat_pars_fragment,
    iridescence_pars_fragment,
    opaque_fragment: opaque_fragment$1,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    transmission_fragment,
    transmission_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    worldpos_vertex,
    background_vert: vertex$h,
    background_frag: fragment$h,
    backgroundCube_vert: vertex$g,
    backgroundCube_frag: fragment$g,
    cube_vert: vertex$f,
    cube_frag: fragment$f,
    depth_vert: vertex$e,
    depth_frag: fragment$e,
    distanceRGBA_vert: vertex$d,
    distanceRGBA_frag: fragment$d,
    equirect_vert: vertex$c,
    equirect_frag: fragment$c,
    linedashed_vert: vertex$b,
    linedashed_frag: fragment$b,
    meshbasic_vert: vertex$a,
    meshbasic_frag: fragment$a,
    meshlambert_vert: vertex$9,
    meshlambert_frag: fragment$9,
    meshmatcap_vert: vertex$8,
    meshmatcap_frag: fragment$8,
    meshnormal_vert: vertex$7,
    meshnormal_frag: fragment$7,
    meshphong_vert: vertex$6,
    meshphong_frag: fragment$6,
    meshphysical_vert: vertex$5,
    meshphysical_frag: fragment$5,
    meshtoon_vert: vertex$4,
    meshtoon_frag: fragment$4,
    points_vert: vertex$3,
    points_frag: fragment$3,
    shadow_vert: vertex$2,
    shadow_frag: fragment$2,
    sprite_vert: vertex$1,
    sprite_frag: fragment$1,
  },
  UniformsLib = {
    common: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Matrix3() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Matrix3() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Matrix3() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Matrix3() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Matrix3() },
      normalScale: { value: new Vector2(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Matrix3() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Matrix3() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Matrix3() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Matrix3() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Color(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() },
    },
    sprite: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      center: { value: new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
    },
  },
  ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog,
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag,
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        { emissive: { value: new Color(0) } },
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag,
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          specular: { value: new Color(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag,
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag,
    },
    toon: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        { emissive: { value: new Color(0) } },
      ]),
      vertexShader: ShaderChunk.meshtoon_vert,
      fragmentShader: ShaderChunk.meshtoon_frag,
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag,
    },
    points: {
      uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag,
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag,
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag,
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: ShaderChunk.meshnormal_vert,
      fragmentShader: ShaderChunk.meshnormal_frag,
    },
    sprite: {
      uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Matrix3() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: ShaderChunk.backgroundCube_vert,
      fragmentShader: ShaderChunk.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag,
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag,
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        { color: { value: new Color(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag,
    },
  }
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Matrix3() },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Matrix3() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Matrix3() },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Matrix3() },
      anisotropyVector: { value: new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Matrix3() },
    },
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag,
}
const _rgb = { r: 0, b: 0, g: 0 }
function WebGLBackground(s, e, a, o, c, d, g) {
  const _ = new Color(0)
  let b = d === !0 ? 0 : 1,
    j,
    $,
    _e = null,
    tt = 0,
    st = null
  function at(ut, it) {
    let ct = !1,
      lt = it.isScene === !0 ? it.background : null
    lt && lt.isTexture && (lt = (it.backgroundBlurriness > 0 ? a : e).get(lt)),
      lt === null ? ot(_, b) : lt && lt.isColor && (ot(lt, 1), (ct = !0))
    const ht = s.xr.getEnvironmentBlendMode()
    ht === "additive"
      ? o.buffers.color.setClear(0, 0, 0, 1, g)
      : ht === "alpha-blend" && o.buffers.color.setClear(0, 0, 0, 0, g),
      (s.autoClear || ct) &&
        s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil),
      lt && (lt.isCubeTexture || lt.mapping === CubeUVReflectionMapping)
        ? ($ === void 0 &&
            (($ = new Mesh(
              new BoxGeometry(1, 1, 1),
              new ShaderMaterial({
                name: "BackgroundCubeMaterial",
                uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
                vertexShader: ShaderLib.backgroundCube.vertexShader,
                fragmentShader: ShaderLib.backgroundCube.fragmentShader,
                side: BackSide,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            $.geometry.deleteAttribute("normal"),
            $.geometry.deleteAttribute("uv"),
            ($.onBeforeRender = function (dt, pt, vt) {
              this.matrixWorld.copyPosition(vt.matrixWorld)
            }),
            Object.defineProperty($.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value
              },
            }),
            c.update($)),
          ($.material.uniforms.envMap.value = lt),
          ($.material.uniforms.flipEnvMap.value =
            lt.isCubeTexture && lt.isRenderTargetTexture === !1 ? -1 : 1),
          ($.material.uniforms.backgroundBlurriness.value =
            it.backgroundBlurriness),
          ($.material.uniforms.backgroundIntensity.value =
            it.backgroundIntensity),
          ($.material.toneMapped = lt.colorSpace !== SRGBColorSpace),
          (_e !== lt || tt !== lt.version || st !== s.toneMapping) &&
            (($.material.needsUpdate = !0),
            (_e = lt),
            (tt = lt.version),
            (st = s.toneMapping)),
          $.layers.enableAll(),
          ut.unshift($, $.geometry, $.material, 0, 0, null))
        : lt &&
          lt.isTexture &&
          (j === void 0 &&
            ((j = new Mesh(
              new PlaneGeometry(2, 2),
              new ShaderMaterial({
                name: "BackgroundMaterial",
                uniforms: cloneUniforms(ShaderLib.background.uniforms),
                vertexShader: ShaderLib.background.vertexShader,
                fragmentShader: ShaderLib.background.fragmentShader,
                side: FrontSide,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            j.geometry.deleteAttribute("normal"),
            Object.defineProperty(j.material, "map", {
              get: function () {
                return this.uniforms.t2D.value
              },
            }),
            c.update(j)),
          (j.material.uniforms.t2D.value = lt),
          (j.material.uniforms.backgroundIntensity.value =
            it.backgroundIntensity),
          (j.material.toneMapped = lt.colorSpace !== SRGBColorSpace),
          lt.matrixAutoUpdate === !0 && lt.updateMatrix(),
          j.material.uniforms.uvTransform.value.copy(lt.matrix),
          (_e !== lt || tt !== lt.version || st !== s.toneMapping) &&
            ((j.material.needsUpdate = !0),
            (_e = lt),
            (tt = lt.version),
            (st = s.toneMapping)),
          j.layers.enableAll(),
          ut.unshift(j, j.geometry, j.material, 0, 0, null))
  }
  function ot(ut, it) {
    ut.getRGB(_rgb, getUnlitUniformColorSpace(s)),
      o.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, it, g)
  }
  return {
    getClearColor: function () {
      return _
    },
    setClearColor: function (ut, it = 1) {
      _.set(ut), (b = it), ot(_, b)
    },
    getClearAlpha: function () {
      return b
    },
    setClearAlpha: function (ut) {
      ;(b = ut), ot(_, b)
    },
    render: at,
  }
}
function WebGLBindingStates(s, e, a, o) {
  const c = s.getParameter(s.MAX_VERTEX_ATTRIBS),
    d = o.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    g = o.isWebGL2 || d !== null,
    _ = {},
    b = ut(null)
  let j = b,
    $ = !1
  function _e(Nt, Dt, Mt, wt, gt) {
    let At = !1
    if (g) {
      const bt = ot(wt, Mt, Dt)
      j !== bt && ((j = bt), st(j.object)),
        (At = it(Nt, wt, Mt, gt)),
        At && ct(Nt, wt, Mt, gt)
    } else {
      const bt = Dt.wireframe === !0
      ;(j.geometry !== wt.id || j.program !== Mt.id || j.wireframe !== bt) &&
        ((j.geometry = wt.id),
        (j.program = Mt.id),
        (j.wireframe = bt),
        (At = !0))
    }
    gt !== null && a.update(gt, s.ELEMENT_ARRAY_BUFFER),
      (At || $) &&
        (($ = !1),
        _t(Nt, Dt, Mt, wt),
        gt !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, a.get(gt).buffer))
  }
  function tt() {
    return o.isWebGL2 ? s.createVertexArray() : d.createVertexArrayOES()
  }
  function st(Nt) {
    return o.isWebGL2 ? s.bindVertexArray(Nt) : d.bindVertexArrayOES(Nt)
  }
  function at(Nt) {
    return o.isWebGL2 ? s.deleteVertexArray(Nt) : d.deleteVertexArrayOES(Nt)
  }
  function ot(Nt, Dt, Mt) {
    const wt = Mt.wireframe === !0
    let gt = _[Nt.id]
    gt === void 0 && ((gt = {}), (_[Nt.id] = gt))
    let At = gt[Dt.id]
    At === void 0 && ((At = {}), (gt[Dt.id] = At))
    let bt = At[wt]
    return bt === void 0 && ((bt = ut(tt())), (At[wt] = bt)), bt
  }
  function ut(Nt) {
    const Dt = [],
      Mt = [],
      wt = []
    for (let gt = 0; gt < c; gt++) (Dt[gt] = 0), (Mt[gt] = 0), (wt[gt] = 0)
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Dt,
      enabledAttributes: Mt,
      attributeDivisors: wt,
      object: Nt,
      attributes: {},
      index: null,
    }
  }
  function it(Nt, Dt, Mt, wt) {
    const gt = j.attributes,
      At = Dt.attributes
    let bt = 0
    const Tt = Mt.getAttributes()
    for (const It in Tt)
      if (Tt[It].location >= 0) {
        const Xt = gt[It]
        let qt = At[It]
        if (
          (qt === void 0 &&
            (It === "instanceMatrix" &&
              Nt.instanceMatrix &&
              (qt = Nt.instanceMatrix),
            It === "instanceColor" &&
              Nt.instanceColor &&
              (qt = Nt.instanceColor)),
          Xt === void 0 || Xt.attribute !== qt || (qt && Xt.data !== qt.data))
        )
          return !0
        bt++
      }
    return j.attributesNum !== bt || j.index !== wt
  }
  function ct(Nt, Dt, Mt, wt) {
    const gt = {},
      At = Dt.attributes
    let bt = 0
    const Tt = Mt.getAttributes()
    for (const It in Tt)
      if (Tt[It].location >= 0) {
        let Xt = At[It]
        Xt === void 0 &&
          (It === "instanceMatrix" &&
            Nt.instanceMatrix &&
            (Xt = Nt.instanceMatrix),
          It === "instanceColor" && Nt.instanceColor && (Xt = Nt.instanceColor))
        const qt = {}
        ;(qt.attribute = Xt),
          Xt && Xt.data && (qt.data = Xt.data),
          (gt[It] = qt),
          bt++
      }
    ;(j.attributes = gt), (j.attributesNum = bt), (j.index = wt)
  }
  function lt() {
    const Nt = j.newAttributes
    for (let Dt = 0, Mt = Nt.length; Dt < Mt; Dt++) Nt[Dt] = 0
  }
  function ht(Nt) {
    dt(Nt, 0)
  }
  function dt(Nt, Dt) {
    const Mt = j.newAttributes,
      wt = j.enabledAttributes,
      gt = j.attributeDivisors
    ;(Mt[Nt] = 1),
      wt[Nt] === 0 && (s.enableVertexAttribArray(Nt), (wt[Nt] = 1)),
      gt[Nt] !== Dt &&
        ((o.isWebGL2 ? s : e.get("ANGLE_instanced_arrays"))[
          o.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](Nt, Dt),
        (gt[Nt] = Dt))
  }
  function pt() {
    const Nt = j.newAttributes,
      Dt = j.enabledAttributes
    for (let Mt = 0, wt = Dt.length; Mt < wt; Mt++)
      Dt[Mt] !== Nt[Mt] && (s.disableVertexAttribArray(Mt), (Dt[Mt] = 0))
  }
  function vt(Nt, Dt, Mt, wt, gt, At, bt) {
    bt === !0
      ? s.vertexAttribIPointer(Nt, Dt, Mt, gt, At)
      : s.vertexAttribPointer(Nt, Dt, Mt, wt, gt, At)
  }
  function _t(Nt, Dt, Mt, wt) {
    if (
      o.isWebGL2 === !1 &&
      (Nt.isInstancedMesh || wt.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return
    lt()
    const gt = wt.attributes,
      At = Mt.getAttributes(),
      bt = Dt.defaultAttributeValues
    for (const Tt in At) {
      const It = At[Tt]
      if (It.location >= 0) {
        let $t = gt[Tt]
        if (
          ($t === void 0 &&
            (Tt === "instanceMatrix" &&
              Nt.instanceMatrix &&
              ($t = Nt.instanceMatrix),
            Tt === "instanceColor" &&
              Nt.instanceColor &&
              ($t = Nt.instanceColor)),
          $t !== void 0)
        ) {
          const Xt = $t.normalized,
            qt = $t.itemSize,
            en = a.get($t)
          if (en === void 0) continue
          const yn = en.buffer,
            Tn = en.type,
            $n = en.bytesPerElement,
            Vn =
              o.isWebGL2 === !0 &&
              (Tn === s.INT || Tn === s.UNSIGNED_INT || $t.gpuType === IntType)
          if ($t.isInterleavedBufferAttribute) {
            const gn = $t.data,
              Ht = gn.stride,
              on = $t.offset
            if (gn.isInstancedInterleavedBuffer) {
              for (let Yt = 0; Yt < It.locationSize; Yt++)
                dt(It.location + Yt, gn.meshPerAttribute)
              Nt.isInstancedMesh !== !0 &&
                wt._maxInstanceCount === void 0 &&
                (wt._maxInstanceCount = gn.meshPerAttribute * gn.count)
            } else
              for (let Yt = 0; Yt < It.locationSize; Yt++) ht(It.location + Yt)
            s.bindBuffer(s.ARRAY_BUFFER, yn)
            for (let Yt = 0; Yt < It.locationSize; Yt++)
              vt(
                It.location + Yt,
                qt / It.locationSize,
                Tn,
                Xt,
                Ht * $n,
                (on + (qt / It.locationSize) * Yt) * $n,
                Vn
              )
          } else {
            if ($t.isInstancedBufferAttribute) {
              for (let gn = 0; gn < It.locationSize; gn++)
                dt(It.location + gn, $t.meshPerAttribute)
              Nt.isInstancedMesh !== !0 &&
                wt._maxInstanceCount === void 0 &&
                (wt._maxInstanceCount = $t.meshPerAttribute * $t.count)
            } else
              for (let gn = 0; gn < It.locationSize; gn++) ht(It.location + gn)
            s.bindBuffer(s.ARRAY_BUFFER, yn)
            for (let gn = 0; gn < It.locationSize; gn++)
              vt(
                It.location + gn,
                qt / It.locationSize,
                Tn,
                Xt,
                qt * $n,
                (qt / It.locationSize) * gn * $n,
                Vn
              )
          }
        } else if (bt !== void 0) {
          const Xt = bt[Tt]
          if (Xt !== void 0)
            switch (Xt.length) {
              case 2:
                s.vertexAttrib2fv(It.location, Xt)
                break
              case 3:
                s.vertexAttrib3fv(It.location, Xt)
                break
              case 4:
                s.vertexAttrib4fv(It.location, Xt)
                break
              default:
                s.vertexAttrib1fv(It.location, Xt)
            }
        }
      }
    }
    pt()
  }
  function yt() {
    Ft()
    for (const Nt in _) {
      const Dt = _[Nt]
      for (const Mt in Dt) {
        const wt = Dt[Mt]
        for (const gt in wt) at(wt[gt].object), delete wt[gt]
        delete Dt[Mt]
      }
      delete _[Nt]
    }
  }
  function Et(Nt) {
    if (_[Nt.id] === void 0) return
    const Dt = _[Nt.id]
    for (const Mt in Dt) {
      const wt = Dt[Mt]
      for (const gt in wt) at(wt[gt].object), delete wt[gt]
      delete Dt[Mt]
    }
    delete _[Nt.id]
  }
  function Rt(Nt) {
    for (const Dt in _) {
      const Mt = _[Dt]
      if (Mt[Nt.id] === void 0) continue
      const wt = Mt[Nt.id]
      for (const gt in wt) at(wt[gt].object), delete wt[gt]
      delete Mt[Nt.id]
    }
  }
  function Ft() {
    kt(), ($ = !0), j !== b && ((j = b), st(j.object))
  }
  function kt() {
    ;(b.geometry = null), (b.program = null), (b.wireframe = !1)
  }
  return {
    setup: _e,
    reset: Ft,
    resetDefaultState: kt,
    dispose: yt,
    releaseStatesOfGeometry: Et,
    releaseStatesOfProgram: Rt,
    initAttributes: lt,
    enableAttribute: ht,
    disableUnusedAttributes: pt,
  }
}
function WebGLBufferRenderer(s, e, a, o) {
  const c = o.isWebGL2
  let d
  function g(j) {
    d = j
  }
  function _(j, $) {
    s.drawArrays(d, j, $), a.update($, d, 1)
  }
  function b(j, $, _e) {
    if (_e === 0) return
    let tt, st
    if (c) (tt = s), (st = "drawArraysInstanced")
    else if (
      ((tt = e.get("ANGLE_instanced_arrays")),
      (st = "drawArraysInstancedANGLE"),
      tt === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      )
      return
    }
    tt[st](d, j, $, _e), a.update($, d, _e)
  }
  ;(this.setMode = g), (this.render = _), (this.renderInstances = b)
}
function WebGLCapabilities(s, e, a) {
  let o
  function c() {
    if (o !== void 0) return o
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const vt = e.get("EXT_texture_filter_anisotropic")
      o = s.getParameter(vt.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
    } else o = 0
    return o
  }
  function d(vt) {
    if (vt === "highp") {
      if (
        s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision >
          0 &&
        s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision >
          0
      )
        return "highp"
      vt = "mediump"
    }
    return vt === "mediump" &&
      s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision >
        0 &&
      s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp"
  }
  const g =
    typeof WebGL2RenderingContext < "u" &&
    s.constructor.name === "WebGL2RenderingContext"
  let _ = a.precision !== void 0 ? a.precision : "highp"
  const b = d(_)
  b !== _ &&
    (console.warn(
      "THREE.WebGLRenderer:",
      _,
      "not supported, using",
      b,
      "instead."
    ),
    (_ = b))
  const j = g || e.has("WEBGL_draw_buffers"),
    $ = a.logarithmicDepthBuffer === !0,
    _e = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS),
    tt = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    st = s.getParameter(s.MAX_TEXTURE_SIZE),
    at = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE),
    ot = s.getParameter(s.MAX_VERTEX_ATTRIBS),
    ut = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS),
    it = s.getParameter(s.MAX_VARYING_VECTORS),
    ct = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS),
    lt = tt > 0,
    ht = g || e.has("OES_texture_float"),
    dt = lt && ht,
    pt = g ? s.getParameter(s.MAX_SAMPLES) : 0
  return {
    isWebGL2: g,
    drawBuffers: j,
    getMaxAnisotropy: c,
    getMaxPrecision: d,
    precision: _,
    logarithmicDepthBuffer: $,
    maxTextures: _e,
    maxVertexTextures: tt,
    maxTextureSize: st,
    maxCubemapSize: at,
    maxAttributes: ot,
    maxVertexUniforms: ut,
    maxVaryings: it,
    maxFragmentUniforms: ct,
    vertexTextures: lt,
    floatFragmentTextures: ht,
    floatVertexTextures: dt,
    maxSamples: pt,
  }
}
function WebGLClipping(s) {
  const e = this
  let a = null,
    o = 0,
    c = !1,
    d = !1
  const g = new Plane(),
    _ = new Matrix3(),
    b = { value: null, needsUpdate: !1 }
  ;(this.uniform = b),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (_e, tt) {
      const st = _e.length !== 0 || tt || o !== 0 || c
      return (c = tt), (o = _e.length), st
    }),
    (this.beginShadows = function () {
      ;(d = !0), $(null)
    }),
    (this.endShadows = function () {
      d = !1
    }),
    (this.setGlobalState = function (_e, tt) {
      a = $(_e, tt, 0)
    }),
    (this.setState = function (_e, tt, st) {
      const at = _e.clippingPlanes,
        ot = _e.clipIntersection,
        ut = _e.clipShadows,
        it = s.get(_e)
      if (!c || at === null || at.length === 0 || (d && !ut)) d ? $(null) : j()
      else {
        const ct = d ? 0 : o,
          lt = ct * 4
        let ht = it.clippingState || null
        ;(b.value = ht), (ht = $(at, tt, lt, st))
        for (let dt = 0; dt !== lt; ++dt) ht[dt] = a[dt]
        ;(it.clippingState = ht),
          (this.numIntersection = ot ? this.numPlanes : 0),
          (this.numPlanes += ct)
      }
    })
  function j() {
    b.value !== a && ((b.value = a), (b.needsUpdate = o > 0)),
      (e.numPlanes = o),
      (e.numIntersection = 0)
  }
  function $(_e, tt, st, at) {
    const ot = _e !== null ? _e.length : 0
    let ut = null
    if (ot !== 0) {
      if (((ut = b.value), at !== !0 || ut === null)) {
        const it = st + ot * 4,
          ct = tt.matrixWorldInverse
        _.getNormalMatrix(ct),
          (ut === null || ut.length < it) && (ut = new Float32Array(it))
        for (let lt = 0, ht = st; lt !== ot; ++lt, ht += 4)
          g.copy(_e[lt]).applyMatrix4(ct, _),
            g.normal.toArray(ut, ht),
            (ut[ht + 3] = g.constant)
      }
      ;(b.value = ut), (b.needsUpdate = !0)
    }
    return (e.numPlanes = ot), (e.numIntersection = 0), ut
  }
}
function WebGLCubeMaps(s) {
  let e = new WeakMap()
  function a(g, _) {
    return (
      _ === EquirectangularReflectionMapping
        ? (g.mapping = CubeReflectionMapping)
        : _ === EquirectangularRefractionMapping &&
          (g.mapping = CubeRefractionMapping),
      g
    )
  }
  function o(g) {
    if (g && g.isTexture && g.isRenderTargetTexture === !1) {
      const _ = g.mapping
      if (
        _ === EquirectangularReflectionMapping ||
        _ === EquirectangularRefractionMapping
      )
        if (e.has(g)) {
          const b = e.get(g).texture
          return a(b, g.mapping)
        } else {
          const b = g.image
          if (b && b.height > 0) {
            const j = new WebGLCubeRenderTarget(b.height / 2)
            return (
              j.fromEquirectangularTexture(s, g),
              e.set(g, j),
              g.addEventListener("dispose", c),
              a(j.texture, g.mapping)
            )
          } else return null
        }
    }
    return g
  }
  function c(g) {
    const _ = g.target
    _.removeEventListener("dispose", c)
    const b = e.get(_)
    b !== void 0 && (e.delete(_), b.dispose())
  }
  function d() {
    e = new WeakMap()
  }
  return { get: o, dispose: d }
}
class OrthographicCamera extends Camera {
  constructor(e = -1, a = 1, o = 1, c = -1, d = 0.1, g = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = a),
      (this.top = o),
      (this.bottom = c),
      (this.near = d),
      (this.far = g),
      this.updateProjectionMatrix()
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    )
  }
  setViewOffset(e, a, o, c, d, g) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = a),
      (this.view.offsetX = o),
      (this.view.offsetY = c),
      (this.view.width = d),
      (this.view.height = g),
      this.updateProjectionMatrix()
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      a = (this.top - this.bottom) / (2 * this.zoom),
      o = (this.right + this.left) / 2,
      c = (this.top + this.bottom) / 2
    let d = o - e,
      g = o + e,
      _ = c + a,
      b = c - a
    if (this.view !== null && this.view.enabled) {
      const j = (this.right - this.left) / this.view.fullWidth / this.zoom,
        $ = (this.top - this.bottom) / this.view.fullHeight / this.zoom
      ;(d += j * this.view.offsetX),
        (g = d + j * this.view.width),
        (_ -= $ * this.view.offsetY),
        (b = _ - $ * this.view.height)
    }
    this.projectionMatrix.makeOrthographic(
      d,
      g,
      _,
      b,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(e) {
    const a = super.toJSON(e)
    return (
      (a.object.zoom = this.zoom),
      (a.object.left = this.left),
      (a.object.right = this.right),
      (a.object.top = this.top),
      (a.object.bottom = this.bottom),
      (a.object.near = this.near),
      (a.object.far = this.far),
      this.view !== null && (a.object.view = Object.assign({}, this.view)),
      a
    )
  }
}
const LOD_MIN = 4,
  EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  MAX_SAMPLES = 20,
  _flatCamera = new OrthographicCamera(),
  _clearColor = new Color()
let _oldTarget = null
const PHI = (1 + Math.sqrt(5)) / 2,
  INV_PHI = 1 / PHI,
  _axisDirections = [
    new Vector3(1, 1, 1),
    new Vector3(-1, 1, 1),
    new Vector3(1, 1, -1),
    new Vector3(-1, 1, -1),
    new Vector3(0, PHI, INV_PHI),
    new Vector3(0, PHI, -INV_PHI),
    new Vector3(INV_PHI, 0, PHI),
    new Vector3(-INV_PHI, 0, PHI),
    new Vector3(PHI, INV_PHI, 0),
    new Vector3(-PHI, INV_PHI, 0),
  ]
class PMREMGenerator {
  constructor(e) {
    ;(this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial)
  }
  fromScene(e, a = 0, o = 0.1, c = 100) {
    ;(_oldTarget = this._renderer.getRenderTarget()), this._setSize(256)
    const d = this._allocateTargets()
    return (
      (d.depthBuffer = !0),
      this._sceneToCubeUV(e, o, c, d),
      a > 0 && this._blur(d, 0, 0, a),
      this._applyPMREM(d),
      this._cleanup(d),
      d
    )
  }
  fromEquirectangular(e, a = null) {
    return this._fromTexture(e, a)
  }
  fromCubemap(e, a = null) {
    return this._fromTexture(e, a)
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = _getCubemapMaterial()),
      this._compileMaterial(this._cubemapMaterial))
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = _getEquirectMaterial()),
      this._compileMaterial(this._equirectMaterial))
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose()
  }
  _setSize(e) {
    ;(this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax))
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose()
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose()
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(_oldTarget),
      (e.scissorTest = !1),
      _setViewport(e, 0, 0, e.width, e.height)
  }
  _fromTexture(e, a) {
    e.mapping === CubeReflectionMapping || e.mapping === CubeRefractionMapping
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (_oldTarget = this._renderer.getRenderTarget())
    const o = a || this._allocateTargets()
    return this._textureToCubeUV(e, o), this._applyPMREM(o), this._cleanup(o), o
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      a = 4 * this._cubeSize,
      o = {
        magFilter: LinearFilter,
        minFilter: LinearFilter,
        generateMipmaps: !1,
        type: HalfFloatType,
        format: RGBAFormat,
        colorSpace: LinearSRGBColorSpace,
        depthBuffer: !1,
      },
      c = _createRenderTarget(e, a, o)
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== a
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = _createRenderTarget(e, a, o))
      const { _lodMax: d } = this
      ;({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = _createPlanes(d)),
        (this._blurMaterial = _getBlurShader(d, e, a))
    }
    return c
  }
  _compileMaterial(e) {
    const a = new Mesh(this._lodPlanes[0], e)
    this._renderer.compile(a, _flatCamera)
  }
  _sceneToCubeUV(e, a, o, c) {
    const _ = new PerspectiveCamera(90, 1, a, o),
      b = [1, -1, 1, 1, 1, 1],
      j = [1, 1, 1, -1, -1, -1],
      $ = this._renderer,
      _e = $.autoClear,
      tt = $.toneMapping
    $.getClearColor(_clearColor),
      ($.toneMapping = NoToneMapping),
      ($.autoClear = !1)
    const st = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: !1,
        depthTest: !1,
      }),
      at = new Mesh(new BoxGeometry(), st)
    let ot = !1
    const ut = e.background
    ut
      ? ut.isColor && (st.color.copy(ut), (e.background = null), (ot = !0))
      : (st.color.copy(_clearColor), (ot = !0))
    for (let it = 0; it < 6; it++) {
      const ct = it % 3
      ct === 0
        ? (_.up.set(0, b[it], 0), _.lookAt(j[it], 0, 0))
        : ct === 1
        ? (_.up.set(0, 0, b[it]), _.lookAt(0, j[it], 0))
        : (_.up.set(0, b[it], 0), _.lookAt(0, 0, j[it]))
      const lt = this._cubeSize
      _setViewport(c, ct * lt, it > 2 ? lt : 0, lt, lt),
        $.setRenderTarget(c),
        ot && $.render(at, _),
        $.render(e, _)
    }
    at.geometry.dispose(),
      at.material.dispose(),
      ($.toneMapping = tt),
      ($.autoClear = _e),
      (e.background = ut)
  }
  _textureToCubeUV(e, a) {
    const o = this._renderer,
      c =
        e.mapping === CubeReflectionMapping ||
        e.mapping === CubeRefractionMapping
    c
      ? (this._cubemapMaterial === null &&
          (this._cubemapMaterial = _getCubemapMaterial()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null &&
        (this._equirectMaterial = _getEquirectMaterial())
    const d = c ? this._cubemapMaterial : this._equirectMaterial,
      g = new Mesh(this._lodPlanes[0], d),
      _ = d.uniforms
    _.envMap.value = e
    const b = this._cubeSize
    _setViewport(a, 0, 0, 3 * b, 2 * b),
      o.setRenderTarget(a),
      o.render(g, _flatCamera)
  }
  _applyPMREM(e) {
    const a = this._renderer,
      o = a.autoClear
    a.autoClear = !1
    for (let c = 1; c < this._lodPlanes.length; c++) {
      const d = Math.sqrt(
          this._sigmas[c] * this._sigmas[c] -
            this._sigmas[c - 1] * this._sigmas[c - 1]
        ),
        g = _axisDirections[(c - 1) % _axisDirections.length]
      this._blur(e, c - 1, c, d, g)
    }
    a.autoClear = o
  }
  _blur(e, a, o, c, d) {
    const g = this._pingPongRenderTarget
    this._halfBlur(e, g, a, o, c, "latitudinal", d),
      this._halfBlur(g, e, o, o, c, "longitudinal", d)
  }
  _halfBlur(e, a, o, c, d, g, _) {
    const b = this._renderer,
      j = this._blurMaterial
    g !== "latitudinal" &&
      g !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      )
    const $ = 3,
      _e = new Mesh(this._lodPlanes[c], j),
      tt = j.uniforms,
      st = this._sizeLods[o] - 1,
      at = isFinite(d)
        ? Math.PI / (2 * st)
        : (2 * Math.PI) / (2 * MAX_SAMPLES - 1),
      ot = d / at,
      ut = isFinite(d) ? 1 + Math.floor($ * ot) : MAX_SAMPLES
    ut > MAX_SAMPLES &&
      console.warn(
        `sigmaRadians, ${d}, is too large and will clip, as it requested ${ut} samples when the maximum is set to ${MAX_SAMPLES}`
      )
    const it = []
    let ct = 0
    for (let vt = 0; vt < MAX_SAMPLES; ++vt) {
      const _t = vt / ot,
        yt = Math.exp((-_t * _t) / 2)
      it.push(yt), vt === 0 ? (ct += yt) : vt < ut && (ct += 2 * yt)
    }
    for (let vt = 0; vt < it.length; vt++) it[vt] = it[vt] / ct
    ;(tt.envMap.value = e.texture),
      (tt.samples.value = ut),
      (tt.weights.value = it),
      (tt.latitudinal.value = g === "latitudinal"),
      _ && (tt.poleAxis.value = _)
    const { _lodMax: lt } = this
    ;(tt.dTheta.value = at), (tt.mipInt.value = lt - o)
    const ht = this._sizeLods[c],
      dt = 3 * ht * (c > lt - LOD_MIN ? c - lt + LOD_MIN : 0),
      pt = 4 * (this._cubeSize - ht)
    _setViewport(a, dt, pt, 3 * ht, 2 * ht),
      b.setRenderTarget(a),
      b.render(_e, _flatCamera)
  }
}
function _createPlanes(s) {
  const e = [],
    a = [],
    o = []
  let c = s
  const d = s - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length
  for (let g = 0; g < d; g++) {
    const _ = Math.pow(2, c)
    a.push(_)
    let b = 1 / _
    g > s - LOD_MIN
      ? (b = EXTRA_LOD_SIGMA[g - s + LOD_MIN - 1])
      : g === 0 && (b = 0),
      o.push(b)
    const j = 1 / (_ - 2),
      $ = -j,
      _e = 1 + j,
      tt = [$, $, _e, $, _e, _e, $, $, _e, _e, $, _e],
      st = 6,
      at = 6,
      ot = 3,
      ut = 2,
      it = 1,
      ct = new Float32Array(ot * at * st),
      lt = new Float32Array(ut * at * st),
      ht = new Float32Array(it * at * st)
    for (let pt = 0; pt < st; pt++) {
      const vt = ((pt % 3) * 2) / 3 - 1,
        _t = pt > 2 ? 0 : -1,
        yt = [
          vt,
          _t,
          0,
          vt + 2 / 3,
          _t,
          0,
          vt + 2 / 3,
          _t + 1,
          0,
          vt,
          _t,
          0,
          vt + 2 / 3,
          _t + 1,
          0,
          vt,
          _t + 1,
          0,
        ]
      ct.set(yt, ot * at * pt), lt.set(tt, ut * at * pt)
      const Et = [pt, pt, pt, pt, pt, pt]
      ht.set(Et, it * at * pt)
    }
    const dt = new BufferGeometry()
    dt.setAttribute("position", new BufferAttribute(ct, ot)),
      dt.setAttribute("uv", new BufferAttribute(lt, ut)),
      dt.setAttribute("faceIndex", new BufferAttribute(ht, it)),
      e.push(dt),
      c > LOD_MIN && c--
  }
  return { lodPlanes: e, sizeLods: a, sigmas: o }
}
function _createRenderTarget(s, e, a) {
  const o = new WebGLRenderTarget(s, e, a)
  return (
    (o.texture.mapping = CubeUVReflectionMapping),
    (o.texture.name = "PMREM.cubeUv"),
    (o.scissorTest = !0),
    o
  )
}
function _setViewport(s, e, a, o, c) {
  s.viewport.set(e, a, o, c), s.scissor.set(e, a, o, c)
}
function _getBlurShader(s, e, a) {
  const o = new Float32Array(MAX_SAMPLES),
    c = new Vector3(0, 1, 0)
  return new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      n: MAX_SAMPLES,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / a,
      CUBEUV_MAX_MIP: `${s}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: o },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: c },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  })
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  })
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: !1,
    depthWrite: !1,
  })
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function WebGLCubeUVMaps(s) {
  let e = new WeakMap(),
    a = null
  function o(_) {
    if (_ && _.isTexture) {
      const b = _.mapping,
        j =
          b === EquirectangularReflectionMapping ||
          b === EquirectangularRefractionMapping,
        $ = b === CubeReflectionMapping || b === CubeRefractionMapping
      if (j || $)
        if (_.isRenderTargetTexture && _.needsPMREMUpdate === !0) {
          _.needsPMREMUpdate = !1
          let _e = e.get(_)
          return (
            a === null && (a = new PMREMGenerator(s)),
            (_e = j ? a.fromEquirectangular(_, _e) : a.fromCubemap(_, _e)),
            e.set(_, _e),
            _e.texture
          )
        } else {
          if (e.has(_)) return e.get(_).texture
          {
            const _e = _.image
            if ((j && _e && _e.height > 0) || ($ && _e && c(_e))) {
              a === null && (a = new PMREMGenerator(s))
              const tt = j ? a.fromEquirectangular(_) : a.fromCubemap(_)
              return e.set(_, tt), _.addEventListener("dispose", d), tt.texture
            } else return null
          }
        }
    }
    return _
  }
  function c(_) {
    let b = 0
    const j = 6
    for (let $ = 0; $ < j; $++) _[$] !== void 0 && b++
    return b === j
  }
  function d(_) {
    const b = _.target
    b.removeEventListener("dispose", d)
    const j = e.get(b)
    j !== void 0 && (e.delete(b), j.dispose())
  }
  function g() {
    ;(e = new WeakMap()), a !== null && (a.dispose(), (a = null))
  }
  return { get: o, dispose: g }
}
function WebGLExtensions(s) {
  const e = {}
  function a(o) {
    if (e[o] !== void 0) return e[o]
    let c
    switch (o) {
      case "WEBGL_depth_texture":
        c =
          s.getExtension("WEBGL_depth_texture") ||
          s.getExtension("MOZ_WEBGL_depth_texture") ||
          s.getExtension("WEBKIT_WEBGL_depth_texture")
        break
      case "EXT_texture_filter_anisotropic":
        c =
          s.getExtension("EXT_texture_filter_anisotropic") ||
          s.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          s.getExtension("WEBKIT_EXT_texture_filter_anisotropic")
        break
      case "WEBGL_compressed_texture_s3tc":
        c =
          s.getExtension("WEBGL_compressed_texture_s3tc") ||
          s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc")
        break
      case "WEBGL_compressed_texture_pvrtc":
        c =
          s.getExtension("WEBGL_compressed_texture_pvrtc") ||
          s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc")
        break
      default:
        c = s.getExtension(o)
    }
    return (e[o] = c), c
  }
  return {
    has: function (o) {
      return a(o) !== null
    },
    init: function (o) {
      o.isWebGL2
        ? a("EXT_color_buffer_float")
        : (a("WEBGL_depth_texture"),
          a("OES_texture_float"),
          a("OES_texture_half_float"),
          a("OES_texture_half_float_linear"),
          a("OES_standard_derivatives"),
          a("OES_element_index_uint"),
          a("OES_vertex_array_object"),
          a("ANGLE_instanced_arrays")),
        a("OES_texture_float_linear"),
        a("EXT_color_buffer_half_float"),
        a("WEBGL_multisampled_render_to_texture")
    },
    get: function (o) {
      const c = a(o)
      return (
        c === null &&
          console.warn(
            "THREE.WebGLRenderer: " + o + " extension not supported."
          ),
        c
      )
    },
  }
}
function WebGLGeometries(s, e, a, o) {
  const c = {},
    d = new WeakMap()
  function g(_e) {
    const tt = _e.target
    tt.index !== null && e.remove(tt.index)
    for (const at in tt.attributes) e.remove(tt.attributes[at])
    for (const at in tt.morphAttributes) {
      const ot = tt.morphAttributes[at]
      for (let ut = 0, it = ot.length; ut < it; ut++) e.remove(ot[ut])
    }
    tt.removeEventListener("dispose", g), delete c[tt.id]
    const st = d.get(tt)
    st && (e.remove(st), d.delete(tt)),
      o.releaseStatesOfGeometry(tt),
      tt.isInstancedBufferGeometry === !0 && delete tt._maxInstanceCount,
      a.memory.geometries--
  }
  function _(_e, tt) {
    return (
      c[tt.id] === !0 ||
        (tt.addEventListener("dispose", g),
        (c[tt.id] = !0),
        a.memory.geometries++),
      tt
    )
  }
  function b(_e) {
    const tt = _e.attributes
    for (const at in tt) e.update(tt[at], s.ARRAY_BUFFER)
    const st = _e.morphAttributes
    for (const at in st) {
      const ot = st[at]
      for (let ut = 0, it = ot.length; ut < it; ut++)
        e.update(ot[ut], s.ARRAY_BUFFER)
    }
  }
  function j(_e) {
    const tt = [],
      st = _e.index,
      at = _e.attributes.position
    let ot = 0
    if (st !== null) {
      const ct = st.array
      ot = st.version
      for (let lt = 0, ht = ct.length; lt < ht; lt += 3) {
        const dt = ct[lt + 0],
          pt = ct[lt + 1],
          vt = ct[lt + 2]
        tt.push(dt, pt, pt, vt, vt, dt)
      }
    } else if (at !== void 0) {
      const ct = at.array
      ot = at.version
      for (let lt = 0, ht = ct.length / 3 - 1; lt < ht; lt += 3) {
        const dt = lt + 0,
          pt = lt + 1,
          vt = lt + 2
        tt.push(dt, pt, pt, vt, vt, dt)
      }
    } else return
    const ut = new (
      arrayNeedsUint32(tt) ? Uint32BufferAttribute : Uint16BufferAttribute
    )(tt, 1)
    ut.version = ot
    const it = d.get(_e)
    it && e.remove(it), d.set(_e, ut)
  }
  function $(_e) {
    const tt = d.get(_e)
    if (tt) {
      const st = _e.index
      st !== null && tt.version < st.version && j(_e)
    } else j(_e)
    return d.get(_e)
  }
  return { get: _, update: b, getWireframeAttribute: $ }
}
function WebGLIndexedBufferRenderer(s, e, a, o) {
  const c = o.isWebGL2
  let d
  function g(tt) {
    d = tt
  }
  let _, b
  function j(tt) {
    ;(_ = tt.type), (b = tt.bytesPerElement)
  }
  function $(tt, st) {
    s.drawElements(d, st, _, tt * b), a.update(st, d, 1)
  }
  function _e(tt, st, at) {
    if (at === 0) return
    let ot, ut
    if (c) (ot = s), (ut = "drawElementsInstanced")
    else if (
      ((ot = e.get("ANGLE_instanced_arrays")),
      (ut = "drawElementsInstancedANGLE"),
      ot === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      )
      return
    }
    ot[ut](d, st, _, tt * b, at), a.update(st, d, at)
  }
  ;(this.setMode = g),
    (this.setIndex = j),
    (this.render = $),
    (this.renderInstances = _e)
}
function WebGLInfo(s) {
  const e = { geometries: 0, textures: 0 },
    a = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }
  function o(d, g, _) {
    switch ((a.calls++, g)) {
      case s.TRIANGLES:
        a.triangles += _ * (d / 3)
        break
      case s.LINES:
        a.lines += _ * (d / 2)
        break
      case s.LINE_STRIP:
        a.lines += _ * (d - 1)
        break
      case s.LINE_LOOP:
        a.lines += _ * d
        break
      case s.POINTS:
        a.points += _ * d
        break
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", g)
        break
    }
  }
  function c() {
    ;(a.calls = 0), (a.triangles = 0), (a.points = 0), (a.lines = 0)
  }
  return {
    memory: e,
    render: a,
    programs: null,
    autoReset: !0,
    reset: c,
    update: o,
  }
}
function numericalSort(s, e) {
  return s[0] - e[0]
}
function absNumericalSort(s, e) {
  return Math.abs(e[1]) - Math.abs(s[1])
}
function WebGLMorphtargets(s, e, a) {
  const o = {},
    c = new Float32Array(8),
    d = new WeakMap(),
    g = new Vector4(),
    _ = []
  for (let j = 0; j < 8; j++) _[j] = [j, 0]
  function b(j, $, _e) {
    const tt = j.morphTargetInfluences
    if (e.isWebGL2 === !0) {
      const at =
          $.morphAttributes.position ||
          $.morphAttributes.normal ||
          $.morphAttributes.color,
        ot = at !== void 0 ? at.length : 0
      let ut = d.get($)
      if (ut === void 0 || ut.count !== ot) {
        let Dt = function () {
          kt.dispose(), d.delete($), $.removeEventListener("dispose", Dt)
        }
        var st = Dt
        ut !== void 0 && ut.texture.dispose()
        const lt = $.morphAttributes.position !== void 0,
          ht = $.morphAttributes.normal !== void 0,
          dt = $.morphAttributes.color !== void 0,
          pt = $.morphAttributes.position || [],
          vt = $.morphAttributes.normal || [],
          _t = $.morphAttributes.color || []
        let yt = 0
        lt === !0 && (yt = 1), ht === !0 && (yt = 2), dt === !0 && (yt = 3)
        let Et = $.attributes.position.count * yt,
          Rt = 1
        Et > e.maxTextureSize &&
          ((Rt = Math.ceil(Et / e.maxTextureSize)), (Et = e.maxTextureSize))
        const Ft = new Float32Array(Et * Rt * 4 * ot),
          kt = new DataArrayTexture(Ft, Et, Rt, ot)
        ;(kt.type = FloatType), (kt.needsUpdate = !0)
        const Nt = yt * 4
        for (let Mt = 0; Mt < ot; Mt++) {
          const wt = pt[Mt],
            gt = vt[Mt],
            At = _t[Mt],
            bt = Et * Rt * 4 * Mt
          for (let Tt = 0; Tt < wt.count; Tt++) {
            const It = Tt * Nt
            lt === !0 &&
              (g.fromBufferAttribute(wt, Tt),
              (Ft[bt + It + 0] = g.x),
              (Ft[bt + It + 1] = g.y),
              (Ft[bt + It + 2] = g.z),
              (Ft[bt + It + 3] = 0)),
              ht === !0 &&
                (g.fromBufferAttribute(gt, Tt),
                (Ft[bt + It + 4] = g.x),
                (Ft[bt + It + 5] = g.y),
                (Ft[bt + It + 6] = g.z),
                (Ft[bt + It + 7] = 0)),
              dt === !0 &&
                (g.fromBufferAttribute(At, Tt),
                (Ft[bt + It + 8] = g.x),
                (Ft[bt + It + 9] = g.y),
                (Ft[bt + It + 10] = g.z),
                (Ft[bt + It + 11] = At.itemSize === 4 ? g.w : 1))
          }
        }
        ;(ut = { count: ot, texture: kt, size: new Vector2(Et, Rt) }),
          d.set($, ut),
          $.addEventListener("dispose", Dt)
      }
      let it = 0
      for (let lt = 0; lt < tt.length; lt++) it += tt[lt]
      const ct = $.morphTargetsRelative ? 1 : 1 - it
      _e.getUniforms().setValue(s, "morphTargetBaseInfluence", ct),
        _e.getUniforms().setValue(s, "morphTargetInfluences", tt),
        _e.getUniforms().setValue(s, "morphTargetsTexture", ut.texture, a),
        _e.getUniforms().setValue(s, "morphTargetsTextureSize", ut.size)
    } else {
      const at = tt === void 0 ? 0 : tt.length
      let ot = o[$.id]
      if (ot === void 0 || ot.length !== at) {
        ot = []
        for (let ht = 0; ht < at; ht++) ot[ht] = [ht, 0]
        o[$.id] = ot
      }
      for (let ht = 0; ht < at; ht++) {
        const dt = ot[ht]
        ;(dt[0] = ht), (dt[1] = tt[ht])
      }
      ot.sort(absNumericalSort)
      for (let ht = 0; ht < 8; ht++)
        ht < at && ot[ht][1]
          ? ((_[ht][0] = ot[ht][0]), (_[ht][1] = ot[ht][1]))
          : ((_[ht][0] = Number.MAX_SAFE_INTEGER), (_[ht][1] = 0))
      _.sort(numericalSort)
      const ut = $.morphAttributes.position,
        it = $.morphAttributes.normal
      let ct = 0
      for (let ht = 0; ht < 8; ht++) {
        const dt = _[ht],
          pt = dt[0],
          vt = dt[1]
        pt !== Number.MAX_SAFE_INTEGER && vt
          ? (ut &&
              $.getAttribute("morphTarget" + ht) !== ut[pt] &&
              $.setAttribute("morphTarget" + ht, ut[pt]),
            it &&
              $.getAttribute("morphNormal" + ht) !== it[pt] &&
              $.setAttribute("morphNormal" + ht, it[pt]),
            (c[ht] = vt),
            (ct += vt))
          : (ut &&
              $.hasAttribute("morphTarget" + ht) === !0 &&
              $.deleteAttribute("morphTarget" + ht),
            it &&
              $.hasAttribute("morphNormal" + ht) === !0 &&
              $.deleteAttribute("morphNormal" + ht),
            (c[ht] = 0))
      }
      const lt = $.morphTargetsRelative ? 1 : 1 - ct
      _e.getUniforms().setValue(s, "morphTargetBaseInfluence", lt),
        _e.getUniforms().setValue(s, "morphTargetInfluences", c)
    }
  }
  return { update: b }
}
function WebGLObjects(s, e, a, o) {
  let c = new WeakMap()
  function d(b) {
    const j = o.render.frame,
      $ = b.geometry,
      _e = e.get(b, $)
    if (
      (c.get(_e) !== j && (e.update(_e), c.set(_e, j)),
      b.isInstancedMesh &&
        (b.hasEventListener("dispose", _) === !1 &&
          b.addEventListener("dispose", _),
        c.get(b) !== j &&
          (a.update(b.instanceMatrix, s.ARRAY_BUFFER),
          b.instanceColor !== null && a.update(b.instanceColor, s.ARRAY_BUFFER),
          c.set(b, j))),
      b.isSkinnedMesh)
    ) {
      const tt = b.skeleton
      c.get(tt) !== j && (tt.update(), c.set(tt, j))
    }
    return _e
  }
  function g() {
    c = new WeakMap()
  }
  function _(b) {
    const j = b.target
    j.removeEventListener("dispose", _),
      a.remove(j.instanceMatrix),
      j.instanceColor !== null && a.remove(j.instanceColor)
  }
  return { update: d, dispose: g }
}
const emptyTexture = new Texture(),
  emptyArrayTexture = new DataArrayTexture(),
  empty3dTexture = new Data3DTexture(),
  emptyCubeTexture = new CubeTexture(),
  arrayCacheF32 = [],
  arrayCacheI32 = [],
  mat4array = new Float32Array(16),
  mat3array = new Float32Array(9),
  mat2array = new Float32Array(4)
function flatten(s, e, a) {
  const o = s[0]
  if (o <= 0 || o > 0) return s
  const c = e * a
  let d = arrayCacheF32[c]
  if (
    (d === void 0 && ((d = new Float32Array(c)), (arrayCacheF32[c] = d)),
    e !== 0)
  ) {
    o.toArray(d, 0)
    for (let g = 1, _ = 0; g !== e; ++g) (_ += a), s[g].toArray(d, _)
  }
  return d
}
function arraysEqual(s, e) {
  if (s.length !== e.length) return !1
  for (let a = 0, o = s.length; a < o; a++) if (s[a] !== e[a]) return !1
  return !0
}
function copyArray(s, e) {
  for (let a = 0, o = e.length; a < o; a++) s[a] = e[a]
}
function allocTexUnits(s, e) {
  let a = arrayCacheI32[e]
  a === void 0 && ((a = new Int32Array(e)), (arrayCacheI32[e] = a))
  for (let o = 0; o !== e; ++o) a[o] = s.allocateTextureUnit()
  return a
}
function setValueV1f(s, e) {
  const a = this.cache
  a[0] !== e && (s.uniform1f(this.addr, e), (a[0] = e))
}
function setValueV2f(s, e) {
  const a = this.cache
  if (e.x !== void 0)
    (a[0] !== e.x || a[1] !== e.y) &&
      (s.uniform2f(this.addr, e.x, e.y), (a[0] = e.x), (a[1] = e.y))
  else {
    if (arraysEqual(a, e)) return
    s.uniform2fv(this.addr, e), copyArray(a, e)
  }
}
function setValueV3f(s, e) {
  const a = this.cache
  if (e.x !== void 0)
    (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z) &&
      (s.uniform3f(this.addr, e.x, e.y, e.z),
      (a[0] = e.x),
      (a[1] = e.y),
      (a[2] = e.z))
  else if (e.r !== void 0)
    (a[0] !== e.r || a[1] !== e.g || a[2] !== e.b) &&
      (s.uniform3f(this.addr, e.r, e.g, e.b),
      (a[0] = e.r),
      (a[1] = e.g),
      (a[2] = e.b))
  else {
    if (arraysEqual(a, e)) return
    s.uniform3fv(this.addr, e), copyArray(a, e)
  }
}
function setValueV4f(s, e) {
  const a = this.cache
  if (e.x !== void 0)
    (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z || a[3] !== e.w) &&
      (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (a[0] = e.x),
      (a[1] = e.y),
      (a[2] = e.z),
      (a[3] = e.w))
  else {
    if (arraysEqual(a, e)) return
    s.uniform4fv(this.addr, e), copyArray(a, e)
  }
}
function setValueM2(s, e) {
  const a = this.cache,
    o = e.elements
  if (o === void 0) {
    if (arraysEqual(a, e)) return
    s.uniformMatrix2fv(this.addr, !1, e), copyArray(a, e)
  } else {
    if (arraysEqual(a, o)) return
    mat2array.set(o),
      s.uniformMatrix2fv(this.addr, !1, mat2array),
      copyArray(a, o)
  }
}
function setValueM3(s, e) {
  const a = this.cache,
    o = e.elements
  if (o === void 0) {
    if (arraysEqual(a, e)) return
    s.uniformMatrix3fv(this.addr, !1, e), copyArray(a, e)
  } else {
    if (arraysEqual(a, o)) return
    mat3array.set(o),
      s.uniformMatrix3fv(this.addr, !1, mat3array),
      copyArray(a, o)
  }
}
function setValueM4(s, e) {
  const a = this.cache,
    o = e.elements
  if (o === void 0) {
    if (arraysEqual(a, e)) return
    s.uniformMatrix4fv(this.addr, !1, e), copyArray(a, e)
  } else {
    if (arraysEqual(a, o)) return
    mat4array.set(o),
      s.uniformMatrix4fv(this.addr, !1, mat4array),
      copyArray(a, o)
  }
}
function setValueV1i(s, e) {
  const a = this.cache
  a[0] !== e && (s.uniform1i(this.addr, e), (a[0] = e))
}
function setValueV2i(s, e) {
  const a = this.cache
  if (e.x !== void 0)
    (a[0] !== e.x || a[1] !== e.y) &&
      (s.uniform2i(this.addr, e.x, e.y), (a[0] = e.x), (a[1] = e.y))
  else {
    if (arraysEqual(a, e)) return
    s.uniform2iv(this.addr, e), copyArray(a, e)
  }
}
function setValueV3i(s, e) {
  const a = this.cache
  if (e.x !== void 0)
    (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z) &&
      (s.uniform3i(this.addr, e.x, e.y, e.z),
      (a[0] = e.x),
      (a[1] = e.y),
      (a[2] = e.z))
  else {
    if (arraysEqual(a, e)) return
    s.uniform3iv(this.addr, e), copyArray(a, e)
  }
}
function setValueV4i(s, e) {
  const a = this.cache
  if (e.x !== void 0)
    (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z || a[3] !== e.w) &&
      (s.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (a[0] = e.x),
      (a[1] = e.y),
      (a[2] = e.z),
      (a[3] = e.w))
  else {
    if (arraysEqual(a, e)) return
    s.uniform4iv(this.addr, e), copyArray(a, e)
  }
}
function setValueV1ui(s, e) {
  const a = this.cache
  a[0] !== e && (s.uniform1ui(this.addr, e), (a[0] = e))
}
function setValueV2ui(s, e) {
  const a = this.cache
  if (e.x !== void 0)
    (a[0] !== e.x || a[1] !== e.y) &&
      (s.uniform2ui(this.addr, e.x, e.y), (a[0] = e.x), (a[1] = e.y))
  else {
    if (arraysEqual(a, e)) return
    s.uniform2uiv(this.addr, e), copyArray(a, e)
  }
}
function setValueV3ui(s, e) {
  const a = this.cache
  if (e.x !== void 0)
    (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z) &&
      (s.uniform3ui(this.addr, e.x, e.y, e.z),
      (a[0] = e.x),
      (a[1] = e.y),
      (a[2] = e.z))
  else {
    if (arraysEqual(a, e)) return
    s.uniform3uiv(this.addr, e), copyArray(a, e)
  }
}
function setValueV4ui(s, e) {
  const a = this.cache
  if (e.x !== void 0)
    (a[0] !== e.x || a[1] !== e.y || a[2] !== e.z || a[3] !== e.w) &&
      (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (a[0] = e.x),
      (a[1] = e.y),
      (a[2] = e.z),
      (a[3] = e.w))
  else {
    if (arraysEqual(a, e)) return
    s.uniform4uiv(this.addr, e), copyArray(a, e)
  }
}
function setValueT1(s, e, a) {
  const o = this.cache,
    c = a.allocateTextureUnit()
  o[0] !== c && (s.uniform1i(this.addr, c), (o[0] = c)),
    a.setTexture2D(e || emptyTexture, c)
}
function setValueT3D1(s, e, a) {
  const o = this.cache,
    c = a.allocateTextureUnit()
  o[0] !== c && (s.uniform1i(this.addr, c), (o[0] = c)),
    a.setTexture3D(e || empty3dTexture, c)
}
function setValueT6(s, e, a) {
  const o = this.cache,
    c = a.allocateTextureUnit()
  o[0] !== c && (s.uniform1i(this.addr, c), (o[0] = c)),
    a.setTextureCube(e || emptyCubeTexture, c)
}
function setValueT2DArray1(s, e, a) {
  const o = this.cache,
    c = a.allocateTextureUnit()
  o[0] !== c && (s.uniform1i(this.addr, c), (o[0] = c)),
    a.setTexture2DArray(e || emptyArrayTexture, c)
}
function getSingularSetter(s) {
  switch (s) {
    case 5126:
      return setValueV1f
    case 35664:
      return setValueV2f
    case 35665:
      return setValueV3f
    case 35666:
      return setValueV4f
    case 35674:
      return setValueM2
    case 35675:
      return setValueM3
    case 35676:
      return setValueM4
    case 5124:
    case 35670:
      return setValueV1i
    case 35667:
    case 35671:
      return setValueV2i
    case 35668:
    case 35672:
      return setValueV3i
    case 35669:
    case 35673:
      return setValueV4i
    case 5125:
      return setValueV1ui
    case 36294:
      return setValueV2ui
    case 36295:
      return setValueV3ui
    case 36296:
      return setValueV4ui
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1
  }
}
function setValueV1fArray(s, e) {
  s.uniform1fv(this.addr, e)
}
function setValueV2fArray(s, e) {
  const a = flatten(e, this.size, 2)
  s.uniform2fv(this.addr, a)
}
function setValueV3fArray(s, e) {
  const a = flatten(e, this.size, 3)
  s.uniform3fv(this.addr, a)
}
function setValueV4fArray(s, e) {
  const a = flatten(e, this.size, 4)
  s.uniform4fv(this.addr, a)
}
function setValueM2Array(s, e) {
  const a = flatten(e, this.size, 4)
  s.uniformMatrix2fv(this.addr, !1, a)
}
function setValueM3Array(s, e) {
  const a = flatten(e, this.size, 9)
  s.uniformMatrix3fv(this.addr, !1, a)
}
function setValueM4Array(s, e) {
  const a = flatten(e, this.size, 16)
  s.uniformMatrix4fv(this.addr, !1, a)
}
function setValueV1iArray(s, e) {
  s.uniform1iv(this.addr, e)
}
function setValueV2iArray(s, e) {
  s.uniform2iv(this.addr, e)
}
function setValueV3iArray(s, e) {
  s.uniform3iv(this.addr, e)
}
function setValueV4iArray(s, e) {
  s.uniform4iv(this.addr, e)
}
function setValueV1uiArray(s, e) {
  s.uniform1uiv(this.addr, e)
}
function setValueV2uiArray(s, e) {
  s.uniform2uiv(this.addr, e)
}
function setValueV3uiArray(s, e) {
  s.uniform3uiv(this.addr, e)
}
function setValueV4uiArray(s, e) {
  s.uniform4uiv(this.addr, e)
}
function setValueT1Array(s, e, a) {
  const o = this.cache,
    c = e.length,
    d = allocTexUnits(a, c)
  arraysEqual(o, d) || (s.uniform1iv(this.addr, d), copyArray(o, d))
  for (let g = 0; g !== c; ++g) a.setTexture2D(e[g] || emptyTexture, d[g])
}
function setValueT3DArray(s, e, a) {
  const o = this.cache,
    c = e.length,
    d = allocTexUnits(a, c)
  arraysEqual(o, d) || (s.uniform1iv(this.addr, d), copyArray(o, d))
  for (let g = 0; g !== c; ++g) a.setTexture3D(e[g] || empty3dTexture, d[g])
}
function setValueT6Array(s, e, a) {
  const o = this.cache,
    c = e.length,
    d = allocTexUnits(a, c)
  arraysEqual(o, d) || (s.uniform1iv(this.addr, d), copyArray(o, d))
  for (let g = 0; g !== c; ++g) a.setTextureCube(e[g] || emptyCubeTexture, d[g])
}
function setValueT2DArrayArray(s, e, a) {
  const o = this.cache,
    c = e.length,
    d = allocTexUnits(a, c)
  arraysEqual(o, d) || (s.uniform1iv(this.addr, d), copyArray(o, d))
  for (let g = 0; g !== c; ++g)
    a.setTexture2DArray(e[g] || emptyArrayTexture, d[g])
}
function getPureArraySetter(s) {
  switch (s) {
    case 5126:
      return setValueV1fArray
    case 35664:
      return setValueV2fArray
    case 35665:
      return setValueV3fArray
    case 35666:
      return setValueV4fArray
    case 35674:
      return setValueM2Array
    case 35675:
      return setValueM3Array
    case 35676:
      return setValueM4Array
    case 5124:
    case 35670:
      return setValueV1iArray
    case 35667:
    case 35671:
      return setValueV2iArray
    case 35668:
    case 35672:
      return setValueV3iArray
    case 35669:
    case 35673:
      return setValueV4iArray
    case 5125:
      return setValueV1uiArray
    case 36294:
      return setValueV2uiArray
    case 36295:
      return setValueV3uiArray
    case 36296:
      return setValueV4uiArray
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray
  }
}
class SingleUniform {
  constructor(e, a, o) {
    ;(this.id = e),
      (this.addr = o),
      (this.cache = []),
      (this.setValue = getSingularSetter(a.type))
  }
}
class PureArrayUniform {
  constructor(e, a, o) {
    ;(this.id = e),
      (this.addr = o),
      (this.cache = []),
      (this.size = a.size),
      (this.setValue = getPureArraySetter(a.type))
  }
}
class StructuredUniform {
  constructor(e) {
    ;(this.id = e), (this.seq = []), (this.map = {})
  }
  setValue(e, a, o) {
    const c = this.seq
    for (let d = 0, g = c.length; d !== g; ++d) {
      const _ = c[d]
      _.setValue(e, a[_.id], o)
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g
function addUniform(s, e) {
  s.seq.push(e), (s.map[e.id] = e)
}
function parseUniform(s, e, a) {
  const o = s.name,
    c = o.length
  for (RePathPart.lastIndex = 0; ; ) {
    const d = RePathPart.exec(o),
      g = RePathPart.lastIndex
    let _ = d[1]
    const b = d[2] === "]",
      j = d[3]
    if ((b && (_ = _ | 0), j === void 0 || (j === "[" && g + 2 === c))) {
      addUniform(
        a,
        j === void 0
          ? new SingleUniform(_, s, e)
          : new PureArrayUniform(_, s, e)
      )
      break
    } else {
      let _e = a.map[_]
      _e === void 0 && ((_e = new StructuredUniform(_)), addUniform(a, _e)),
        (a = _e)
    }
  }
}
class WebGLUniforms {
  constructor(e, a) {
    ;(this.seq = []), (this.map = {})
    const o = e.getProgramParameter(a, e.ACTIVE_UNIFORMS)
    for (let c = 0; c < o; ++c) {
      const d = e.getActiveUniform(a, c),
        g = e.getUniformLocation(a, d.name)
      parseUniform(d, g, this)
    }
  }
  setValue(e, a, o, c) {
    const d = this.map[a]
    d !== void 0 && d.setValue(e, o, c)
  }
  setOptional(e, a, o) {
    const c = a[o]
    c !== void 0 && this.setValue(e, o, c)
  }
  static upload(e, a, o, c) {
    for (let d = 0, g = a.length; d !== g; ++d) {
      const _ = a[d],
        b = o[_.id]
      b.needsUpdate !== !1 && _.setValue(e, b.value, c)
    }
  }
  static seqWithValue(e, a) {
    const o = []
    for (let c = 0, d = e.length; c !== d; ++c) {
      const g = e[c]
      g.id in a && o.push(g)
    }
    return o
  }
}
function WebGLShader(s, e, a) {
  const o = s.createShader(e)
  return s.shaderSource(o, a), s.compileShader(o), o
}
let programIdCount = 0
function handleSource(s, e) {
  const a = s.split(`
`),
    o = [],
    c = Math.max(e - 6, 0),
    d = Math.min(e + 6, a.length)
  for (let g = c; g < d; g++) {
    const _ = g + 1
    o.push(`${_ === e ? ">" : " "} ${_}: ${a[g]}`)
  }
  return o.join(`
`)
}
function getEncodingComponents(s) {
  switch (s) {
    case LinearSRGBColorSpace:
      return ["Linear", "( value )"]
    case SRGBColorSpace:
      return ["sRGB", "( value )"]
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", s),
        ["Linear", "( value )"]
      )
  }
}
function getShaderErrors(s, e, a) {
  const o = s.getShaderParameter(e, s.COMPILE_STATUS),
    c = s.getShaderInfoLog(e).trim()
  if (o && c === "") return ""
  const d = /ERROR: 0:(\d+)/.exec(c)
  if (d) {
    const g = parseInt(d[1])
    return (
      a.toUpperCase() +
      `

` +
      c +
      `

` +
      handleSource(s.getShaderSource(e), g)
    )
  } else return c
}
function getTexelEncodingFunction(s, e) {
  const a = getEncodingComponents(e)
  return "vec4 " + s + "( vec4 value ) { return LinearTo" + a[0] + a[1] + "; }"
}
function getToneMappingFunction(s, e) {
  let a
  switch (e) {
    case LinearToneMapping:
      a = "Linear"
      break
    case ReinhardToneMapping:
      a = "Reinhard"
      break
    case CineonToneMapping:
      a = "OptimizedCineon"
      break
    case ACESFilmicToneMapping:
      a = "ACESFilmic"
      break
    case CustomToneMapping:
      a = "Custom"
      break
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (a = "Linear")
  }
  return (
    "vec3 " + s + "( vec3 color ) { return " + a + "ToneMapping( color ); }"
  )
}
function generateExtensions(s) {
  return [
    s.extensionDerivatives ||
    s.envMapCubeUVHeight ||
    s.bumpMap ||
    s.normalMapTangentSpace ||
    s.clearcoatNormalMap ||
    s.flatShading ||
    s.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (s.extensionFragDepth || s.logarithmicDepthBuffer) &&
    s.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    s.extensionDrawBuffers && s.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (s.extensionShaderTextureLOD || s.envMap || s.transmission) &&
    s.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(filterEmptyLine).join(`
`)
}
function generateDefines(s) {
  const e = []
  for (const a in s) {
    const o = s[a]
    o !== !1 && e.push("#define " + a + " " + o)
  }
  return e.join(`
`)
}
function fetchAttributeLocations(s, e) {
  const a = {},
    o = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES)
  for (let c = 0; c < o; c++) {
    const d = s.getActiveAttrib(e, c),
      g = d.name
    let _ = 1
    d.type === s.FLOAT_MAT2 && (_ = 2),
      d.type === s.FLOAT_MAT3 && (_ = 3),
      d.type === s.FLOAT_MAT4 && (_ = 4),
      (a[g] = {
        type: d.type,
        location: s.getAttribLocation(e, g),
        locationSize: _,
      })
  }
  return a
}
function filterEmptyLine(s) {
  return s !== ""
}
function replaceLightNums(s, e) {
  const a =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps
  return s
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, a)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function replaceClippingPlaneNums(s, e) {
  return s
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    )
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm
function resolveIncludes(s) {
  return s.replace(includePattern, includeReplacer)
}
const shaderChunkMap = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
])
function includeReplacer(s, e) {
  let a = ShaderChunk[e]
  if (a === void 0) {
    const o = shaderChunkMap.get(e)
    if (o !== void 0)
      (a = ShaderChunk[o]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          o
        )
    else throw new Error("Can not resolve #include <" + e + ">")
  }
  return resolveIncludes(a)
}
const unrollLoopPattern =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
function unrollLoops(s) {
  return s.replace(unrollLoopPattern, loopReplacer)
}
function loopReplacer(s, e, a, o) {
  let c = ""
  for (let d = parseInt(e); d < parseInt(a); d++)
    c += o
      .replace(/\[\s*i\s*\]/g, "[ " + d + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, d)
  return c
}
function generatePrecision(s) {
  let e =
    "precision " +
    s.precision +
    ` float;
precision ` +
    s.precision +
    " int;"
  return (
    s.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : s.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : s.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  )
}
function generateShadowMapTypeDefine(s) {
  let e = "SHADOWMAP_TYPE_BASIC"
  return (
    s.shadowMapType === PCFShadowMap
      ? (e = "SHADOWMAP_TYPE_PCF")
      : s.shadowMapType === PCFSoftShadowMap
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : s.shadowMapType === VSMShadowMap && (e = "SHADOWMAP_TYPE_VSM"),
    e
  )
}
function generateEnvMapTypeDefine(s) {
  let e = "ENVMAP_TYPE_CUBE"
  if (s.envMap)
    switch (s.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        e = "ENVMAP_TYPE_CUBE"
        break
      case CubeUVReflectionMapping:
        e = "ENVMAP_TYPE_CUBE_UV"
        break
    }
  return e
}
function generateEnvMapModeDefine(s) {
  let e = "ENVMAP_MODE_REFLECTION"
  if (s.envMap)
    switch (s.envMapMode) {
      case CubeRefractionMapping:
        e = "ENVMAP_MODE_REFRACTION"
        break
    }
  return e
}
function generateEnvMapBlendingDefine(s) {
  let e = "ENVMAP_BLENDING_NONE"
  if (s.envMap)
    switch (s.combine) {
      case MultiplyOperation:
        e = "ENVMAP_BLENDING_MULTIPLY"
        break
      case MixOperation:
        e = "ENVMAP_BLENDING_MIX"
        break
      case AddOperation:
        e = "ENVMAP_BLENDING_ADD"
        break
    }
  return e
}
function generateCubeUVSize(s) {
  const e = s.envMapCubeUVHeight
  if (e === null) return null
  const a = Math.log2(e) - 2,
    o = 1 / e
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, a), 7 * 16)),
    texelHeight: o,
    maxMip: a,
  }
}
function WebGLProgram(s, e, a, o) {
  const c = s.getContext(),
    d = a.defines
  let g = a.vertexShader,
    _ = a.fragmentShader
  const b = generateShadowMapTypeDefine(a),
    j = generateEnvMapTypeDefine(a),
    $ = generateEnvMapModeDefine(a),
    _e = generateEnvMapBlendingDefine(a),
    tt = generateCubeUVSize(a),
    st = a.isWebGL2 ? "" : generateExtensions(a),
    at = generateDefines(d),
    ot = c.createProgram()
  let ut,
    it,
    ct = a.glslVersion
      ? "#version " +
        a.glslVersion +
        `
`
      : ""
  a.isRawShaderMaterial
    ? ((ut = [
        "#define SHADER_TYPE " + a.shaderType,
        "#define SHADER_NAME " + a.shaderName,
        at,
      ].filter(filterEmptyLine).join(`
`)),
      ut.length > 0 &&
        (ut += `
`),
      (it = [
        st,
        "#define SHADER_TYPE " + a.shaderType,
        "#define SHADER_NAME " + a.shaderName,
        at,
      ].filter(filterEmptyLine).join(`
`)),
      it.length > 0 &&
        (it += `
`))
    : ((ut = [
        generatePrecision(a),
        "#define SHADER_TYPE " + a.shaderType,
        "#define SHADER_NAME " + a.shaderName,
        at,
        a.instancing ? "#define USE_INSTANCING" : "",
        a.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        a.useFog && a.fog ? "#define USE_FOG" : "",
        a.useFog && a.fogExp2 ? "#define FOG_EXP2" : "",
        a.map ? "#define USE_MAP" : "",
        a.envMap ? "#define USE_ENVMAP" : "",
        a.envMap ? "#define " + $ : "",
        a.lightMap ? "#define USE_LIGHTMAP" : "",
        a.aoMap ? "#define USE_AOMAP" : "",
        a.bumpMap ? "#define USE_BUMPMAP" : "",
        a.normalMap ? "#define USE_NORMALMAP" : "",
        a.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        a.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        a.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        a.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        a.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        a.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        a.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        a.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        a.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        a.specularMap ? "#define USE_SPECULARMAP" : "",
        a.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        a.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        a.metalnessMap ? "#define USE_METALNESSMAP" : "",
        a.alphaMap ? "#define USE_ALPHAMAP" : "",
        a.alphaHash ? "#define USE_ALPHAHASH" : "",
        a.transmission ? "#define USE_TRANSMISSION" : "",
        a.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        a.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        a.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        a.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        a.mapUv ? "#define MAP_UV " + a.mapUv : "",
        a.alphaMapUv ? "#define ALPHAMAP_UV " + a.alphaMapUv : "",
        a.lightMapUv ? "#define LIGHTMAP_UV " + a.lightMapUv : "",
        a.aoMapUv ? "#define AOMAP_UV " + a.aoMapUv : "",
        a.emissiveMapUv ? "#define EMISSIVEMAP_UV " + a.emissiveMapUv : "",
        a.bumpMapUv ? "#define BUMPMAP_UV " + a.bumpMapUv : "",
        a.normalMapUv ? "#define NORMALMAP_UV " + a.normalMapUv : "",
        a.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + a.displacementMapUv
          : "",
        a.metalnessMapUv ? "#define METALNESSMAP_UV " + a.metalnessMapUv : "",
        a.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + a.roughnessMapUv : "",
        a.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + a.anisotropyMapUv
          : "",
        a.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + a.clearcoatMapUv : "",
        a.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + a.clearcoatNormalMapUv
          : "",
        a.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + a.clearcoatRoughnessMapUv
          : "",
        a.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + a.iridescenceMapUv
          : "",
        a.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + a.iridescenceThicknessMapUv
          : "",
        a.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + a.sheenColorMapUv
          : "",
        a.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + a.sheenRoughnessMapUv
          : "",
        a.specularMapUv ? "#define SPECULARMAP_UV " + a.specularMapUv : "",
        a.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + a.specularColorMapUv
          : "",
        a.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + a.specularIntensityMapUv
          : "",
        a.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + a.transmissionMapUv
          : "",
        a.thicknessMapUv ? "#define THICKNESSMAP_UV " + a.thicknessMapUv : "",
        a.vertexTangents && a.flatShading === !1 ? "#define USE_TANGENT" : "",
        a.vertexColors ? "#define USE_COLOR" : "",
        a.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        a.vertexUv1s ? "#define USE_UV1" : "",
        a.vertexUv2s ? "#define USE_UV2" : "",
        a.vertexUv3s ? "#define USE_UV3" : "",
        a.pointsUvs ? "#define USE_POINTS_UV" : "",
        a.flatShading ? "#define FLAT_SHADED" : "",
        a.skinning ? "#define USE_SKINNING" : "",
        a.morphTargets ? "#define USE_MORPHTARGETS" : "",
        a.morphNormals && a.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        a.morphColors && a.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        a.morphTargetsCount > 0 && a.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        a.morphTargetsCount > 0 && a.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + a.morphTextureStride
          : "",
        a.morphTargetsCount > 0 && a.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + a.morphTargetsCount
          : "",
        a.doubleSided ? "#define DOUBLE_SIDED" : "",
        a.flipSided ? "#define FLIP_SIDED" : "",
        a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        a.shadowMapEnabled ? "#define " + b : "",
        a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        a.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        a.logarithmicDepthBuffer && a.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(filterEmptyLine).join(`
`)),
      (it = [
        st,
        generatePrecision(a),
        "#define SHADER_TYPE " + a.shaderType,
        "#define SHADER_NAME " + a.shaderName,
        at,
        a.useFog && a.fog ? "#define USE_FOG" : "",
        a.useFog && a.fogExp2 ? "#define FOG_EXP2" : "",
        a.map ? "#define USE_MAP" : "",
        a.matcap ? "#define USE_MATCAP" : "",
        a.envMap ? "#define USE_ENVMAP" : "",
        a.envMap ? "#define " + j : "",
        a.envMap ? "#define " + $ : "",
        a.envMap ? "#define " + _e : "",
        tt ? "#define CUBEUV_TEXEL_WIDTH " + tt.texelWidth : "",
        tt ? "#define CUBEUV_TEXEL_HEIGHT " + tt.texelHeight : "",
        tt ? "#define CUBEUV_MAX_MIP " + tt.maxMip + ".0" : "",
        a.lightMap ? "#define USE_LIGHTMAP" : "",
        a.aoMap ? "#define USE_AOMAP" : "",
        a.bumpMap ? "#define USE_BUMPMAP" : "",
        a.normalMap ? "#define USE_NORMALMAP" : "",
        a.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        a.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        a.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        a.anisotropy ? "#define USE_ANISOTROPY" : "",
        a.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        a.clearcoat ? "#define USE_CLEARCOAT" : "",
        a.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        a.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        a.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        a.iridescence ? "#define USE_IRIDESCENCE" : "",
        a.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        a.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        a.specularMap ? "#define USE_SPECULARMAP" : "",
        a.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        a.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        a.metalnessMap ? "#define USE_METALNESSMAP" : "",
        a.alphaMap ? "#define USE_ALPHAMAP" : "",
        a.alphaTest ? "#define USE_ALPHATEST" : "",
        a.alphaHash ? "#define USE_ALPHAHASH" : "",
        a.sheen ? "#define USE_SHEEN" : "",
        a.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        a.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        a.transmission ? "#define USE_TRANSMISSION" : "",
        a.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        a.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        a.vertexTangents && a.flatShading === !1 ? "#define USE_TANGENT" : "",
        a.vertexColors || a.instancingColor ? "#define USE_COLOR" : "",
        a.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        a.vertexUv1s ? "#define USE_UV1" : "",
        a.vertexUv2s ? "#define USE_UV2" : "",
        a.vertexUv3s ? "#define USE_UV3" : "",
        a.pointsUvs ? "#define USE_POINTS_UV" : "",
        a.gradientMap ? "#define USE_GRADIENTMAP" : "",
        a.flatShading ? "#define FLAT_SHADED" : "",
        a.doubleSided ? "#define DOUBLE_SIDED" : "",
        a.flipSided ? "#define FLIP_SIDED" : "",
        a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        a.shadowMapEnabled ? "#define " + b : "",
        a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        a.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        a.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        a.logarithmicDepthBuffer && a.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        a.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        a.toneMapping !== NoToneMapping
          ? ShaderChunk.tonemapping_pars_fragment
          : "",
        a.toneMapping !== NoToneMapping
          ? getToneMappingFunction("toneMapping", a.toneMapping)
          : "",
        a.dithering ? "#define DITHERING" : "",
        a.opaque ? "#define OPAQUE" : "",
        ShaderChunk.colorspace_pars_fragment,
        getTexelEncodingFunction("linearToOutputTexel", a.outputColorSpace),
        a.useDepthPacking ? "#define DEPTH_PACKING " + a.depthPacking : "",
        `
`,
      ].filter(filterEmptyLine).join(`
`))),
    (g = resolveIncludes(g)),
    (g = replaceLightNums(g, a)),
    (g = replaceClippingPlaneNums(g, a)),
    (_ = resolveIncludes(_)),
    (_ = replaceLightNums(_, a)),
    (_ = replaceClippingPlaneNums(_, a)),
    (g = unrollLoops(g)),
    (_ = unrollLoops(_)),
    a.isWebGL2 &&
      a.isRawShaderMaterial !== !0 &&
      ((ct = `#version 300 es
`),
      (ut =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        ut),
      (it =
        [
          "#define varying in",
          a.glslVersion === GLSL3
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          a.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        it))
  const lt = ct + ut + g,
    ht = ct + it + _,
    dt = WebGLShader(c, c.VERTEX_SHADER, lt),
    pt = WebGLShader(c, c.FRAGMENT_SHADER, ht)
  if (
    (c.attachShader(ot, dt),
    c.attachShader(ot, pt),
    a.index0AttributeName !== void 0
      ? c.bindAttribLocation(ot, 0, a.index0AttributeName)
      : a.morphTargets === !0 && c.bindAttribLocation(ot, 0, "position"),
    c.linkProgram(ot),
    s.debug.checkShaderErrors)
  ) {
    const yt = c.getProgramInfoLog(ot).trim(),
      Et = c.getShaderInfoLog(dt).trim(),
      Rt = c.getShaderInfoLog(pt).trim()
    let Ft = !0,
      kt = !0
    if (c.getProgramParameter(ot, c.LINK_STATUS) === !1)
      if (((Ft = !1), typeof s.debug.onShaderError == "function"))
        s.debug.onShaderError(c, ot, dt, pt)
      else {
        const Nt = getShaderErrors(c, dt, "vertex"),
          Dt = getShaderErrors(c, pt, "fragment")
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            c.getError() +
            " - VALIDATE_STATUS " +
            c.getProgramParameter(ot, c.VALIDATE_STATUS) +
            `

Program Info Log: ` +
            yt +
            `
` +
            Nt +
            `
` +
            Dt
        )
      }
    else
      yt !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", yt)
        : (Et === "" || Rt === "") && (kt = !1)
    kt &&
      (this.diagnostics = {
        runnable: Ft,
        programLog: yt,
        vertexShader: { log: Et, prefix: ut },
        fragmentShader: { log: Rt, prefix: it },
      })
  }
  c.deleteShader(dt), c.deleteShader(pt)
  let vt
  this.getUniforms = function () {
    return vt === void 0 && (vt = new WebGLUniforms(c, ot)), vt
  }
  let _t
  return (
    (this.getAttributes = function () {
      return _t === void 0 && (_t = fetchAttributeLocations(c, ot)), _t
    }),
    (this.destroy = function () {
      o.releaseStatesOfProgram(this),
        c.deleteProgram(ot),
        (this.program = void 0)
    }),
    (this.type = a.shaderType),
    (this.name = a.shaderName),
    (this.id = programIdCount++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = ot),
    (this.vertexShader = dt),
    (this.fragmentShader = pt),
    this
  )
}
let _id$1 = 0
class WebGLShaderCache {
  constructor() {
    ;(this.shaderCache = new Map()), (this.materialCache = new Map())
  }
  update(e) {
    const a = e.vertexShader,
      o = e.fragmentShader,
      c = this._getShaderStage(a),
      d = this._getShaderStage(o),
      g = this._getShaderCacheForMaterial(e)
    return (
      g.has(c) === !1 && (g.add(c), c.usedTimes++),
      g.has(d) === !1 && (g.add(d), d.usedTimes++),
      this
    )
  }
  remove(e) {
    const a = this.materialCache.get(e)
    for (const o of a)
      o.usedTimes--, o.usedTimes === 0 && this.shaderCache.delete(o.code)
    return this.materialCache.delete(e), this
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear()
  }
  _getShaderCacheForMaterial(e) {
    const a = this.materialCache
    let o = a.get(e)
    return o === void 0 && ((o = new Set()), a.set(e, o)), o
  }
  _getShaderStage(e) {
    const a = this.shaderCache
    let o = a.get(e)
    return o === void 0 && ((o = new WebGLShaderStage(e)), a.set(e, o)), o
  }
}
class WebGLShaderStage {
  constructor(e) {
    ;(this.id = _id$1++), (this.code = e), (this.usedTimes = 0)
  }
}
function WebGLPrograms(s, e, a, o, c, d, g) {
  const _ = new Layers(),
    b = new WebGLShaderCache(),
    j = [],
    $ = c.isWebGL2,
    _e = c.logarithmicDepthBuffer,
    tt = c.vertexTextures
  let st = c.precision
  const at = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  }
  function ot(yt) {
    return yt === 0 ? "uv" : `uv${yt}`
  }
  function ut(yt, Et, Rt, Ft, kt) {
    const Nt = Ft.fog,
      Dt = kt.geometry,
      Mt = yt.isMeshStandardMaterial ? Ft.environment : null,
      wt = (yt.isMeshStandardMaterial ? a : e).get(yt.envMap || Mt),
      gt =
        wt && wt.mapping === CubeUVReflectionMapping ? wt.image.height : null,
      At = at[yt.type]
    yt.precision !== null &&
      ((st = c.getMaxPrecision(yt.precision)),
      st !== yt.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          yt.precision,
          "not supported, using",
          st,
          "instead."
        ))
    const bt =
        Dt.morphAttributes.position ||
        Dt.morphAttributes.normal ||
        Dt.morphAttributes.color,
      Tt = bt !== void 0 ? bt.length : 0
    let It = 0
    Dt.morphAttributes.position !== void 0 && (It = 1),
      Dt.morphAttributes.normal !== void 0 && (It = 2),
      Dt.morphAttributes.color !== void 0 && (It = 3)
    let $t, Xt, qt, en
    if (At) {
      const dr = ShaderLib[At]
      ;($t = dr.vertexShader), (Xt = dr.fragmentShader)
    } else
      ($t = yt.vertexShader),
        (Xt = yt.fragmentShader),
        b.update(yt),
        (qt = b.getVertexShaderID(yt)),
        (en = b.getFragmentShaderID(yt))
    const yn = s.getRenderTarget(),
      Tn = kt.isInstancedMesh === !0,
      $n = !!yt.map,
      Vn = !!yt.matcap,
      gn = !!wt,
      Ht = !!yt.aoMap,
      on = !!yt.lightMap,
      Yt = !!yt.bumpMap,
      _n = !!yt.normalMap,
      pn = !!yt.displacementMap,
      Rn = !!yt.emissiveMap,
      bn = !!yt.metalnessMap,
      Pn = !!yt.roughnessMap,
      Gn = yt.anisotropy > 0,
      jn = yt.clearcoat > 0,
      ar = yt.iridescence > 0,
      Vt = yt.sheen > 0,
      Lt = yt.transmission > 0,
      Zt = Gn && !!yt.anisotropyMap,
      xn = jn && !!yt.clearcoatMap,
      vn = jn && !!yt.clearcoatNormalMap,
      An = jn && !!yt.clearcoatRoughnessMap,
      Nn = ar && !!yt.iridescenceMap,
      Sn = ar && !!yt.iridescenceThicknessMap,
      an = Vt && !!yt.sheenColorMap,
      Jn = Vt && !!yt.sheenRoughnessMap,
      Hn = !!yt.specularMap,
      Fn = !!yt.specularColorMap,
      Un = !!yt.specularIntensityMap,
      Wt = Lt && !!yt.transmissionMap,
      un = Lt && !!yt.thicknessMap,
      Mn = !!yt.gradientMap,
      jt = !!yt.alphaMap,
      Qt = yt.alphaTest > 0,
      nn = !!yt.alphaHash,
      En = !!yt.extensions,
      In = !!Dt.attributes.uv1,
      or = !!Dt.attributes.uv2,
      hr = !!Dt.attributes.uv3
    let mr = NoToneMapping
    return (
      yt.toneMapped &&
        (yn === null || yn.isXRRenderTarget === !0) &&
        (mr = s.toneMapping),
      {
        isWebGL2: $,
        shaderID: At,
        shaderType: yt.type,
        shaderName: yt.name,
        vertexShader: $t,
        fragmentShader: Xt,
        defines: yt.defines,
        customVertexShaderID: qt,
        customFragmentShaderID: en,
        isRawShaderMaterial: yt.isRawShaderMaterial === !0,
        glslVersion: yt.glslVersion,
        precision: st,
        instancing: Tn,
        instancingColor: Tn && kt.instanceColor !== null,
        supportsVertexTextures: tt,
        outputColorSpace:
          yn === null
            ? s.outputColorSpace
            : yn.isXRRenderTarget === !0
            ? yn.texture.colorSpace
            : LinearSRGBColorSpace,
        map: $n,
        matcap: Vn,
        envMap: gn,
        envMapMode: gn && wt.mapping,
        envMapCubeUVHeight: gt,
        aoMap: Ht,
        lightMap: on,
        bumpMap: Yt,
        normalMap: _n,
        displacementMap: tt && pn,
        emissiveMap: Rn,
        normalMapObjectSpace: _n && yt.normalMapType === ObjectSpaceNormalMap,
        normalMapTangentSpace: _n && yt.normalMapType === TangentSpaceNormalMap,
        metalnessMap: bn,
        roughnessMap: Pn,
        anisotropy: Gn,
        anisotropyMap: Zt,
        clearcoat: jn,
        clearcoatMap: xn,
        clearcoatNormalMap: vn,
        clearcoatRoughnessMap: An,
        iridescence: ar,
        iridescenceMap: Nn,
        iridescenceThicknessMap: Sn,
        sheen: Vt,
        sheenColorMap: an,
        sheenRoughnessMap: Jn,
        specularMap: Hn,
        specularColorMap: Fn,
        specularIntensityMap: Un,
        transmission: Lt,
        transmissionMap: Wt,
        thicknessMap: un,
        gradientMap: Mn,
        opaque: yt.transparent === !1 && yt.blending === NormalBlending,
        alphaMap: jt,
        alphaTest: Qt,
        alphaHash: nn,
        combine: yt.combine,
        mapUv: $n && ot(yt.map.channel),
        aoMapUv: Ht && ot(yt.aoMap.channel),
        lightMapUv: on && ot(yt.lightMap.channel),
        bumpMapUv: Yt && ot(yt.bumpMap.channel),
        normalMapUv: _n && ot(yt.normalMap.channel),
        displacementMapUv: pn && ot(yt.displacementMap.channel),
        emissiveMapUv: Rn && ot(yt.emissiveMap.channel),
        metalnessMapUv: bn && ot(yt.metalnessMap.channel),
        roughnessMapUv: Pn && ot(yt.roughnessMap.channel),
        anisotropyMapUv: Zt && ot(yt.anisotropyMap.channel),
        clearcoatMapUv: xn && ot(yt.clearcoatMap.channel),
        clearcoatNormalMapUv: vn && ot(yt.clearcoatNormalMap.channel),
        clearcoatRoughnessMapUv: An && ot(yt.clearcoatRoughnessMap.channel),
        iridescenceMapUv: Nn && ot(yt.iridescenceMap.channel),
        iridescenceThicknessMapUv: Sn && ot(yt.iridescenceThicknessMap.channel),
        sheenColorMapUv: an && ot(yt.sheenColorMap.channel),
        sheenRoughnessMapUv: Jn && ot(yt.sheenRoughnessMap.channel),
        specularMapUv: Hn && ot(yt.specularMap.channel),
        specularColorMapUv: Fn && ot(yt.specularColorMap.channel),
        specularIntensityMapUv: Un && ot(yt.specularIntensityMap.channel),
        transmissionMapUv: Wt && ot(yt.transmissionMap.channel),
        thicknessMapUv: un && ot(yt.thicknessMap.channel),
        alphaMapUv: jt && ot(yt.alphaMap.channel),
        vertexTangents: !!Dt.attributes.tangent && (_n || Gn),
        vertexColors: yt.vertexColors,
        vertexAlphas:
          yt.vertexColors === !0 &&
          !!Dt.attributes.color &&
          Dt.attributes.color.itemSize === 4,
        vertexUv1s: In,
        vertexUv2s: or,
        vertexUv3s: hr,
        pointsUvs: kt.isPoints === !0 && !!Dt.attributes.uv && ($n || jt),
        fog: !!Nt,
        useFog: yt.fog === !0,
        fogExp2: Nt && Nt.isFogExp2,
        flatShading: yt.flatShading === !0,
        sizeAttenuation: yt.sizeAttenuation === !0,
        logarithmicDepthBuffer: _e,
        skinning: kt.isSkinnedMesh === !0,
        morphTargets: Dt.morphAttributes.position !== void 0,
        morphNormals: Dt.morphAttributes.normal !== void 0,
        morphColors: Dt.morphAttributes.color !== void 0,
        morphTargetsCount: Tt,
        morphTextureStride: It,
        numDirLights: Et.directional.length,
        numPointLights: Et.point.length,
        numSpotLights: Et.spot.length,
        numSpotLightMaps: Et.spotLightMap.length,
        numRectAreaLights: Et.rectArea.length,
        numHemiLights: Et.hemi.length,
        numDirLightShadows: Et.directionalShadowMap.length,
        numPointLightShadows: Et.pointShadowMap.length,
        numSpotLightShadows: Et.spotShadowMap.length,
        numSpotLightShadowsWithMaps: Et.numSpotLightShadowsWithMaps,
        numClippingPlanes: g.numPlanes,
        numClipIntersection: g.numIntersection,
        dithering: yt.dithering,
        shadowMapEnabled: s.shadowMap.enabled && Rt.length > 0,
        shadowMapType: s.shadowMap.type,
        toneMapping: mr,
        useLegacyLights: s._useLegacyLights,
        decodeVideoTexture:
          $n &&
          yt.map.isVideoTexture === !0 &&
          yt.map.colorSpace === SRGBColorSpace,
        premultipliedAlpha: yt.premultipliedAlpha,
        doubleSided: yt.side === DoubleSide,
        flipSided: yt.side === BackSide,
        useDepthPacking: yt.depthPacking >= 0,
        depthPacking: yt.depthPacking || 0,
        index0AttributeName: yt.index0AttributeName,
        extensionDerivatives: En && yt.extensions.derivatives === !0,
        extensionFragDepth: En && yt.extensions.fragDepth === !0,
        extensionDrawBuffers: En && yt.extensions.drawBuffers === !0,
        extensionShaderTextureLOD: En && yt.extensions.shaderTextureLOD === !0,
        rendererExtensionFragDepth: $ || o.has("EXT_frag_depth"),
        rendererExtensionDrawBuffers: $ || o.has("WEBGL_draw_buffers"),
        rendererExtensionShaderTextureLod: $ || o.has("EXT_shader_texture_lod"),
        customProgramCacheKey: yt.customProgramCacheKey(),
      }
    )
  }
  function it(yt) {
    const Et = []
    if (
      (yt.shaderID
        ? Et.push(yt.shaderID)
        : (Et.push(yt.customVertexShaderID),
          Et.push(yt.customFragmentShaderID)),
      yt.defines !== void 0)
    )
      for (const Rt in yt.defines) Et.push(Rt), Et.push(yt.defines[Rt])
    return (
      yt.isRawShaderMaterial === !1 &&
        (ct(Et, yt), lt(Et, yt), Et.push(s.outputColorSpace)),
      Et.push(yt.customProgramCacheKey),
      Et.join()
    )
  }
  function ct(yt, Et) {
    yt.push(Et.precision),
      yt.push(Et.outputColorSpace),
      yt.push(Et.envMapMode),
      yt.push(Et.envMapCubeUVHeight),
      yt.push(Et.mapUv),
      yt.push(Et.alphaMapUv),
      yt.push(Et.lightMapUv),
      yt.push(Et.aoMapUv),
      yt.push(Et.bumpMapUv),
      yt.push(Et.normalMapUv),
      yt.push(Et.displacementMapUv),
      yt.push(Et.emissiveMapUv),
      yt.push(Et.metalnessMapUv),
      yt.push(Et.roughnessMapUv),
      yt.push(Et.anisotropyMapUv),
      yt.push(Et.clearcoatMapUv),
      yt.push(Et.clearcoatNormalMapUv),
      yt.push(Et.clearcoatRoughnessMapUv),
      yt.push(Et.iridescenceMapUv),
      yt.push(Et.iridescenceThicknessMapUv),
      yt.push(Et.sheenColorMapUv),
      yt.push(Et.sheenRoughnessMapUv),
      yt.push(Et.specularMapUv),
      yt.push(Et.specularColorMapUv),
      yt.push(Et.specularIntensityMapUv),
      yt.push(Et.transmissionMapUv),
      yt.push(Et.thicknessMapUv),
      yt.push(Et.combine),
      yt.push(Et.fogExp2),
      yt.push(Et.sizeAttenuation),
      yt.push(Et.morphTargetsCount),
      yt.push(Et.morphAttributeCount),
      yt.push(Et.numDirLights),
      yt.push(Et.numPointLights),
      yt.push(Et.numSpotLights),
      yt.push(Et.numSpotLightMaps),
      yt.push(Et.numHemiLights),
      yt.push(Et.numRectAreaLights),
      yt.push(Et.numDirLightShadows),
      yt.push(Et.numPointLightShadows),
      yt.push(Et.numSpotLightShadows),
      yt.push(Et.numSpotLightShadowsWithMaps),
      yt.push(Et.shadowMapType),
      yt.push(Et.toneMapping),
      yt.push(Et.numClippingPlanes),
      yt.push(Et.numClipIntersection),
      yt.push(Et.depthPacking)
  }
  function lt(yt, Et) {
    _.disableAll(),
      Et.isWebGL2 && _.enable(0),
      Et.supportsVertexTextures && _.enable(1),
      Et.instancing && _.enable(2),
      Et.instancingColor && _.enable(3),
      Et.matcap && _.enable(4),
      Et.envMap && _.enable(5),
      Et.normalMapObjectSpace && _.enable(6),
      Et.normalMapTangentSpace && _.enable(7),
      Et.clearcoat && _.enable(8),
      Et.iridescence && _.enable(9),
      Et.alphaTest && _.enable(10),
      Et.vertexColors && _.enable(11),
      Et.vertexAlphas && _.enable(12),
      Et.vertexUv1s && _.enable(13),
      Et.vertexUv2s && _.enable(14),
      Et.vertexUv3s && _.enable(15),
      Et.vertexTangents && _.enable(16),
      Et.anisotropy && _.enable(17),
      yt.push(_.mask),
      _.disableAll(),
      Et.fog && _.enable(0),
      Et.useFog && _.enable(1),
      Et.flatShading && _.enable(2),
      Et.logarithmicDepthBuffer && _.enable(3),
      Et.skinning && _.enable(4),
      Et.morphTargets && _.enable(5),
      Et.morphNormals && _.enable(6),
      Et.morphColors && _.enable(7),
      Et.premultipliedAlpha && _.enable(8),
      Et.shadowMapEnabled && _.enable(9),
      Et.useLegacyLights && _.enable(10),
      Et.doubleSided && _.enable(11),
      Et.flipSided && _.enable(12),
      Et.useDepthPacking && _.enable(13),
      Et.dithering && _.enable(14),
      Et.transmission && _.enable(15),
      Et.sheen && _.enable(16),
      Et.opaque && _.enable(17),
      Et.pointsUvs && _.enable(18),
      Et.decodeVideoTexture && _.enable(19),
      yt.push(_.mask)
  }
  function ht(yt) {
    const Et = at[yt.type]
    let Rt
    if (Et) {
      const Ft = ShaderLib[Et]
      Rt = UniformsUtils.clone(Ft.uniforms)
    } else Rt = yt.uniforms
    return Rt
  }
  function dt(yt, Et) {
    let Rt
    for (let Ft = 0, kt = j.length; Ft < kt; Ft++) {
      const Nt = j[Ft]
      if (Nt.cacheKey === Et) {
        ;(Rt = Nt), ++Rt.usedTimes
        break
      }
    }
    return (
      Rt === void 0 && ((Rt = new WebGLProgram(s, Et, yt, d)), j.push(Rt)), Rt
    )
  }
  function pt(yt) {
    if (--yt.usedTimes === 0) {
      const Et = j.indexOf(yt)
      ;(j[Et] = j[j.length - 1]), j.pop(), yt.destroy()
    }
  }
  function vt(yt) {
    b.remove(yt)
  }
  function _t() {
    b.dispose()
  }
  return {
    getParameters: ut,
    getProgramCacheKey: it,
    getUniforms: ht,
    acquireProgram: dt,
    releaseProgram: pt,
    releaseShaderCache: vt,
    programs: j,
    dispose: _t,
  }
}
function WebGLProperties() {
  let s = new WeakMap()
  function e(d) {
    let g = s.get(d)
    return g === void 0 && ((g = {}), s.set(d, g)), g
  }
  function a(d) {
    s.delete(d)
  }
  function o(d, g, _) {
    s.get(d)[g] = _
  }
  function c() {
    s = new WeakMap()
  }
  return { get: e, remove: a, update: o, dispose: c }
}
function painterSortStable(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.material.id !== e.material.id
    ? s.material.id - e.material.id
    : s.z !== e.z
    ? s.z - e.z
    : s.id - e.id
}
function reversePainterSortStable(s, e) {
  return s.groupOrder !== e.groupOrder
    ? s.groupOrder - e.groupOrder
    : s.renderOrder !== e.renderOrder
    ? s.renderOrder - e.renderOrder
    : s.z !== e.z
    ? e.z - s.z
    : s.id - e.id
}
function WebGLRenderList() {
  const s = []
  let e = 0
  const a = [],
    o = [],
    c = []
  function d() {
    ;(e = 0), (a.length = 0), (o.length = 0), (c.length = 0)
  }
  function g(_e, tt, st, at, ot, ut) {
    let it = s[e]
    return (
      it === void 0
        ? ((it = {
            id: _e.id,
            object: _e,
            geometry: tt,
            material: st,
            groupOrder: at,
            renderOrder: _e.renderOrder,
            z: ot,
            group: ut,
          }),
          (s[e] = it))
        : ((it.id = _e.id),
          (it.object = _e),
          (it.geometry = tt),
          (it.material = st),
          (it.groupOrder = at),
          (it.renderOrder = _e.renderOrder),
          (it.z = ot),
          (it.group = ut)),
      e++,
      it
    )
  }
  function _(_e, tt, st, at, ot, ut) {
    const it = g(_e, tt, st, at, ot, ut)
    st.transmission > 0
      ? o.push(it)
      : st.transparent === !0
      ? c.push(it)
      : a.push(it)
  }
  function b(_e, tt, st, at, ot, ut) {
    const it = g(_e, tt, st, at, ot, ut)
    st.transmission > 0
      ? o.unshift(it)
      : st.transparent === !0
      ? c.unshift(it)
      : a.unshift(it)
  }
  function j(_e, tt) {
    a.length > 1 && a.sort(_e || painterSortStable),
      o.length > 1 && o.sort(tt || reversePainterSortStable),
      c.length > 1 && c.sort(tt || reversePainterSortStable)
  }
  function $() {
    for (let _e = e, tt = s.length; _e < tt; _e++) {
      const st = s[_e]
      if (st.id === null) break
      ;(st.id = null),
        (st.object = null),
        (st.geometry = null),
        (st.material = null),
        (st.group = null)
    }
  }
  return {
    opaque: a,
    transmissive: o,
    transparent: c,
    init: d,
    push: _,
    unshift: b,
    finish: $,
    sort: j,
  }
}
function WebGLRenderLists() {
  let s = new WeakMap()
  function e(o, c) {
    const d = s.get(o)
    let g
    return (
      d === void 0
        ? ((g = new WebGLRenderList()), s.set(o, [g]))
        : c >= d.length
        ? ((g = new WebGLRenderList()), d.push(g))
        : (g = d[c]),
      g
    )
  }
  function a() {
    s = new WeakMap()
  }
  return { get: e, dispose: a }
}
function UniformsCache() {
  const s = {}
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id]
      let a
      switch (e.type) {
        case "DirectionalLight":
          a = { direction: new Vector3(), color: new Color() }
          break
        case "SpotLight":
          a = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          }
          break
        case "PointLight":
          a = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
          }
          break
        case "HemisphereLight":
          a = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color(),
          }
          break
        case "RectAreaLight":
          a = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3(),
          }
          break
      }
      return (s[e.id] = a), a
    },
  }
}
function ShadowUniformsCache() {
  const s = {}
  return {
    get: function (e) {
      if (s[e.id] !== void 0) return s[e.id]
      let a
      switch (e.type) {
        case "DirectionalLight":
          a = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          }
          break
        case "SpotLight":
          a = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          }
          break
        case "PointLight":
          a = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          }
          break
      }
      return (s[e.id] = a), a
    },
  }
}
let nextVersion = 0
function shadowCastingAndTexturingLightsFirst(s, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (s.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (s.map ? 1 : 0)
  )
}
function WebGLLights(s, e) {
  const a = new UniformsCache(),
    o = ShadowUniformsCache(),
    c = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    }
  for (let $ = 0; $ < 9; $++) c.probe.push(new Vector3())
  const d = new Vector3(),
    g = new Matrix4(),
    _ = new Matrix4()
  function b($, _e) {
    let tt = 0,
      st = 0,
      at = 0
    for (let Rt = 0; Rt < 9; Rt++) c.probe[Rt].set(0, 0, 0)
    let ot = 0,
      ut = 0,
      it = 0,
      ct = 0,
      lt = 0,
      ht = 0,
      dt = 0,
      pt = 0,
      vt = 0,
      _t = 0
    $.sort(shadowCastingAndTexturingLightsFirst)
    const yt = _e === !0 ? Math.PI : 1
    for (let Rt = 0, Ft = $.length; Rt < Ft; Rt++) {
      const kt = $[Rt],
        Nt = kt.color,
        Dt = kt.intensity,
        Mt = kt.distance,
        wt = kt.shadow && kt.shadow.map ? kt.shadow.map.texture : null
      if (kt.isAmbientLight)
        (tt += Nt.r * Dt * yt), (st += Nt.g * Dt * yt), (at += Nt.b * Dt * yt)
      else if (kt.isLightProbe)
        for (let gt = 0; gt < 9; gt++)
          c.probe[gt].addScaledVector(kt.sh.coefficients[gt], Dt)
      else if (kt.isDirectionalLight) {
        const gt = a.get(kt)
        if (
          (gt.color.copy(kt.color).multiplyScalar(kt.intensity * yt),
          kt.castShadow)
        ) {
          const At = kt.shadow,
            bt = o.get(kt)
          ;(bt.shadowBias = At.bias),
            (bt.shadowNormalBias = At.normalBias),
            (bt.shadowRadius = At.radius),
            (bt.shadowMapSize = At.mapSize),
            (c.directionalShadow[ot] = bt),
            (c.directionalShadowMap[ot] = wt),
            (c.directionalShadowMatrix[ot] = kt.shadow.matrix),
            ht++
        }
        ;(c.directional[ot] = gt), ot++
      } else if (kt.isSpotLight) {
        const gt = a.get(kt)
        gt.position.setFromMatrixPosition(kt.matrixWorld),
          gt.color.copy(Nt).multiplyScalar(Dt * yt),
          (gt.distance = Mt),
          (gt.coneCos = Math.cos(kt.angle)),
          (gt.penumbraCos = Math.cos(kt.angle * (1 - kt.penumbra))),
          (gt.decay = kt.decay),
          (c.spot[it] = gt)
        const At = kt.shadow
        if (
          (kt.map &&
            ((c.spotLightMap[vt] = kt.map),
            vt++,
            At.updateMatrices(kt),
            kt.castShadow && _t++),
          (c.spotLightMatrix[it] = At.matrix),
          kt.castShadow)
        ) {
          const bt = o.get(kt)
          ;(bt.shadowBias = At.bias),
            (bt.shadowNormalBias = At.normalBias),
            (bt.shadowRadius = At.radius),
            (bt.shadowMapSize = At.mapSize),
            (c.spotShadow[it] = bt),
            (c.spotShadowMap[it] = wt),
            pt++
        }
        it++
      } else if (kt.isRectAreaLight) {
        const gt = a.get(kt)
        gt.color.copy(Nt).multiplyScalar(Dt),
          gt.halfWidth.set(kt.width * 0.5, 0, 0),
          gt.halfHeight.set(0, kt.height * 0.5, 0),
          (c.rectArea[ct] = gt),
          ct++
      } else if (kt.isPointLight) {
        const gt = a.get(kt)
        if (
          (gt.color.copy(kt.color).multiplyScalar(kt.intensity * yt),
          (gt.distance = kt.distance),
          (gt.decay = kt.decay),
          kt.castShadow)
        ) {
          const At = kt.shadow,
            bt = o.get(kt)
          ;(bt.shadowBias = At.bias),
            (bt.shadowNormalBias = At.normalBias),
            (bt.shadowRadius = At.radius),
            (bt.shadowMapSize = At.mapSize),
            (bt.shadowCameraNear = At.camera.near),
            (bt.shadowCameraFar = At.camera.far),
            (c.pointShadow[ut] = bt),
            (c.pointShadowMap[ut] = wt),
            (c.pointShadowMatrix[ut] = kt.shadow.matrix),
            dt++
        }
        ;(c.point[ut] = gt), ut++
      } else if (kt.isHemisphereLight) {
        const gt = a.get(kt)
        gt.skyColor.copy(kt.color).multiplyScalar(Dt * yt),
          gt.groundColor.copy(kt.groundColor).multiplyScalar(Dt * yt),
          (c.hemi[lt] = gt),
          lt++
      }
    }
    ct > 0 &&
      (e.isWebGL2 || s.has("OES_texture_float_linear") === !0
        ? ((c.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1),
          (c.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2))
        : s.has("OES_texture_half_float_linear") === !0
        ? ((c.rectAreaLTC1 = UniformsLib.LTC_HALF_1),
          (c.rectAreaLTC2 = UniformsLib.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (c.ambient[0] = tt),
      (c.ambient[1] = st),
      (c.ambient[2] = at)
    const Et = c.hash
    ;(Et.directionalLength !== ot ||
      Et.pointLength !== ut ||
      Et.spotLength !== it ||
      Et.rectAreaLength !== ct ||
      Et.hemiLength !== lt ||
      Et.numDirectionalShadows !== ht ||
      Et.numPointShadows !== dt ||
      Et.numSpotShadows !== pt ||
      Et.numSpotMaps !== vt) &&
      ((c.directional.length = ot),
      (c.spot.length = it),
      (c.rectArea.length = ct),
      (c.point.length = ut),
      (c.hemi.length = lt),
      (c.directionalShadow.length = ht),
      (c.directionalShadowMap.length = ht),
      (c.pointShadow.length = dt),
      (c.pointShadowMap.length = dt),
      (c.spotShadow.length = pt),
      (c.spotShadowMap.length = pt),
      (c.directionalShadowMatrix.length = ht),
      (c.pointShadowMatrix.length = dt),
      (c.spotLightMatrix.length = pt + vt - _t),
      (c.spotLightMap.length = vt),
      (c.numSpotLightShadowsWithMaps = _t),
      (Et.directionalLength = ot),
      (Et.pointLength = ut),
      (Et.spotLength = it),
      (Et.rectAreaLength = ct),
      (Et.hemiLength = lt),
      (Et.numDirectionalShadows = ht),
      (Et.numPointShadows = dt),
      (Et.numSpotShadows = pt),
      (Et.numSpotMaps = vt),
      (c.version = nextVersion++))
  }
  function j($, _e) {
    let tt = 0,
      st = 0,
      at = 0,
      ot = 0,
      ut = 0
    const it = _e.matrixWorldInverse
    for (let ct = 0, lt = $.length; ct < lt; ct++) {
      const ht = $[ct]
      if (ht.isDirectionalLight) {
        const dt = c.directional[tt]
        dt.direction.setFromMatrixPosition(ht.matrixWorld),
          d.setFromMatrixPosition(ht.target.matrixWorld),
          dt.direction.sub(d),
          dt.direction.transformDirection(it),
          tt++
      } else if (ht.isSpotLight) {
        const dt = c.spot[at]
        dt.position.setFromMatrixPosition(ht.matrixWorld),
          dt.position.applyMatrix4(it),
          dt.direction.setFromMatrixPosition(ht.matrixWorld),
          d.setFromMatrixPosition(ht.target.matrixWorld),
          dt.direction.sub(d),
          dt.direction.transformDirection(it),
          at++
      } else if (ht.isRectAreaLight) {
        const dt = c.rectArea[ot]
        dt.position.setFromMatrixPosition(ht.matrixWorld),
          dt.position.applyMatrix4(it),
          _.identity(),
          g.copy(ht.matrixWorld),
          g.premultiply(it),
          _.extractRotation(g),
          dt.halfWidth.set(ht.width * 0.5, 0, 0),
          dt.halfHeight.set(0, ht.height * 0.5, 0),
          dt.halfWidth.applyMatrix4(_),
          dt.halfHeight.applyMatrix4(_),
          ot++
      } else if (ht.isPointLight) {
        const dt = c.point[st]
        dt.position.setFromMatrixPosition(ht.matrixWorld),
          dt.position.applyMatrix4(it),
          st++
      } else if (ht.isHemisphereLight) {
        const dt = c.hemi[ut]
        dt.direction.setFromMatrixPosition(ht.matrixWorld),
          dt.direction.transformDirection(it),
          ut++
      }
    }
  }
  return { setup: b, setupView: j, state: c }
}
function WebGLRenderState(s, e) {
  const a = new WebGLLights(s, e),
    o = [],
    c = []
  function d() {
    ;(o.length = 0), (c.length = 0)
  }
  function g(_e) {
    o.push(_e)
  }
  function _(_e) {
    c.push(_e)
  }
  function b(_e) {
    a.setup(o, _e)
  }
  function j(_e) {
    a.setupView(o, _e)
  }
  return {
    init: d,
    state: { lightsArray: o, shadowsArray: c, lights: a },
    setupLights: b,
    setupLightsView: j,
    pushLight: g,
    pushShadow: _,
  }
}
function WebGLRenderStates(s, e) {
  let a = new WeakMap()
  function o(d, g = 0) {
    const _ = a.get(d)
    let b
    return (
      _ === void 0
        ? ((b = new WebGLRenderState(s, e)), a.set(d, [b]))
        : g >= _.length
        ? ((b = new WebGLRenderState(s, e)), _.push(b))
        : (b = _[g]),
      b
    )
  }
  function c() {
    a = new WeakMap()
  }
  return { get: o, dispose: c }
}
class MeshDepthMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = BasicDepthPacking),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    )
  }
}
class MeshDistanceMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    )
  }
}
const vertex = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  fragment = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`
function WebGLShadowMap(s, e, a) {
  let o = new Frustum()
  const c = new Vector2(),
    d = new Vector2(),
    g = new Vector4(),
    _ = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
    b = new MeshDistanceMaterial(),
    j = {},
    $ = a.maxTextureSize,
    _e = {
      [FrontSide]: BackSide,
      [BackSide]: FrontSide,
      [DoubleSide]: DoubleSide,
    },
    tt = new ShaderMaterial({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 },
      },
      vertexShader: vertex,
      fragmentShader: fragment,
    }),
    st = tt.clone()
  st.defines.HORIZONTAL_PASS = 1
  const at = new BufferGeometry()
  at.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  )
  const ot = new Mesh(at, tt),
    ut = this
  ;(this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = PCFShadowMap)
  let it = this.type
  this.render = function (dt, pt, vt) {
    if (
      ut.enabled === !1 ||
      (ut.autoUpdate === !1 && ut.needsUpdate === !1) ||
      dt.length === 0
    )
      return
    const _t = s.getRenderTarget(),
      yt = s.getActiveCubeFace(),
      Et = s.getActiveMipmapLevel(),
      Rt = s.state
    Rt.setBlending(NoBlending),
      Rt.buffers.color.setClear(1, 1, 1, 1),
      Rt.buffers.depth.setTest(!0),
      Rt.setScissorTest(!1)
    const Ft = it !== VSMShadowMap && this.type === VSMShadowMap,
      kt = it === VSMShadowMap && this.type !== VSMShadowMap
    for (let Nt = 0, Dt = dt.length; Nt < Dt; Nt++) {
      const Mt = dt[Nt],
        wt = Mt.shadow
      if (wt === void 0) {
        console.warn("THREE.WebGLShadowMap:", Mt, "has no shadow.")
        continue
      }
      if (wt.autoUpdate === !1 && wt.needsUpdate === !1) continue
      c.copy(wt.mapSize)
      const gt = wt.getFrameExtents()
      if (
        (c.multiply(gt),
        d.copy(wt.mapSize),
        (c.x > $ || c.y > $) &&
          (c.x > $ &&
            ((d.x = Math.floor($ / gt.x)),
            (c.x = d.x * gt.x),
            (wt.mapSize.x = d.x)),
          c.y > $ &&
            ((d.y = Math.floor($ / gt.y)),
            (c.y = d.y * gt.y),
            (wt.mapSize.y = d.y))),
        wt.map === null || Ft === !0 || kt === !0)
      ) {
        const bt =
          this.type !== VSMShadowMap
            ? { minFilter: NearestFilter, magFilter: NearestFilter }
            : {}
        wt.map !== null && wt.map.dispose(),
          (wt.map = new WebGLRenderTarget(c.x, c.y, bt)),
          (wt.map.texture.name = Mt.name + ".shadowMap"),
          wt.camera.updateProjectionMatrix()
      }
      s.setRenderTarget(wt.map), s.clear()
      const At = wt.getViewportCount()
      for (let bt = 0; bt < At; bt++) {
        const Tt = wt.getViewport(bt)
        g.set(d.x * Tt.x, d.y * Tt.y, d.x * Tt.z, d.y * Tt.w),
          Rt.viewport(g),
          wt.updateMatrices(Mt, bt),
          (o = wt.getFrustum()),
          ht(pt, vt, wt.camera, Mt, this.type)
      }
      wt.isPointLightShadow !== !0 && this.type === VSMShadowMap && ct(wt, vt),
        (wt.needsUpdate = !1)
    }
    ;(it = this.type), (ut.needsUpdate = !1), s.setRenderTarget(_t, yt, Et)
  }
  function ct(dt, pt) {
    const vt = e.update(ot)
    tt.defines.VSM_SAMPLES !== dt.blurSamples &&
      ((tt.defines.VSM_SAMPLES = dt.blurSamples),
      (st.defines.VSM_SAMPLES = dt.blurSamples),
      (tt.needsUpdate = !0),
      (st.needsUpdate = !0)),
      dt.mapPass === null && (dt.mapPass = new WebGLRenderTarget(c.x, c.y)),
      (tt.uniforms.shadow_pass.value = dt.map.texture),
      (tt.uniforms.resolution.value = dt.mapSize),
      (tt.uniforms.radius.value = dt.radius),
      s.setRenderTarget(dt.mapPass),
      s.clear(),
      s.renderBufferDirect(pt, null, vt, tt, ot, null),
      (st.uniforms.shadow_pass.value = dt.mapPass.texture),
      (st.uniforms.resolution.value = dt.mapSize),
      (st.uniforms.radius.value = dt.radius),
      s.setRenderTarget(dt.map),
      s.clear(),
      s.renderBufferDirect(pt, null, vt, st, ot, null)
  }
  function lt(dt, pt, vt, _t) {
    let yt = null
    const Et =
      vt.isPointLight === !0
        ? dt.customDistanceMaterial
        : dt.customDepthMaterial
    if (Et !== void 0) yt = Et
    else if (
      ((yt = vt.isPointLight === !0 ? b : _),
      (s.localClippingEnabled &&
        pt.clipShadows === !0 &&
        Array.isArray(pt.clippingPlanes) &&
        pt.clippingPlanes.length !== 0) ||
        (pt.displacementMap && pt.displacementScale !== 0) ||
        (pt.alphaMap && pt.alphaTest > 0) ||
        (pt.map && pt.alphaTest > 0))
    ) {
      const Rt = yt.uuid,
        Ft = pt.uuid
      let kt = j[Rt]
      kt === void 0 && ((kt = {}), (j[Rt] = kt))
      let Nt = kt[Ft]
      Nt === void 0 && ((Nt = yt.clone()), (kt[Ft] = Nt)), (yt = Nt)
    }
    if (
      ((yt.visible = pt.visible),
      (yt.wireframe = pt.wireframe),
      _t === VSMShadowMap
        ? (yt.side = pt.shadowSide !== null ? pt.shadowSide : pt.side)
        : (yt.side = pt.shadowSide !== null ? pt.shadowSide : _e[pt.side]),
      (yt.alphaMap = pt.alphaMap),
      (yt.alphaTest = pt.alphaTest),
      (yt.map = pt.map),
      (yt.clipShadows = pt.clipShadows),
      (yt.clippingPlanes = pt.clippingPlanes),
      (yt.clipIntersection = pt.clipIntersection),
      (yt.displacementMap = pt.displacementMap),
      (yt.displacementScale = pt.displacementScale),
      (yt.displacementBias = pt.displacementBias),
      (yt.wireframeLinewidth = pt.wireframeLinewidth),
      (yt.linewidth = pt.linewidth),
      vt.isPointLight === !0 && yt.isMeshDistanceMaterial === !0)
    ) {
      const Rt = s.properties.get(yt)
      Rt.light = vt
    }
    return yt
  }
  function ht(dt, pt, vt, _t, yt) {
    if (dt.visible === !1) return
    if (
      dt.layers.test(pt.layers) &&
      (dt.isMesh || dt.isLine || dt.isPoints) &&
      (dt.castShadow || (dt.receiveShadow && yt === VSMShadowMap)) &&
      (!dt.frustumCulled || o.intersectsObject(dt))
    ) {
      dt.modelViewMatrix.multiplyMatrices(vt.matrixWorldInverse, dt.matrixWorld)
      const Ft = e.update(dt),
        kt = dt.material
      if (Array.isArray(kt)) {
        const Nt = Ft.groups
        for (let Dt = 0, Mt = Nt.length; Dt < Mt; Dt++) {
          const wt = Nt[Dt],
            gt = kt[wt.materialIndex]
          if (gt && gt.visible) {
            const At = lt(dt, gt, _t, yt)
            s.renderBufferDirect(vt, null, Ft, At, dt, wt)
          }
        }
      } else if (kt.visible) {
        const Nt = lt(dt, kt, _t, yt)
        s.renderBufferDirect(vt, null, Ft, Nt, dt, null)
      }
    }
    const Rt = dt.children
    for (let Ft = 0, kt = Rt.length; Ft < kt; Ft++) ht(Rt[Ft], pt, vt, _t, yt)
  }
}
function WebGLState(s, e, a) {
  const o = a.isWebGL2
  function c() {
    let jt = !1
    const Qt = new Vector4()
    let nn = null
    const En = new Vector4(0, 0, 0, 0)
    return {
      setMask: function (In) {
        nn !== In && !jt && (s.colorMask(In, In, In, In), (nn = In))
      },
      setLocked: function (In) {
        jt = In
      },
      setClear: function (In, or, hr, mr, kr) {
        kr === !0 && ((In *= mr), (or *= mr), (hr *= mr)),
          Qt.set(In, or, hr, mr),
          En.equals(Qt) === !1 && (s.clearColor(In, or, hr, mr), En.copy(Qt))
      },
      reset: function () {
        ;(jt = !1), (nn = null), En.set(-1, 0, 0, 0)
      },
    }
  }
  function d() {
    let jt = !1,
      Qt = null,
      nn = null,
      En = null
    return {
      setTest: function (In) {
        In ? yn(s.DEPTH_TEST) : Tn(s.DEPTH_TEST)
      },
      setMask: function (In) {
        Qt !== In && !jt && (s.depthMask(In), (Qt = In))
      },
      setFunc: function (In) {
        if (nn !== In) {
          switch (In) {
            case NeverDepth:
              s.depthFunc(s.NEVER)
              break
            case AlwaysDepth:
              s.depthFunc(s.ALWAYS)
              break
            case LessDepth:
              s.depthFunc(s.LESS)
              break
            case LessEqualDepth:
              s.depthFunc(s.LEQUAL)
              break
            case EqualDepth:
              s.depthFunc(s.EQUAL)
              break
            case GreaterEqualDepth:
              s.depthFunc(s.GEQUAL)
              break
            case GreaterDepth:
              s.depthFunc(s.GREATER)
              break
            case NotEqualDepth:
              s.depthFunc(s.NOTEQUAL)
              break
            default:
              s.depthFunc(s.LEQUAL)
          }
          nn = In
        }
      },
      setLocked: function (In) {
        jt = In
      },
      setClear: function (In) {
        En !== In && (s.clearDepth(In), (En = In))
      },
      reset: function () {
        ;(jt = !1), (Qt = null), (nn = null), (En = null)
      },
    }
  }
  function g() {
    let jt = !1,
      Qt = null,
      nn = null,
      En = null,
      In = null,
      or = null,
      hr = null,
      mr = null,
      kr = null
    return {
      setTest: function (dr) {
        jt || (dr ? yn(s.STENCIL_TEST) : Tn(s.STENCIL_TEST))
      },
      setMask: function (dr) {
        Qt !== dr && !jt && (s.stencilMask(dr), (Qt = dr))
      },
      setFunc: function (dr, Br, Tr) {
        ;(nn !== dr || En !== Br || In !== Tr) &&
          (s.stencilFunc(dr, Br, Tr), (nn = dr), (En = Br), (In = Tr))
      },
      setOp: function (dr, Br, Tr) {
        ;(or !== dr || hr !== Br || mr !== Tr) &&
          (s.stencilOp(dr, Br, Tr), (or = dr), (hr = Br), (mr = Tr))
      },
      setLocked: function (dr) {
        jt = dr
      },
      setClear: function (dr) {
        kr !== dr && (s.clearStencil(dr), (kr = dr))
      },
      reset: function () {
        ;(jt = !1),
          (Qt = null),
          (nn = null),
          (En = null),
          (In = null),
          (or = null),
          (hr = null),
          (mr = null),
          (kr = null)
      },
    }
  }
  const _ = new c(),
    b = new d(),
    j = new g(),
    $ = new WeakMap(),
    _e = new WeakMap()
  let tt = {},
    st = {},
    at = new WeakMap(),
    ot = [],
    ut = null,
    it = !1,
    ct = null,
    lt = null,
    ht = null,
    dt = null,
    pt = null,
    vt = null,
    _t = null,
    yt = !1,
    Et = null,
    Rt = null,
    Ft = null,
    kt = null,
    Nt = null
  const Dt = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS)
  let Mt = !1,
    wt = 0
  const gt = s.getParameter(s.VERSION)
  gt.indexOf("WebGL") !== -1
    ? ((wt = parseFloat(/^WebGL (\d)/.exec(gt)[1])), (Mt = wt >= 1))
    : gt.indexOf("OpenGL ES") !== -1 &&
      ((wt = parseFloat(/^OpenGL ES (\d)/.exec(gt)[1])), (Mt = wt >= 2))
  let At = null,
    bt = {}
  const Tt = s.getParameter(s.SCISSOR_BOX),
    It = s.getParameter(s.VIEWPORT),
    $t = new Vector4().fromArray(Tt),
    Xt = new Vector4().fromArray(It)
  function qt(jt, Qt, nn, En) {
    const In = new Uint8Array(4),
      or = s.createTexture()
    s.bindTexture(jt, or),
      s.texParameteri(jt, s.TEXTURE_MIN_FILTER, s.NEAREST),
      s.texParameteri(jt, s.TEXTURE_MAG_FILTER, s.NEAREST)
    for (let hr = 0; hr < nn; hr++)
      o && (jt === s.TEXTURE_3D || jt === s.TEXTURE_2D_ARRAY)
        ? s.texImage3D(Qt, 0, s.RGBA, 1, 1, En, 0, s.RGBA, s.UNSIGNED_BYTE, In)
        : s.texImage2D(Qt + hr, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, In)
    return or
  }
  const en = {}
  ;(en[s.TEXTURE_2D] = qt(s.TEXTURE_2D, s.TEXTURE_2D, 1)),
    (en[s.TEXTURE_CUBE_MAP] = qt(
      s.TEXTURE_CUBE_MAP,
      s.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    o &&
      ((en[s.TEXTURE_2D_ARRAY] = qt(
        s.TEXTURE_2D_ARRAY,
        s.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (en[s.TEXTURE_3D] = qt(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1))),
    _.setClear(0, 0, 0, 1),
    b.setClear(1),
    j.setClear(0),
    yn(s.DEPTH_TEST),
    b.setFunc(LessEqualDepth),
    pn(!1),
    Rn(CullFaceBack),
    yn(s.CULL_FACE),
    Yt(NoBlending)
  function yn(jt) {
    tt[jt] !== !0 && (s.enable(jt), (tt[jt] = !0))
  }
  function Tn(jt) {
    tt[jt] !== !1 && (s.disable(jt), (tt[jt] = !1))
  }
  function $n(jt, Qt) {
    return st[jt] !== Qt
      ? (s.bindFramebuffer(jt, Qt),
        (st[jt] = Qt),
        o &&
          (jt === s.DRAW_FRAMEBUFFER && (st[s.FRAMEBUFFER] = Qt),
          jt === s.FRAMEBUFFER && (st[s.DRAW_FRAMEBUFFER] = Qt)),
        !0)
      : !1
  }
  function Vn(jt, Qt) {
    let nn = ot,
      En = !1
    if (jt)
      if (
        ((nn = at.get(Qt)),
        nn === void 0 && ((nn = []), at.set(Qt, nn)),
        jt.isWebGLMultipleRenderTargets)
      ) {
        const In = jt.texture
        if (nn.length !== In.length || nn[0] !== s.COLOR_ATTACHMENT0) {
          for (let or = 0, hr = In.length; or < hr; or++)
            nn[or] = s.COLOR_ATTACHMENT0 + or
          ;(nn.length = In.length), (En = !0)
        }
      } else
        nn[0] !== s.COLOR_ATTACHMENT0 &&
          ((nn[0] = s.COLOR_ATTACHMENT0), (En = !0))
    else nn[0] !== s.BACK && ((nn[0] = s.BACK), (En = !0))
    En &&
      (a.isWebGL2
        ? s.drawBuffers(nn)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(nn))
  }
  function gn(jt) {
    return ut !== jt ? (s.useProgram(jt), (ut = jt), !0) : !1
  }
  const Ht = {
    [AddEquation]: s.FUNC_ADD,
    [SubtractEquation]: s.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: s.FUNC_REVERSE_SUBTRACT,
  }
  if (o) (Ht[MinEquation] = s.MIN), (Ht[MaxEquation] = s.MAX)
  else {
    const jt = e.get("EXT_blend_minmax")
    jt !== null &&
      ((Ht[MinEquation] = jt.MIN_EXT), (Ht[MaxEquation] = jt.MAX_EXT))
  }
  const on = {
    [ZeroFactor]: s.ZERO,
    [OneFactor]: s.ONE,
    [SrcColorFactor]: s.SRC_COLOR,
    [SrcAlphaFactor]: s.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: s.SRC_ALPHA_SATURATE,
    [DstColorFactor]: s.DST_COLOR,
    [DstAlphaFactor]: s.DST_ALPHA,
    [OneMinusSrcColorFactor]: s.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: s.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: s.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: s.ONE_MINUS_DST_ALPHA,
  }
  function Yt(jt, Qt, nn, En, In, or, hr, mr) {
    if (jt === NoBlending) {
      it === !0 && (Tn(s.BLEND), (it = !1))
      return
    }
    if ((it === !1 && (yn(s.BLEND), (it = !0)), jt !== CustomBlending)) {
      if (jt !== ct || mr !== yt) {
        if (
          ((lt !== AddEquation || pt !== AddEquation) &&
            (s.blendEquation(s.FUNC_ADD),
            (lt = AddEquation),
            (pt = AddEquation)),
          mr)
        )
          switch (jt) {
            case NormalBlending:
              s.blendFuncSeparate(
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA,
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA
              )
              break
            case AdditiveBlending:
              s.blendFunc(s.ONE, s.ONE)
              break
            case SubtractiveBlending:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE)
              break
            case MultiplyBlending:
              s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA)
              break
            default:
              console.error("THREE.WebGLState: Invalid blending: ", jt)
              break
          }
        else
          switch (jt) {
            case NormalBlending:
              s.blendFuncSeparate(
                s.SRC_ALPHA,
                s.ONE_MINUS_SRC_ALPHA,
                s.ONE,
                s.ONE_MINUS_SRC_ALPHA
              )
              break
            case AdditiveBlending:
              s.blendFunc(s.SRC_ALPHA, s.ONE)
              break
            case SubtractiveBlending:
              s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE)
              break
            case MultiplyBlending:
              s.blendFunc(s.ZERO, s.SRC_COLOR)
              break
            default:
              console.error("THREE.WebGLState: Invalid blending: ", jt)
              break
          }
        ;(ht = null),
          (dt = null),
          (vt = null),
          (_t = null),
          (ct = jt),
          (yt = mr)
      }
      return
    }
    ;(In = In || Qt),
      (or = or || nn),
      (hr = hr || En),
      (Qt !== lt || In !== pt) &&
        (s.blendEquationSeparate(Ht[Qt], Ht[In]), (lt = Qt), (pt = In)),
      (nn !== ht || En !== dt || or !== vt || hr !== _t) &&
        (s.blendFuncSeparate(on[nn], on[En], on[or], on[hr]),
        (ht = nn),
        (dt = En),
        (vt = or),
        (_t = hr)),
      (ct = jt),
      (yt = !1)
  }
  function _n(jt, Qt) {
    jt.side === DoubleSide ? Tn(s.CULL_FACE) : yn(s.CULL_FACE)
    let nn = jt.side === BackSide
    Qt && (nn = !nn),
      pn(nn),
      jt.blending === NormalBlending && jt.transparent === !1
        ? Yt(NoBlending)
        : Yt(
            jt.blending,
            jt.blendEquation,
            jt.blendSrc,
            jt.blendDst,
            jt.blendEquationAlpha,
            jt.blendSrcAlpha,
            jt.blendDstAlpha,
            jt.premultipliedAlpha
          ),
      b.setFunc(jt.depthFunc),
      b.setTest(jt.depthTest),
      b.setMask(jt.depthWrite),
      _.setMask(jt.colorWrite)
    const En = jt.stencilWrite
    j.setTest(En),
      En &&
        (j.setMask(jt.stencilWriteMask),
        j.setFunc(jt.stencilFunc, jt.stencilRef, jt.stencilFuncMask),
        j.setOp(jt.stencilFail, jt.stencilZFail, jt.stencilZPass)),
      Pn(jt.polygonOffset, jt.polygonOffsetFactor, jt.polygonOffsetUnits),
      jt.alphaToCoverage === !0
        ? yn(s.SAMPLE_ALPHA_TO_COVERAGE)
        : Tn(s.SAMPLE_ALPHA_TO_COVERAGE)
  }
  function pn(jt) {
    Et !== jt && (jt ? s.frontFace(s.CW) : s.frontFace(s.CCW), (Et = jt))
  }
  function Rn(jt) {
    jt !== CullFaceNone
      ? (yn(s.CULL_FACE),
        jt !== Rt &&
          (jt === CullFaceBack
            ? s.cullFace(s.BACK)
            : jt === CullFaceFront
            ? s.cullFace(s.FRONT)
            : s.cullFace(s.FRONT_AND_BACK)))
      : Tn(s.CULL_FACE),
      (Rt = jt)
  }
  function bn(jt) {
    jt !== Ft && (Mt && s.lineWidth(jt), (Ft = jt))
  }
  function Pn(jt, Qt, nn) {
    jt
      ? (yn(s.POLYGON_OFFSET_FILL),
        (kt !== Qt || Nt !== nn) &&
          (s.polygonOffset(Qt, nn), (kt = Qt), (Nt = nn)))
      : Tn(s.POLYGON_OFFSET_FILL)
  }
  function Gn(jt) {
    jt ? yn(s.SCISSOR_TEST) : Tn(s.SCISSOR_TEST)
  }
  function jn(jt) {
    jt === void 0 && (jt = s.TEXTURE0 + Dt - 1),
      At !== jt && (s.activeTexture(jt), (At = jt))
  }
  function ar(jt, Qt, nn) {
    nn === void 0 && (At === null ? (nn = s.TEXTURE0 + Dt - 1) : (nn = At))
    let En = bt[nn]
    En === void 0 && ((En = { type: void 0, texture: void 0 }), (bt[nn] = En)),
      (En.type !== jt || En.texture !== Qt) &&
        (At !== nn && (s.activeTexture(nn), (At = nn)),
        s.bindTexture(jt, Qt || en[jt]),
        (En.type = jt),
        (En.texture = Qt))
  }
  function Vt() {
    const jt = bt[At]
    jt !== void 0 &&
      jt.type !== void 0 &&
      (s.bindTexture(jt.type, null), (jt.type = void 0), (jt.texture = void 0))
  }
  function Lt() {
    try {
      s.compressedTexImage2D.apply(s, arguments)
    } catch (jt) {
      console.error("THREE.WebGLState:", jt)
    }
  }
  function Zt() {
    try {
      s.compressedTexImage3D.apply(s, arguments)
    } catch (jt) {
      console.error("THREE.WebGLState:", jt)
    }
  }
  function xn() {
    try {
      s.texSubImage2D.apply(s, arguments)
    } catch (jt) {
      console.error("THREE.WebGLState:", jt)
    }
  }
  function vn() {
    try {
      s.texSubImage3D.apply(s, arguments)
    } catch (jt) {
      console.error("THREE.WebGLState:", jt)
    }
  }
  function An() {
    try {
      s.compressedTexSubImage2D.apply(s, arguments)
    } catch (jt) {
      console.error("THREE.WebGLState:", jt)
    }
  }
  function Nn() {
    try {
      s.compressedTexSubImage3D.apply(s, arguments)
    } catch (jt) {
      console.error("THREE.WebGLState:", jt)
    }
  }
  function Sn() {
    try {
      s.texStorage2D.apply(s, arguments)
    } catch (jt) {
      console.error("THREE.WebGLState:", jt)
    }
  }
  function an() {
    try {
      s.texStorage3D.apply(s, arguments)
    } catch (jt) {
      console.error("THREE.WebGLState:", jt)
    }
  }
  function Jn() {
    try {
      s.texImage2D.apply(s, arguments)
    } catch (jt) {
      console.error("THREE.WebGLState:", jt)
    }
  }
  function Hn() {
    try {
      s.texImage3D.apply(s, arguments)
    } catch (jt) {
      console.error("THREE.WebGLState:", jt)
    }
  }
  function Fn(jt) {
    $t.equals(jt) === !1 && (s.scissor(jt.x, jt.y, jt.z, jt.w), $t.copy(jt))
  }
  function Un(jt) {
    Xt.equals(jt) === !1 && (s.viewport(jt.x, jt.y, jt.z, jt.w), Xt.copy(jt))
  }
  function Wt(jt, Qt) {
    let nn = _e.get(Qt)
    nn === void 0 && ((nn = new WeakMap()), _e.set(Qt, nn))
    let En = nn.get(jt)
    En === void 0 &&
      ((En = s.getUniformBlockIndex(Qt, jt.name)), nn.set(jt, En))
  }
  function un(jt, Qt) {
    const En = _e.get(Qt).get(jt)
    $.get(Qt) !== En &&
      (s.uniformBlockBinding(Qt, En, jt.__bindingPointIndex), $.set(Qt, En))
  }
  function Mn() {
    s.disable(s.BLEND),
      s.disable(s.CULL_FACE),
      s.disable(s.DEPTH_TEST),
      s.disable(s.POLYGON_OFFSET_FILL),
      s.disable(s.SCISSOR_TEST),
      s.disable(s.STENCIL_TEST),
      s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),
      s.blendEquation(s.FUNC_ADD),
      s.blendFunc(s.ONE, s.ZERO),
      s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO),
      s.colorMask(!0, !0, !0, !0),
      s.clearColor(0, 0, 0, 0),
      s.depthMask(!0),
      s.depthFunc(s.LESS),
      s.clearDepth(1),
      s.stencilMask(4294967295),
      s.stencilFunc(s.ALWAYS, 0, 4294967295),
      s.stencilOp(s.KEEP, s.KEEP, s.KEEP),
      s.clearStencil(0),
      s.cullFace(s.BACK),
      s.frontFace(s.CCW),
      s.polygonOffset(0, 0),
      s.activeTexture(s.TEXTURE0),
      s.bindFramebuffer(s.FRAMEBUFFER, null),
      o === !0 &&
        (s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
        s.bindFramebuffer(s.READ_FRAMEBUFFER, null)),
      s.useProgram(null),
      s.lineWidth(1),
      s.scissor(0, 0, s.canvas.width, s.canvas.height),
      s.viewport(0, 0, s.canvas.width, s.canvas.height),
      (tt = {}),
      (At = null),
      (bt = {}),
      (st = {}),
      (at = new WeakMap()),
      (ot = []),
      (ut = null),
      (it = !1),
      (ct = null),
      (lt = null),
      (ht = null),
      (dt = null),
      (pt = null),
      (vt = null),
      (_t = null),
      (yt = !1),
      (Et = null),
      (Rt = null),
      (Ft = null),
      (kt = null),
      (Nt = null),
      $t.set(0, 0, s.canvas.width, s.canvas.height),
      Xt.set(0, 0, s.canvas.width, s.canvas.height),
      _.reset(),
      b.reset(),
      j.reset()
  }
  return {
    buffers: { color: _, depth: b, stencil: j },
    enable: yn,
    disable: Tn,
    bindFramebuffer: $n,
    drawBuffers: Vn,
    useProgram: gn,
    setBlending: Yt,
    setMaterial: _n,
    setFlipSided: pn,
    setCullFace: Rn,
    setLineWidth: bn,
    setPolygonOffset: Pn,
    setScissorTest: Gn,
    activeTexture: jn,
    bindTexture: ar,
    unbindTexture: Vt,
    compressedTexImage2D: Lt,
    compressedTexImage3D: Zt,
    texImage2D: Jn,
    texImage3D: Hn,
    updateUBOMapping: Wt,
    uniformBlockBinding: un,
    texStorage2D: Sn,
    texStorage3D: an,
    texSubImage2D: xn,
    texSubImage3D: vn,
    compressedTexSubImage2D: An,
    compressedTexSubImage3D: Nn,
    scissor: Fn,
    viewport: Un,
    reset: Mn,
  }
}
function WebGLTextures(s, e, a, o, c, d, g) {
  const _ = c.isWebGL2,
    b = c.maxTextures,
    j = c.maxCubemapSize,
    $ = c.maxTextureSize,
    _e = c.maxSamples,
    tt = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    st =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    at = new WeakMap()
  let ot
  const ut = new WeakMap()
  let it = !1
  try {
    it =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null
  } catch {}
  function ct(Vt, Lt) {
    return it ? new OffscreenCanvas(Vt, Lt) : createElementNS("canvas")
  }
  function lt(Vt, Lt, Zt, xn) {
    let vn = 1
    if (
      ((Vt.width > xn || Vt.height > xn) &&
        (vn = xn / Math.max(Vt.width, Vt.height)),
      vn < 1 || Lt === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && Vt instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && Vt instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && Vt instanceof ImageBitmap)
      ) {
        const An = Lt ? floorPowerOfTwo : Math.floor,
          Nn = An(vn * Vt.width),
          Sn = An(vn * Vt.height)
        ot === void 0 && (ot = ct(Nn, Sn))
        const an = Zt ? ct(Nn, Sn) : ot
        return (
          (an.width = Nn),
          (an.height = Sn),
          an.getContext("2d").drawImage(Vt, 0, 0, Nn, Sn),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              Vt.width +
              "x" +
              Vt.height +
              ") to (" +
              Nn +
              "x" +
              Sn +
              ")."
          ),
          an
        )
      } else
        return (
          "data" in Vt &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                Vt.width +
                "x" +
                Vt.height +
                ")."
            ),
          Vt
        )
    return Vt
  }
  function ht(Vt) {
    return isPowerOfTwo(Vt.width) && isPowerOfTwo(Vt.height)
  }
  function dt(Vt) {
    return _
      ? !1
      : Vt.wrapS !== ClampToEdgeWrapping ||
          Vt.wrapT !== ClampToEdgeWrapping ||
          (Vt.minFilter !== NearestFilter && Vt.minFilter !== LinearFilter)
  }
  function pt(Vt, Lt) {
    return (
      Vt.generateMipmaps &&
      Lt &&
      Vt.minFilter !== NearestFilter &&
      Vt.minFilter !== LinearFilter
    )
  }
  function vt(Vt) {
    s.generateMipmap(Vt)
  }
  function _t(Vt, Lt, Zt, xn, vn = !1) {
    if (_ === !1) return Lt
    if (Vt !== null) {
      if (s[Vt] !== void 0) return s[Vt]
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          Vt +
          "'"
      )
    }
    let An = Lt
    return (
      Lt === s.RED &&
        (Zt === s.FLOAT && (An = s.R32F),
        Zt === s.HALF_FLOAT && (An = s.R16F),
        Zt === s.UNSIGNED_BYTE && (An = s.R8)),
      Lt === s.RED_INTEGER &&
        (Zt === s.UNSIGNED_BYTE && (An = s.R8UI),
        Zt === s.UNSIGNED_SHORT && (An = s.R16UI),
        Zt === s.UNSIGNED_INT && (An = s.R32UI),
        Zt === s.BYTE && (An = s.R8I),
        Zt === s.SHORT && (An = s.R16I),
        Zt === s.INT && (An = s.R32I)),
      Lt === s.RG &&
        (Zt === s.FLOAT && (An = s.RG32F),
        Zt === s.HALF_FLOAT && (An = s.RG16F),
        Zt === s.UNSIGNED_BYTE && (An = s.RG8)),
      Lt === s.RGBA &&
        (Zt === s.FLOAT && (An = s.RGBA32F),
        Zt === s.HALF_FLOAT && (An = s.RGBA16F),
        Zt === s.UNSIGNED_BYTE &&
          (An = xn === SRGBColorSpace && vn === !1 ? s.SRGB8_ALPHA8 : s.RGBA8),
        Zt === s.UNSIGNED_SHORT_4_4_4_4 && (An = s.RGBA4),
        Zt === s.UNSIGNED_SHORT_5_5_5_1 && (An = s.RGB5_A1)),
      (An === s.R16F ||
        An === s.R32F ||
        An === s.RG16F ||
        An === s.RG32F ||
        An === s.RGBA16F ||
        An === s.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      An
    )
  }
  function yt(Vt, Lt, Zt) {
    return pt(Vt, Zt) === !0 ||
      (Vt.isFramebufferTexture &&
        Vt.minFilter !== NearestFilter &&
        Vt.minFilter !== LinearFilter)
      ? Math.log2(Math.max(Lt.width, Lt.height)) + 1
      : Vt.mipmaps !== void 0 && Vt.mipmaps.length > 0
      ? Vt.mipmaps.length
      : Vt.isCompressedTexture && Array.isArray(Vt.image)
      ? Lt.mipmaps.length
      : 1
  }
  function Et(Vt) {
    return Vt === NearestFilter ||
      Vt === NearestMipmapNearestFilter ||
      Vt === NearestMipmapLinearFilter
      ? s.NEAREST
      : s.LINEAR
  }
  function Rt(Vt) {
    const Lt = Vt.target
    Lt.removeEventListener("dispose", Rt),
      kt(Lt),
      Lt.isVideoTexture && at.delete(Lt)
  }
  function Ft(Vt) {
    const Lt = Vt.target
    Lt.removeEventListener("dispose", Ft), Dt(Lt)
  }
  function kt(Vt) {
    const Lt = o.get(Vt)
    if (Lt.__webglInit === void 0) return
    const Zt = Vt.source,
      xn = ut.get(Zt)
    if (xn) {
      const vn = xn[Lt.__cacheKey]
      vn.usedTimes--,
        vn.usedTimes === 0 && Nt(Vt),
        Object.keys(xn).length === 0 && ut.delete(Zt)
    }
    o.remove(Vt)
  }
  function Nt(Vt) {
    const Lt = o.get(Vt)
    s.deleteTexture(Lt.__webglTexture)
    const Zt = Vt.source,
      xn = ut.get(Zt)
    delete xn[Lt.__cacheKey], g.memory.textures--
  }
  function Dt(Vt) {
    const Lt = Vt.texture,
      Zt = o.get(Vt),
      xn = o.get(Lt)
    if (
      (xn.__webglTexture !== void 0 &&
        (s.deleteTexture(xn.__webglTexture), g.memory.textures--),
      Vt.depthTexture && Vt.depthTexture.dispose(),
      Vt.isWebGLCubeRenderTarget)
    )
      for (let vn = 0; vn < 6; vn++) {
        if (Array.isArray(Zt.__webglFramebuffer[vn]))
          for (let An = 0; An < Zt.__webglFramebuffer[vn].length; An++)
            s.deleteFramebuffer(Zt.__webglFramebuffer[vn][An])
        else s.deleteFramebuffer(Zt.__webglFramebuffer[vn])
        Zt.__webglDepthbuffer && s.deleteRenderbuffer(Zt.__webglDepthbuffer[vn])
      }
    else {
      if (Array.isArray(Zt.__webglFramebuffer))
        for (let vn = 0; vn < Zt.__webglFramebuffer.length; vn++)
          s.deleteFramebuffer(Zt.__webglFramebuffer[vn])
      else s.deleteFramebuffer(Zt.__webglFramebuffer)
      if (
        (Zt.__webglDepthbuffer && s.deleteRenderbuffer(Zt.__webglDepthbuffer),
        Zt.__webglMultisampledFramebuffer &&
          s.deleteFramebuffer(Zt.__webglMultisampledFramebuffer),
        Zt.__webglColorRenderbuffer)
      )
        for (let vn = 0; vn < Zt.__webglColorRenderbuffer.length; vn++)
          Zt.__webglColorRenderbuffer[vn] &&
            s.deleteRenderbuffer(Zt.__webglColorRenderbuffer[vn])
      Zt.__webglDepthRenderbuffer &&
        s.deleteRenderbuffer(Zt.__webglDepthRenderbuffer)
    }
    if (Vt.isWebGLMultipleRenderTargets)
      for (let vn = 0, An = Lt.length; vn < An; vn++) {
        const Nn = o.get(Lt[vn])
        Nn.__webglTexture &&
          (s.deleteTexture(Nn.__webglTexture), g.memory.textures--),
          o.remove(Lt[vn])
      }
    o.remove(Lt), o.remove(Vt)
  }
  let Mt = 0
  function wt() {
    Mt = 0
  }
  function gt() {
    const Vt = Mt
    return (
      Vt >= b &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            Vt +
            " texture units while this GPU supports only " +
            b
        ),
      (Mt += 1),
      Vt
    )
  }
  function At(Vt) {
    const Lt = []
    return (
      Lt.push(Vt.wrapS),
      Lt.push(Vt.wrapT),
      Lt.push(Vt.wrapR || 0),
      Lt.push(Vt.magFilter),
      Lt.push(Vt.minFilter),
      Lt.push(Vt.anisotropy),
      Lt.push(Vt.internalFormat),
      Lt.push(Vt.format),
      Lt.push(Vt.type),
      Lt.push(Vt.generateMipmaps),
      Lt.push(Vt.premultiplyAlpha),
      Lt.push(Vt.flipY),
      Lt.push(Vt.unpackAlignment),
      Lt.push(Vt.colorSpace),
      Lt.join()
    )
  }
  function bt(Vt, Lt) {
    const Zt = o.get(Vt)
    if (
      (Vt.isVideoTexture && jn(Vt),
      Vt.isRenderTargetTexture === !1 &&
        Vt.version > 0 &&
        Zt.__version !== Vt.version)
    ) {
      const xn = Vt.image
      if (xn === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        )
      else if (xn.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        )
      else {
        $n(Zt, Vt, Lt)
        return
      }
    }
    a.bindTexture(s.TEXTURE_2D, Zt.__webglTexture, s.TEXTURE0 + Lt)
  }
  function Tt(Vt, Lt) {
    const Zt = o.get(Vt)
    if (Vt.version > 0 && Zt.__version !== Vt.version) {
      $n(Zt, Vt, Lt)
      return
    }
    a.bindTexture(s.TEXTURE_2D_ARRAY, Zt.__webglTexture, s.TEXTURE0 + Lt)
  }
  function It(Vt, Lt) {
    const Zt = o.get(Vt)
    if (Vt.version > 0 && Zt.__version !== Vt.version) {
      $n(Zt, Vt, Lt)
      return
    }
    a.bindTexture(s.TEXTURE_3D, Zt.__webglTexture, s.TEXTURE0 + Lt)
  }
  function $t(Vt, Lt) {
    const Zt = o.get(Vt)
    if (Vt.version > 0 && Zt.__version !== Vt.version) {
      Vn(Zt, Vt, Lt)
      return
    }
    a.bindTexture(s.TEXTURE_CUBE_MAP, Zt.__webglTexture, s.TEXTURE0 + Lt)
  }
  const Xt = {
      [RepeatWrapping]: s.REPEAT,
      [ClampToEdgeWrapping]: s.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: s.MIRRORED_REPEAT,
    },
    qt = {
      [NearestFilter]: s.NEAREST,
      [NearestMipmapNearestFilter]: s.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: s.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: s.LINEAR,
      [LinearMipmapNearestFilter]: s.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: s.LINEAR_MIPMAP_LINEAR,
    },
    en = {
      [NeverCompare]: s.NEVER,
      [AlwaysCompare]: s.ALWAYS,
      [LessCompare]: s.LESS,
      [LessEqualCompare]: s.LEQUAL,
      [EqualCompare]: s.EQUAL,
      [GreaterEqualCompare]: s.GEQUAL,
      [GreaterCompare]: s.GREATER,
      [NotEqualCompare]: s.NOTEQUAL,
    }
  function yn(Vt, Lt, Zt) {
    if (
      (Zt
        ? (s.texParameteri(Vt, s.TEXTURE_WRAP_S, Xt[Lt.wrapS]),
          s.texParameteri(Vt, s.TEXTURE_WRAP_T, Xt[Lt.wrapT]),
          (Vt === s.TEXTURE_3D || Vt === s.TEXTURE_2D_ARRAY) &&
            s.texParameteri(Vt, s.TEXTURE_WRAP_R, Xt[Lt.wrapR]),
          s.texParameteri(Vt, s.TEXTURE_MAG_FILTER, qt[Lt.magFilter]),
          s.texParameteri(Vt, s.TEXTURE_MIN_FILTER, qt[Lt.minFilter]))
        : (s.texParameteri(Vt, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
          s.texParameteri(Vt, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
          (Vt === s.TEXTURE_3D || Vt === s.TEXTURE_2D_ARRAY) &&
            s.texParameteri(Vt, s.TEXTURE_WRAP_R, s.CLAMP_TO_EDGE),
          (Lt.wrapS !== ClampToEdgeWrapping ||
            Lt.wrapT !== ClampToEdgeWrapping) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          s.texParameteri(Vt, s.TEXTURE_MAG_FILTER, Et(Lt.magFilter)),
          s.texParameteri(Vt, s.TEXTURE_MIN_FILTER, Et(Lt.minFilter)),
          Lt.minFilter !== NearestFilter &&
            Lt.minFilter !== LinearFilter &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      Lt.compareFunction &&
        (s.texParameteri(Vt, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE),
        s.texParameteri(Vt, s.TEXTURE_COMPARE_FUNC, en[Lt.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const xn = e.get("EXT_texture_filter_anisotropic")
      if (
        Lt.magFilter === NearestFilter ||
        (Lt.minFilter !== NearestMipmapLinearFilter &&
          Lt.minFilter !== LinearMipmapLinearFilter) ||
        (Lt.type === FloatType && e.has("OES_texture_float_linear") === !1) ||
        (_ === !1 &&
          Lt.type === HalfFloatType &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return
      ;(Lt.anisotropy > 1 || o.get(Lt).__currentAnisotropy) &&
        (s.texParameterf(
          Vt,
          xn.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(Lt.anisotropy, c.getMaxAnisotropy())
        ),
        (o.get(Lt).__currentAnisotropy = Lt.anisotropy))
    }
  }
  function Tn(Vt, Lt) {
    let Zt = !1
    Vt.__webglInit === void 0 &&
      ((Vt.__webglInit = !0), Lt.addEventListener("dispose", Rt))
    const xn = Lt.source
    let vn = ut.get(xn)
    vn === void 0 && ((vn = {}), ut.set(xn, vn))
    const An = At(Lt)
    if (An !== Vt.__cacheKey) {
      vn[An] === void 0 &&
        ((vn[An] = { texture: s.createTexture(), usedTimes: 0 }),
        g.memory.textures++,
        (Zt = !0)),
        vn[An].usedTimes++
      const Nn = vn[Vt.__cacheKey]
      Nn !== void 0 &&
        (vn[Vt.__cacheKey].usedTimes--, Nn.usedTimes === 0 && Nt(Lt)),
        (Vt.__cacheKey = An),
        (Vt.__webglTexture = vn[An].texture)
    }
    return Zt
  }
  function $n(Vt, Lt, Zt) {
    let xn = s.TEXTURE_2D
    ;(Lt.isDataArrayTexture || Lt.isCompressedArrayTexture) &&
      (xn = s.TEXTURE_2D_ARRAY),
      Lt.isData3DTexture && (xn = s.TEXTURE_3D)
    const vn = Tn(Vt, Lt),
      An = Lt.source
    a.bindTexture(xn, Vt.__webglTexture, s.TEXTURE0 + Zt)
    const Nn = o.get(An)
    if (An.version !== Nn.__version || vn === !0) {
      a.activeTexture(s.TEXTURE0 + Zt),
        s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, Lt.flipY),
        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Lt.premultiplyAlpha),
        s.pixelStorei(s.UNPACK_ALIGNMENT, Lt.unpackAlignment),
        s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, s.NONE)
      const Sn = dt(Lt) && ht(Lt.image) === !1
      let an = lt(Lt.image, Sn, !1, $)
      an = ar(Lt, an)
      const Jn = ht(an) || _,
        Hn = d.convert(Lt.format, Lt.colorSpace)
      let Fn = d.convert(Lt.type),
        Un = _t(Lt.internalFormat, Hn, Fn, Lt.colorSpace, Lt.isVideoTexture)
      yn(xn, Lt, Jn)
      let Wt
      const un = Lt.mipmaps,
        Mn = _ && Lt.isVideoTexture !== !0,
        jt = Nn.__version === void 0 || vn === !0,
        Qt = yt(Lt, an, Jn)
      if (Lt.isDepthTexture)
        (Un = s.DEPTH_COMPONENT),
          _
            ? Lt.type === FloatType
              ? (Un = s.DEPTH_COMPONENT32F)
              : Lt.type === UnsignedIntType
              ? (Un = s.DEPTH_COMPONENT24)
              : Lt.type === UnsignedInt248Type
              ? (Un = s.DEPTH24_STENCIL8)
              : (Un = s.DEPTH_COMPONENT16)
            : Lt.type === FloatType &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          Lt.format === DepthFormat &&
            Un === s.DEPTH_COMPONENT &&
            Lt.type !== UnsignedShortType &&
            Lt.type !== UnsignedIntType &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (Lt.type = UnsignedIntType),
            (Fn = d.convert(Lt.type))),
          Lt.format === DepthStencilFormat &&
            Un === s.DEPTH_COMPONENT &&
            ((Un = s.DEPTH_STENCIL),
            Lt.type !== UnsignedInt248Type &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (Lt.type = UnsignedInt248Type),
              (Fn = d.convert(Lt.type)))),
          jt &&
            (Mn
              ? a.texStorage2D(s.TEXTURE_2D, 1, Un, an.width, an.height)
              : a.texImage2D(
                  s.TEXTURE_2D,
                  0,
                  Un,
                  an.width,
                  an.height,
                  0,
                  Hn,
                  Fn,
                  null
                ))
      else if (Lt.isDataTexture)
        if (un.length > 0 && Jn) {
          Mn &&
            jt &&
            a.texStorage2D(s.TEXTURE_2D, Qt, Un, un[0].width, un[0].height)
          for (let nn = 0, En = un.length; nn < En; nn++)
            (Wt = un[nn]),
              Mn
                ? a.texSubImage2D(
                    s.TEXTURE_2D,
                    nn,
                    0,
                    0,
                    Wt.width,
                    Wt.height,
                    Hn,
                    Fn,
                    Wt.data
                  )
                : a.texImage2D(
                    s.TEXTURE_2D,
                    nn,
                    Un,
                    Wt.width,
                    Wt.height,
                    0,
                    Hn,
                    Fn,
                    Wt.data
                  )
          Lt.generateMipmaps = !1
        } else
          Mn
            ? (jt && a.texStorage2D(s.TEXTURE_2D, Qt, Un, an.width, an.height),
              a.texSubImage2D(
                s.TEXTURE_2D,
                0,
                0,
                0,
                an.width,
                an.height,
                Hn,
                Fn,
                an.data
              ))
            : a.texImage2D(
                s.TEXTURE_2D,
                0,
                Un,
                an.width,
                an.height,
                0,
                Hn,
                Fn,
                an.data
              )
      else if (Lt.isCompressedTexture)
        if (Lt.isCompressedArrayTexture) {
          Mn &&
            jt &&
            a.texStorage3D(
              s.TEXTURE_2D_ARRAY,
              Qt,
              Un,
              un[0].width,
              un[0].height,
              an.depth
            )
          for (let nn = 0, En = un.length; nn < En; nn++)
            (Wt = un[nn]),
              Lt.format !== RGBAFormat
                ? Hn !== null
                  ? Mn
                    ? a.compressedTexSubImage3D(
                        s.TEXTURE_2D_ARRAY,
                        nn,
                        0,
                        0,
                        0,
                        Wt.width,
                        Wt.height,
                        an.depth,
                        Hn,
                        Wt.data,
                        0,
                        0
                      )
                    : a.compressedTexImage3D(
                        s.TEXTURE_2D_ARRAY,
                        nn,
                        Un,
                        Wt.width,
                        Wt.height,
                        an.depth,
                        0,
                        Wt.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Mn
                ? a.texSubImage3D(
                    s.TEXTURE_2D_ARRAY,
                    nn,
                    0,
                    0,
                    0,
                    Wt.width,
                    Wt.height,
                    an.depth,
                    Hn,
                    Fn,
                    Wt.data
                  )
                : a.texImage3D(
                    s.TEXTURE_2D_ARRAY,
                    nn,
                    Un,
                    Wt.width,
                    Wt.height,
                    an.depth,
                    0,
                    Hn,
                    Fn,
                    Wt.data
                  )
        } else {
          Mn &&
            jt &&
            a.texStorage2D(s.TEXTURE_2D, Qt, Un, un[0].width, un[0].height)
          for (let nn = 0, En = un.length; nn < En; nn++)
            (Wt = un[nn]),
              Lt.format !== RGBAFormat
                ? Hn !== null
                  ? Mn
                    ? a.compressedTexSubImage2D(
                        s.TEXTURE_2D,
                        nn,
                        0,
                        0,
                        Wt.width,
                        Wt.height,
                        Hn,
                        Wt.data
                      )
                    : a.compressedTexImage2D(
                        s.TEXTURE_2D,
                        nn,
                        Un,
                        Wt.width,
                        Wt.height,
                        0,
                        Wt.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Mn
                ? a.texSubImage2D(
                    s.TEXTURE_2D,
                    nn,
                    0,
                    0,
                    Wt.width,
                    Wt.height,
                    Hn,
                    Fn,
                    Wt.data
                  )
                : a.texImage2D(
                    s.TEXTURE_2D,
                    nn,
                    Un,
                    Wt.width,
                    Wt.height,
                    0,
                    Hn,
                    Fn,
                    Wt.data
                  )
        }
      else if (Lt.isDataArrayTexture)
        Mn
          ? (jt &&
              a.texStorage3D(
                s.TEXTURE_2D_ARRAY,
                Qt,
                Un,
                an.width,
                an.height,
                an.depth
              ),
            a.texSubImage3D(
              s.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              an.width,
              an.height,
              an.depth,
              Hn,
              Fn,
              an.data
            ))
          : a.texImage3D(
              s.TEXTURE_2D_ARRAY,
              0,
              Un,
              an.width,
              an.height,
              an.depth,
              0,
              Hn,
              Fn,
              an.data
            )
      else if (Lt.isData3DTexture)
        Mn
          ? (jt &&
              a.texStorage3D(
                s.TEXTURE_3D,
                Qt,
                Un,
                an.width,
                an.height,
                an.depth
              ),
            a.texSubImage3D(
              s.TEXTURE_3D,
              0,
              0,
              0,
              0,
              an.width,
              an.height,
              an.depth,
              Hn,
              Fn,
              an.data
            ))
          : a.texImage3D(
              s.TEXTURE_3D,
              0,
              Un,
              an.width,
              an.height,
              an.depth,
              0,
              Hn,
              Fn,
              an.data
            )
      else if (Lt.isFramebufferTexture) {
        if (jt)
          if (Mn) a.texStorage2D(s.TEXTURE_2D, Qt, Un, an.width, an.height)
          else {
            let nn = an.width,
              En = an.height
            for (let In = 0; In < Qt; In++)
              a.texImage2D(s.TEXTURE_2D, In, Un, nn, En, 0, Hn, Fn, null),
                (nn >>= 1),
                (En >>= 1)
          }
      } else if (un.length > 0 && Jn) {
        Mn &&
          jt &&
          a.texStorage2D(s.TEXTURE_2D, Qt, Un, un[0].width, un[0].height)
        for (let nn = 0, En = un.length; nn < En; nn++)
          (Wt = un[nn]),
            Mn
              ? a.texSubImage2D(s.TEXTURE_2D, nn, 0, 0, Hn, Fn, Wt)
              : a.texImage2D(s.TEXTURE_2D, nn, Un, Hn, Fn, Wt)
        Lt.generateMipmaps = !1
      } else
        Mn
          ? (jt && a.texStorage2D(s.TEXTURE_2D, Qt, Un, an.width, an.height),
            a.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, Hn, Fn, an))
          : a.texImage2D(s.TEXTURE_2D, 0, Un, Hn, Fn, an)
      pt(Lt, Jn) && vt(xn),
        (Nn.__version = An.version),
        Lt.onUpdate && Lt.onUpdate(Lt)
    }
    Vt.__version = Lt.version
  }
  function Vn(Vt, Lt, Zt) {
    if (Lt.image.length !== 6) return
    const xn = Tn(Vt, Lt),
      vn = Lt.source
    a.bindTexture(s.TEXTURE_CUBE_MAP, Vt.__webglTexture, s.TEXTURE0 + Zt)
    const An = o.get(vn)
    if (vn.version !== An.__version || xn === !0) {
      a.activeTexture(s.TEXTURE0 + Zt),
        s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, Lt.flipY),
        s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Lt.premultiplyAlpha),
        s.pixelStorei(s.UNPACK_ALIGNMENT, Lt.unpackAlignment),
        s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, s.NONE)
      const Nn = Lt.isCompressedTexture || Lt.image[0].isCompressedTexture,
        Sn = Lt.image[0] && Lt.image[0].isDataTexture,
        an = []
      for (let nn = 0; nn < 6; nn++)
        !Nn && !Sn
          ? (an[nn] = lt(Lt.image[nn], !1, !0, j))
          : (an[nn] = Sn ? Lt.image[nn].image : Lt.image[nn]),
          (an[nn] = ar(Lt, an[nn]))
      const Jn = an[0],
        Hn = ht(Jn) || _,
        Fn = d.convert(Lt.format, Lt.colorSpace),
        Un = d.convert(Lt.type),
        Wt = _t(Lt.internalFormat, Fn, Un, Lt.colorSpace),
        un = _ && Lt.isVideoTexture !== !0,
        Mn = An.__version === void 0 || xn === !0
      let jt = yt(Lt, Jn, Hn)
      yn(s.TEXTURE_CUBE_MAP, Lt, Hn)
      let Qt
      if (Nn) {
        un &&
          Mn &&
          a.texStorage2D(s.TEXTURE_CUBE_MAP, jt, Wt, Jn.width, Jn.height)
        for (let nn = 0; nn < 6; nn++) {
          Qt = an[nn].mipmaps
          for (let En = 0; En < Qt.length; En++) {
            const In = Qt[En]
            Lt.format !== RGBAFormat
              ? Fn !== null
                ? un
                  ? a.compressedTexSubImage2D(
                      s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                      En,
                      0,
                      0,
                      In.width,
                      In.height,
                      Fn,
                      In.data
                    )
                  : a.compressedTexImage2D(
                      s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                      En,
                      Wt,
                      In.width,
                      In.height,
                      0,
                      In.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : un
              ? a.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                  En,
                  0,
                  0,
                  In.width,
                  In.height,
                  Fn,
                  Un,
                  In.data
                )
              : a.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                  En,
                  Wt,
                  In.width,
                  In.height,
                  0,
                  Fn,
                  Un,
                  In.data
                )
          }
        }
      } else {
        ;(Qt = Lt.mipmaps),
          un &&
            Mn &&
            (Qt.length > 0 && jt++,
            a.texStorage2D(
              s.TEXTURE_CUBE_MAP,
              jt,
              Wt,
              an[0].width,
              an[0].height
            ))
        for (let nn = 0; nn < 6; nn++)
          if (Sn) {
            un
              ? a.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                  0,
                  0,
                  0,
                  an[nn].width,
                  an[nn].height,
                  Fn,
                  Un,
                  an[nn].data
                )
              : a.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                  0,
                  Wt,
                  an[nn].width,
                  an[nn].height,
                  0,
                  Fn,
                  Un,
                  an[nn].data
                )
            for (let En = 0; En < Qt.length; En++) {
              const or = Qt[En].image[nn].image
              un
                ? a.texSubImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                    En + 1,
                    0,
                    0,
                    or.width,
                    or.height,
                    Fn,
                    Un,
                    or.data
                  )
                : a.texImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                    En + 1,
                    Wt,
                    or.width,
                    or.height,
                    0,
                    Fn,
                    Un,
                    or.data
                  )
            }
          } else {
            un
              ? a.texSubImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                  0,
                  0,
                  0,
                  Fn,
                  Un,
                  an[nn]
                )
              : a.texImage2D(
                  s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                  0,
                  Wt,
                  Fn,
                  Un,
                  an[nn]
                )
            for (let En = 0; En < Qt.length; En++) {
              const In = Qt[En]
              un
                ? a.texSubImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                    En + 1,
                    0,
                    0,
                    Fn,
                    Un,
                    In.image[nn]
                  )
                : a.texImage2D(
                    s.TEXTURE_CUBE_MAP_POSITIVE_X + nn,
                    En + 1,
                    Wt,
                    Fn,
                    Un,
                    In.image[nn]
                  )
            }
          }
      }
      pt(Lt, Hn) && vt(s.TEXTURE_CUBE_MAP),
        (An.__version = vn.version),
        Lt.onUpdate && Lt.onUpdate(Lt)
    }
    Vt.__version = Lt.version
  }
  function gn(Vt, Lt, Zt, xn, vn, An) {
    const Nn = d.convert(Zt.format, Zt.colorSpace),
      Sn = d.convert(Zt.type),
      an = _t(Zt.internalFormat, Nn, Sn, Zt.colorSpace)
    if (!o.get(Lt).__hasExternalTextures) {
      const Hn = Math.max(1, Lt.width >> An),
        Fn = Math.max(1, Lt.height >> An)
      vn === s.TEXTURE_3D || vn === s.TEXTURE_2D_ARRAY
        ? a.texImage3D(vn, An, an, Hn, Fn, Lt.depth, 0, Nn, Sn, null)
        : a.texImage2D(vn, An, an, Hn, Fn, 0, Nn, Sn, null)
    }
    a.bindFramebuffer(s.FRAMEBUFFER, Vt),
      Gn(Lt)
        ? tt.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            xn,
            vn,
            o.get(Zt).__webglTexture,
            0,
            Pn(Lt)
          )
        : (vn === s.TEXTURE_2D ||
            (vn >= s.TEXTURE_CUBE_MAP_POSITIVE_X &&
              vn <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          s.framebufferTexture2D(
            s.FRAMEBUFFER,
            xn,
            vn,
            o.get(Zt).__webglTexture,
            An
          ),
      a.bindFramebuffer(s.FRAMEBUFFER, null)
  }
  function Ht(Vt, Lt, Zt) {
    if (
      (s.bindRenderbuffer(s.RENDERBUFFER, Vt),
      Lt.depthBuffer && !Lt.stencilBuffer)
    ) {
      let xn = s.DEPTH_COMPONENT16
      if (Zt || Gn(Lt)) {
        const vn = Lt.depthTexture
        vn &&
          vn.isDepthTexture &&
          (vn.type === FloatType
            ? (xn = s.DEPTH_COMPONENT32F)
            : vn.type === UnsignedIntType && (xn = s.DEPTH_COMPONENT24))
        const An = Pn(Lt)
        Gn(Lt)
          ? tt.renderbufferStorageMultisampleEXT(
              s.RENDERBUFFER,
              An,
              xn,
              Lt.width,
              Lt.height
            )
          : s.renderbufferStorageMultisample(
              s.RENDERBUFFER,
              An,
              xn,
              Lt.width,
              Lt.height
            )
      } else s.renderbufferStorage(s.RENDERBUFFER, xn, Lt.width, Lt.height)
      s.framebufferRenderbuffer(
        s.FRAMEBUFFER,
        s.DEPTH_ATTACHMENT,
        s.RENDERBUFFER,
        Vt
      )
    } else if (Lt.depthBuffer && Lt.stencilBuffer) {
      const xn = Pn(Lt)
      Zt && Gn(Lt) === !1
        ? s.renderbufferStorageMultisample(
            s.RENDERBUFFER,
            xn,
            s.DEPTH24_STENCIL8,
            Lt.width,
            Lt.height
          )
        : Gn(Lt)
        ? tt.renderbufferStorageMultisampleEXT(
            s.RENDERBUFFER,
            xn,
            s.DEPTH24_STENCIL8,
            Lt.width,
            Lt.height
          )
        : s.renderbufferStorage(
            s.RENDERBUFFER,
            s.DEPTH_STENCIL,
            Lt.width,
            Lt.height
          ),
        s.framebufferRenderbuffer(
          s.FRAMEBUFFER,
          s.DEPTH_STENCIL_ATTACHMENT,
          s.RENDERBUFFER,
          Vt
        )
    } else {
      const xn =
        Lt.isWebGLMultipleRenderTargets === !0 ? Lt.texture : [Lt.texture]
      for (let vn = 0; vn < xn.length; vn++) {
        const An = xn[vn],
          Nn = d.convert(An.format, An.colorSpace),
          Sn = d.convert(An.type),
          an = _t(An.internalFormat, Nn, Sn, An.colorSpace),
          Jn = Pn(Lt)
        Zt && Gn(Lt) === !1
          ? s.renderbufferStorageMultisample(
              s.RENDERBUFFER,
              Jn,
              an,
              Lt.width,
              Lt.height
            )
          : Gn(Lt)
          ? tt.renderbufferStorageMultisampleEXT(
              s.RENDERBUFFER,
              Jn,
              an,
              Lt.width,
              Lt.height
            )
          : s.renderbufferStorage(s.RENDERBUFFER, an, Lt.width, Lt.height)
      }
    }
    s.bindRenderbuffer(s.RENDERBUFFER, null)
  }
  function on(Vt, Lt) {
    if (Lt && Lt.isWebGLCubeRenderTarget)
      throw new Error("Depth Texture with cube render targets is not supported")
    if (
      (a.bindFramebuffer(s.FRAMEBUFFER, Vt),
      !(Lt.depthTexture && Lt.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      )
    ;(!o.get(Lt.depthTexture).__webglTexture ||
      Lt.depthTexture.image.width !== Lt.width ||
      Lt.depthTexture.image.height !== Lt.height) &&
      ((Lt.depthTexture.image.width = Lt.width),
      (Lt.depthTexture.image.height = Lt.height),
      (Lt.depthTexture.needsUpdate = !0)),
      bt(Lt.depthTexture, 0)
    const xn = o.get(Lt.depthTexture).__webglTexture,
      vn = Pn(Lt)
    if (Lt.depthTexture.format === DepthFormat)
      Gn(Lt)
        ? tt.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            s.DEPTH_ATTACHMENT,
            s.TEXTURE_2D,
            xn,
            0,
            vn
          )
        : s.framebufferTexture2D(
            s.FRAMEBUFFER,
            s.DEPTH_ATTACHMENT,
            s.TEXTURE_2D,
            xn,
            0
          )
    else if (Lt.depthTexture.format === DepthStencilFormat)
      Gn(Lt)
        ? tt.framebufferTexture2DMultisampleEXT(
            s.FRAMEBUFFER,
            s.DEPTH_STENCIL_ATTACHMENT,
            s.TEXTURE_2D,
            xn,
            0,
            vn
          )
        : s.framebufferTexture2D(
            s.FRAMEBUFFER,
            s.DEPTH_STENCIL_ATTACHMENT,
            s.TEXTURE_2D,
            xn,
            0
          )
    else throw new Error("Unknown depthTexture format")
  }
  function Yt(Vt) {
    const Lt = o.get(Vt),
      Zt = Vt.isWebGLCubeRenderTarget === !0
    if (Vt.depthTexture && !Lt.__autoAllocateDepthBuffer) {
      if (Zt)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        )
      on(Lt.__webglFramebuffer, Vt)
    } else if (Zt) {
      Lt.__webglDepthbuffer = []
      for (let xn = 0; xn < 6; xn++)
        a.bindFramebuffer(s.FRAMEBUFFER, Lt.__webglFramebuffer[xn]),
          (Lt.__webglDepthbuffer[xn] = s.createRenderbuffer()),
          Ht(Lt.__webglDepthbuffer[xn], Vt, !1)
    } else
      a.bindFramebuffer(s.FRAMEBUFFER, Lt.__webglFramebuffer),
        (Lt.__webglDepthbuffer = s.createRenderbuffer()),
        Ht(Lt.__webglDepthbuffer, Vt, !1)
    a.bindFramebuffer(s.FRAMEBUFFER, null)
  }
  function _n(Vt, Lt, Zt) {
    const xn = o.get(Vt)
    Lt !== void 0 &&
      gn(
        xn.__webglFramebuffer,
        Vt,
        Vt.texture,
        s.COLOR_ATTACHMENT0,
        s.TEXTURE_2D,
        0
      ),
      Zt !== void 0 && Yt(Vt)
  }
  function pn(Vt) {
    const Lt = Vt.texture,
      Zt = o.get(Vt),
      xn = o.get(Lt)
    Vt.addEventListener("dispose", Ft),
      Vt.isWebGLMultipleRenderTargets !== !0 &&
        (xn.__webglTexture === void 0 &&
          (xn.__webglTexture = s.createTexture()),
        (xn.__version = Lt.version),
        g.memory.textures++)
    const vn = Vt.isWebGLCubeRenderTarget === !0,
      An = Vt.isWebGLMultipleRenderTargets === !0,
      Nn = ht(Vt) || _
    if (vn) {
      Zt.__webglFramebuffer = []
      for (let Sn = 0; Sn < 6; Sn++)
        if (_ && Lt.mipmaps && Lt.mipmaps.length > 0) {
          Zt.__webglFramebuffer[Sn] = []
          for (let an = 0; an < Lt.mipmaps.length; an++)
            Zt.__webglFramebuffer[Sn][an] = s.createFramebuffer()
        } else Zt.__webglFramebuffer[Sn] = s.createFramebuffer()
    } else {
      if (_ && Lt.mipmaps && Lt.mipmaps.length > 0) {
        Zt.__webglFramebuffer = []
        for (let Sn = 0; Sn < Lt.mipmaps.length; Sn++)
          Zt.__webglFramebuffer[Sn] = s.createFramebuffer()
      } else Zt.__webglFramebuffer = s.createFramebuffer()
      if (An)
        if (c.drawBuffers) {
          const Sn = Vt.texture
          for (let an = 0, Jn = Sn.length; an < Jn; an++) {
            const Hn = o.get(Sn[an])
            Hn.__webglTexture === void 0 &&
              ((Hn.__webglTexture = s.createTexture()), g.memory.textures++)
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          )
      if (_ && Vt.samples > 0 && Gn(Vt) === !1) {
        const Sn = An ? Lt : [Lt]
        ;(Zt.__webglMultisampledFramebuffer = s.createFramebuffer()),
          (Zt.__webglColorRenderbuffer = []),
          a.bindFramebuffer(s.FRAMEBUFFER, Zt.__webglMultisampledFramebuffer)
        for (let an = 0; an < Sn.length; an++) {
          const Jn = Sn[an]
          ;(Zt.__webglColorRenderbuffer[an] = s.createRenderbuffer()),
            s.bindRenderbuffer(s.RENDERBUFFER, Zt.__webglColorRenderbuffer[an])
          const Hn = d.convert(Jn.format, Jn.colorSpace),
            Fn = d.convert(Jn.type),
            Un = _t(
              Jn.internalFormat,
              Hn,
              Fn,
              Jn.colorSpace,
              Vt.isXRRenderTarget === !0
            ),
            Wt = Pn(Vt)
          s.renderbufferStorageMultisample(
            s.RENDERBUFFER,
            Wt,
            Un,
            Vt.width,
            Vt.height
          ),
            s.framebufferRenderbuffer(
              s.FRAMEBUFFER,
              s.COLOR_ATTACHMENT0 + an,
              s.RENDERBUFFER,
              Zt.__webglColorRenderbuffer[an]
            )
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null),
          Vt.depthBuffer &&
            ((Zt.__webglDepthRenderbuffer = s.createRenderbuffer()),
            Ht(Zt.__webglDepthRenderbuffer, Vt, !0)),
          a.bindFramebuffer(s.FRAMEBUFFER, null)
      }
    }
    if (vn) {
      a.bindTexture(s.TEXTURE_CUBE_MAP, xn.__webglTexture),
        yn(s.TEXTURE_CUBE_MAP, Lt, Nn)
      for (let Sn = 0; Sn < 6; Sn++)
        if (_ && Lt.mipmaps && Lt.mipmaps.length > 0)
          for (let an = 0; an < Lt.mipmaps.length; an++)
            gn(
              Zt.__webglFramebuffer[Sn][an],
              Vt,
              Lt,
              s.COLOR_ATTACHMENT0,
              s.TEXTURE_CUBE_MAP_POSITIVE_X + Sn,
              an
            )
        else
          gn(
            Zt.__webglFramebuffer[Sn],
            Vt,
            Lt,
            s.COLOR_ATTACHMENT0,
            s.TEXTURE_CUBE_MAP_POSITIVE_X + Sn,
            0
          )
      pt(Lt, Nn) && vt(s.TEXTURE_CUBE_MAP), a.unbindTexture()
    } else if (An) {
      const Sn = Vt.texture
      for (let an = 0, Jn = Sn.length; an < Jn; an++) {
        const Hn = Sn[an],
          Fn = o.get(Hn)
        a.bindTexture(s.TEXTURE_2D, Fn.__webglTexture),
          yn(s.TEXTURE_2D, Hn, Nn),
          gn(
            Zt.__webglFramebuffer,
            Vt,
            Hn,
            s.COLOR_ATTACHMENT0 + an,
            s.TEXTURE_2D,
            0
          ),
          pt(Hn, Nn) && vt(s.TEXTURE_2D)
      }
      a.unbindTexture()
    } else {
      let Sn = s.TEXTURE_2D
      if (
        ((Vt.isWebGL3DRenderTarget || Vt.isWebGLArrayRenderTarget) &&
          (_
            ? (Sn = Vt.isWebGL3DRenderTarget
                ? s.TEXTURE_3D
                : s.TEXTURE_2D_ARRAY)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
              )),
        a.bindTexture(Sn, xn.__webglTexture),
        yn(Sn, Lt, Nn),
        _ && Lt.mipmaps && Lt.mipmaps.length > 0)
      )
        for (let an = 0; an < Lt.mipmaps.length; an++)
          gn(Zt.__webglFramebuffer[an], Vt, Lt, s.COLOR_ATTACHMENT0, Sn, an)
      else gn(Zt.__webglFramebuffer, Vt, Lt, s.COLOR_ATTACHMENT0, Sn, 0)
      pt(Lt, Nn) && vt(Sn), a.unbindTexture()
    }
    Vt.depthBuffer && Yt(Vt)
  }
  function Rn(Vt) {
    const Lt = ht(Vt) || _,
      Zt = Vt.isWebGLMultipleRenderTargets === !0 ? Vt.texture : [Vt.texture]
    for (let xn = 0, vn = Zt.length; xn < vn; xn++) {
      const An = Zt[xn]
      if (pt(An, Lt)) {
        const Nn = Vt.isWebGLCubeRenderTarget
            ? s.TEXTURE_CUBE_MAP
            : s.TEXTURE_2D,
          Sn = o.get(An).__webglTexture
        a.bindTexture(Nn, Sn), vt(Nn), a.unbindTexture()
      }
    }
  }
  function bn(Vt) {
    if (_ && Vt.samples > 0 && Gn(Vt) === !1) {
      const Lt = Vt.isWebGLMultipleRenderTargets ? Vt.texture : [Vt.texture],
        Zt = Vt.width,
        xn = Vt.height
      let vn = s.COLOR_BUFFER_BIT
      const An = [],
        Nn = Vt.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT,
        Sn = o.get(Vt),
        an = Vt.isWebGLMultipleRenderTargets === !0
      if (an)
        for (let Jn = 0; Jn < Lt.length; Jn++)
          a.bindFramebuffer(s.FRAMEBUFFER, Sn.__webglMultisampledFramebuffer),
            s.framebufferRenderbuffer(
              s.FRAMEBUFFER,
              s.COLOR_ATTACHMENT0 + Jn,
              s.RENDERBUFFER,
              null
            ),
            a.bindFramebuffer(s.FRAMEBUFFER, Sn.__webglFramebuffer),
            s.framebufferTexture2D(
              s.DRAW_FRAMEBUFFER,
              s.COLOR_ATTACHMENT0 + Jn,
              s.TEXTURE_2D,
              null,
              0
            )
      a.bindFramebuffer(s.READ_FRAMEBUFFER, Sn.__webglMultisampledFramebuffer),
        a.bindFramebuffer(s.DRAW_FRAMEBUFFER, Sn.__webglFramebuffer)
      for (let Jn = 0; Jn < Lt.length; Jn++) {
        An.push(s.COLOR_ATTACHMENT0 + Jn), Vt.depthBuffer && An.push(Nn)
        const Hn =
          Sn.__ignoreDepthValues !== void 0 ? Sn.__ignoreDepthValues : !1
        if (
          (Hn === !1 &&
            (Vt.depthBuffer && (vn |= s.DEPTH_BUFFER_BIT),
            Vt.stencilBuffer && (vn |= s.STENCIL_BUFFER_BIT)),
          an &&
            s.framebufferRenderbuffer(
              s.READ_FRAMEBUFFER,
              s.COLOR_ATTACHMENT0,
              s.RENDERBUFFER,
              Sn.__webglColorRenderbuffer[Jn]
            ),
          Hn === !0 &&
            (s.invalidateFramebuffer(s.READ_FRAMEBUFFER, [Nn]),
            s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [Nn])),
          an)
        ) {
          const Fn = o.get(Lt[Jn]).__webglTexture
          s.framebufferTexture2D(
            s.DRAW_FRAMEBUFFER,
            s.COLOR_ATTACHMENT0,
            s.TEXTURE_2D,
            Fn,
            0
          )
        }
        s.blitFramebuffer(0, 0, Zt, xn, 0, 0, Zt, xn, vn, s.NEAREST),
          st && s.invalidateFramebuffer(s.READ_FRAMEBUFFER, An)
      }
      if (
        (a.bindFramebuffer(s.READ_FRAMEBUFFER, null),
        a.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
        an)
      )
        for (let Jn = 0; Jn < Lt.length; Jn++) {
          a.bindFramebuffer(s.FRAMEBUFFER, Sn.__webglMultisampledFramebuffer),
            s.framebufferRenderbuffer(
              s.FRAMEBUFFER,
              s.COLOR_ATTACHMENT0 + Jn,
              s.RENDERBUFFER,
              Sn.__webglColorRenderbuffer[Jn]
            )
          const Hn = o.get(Lt[Jn]).__webglTexture
          a.bindFramebuffer(s.FRAMEBUFFER, Sn.__webglFramebuffer),
            s.framebufferTexture2D(
              s.DRAW_FRAMEBUFFER,
              s.COLOR_ATTACHMENT0 + Jn,
              s.TEXTURE_2D,
              Hn,
              0
            )
        }
      a.bindFramebuffer(s.DRAW_FRAMEBUFFER, Sn.__webglMultisampledFramebuffer)
    }
  }
  function Pn(Vt) {
    return Math.min(_e, Vt.samples)
  }
  function Gn(Vt) {
    const Lt = o.get(Vt)
    return (
      _ &&
      Vt.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      Lt.__useRenderToTexture !== !1
    )
  }
  function jn(Vt) {
    const Lt = g.render.frame
    at.get(Vt) !== Lt && (at.set(Vt, Lt), Vt.update())
  }
  function ar(Vt, Lt) {
    const Zt = Vt.colorSpace,
      xn = Vt.format,
      vn = Vt.type
    return (
      Vt.isCompressedTexture === !0 ||
        Vt.isVideoTexture === !0 ||
        Vt.format === _SRGBAFormat ||
        (Zt !== LinearSRGBColorSpace &&
          Zt !== NoColorSpace &&
          (Zt === SRGBColorSpace || Zt === DisplayP3ColorSpace
            ? _ === !1
              ? e.has("EXT_sRGB") === !0 && xn === RGBAFormat
                ? ((Vt.format = _SRGBAFormat),
                  (Vt.minFilter = LinearFilter),
                  (Vt.generateMipmaps = !1))
                : (Lt = ImageUtils.sRGBToLinear(Lt))
              : (xn !== RGBAFormat || vn !== UnsignedByteType) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                Zt
              ))),
      Lt
    )
  }
  ;(this.allocateTextureUnit = gt),
    (this.resetTextureUnits = wt),
    (this.setTexture2D = bt),
    (this.setTexture2DArray = Tt),
    (this.setTexture3D = It),
    (this.setTextureCube = $t),
    (this.rebindTextures = _n),
    (this.setupRenderTarget = pn),
    (this.updateRenderTargetMipmap = Rn),
    (this.updateMultisampleRenderTarget = bn),
    (this.setupDepthRenderbuffer = Yt),
    (this.setupFrameBufferTexture = gn),
    (this.useMultisampledRTT = Gn)
}
const LinearTransferFunction = 0,
  SRGBTransferFunction = 1
function WebGLUtils(s, e, a) {
  const o = a.isWebGL2
  function c(d, g = NoColorSpace) {
    let _
    const b =
      g === SRGBColorSpace || g === DisplayP3ColorSpace
        ? SRGBTransferFunction
        : LinearTransferFunction
    if (d === UnsignedByteType) return s.UNSIGNED_BYTE
    if (d === UnsignedShort4444Type) return s.UNSIGNED_SHORT_4_4_4_4
    if (d === UnsignedShort5551Type) return s.UNSIGNED_SHORT_5_5_5_1
    if (d === ByteType) return s.BYTE
    if (d === ShortType) return s.SHORT
    if (d === UnsignedShortType) return s.UNSIGNED_SHORT
    if (d === IntType) return s.INT
    if (d === UnsignedIntType) return s.UNSIGNED_INT
    if (d === FloatType) return s.FLOAT
    if (d === HalfFloatType)
      return o
        ? s.HALF_FLOAT
        : ((_ = e.get("OES_texture_half_float")),
          _ !== null ? _.HALF_FLOAT_OES : null)
    if (d === AlphaFormat) return s.ALPHA
    if (d === RGBAFormat) return s.RGBA
    if (d === LuminanceFormat) return s.LUMINANCE
    if (d === LuminanceAlphaFormat) return s.LUMINANCE_ALPHA
    if (d === DepthFormat) return s.DEPTH_COMPONENT
    if (d === DepthStencilFormat) return s.DEPTH_STENCIL
    if (d === _SRGBAFormat)
      return (_ = e.get("EXT_sRGB")), _ !== null ? _.SRGB_ALPHA_EXT : null
    if (d === RedFormat) return s.RED
    if (d === RedIntegerFormat) return s.RED_INTEGER
    if (d === RGFormat) return s.RG
    if (d === RGIntegerFormat) return s.RG_INTEGER
    if (d === RGBAIntegerFormat) return s.RGBA_INTEGER
    if (
      d === RGB_S3TC_DXT1_Format ||
      d === RGBA_S3TC_DXT1_Format ||
      d === RGBA_S3TC_DXT3_Format ||
      d === RGBA_S3TC_DXT5_Format
    )
      if (b === SRGBTransferFunction)
        if (((_ = e.get("WEBGL_compressed_texture_s3tc_srgb")), _ !== null)) {
          if (d === RGB_S3TC_DXT1_Format) return _.COMPRESSED_SRGB_S3TC_DXT1_EXT
          if (d === RGBA_S3TC_DXT1_Format)
            return _.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
          if (d === RGBA_S3TC_DXT3_Format)
            return _.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
          if (d === RGBA_S3TC_DXT5_Format)
            return _.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } else return null
      else if (((_ = e.get("WEBGL_compressed_texture_s3tc")), _ !== null)) {
        if (d === RGB_S3TC_DXT1_Format) return _.COMPRESSED_RGB_S3TC_DXT1_EXT
        if (d === RGBA_S3TC_DXT1_Format) return _.COMPRESSED_RGBA_S3TC_DXT1_EXT
        if (d === RGBA_S3TC_DXT3_Format) return _.COMPRESSED_RGBA_S3TC_DXT3_EXT
        if (d === RGBA_S3TC_DXT5_Format) return _.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } else return null
    if (
      d === RGB_PVRTC_4BPPV1_Format ||
      d === RGB_PVRTC_2BPPV1_Format ||
      d === RGBA_PVRTC_4BPPV1_Format ||
      d === RGBA_PVRTC_2BPPV1_Format
    )
      if (((_ = e.get("WEBGL_compressed_texture_pvrtc")), _ !== null)) {
        if (d === RGB_PVRTC_4BPPV1_Format)
          return _.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        if (d === RGB_PVRTC_2BPPV1_Format)
          return _.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
        if (d === RGBA_PVRTC_4BPPV1_Format)
          return _.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        if (d === RGBA_PVRTC_2BPPV1_Format)
          return _.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
      } else return null
    if (d === RGB_ETC1_Format)
      return (
        (_ = e.get("WEBGL_compressed_texture_etc1")),
        _ !== null ? _.COMPRESSED_RGB_ETC1_WEBGL : null
      )
    if (d === RGB_ETC2_Format || d === RGBA_ETC2_EAC_Format)
      if (((_ = e.get("WEBGL_compressed_texture_etc")), _ !== null)) {
        if (d === RGB_ETC2_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ETC2
            : _.COMPRESSED_RGB8_ETC2
        if (d === RGBA_ETC2_EAC_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : _.COMPRESSED_RGBA8_ETC2_EAC
      } else return null
    if (
      d === RGBA_ASTC_4x4_Format ||
      d === RGBA_ASTC_5x4_Format ||
      d === RGBA_ASTC_5x5_Format ||
      d === RGBA_ASTC_6x5_Format ||
      d === RGBA_ASTC_6x6_Format ||
      d === RGBA_ASTC_8x5_Format ||
      d === RGBA_ASTC_8x6_Format ||
      d === RGBA_ASTC_8x8_Format ||
      d === RGBA_ASTC_10x5_Format ||
      d === RGBA_ASTC_10x6_Format ||
      d === RGBA_ASTC_10x8_Format ||
      d === RGBA_ASTC_10x10_Format ||
      d === RGBA_ASTC_12x10_Format ||
      d === RGBA_ASTC_12x12_Format
    )
      if (((_ = e.get("WEBGL_compressed_texture_astc")), _ !== null)) {
        if (d === RGBA_ASTC_4x4_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : _.COMPRESSED_RGBA_ASTC_4x4_KHR
        if (d === RGBA_ASTC_5x4_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : _.COMPRESSED_RGBA_ASTC_5x4_KHR
        if (d === RGBA_ASTC_5x5_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : _.COMPRESSED_RGBA_ASTC_5x5_KHR
        if (d === RGBA_ASTC_6x5_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : _.COMPRESSED_RGBA_ASTC_6x5_KHR
        if (d === RGBA_ASTC_6x6_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : _.COMPRESSED_RGBA_ASTC_6x6_KHR
        if (d === RGBA_ASTC_8x5_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : _.COMPRESSED_RGBA_ASTC_8x5_KHR
        if (d === RGBA_ASTC_8x6_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : _.COMPRESSED_RGBA_ASTC_8x6_KHR
        if (d === RGBA_ASTC_8x8_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : _.COMPRESSED_RGBA_ASTC_8x8_KHR
        if (d === RGBA_ASTC_10x5_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : _.COMPRESSED_RGBA_ASTC_10x5_KHR
        if (d === RGBA_ASTC_10x6_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : _.COMPRESSED_RGBA_ASTC_10x6_KHR
        if (d === RGBA_ASTC_10x8_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : _.COMPRESSED_RGBA_ASTC_10x8_KHR
        if (d === RGBA_ASTC_10x10_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : _.COMPRESSED_RGBA_ASTC_10x10_KHR
        if (d === RGBA_ASTC_12x10_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : _.COMPRESSED_RGBA_ASTC_12x10_KHR
        if (d === RGBA_ASTC_12x12_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : _.COMPRESSED_RGBA_ASTC_12x12_KHR
      } else return null
    if (
      d === RGBA_BPTC_Format ||
      d === RGB_BPTC_SIGNED_Format ||
      d === RGB_BPTC_UNSIGNED_Format
    )
      if (((_ = e.get("EXT_texture_compression_bptc")), _ !== null)) {
        if (d === RGBA_BPTC_Format)
          return b === SRGBTransferFunction
            ? _.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : _.COMPRESSED_RGBA_BPTC_UNORM_EXT
        if (d === RGB_BPTC_SIGNED_Format)
          return _.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT
        if (d === RGB_BPTC_UNSIGNED_Format)
          return _.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
      } else return null
    if (
      d === RED_RGTC1_Format ||
      d === SIGNED_RED_RGTC1_Format ||
      d === RED_GREEN_RGTC2_Format ||
      d === SIGNED_RED_GREEN_RGTC2_Format
    )
      if (((_ = e.get("EXT_texture_compression_rgtc")), _ !== null)) {
        if (d === RGBA_BPTC_Format) return _.COMPRESSED_RED_RGTC1_EXT
        if (d === SIGNED_RED_RGTC1_Format)
          return _.COMPRESSED_SIGNED_RED_RGTC1_EXT
        if (d === RED_GREEN_RGTC2_Format)
          return _.COMPRESSED_RED_GREEN_RGTC2_EXT
        if (d === SIGNED_RED_GREEN_RGTC2_Format)
          return _.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
      } else return null
    return d === UnsignedInt248Type
      ? o
        ? s.UNSIGNED_INT_24_8
        : ((_ = e.get("WEBGL_depth_texture")),
          _ !== null ? _.UNSIGNED_INT_24_8_WEBGL : null)
      : s[d] !== void 0
      ? s[d]
      : null
  }
  return { convert: c }
}
class ArrayCamera extends PerspectiveCamera {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e)
  }
}
class Group extends Object3D {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group")
  }
}
const _moveEvent = { type: "move" }
class WebXRController {
  constructor() {
    ;(this._targetRay = null), (this._grip = null), (this._hand = null)
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Group()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    )
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Group()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Vector3()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Vector3())),
      this._targetRay
    )
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Group()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Vector3()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Vector3())),
      this._grip
    )
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    )
  }
  connect(e) {
    if (e && e.hand) {
      const a = this._hand
      if (a) for (const o of e.hand.values()) this._getHandJoint(a, o)
    }
    return this.dispatchEvent({ type: "connected", data: e }), this
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    )
  }
  update(e, a, o) {
    let c = null,
      d = null,
      g = null
    const _ = this._targetRay,
      b = this._grip,
      j = this._hand
    if (e && a.session.visibilityState !== "visible-blurred") {
      if (j && e.hand) {
        g = !0
        for (const ot of e.hand.values()) {
          const ut = a.getJointPose(ot, o),
            it = this._getHandJoint(j, ot)
          ut !== null &&
            (it.matrix.fromArray(ut.transform.matrix),
            it.matrix.decompose(it.position, it.rotation, it.scale),
            (it.matrixWorldNeedsUpdate = !0),
            (it.jointRadius = ut.radius)),
            (it.visible = ut !== null)
        }
        const $ = j.joints["index-finger-tip"],
          _e = j.joints["thumb-tip"],
          tt = $.position.distanceTo(_e.position),
          st = 0.02,
          at = 0.005
        j.inputState.pinching && tt > st + at
          ? ((j.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !j.inputState.pinching &&
            tt <= st - at &&
            ((j.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }))
      } else
        b !== null &&
          e.gripSpace &&
          ((d = a.getPose(e.gripSpace, o)),
          d !== null &&
            (b.matrix.fromArray(d.transform.matrix),
            b.matrix.decompose(b.position, b.rotation, b.scale),
            (b.matrixWorldNeedsUpdate = !0),
            d.linearVelocity
              ? ((b.hasLinearVelocity = !0),
                b.linearVelocity.copy(d.linearVelocity))
              : (b.hasLinearVelocity = !1),
            d.angularVelocity
              ? ((b.hasAngularVelocity = !0),
                b.angularVelocity.copy(d.angularVelocity))
              : (b.hasAngularVelocity = !1)))
      _ !== null &&
        ((c = a.getPose(e.targetRaySpace, o)),
        c === null && d !== null && (c = d),
        c !== null &&
          (_.matrix.fromArray(c.transform.matrix),
          _.matrix.decompose(_.position, _.rotation, _.scale),
          (_.matrixWorldNeedsUpdate = !0),
          c.linearVelocity
            ? ((_.hasLinearVelocity = !0),
              _.linearVelocity.copy(c.linearVelocity))
            : (_.hasLinearVelocity = !1),
          c.angularVelocity
            ? ((_.hasAngularVelocity = !0),
              _.angularVelocity.copy(c.angularVelocity))
            : (_.hasAngularVelocity = !1),
          this.dispatchEvent(_moveEvent)))
    }
    return (
      _ !== null && (_.visible = c !== null),
      b !== null && (b.visible = d !== null),
      j !== null && (j.visible = g !== null),
      this
    )
  }
  _getHandJoint(e, a) {
    if (e.joints[a.jointName] === void 0) {
      const o = new Group()
      ;(o.matrixAutoUpdate = !1),
        (o.visible = !1),
        (e.joints[a.jointName] = o),
        e.add(o)
    }
    return e.joints[a.jointName]
  }
}
class DepthTexture extends Texture {
  constructor(e, a, o, c, d, g, _, b, j, $) {
    if (
      (($ = $ !== void 0 ? $ : DepthFormat),
      $ !== DepthFormat && $ !== DepthStencilFormat)
    )
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      )
    o === void 0 && $ === DepthFormat && (o = UnsignedIntType),
      o === void 0 && $ === DepthStencilFormat && (o = UnsignedInt248Type),
      super(null, c, d, g, _, b, $, o, j),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: a }),
      (this.magFilter = _ !== void 0 ? _ : NearestFilter),
      (this.minFilter = b !== void 0 ? b : NearestFilter),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null)
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this
  }
  toJSON(e) {
    const a = super.toJSON(e)
    return (
      this.compareFunction !== null &&
        (a.compareFunction = this.compareFunction),
      a
    )
  }
}
class WebXRManager extends EventDispatcher {
  constructor(e, a) {
    super()
    const o = this
    let c = null,
      d = 1,
      g = null,
      _ = "local-floor",
      b = 1,
      j = null,
      $ = null,
      _e = null,
      tt = null,
      st = null,
      at = null
    const ot = a.getContextAttributes()
    let ut = null,
      it = null
    const ct = [],
      lt = [],
      ht = new PerspectiveCamera()
    ht.layers.enable(1), (ht.viewport = new Vector4())
    const dt = new PerspectiveCamera()
    dt.layers.enable(2), (dt.viewport = new Vector4())
    const pt = [ht, dt],
      vt = new ArrayCamera()
    vt.layers.enable(1), vt.layers.enable(2)
    let _t = null,
      yt = null
    ;(this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (Tt) {
        let It = ct[Tt]
        return (
          It === void 0 && ((It = new WebXRController()), (ct[Tt] = It)),
          It.getTargetRaySpace()
        )
      }),
      (this.getControllerGrip = function (Tt) {
        let It = ct[Tt]
        return (
          It === void 0 && ((It = new WebXRController()), (ct[Tt] = It)),
          It.getGripSpace()
        )
      }),
      (this.getHand = function (Tt) {
        let It = ct[Tt]
        return (
          It === void 0 && ((It = new WebXRController()), (ct[Tt] = It)),
          It.getHandSpace()
        )
      })
    function Et(Tt) {
      const It = lt.indexOf(Tt.inputSource)
      if (It === -1) return
      const $t = ct[It]
      $t !== void 0 &&
        ($t.update(Tt.inputSource, Tt.frame, j || g),
        $t.dispatchEvent({ type: Tt.type, data: Tt.inputSource }))
    }
    function Rt() {
      c.removeEventListener("select", Et),
        c.removeEventListener("selectstart", Et),
        c.removeEventListener("selectend", Et),
        c.removeEventListener("squeeze", Et),
        c.removeEventListener("squeezestart", Et),
        c.removeEventListener("squeezeend", Et),
        c.removeEventListener("end", Rt),
        c.removeEventListener("inputsourceschange", Ft)
      for (let Tt = 0; Tt < ct.length; Tt++) {
        const It = lt[Tt]
        It !== null && ((lt[Tt] = null), ct[Tt].disconnect(It))
      }
      ;(_t = null),
        (yt = null),
        e.setRenderTarget(ut),
        (st = null),
        (tt = null),
        (_e = null),
        (c = null),
        (it = null),
        bt.stop(),
        (o.isPresenting = !1),
        o.dispatchEvent({ type: "sessionend" })
    }
    ;(this.setFramebufferScaleFactor = function (Tt) {
      ;(d = Tt),
        o.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          )
    }),
      (this.setReferenceSpaceType = function (Tt) {
        ;(_ = Tt),
          o.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            )
      }),
      (this.getReferenceSpace = function () {
        return j || g
      }),
      (this.setReferenceSpace = function (Tt) {
        j = Tt
      }),
      (this.getBaseLayer = function () {
        return tt !== null ? tt : st
      }),
      (this.getBinding = function () {
        return _e
      }),
      (this.getFrame = function () {
        return at
      }),
      (this.getSession = function () {
        return c
      }),
      (this.setSession = async function (Tt) {
        if (((c = Tt), c !== null)) {
          if (
            ((ut = e.getRenderTarget()),
            c.addEventListener("select", Et),
            c.addEventListener("selectstart", Et),
            c.addEventListener("selectend", Et),
            c.addEventListener("squeeze", Et),
            c.addEventListener("squeezestart", Et),
            c.addEventListener("squeezeend", Et),
            c.addEventListener("end", Rt),
            c.addEventListener("inputsourceschange", Ft),
            ot.xrCompatible !== !0 && (await a.makeXRCompatible()),
            c.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const It = {
              antialias: c.renderState.layers === void 0 ? ot.antialias : !0,
              alpha: !0,
              depth: ot.depth,
              stencil: ot.stencil,
              framebufferScaleFactor: d,
            }
            ;(st = new XRWebGLLayer(c, a, It)),
              c.updateRenderState({ baseLayer: st }),
              (it = new WebGLRenderTarget(
                st.framebufferWidth,
                st.framebufferHeight,
                {
                  format: RGBAFormat,
                  type: UnsignedByteType,
                  colorSpace: e.outputColorSpace,
                  stencilBuffer: ot.stencil,
                }
              ))
          } else {
            let It = null,
              $t = null,
              Xt = null
            ot.depth &&
              ((Xt = ot.stencil ? a.DEPTH24_STENCIL8 : a.DEPTH_COMPONENT24),
              (It = ot.stencil ? DepthStencilFormat : DepthFormat),
              ($t = ot.stencil ? UnsignedInt248Type : UnsignedIntType))
            const qt = { colorFormat: a.RGBA8, depthFormat: Xt, scaleFactor: d }
            ;(_e = new XRWebGLBinding(c, a)),
              (tt = _e.createProjectionLayer(qt)),
              c.updateRenderState({ layers: [tt] }),
              (it = new WebGLRenderTarget(tt.textureWidth, tt.textureHeight, {
                format: RGBAFormat,
                type: UnsignedByteType,
                depthTexture: new DepthTexture(
                  tt.textureWidth,
                  tt.textureHeight,
                  $t,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  It
                ),
                stencilBuffer: ot.stencil,
                colorSpace: e.outputColorSpace,
                samples: ot.antialias ? 4 : 0,
              }))
            const en = e.properties.get(it)
            en.__ignoreDepthValues = tt.ignoreDepthValues
          }
          ;(it.isXRRenderTarget = !0),
            this.setFoveation(b),
            (j = null),
            (g = await c.requestReferenceSpace(_)),
            bt.setContext(c),
            bt.start(),
            (o.isPresenting = !0),
            o.dispatchEvent({ type: "sessionstart" })
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (c !== null) return c.environmentBlendMode
      })
    function Ft(Tt) {
      for (let It = 0; It < Tt.removed.length; It++) {
        const $t = Tt.removed[It],
          Xt = lt.indexOf($t)
        Xt >= 0 && ((lt[Xt] = null), ct[Xt].disconnect($t))
      }
      for (let It = 0; It < Tt.added.length; It++) {
        const $t = Tt.added[It]
        let Xt = lt.indexOf($t)
        if (Xt === -1) {
          for (let en = 0; en < ct.length; en++)
            if (en >= lt.length) {
              lt.push($t), (Xt = en)
              break
            } else if (lt[en] === null) {
              ;(lt[en] = $t), (Xt = en)
              break
            }
          if (Xt === -1) break
        }
        const qt = ct[Xt]
        qt && qt.connect($t)
      }
    }
    const kt = new Vector3(),
      Nt = new Vector3()
    function Dt(Tt, It, $t) {
      kt.setFromMatrixPosition(It.matrixWorld),
        Nt.setFromMatrixPosition($t.matrixWorld)
      const Xt = kt.distanceTo(Nt),
        qt = It.projectionMatrix.elements,
        en = $t.projectionMatrix.elements,
        yn = qt[14] / (qt[10] - 1),
        Tn = qt[14] / (qt[10] + 1),
        $n = (qt[9] + 1) / qt[5],
        Vn = (qt[9] - 1) / qt[5],
        gn = (qt[8] - 1) / qt[0],
        Ht = (en[8] + 1) / en[0],
        on = yn * gn,
        Yt = yn * Ht,
        _n = Xt / (-gn + Ht),
        pn = _n * -gn
      It.matrixWorld.decompose(Tt.position, Tt.quaternion, Tt.scale),
        Tt.translateX(pn),
        Tt.translateZ(_n),
        Tt.matrixWorld.compose(Tt.position, Tt.quaternion, Tt.scale),
        Tt.matrixWorldInverse.copy(Tt.matrixWorld).invert()
      const Rn = yn + _n,
        bn = Tn + _n,
        Pn = on - pn,
        Gn = Yt + (Xt - pn),
        jn = (($n * Tn) / bn) * Rn,
        ar = ((Vn * Tn) / bn) * Rn
      Tt.projectionMatrix.makePerspective(Pn, Gn, jn, ar, Rn, bn),
        Tt.projectionMatrixInverse.copy(Tt.projectionMatrix).invert()
    }
    function Mt(Tt, It) {
      It === null
        ? Tt.matrixWorld.copy(Tt.matrix)
        : Tt.matrixWorld.multiplyMatrices(It.matrixWorld, Tt.matrix),
        Tt.matrixWorldInverse.copy(Tt.matrixWorld).invert()
    }
    this.updateCamera = function (Tt) {
      if (c === null) return
      ;(vt.near = dt.near = ht.near = Tt.near),
        (vt.far = dt.far = ht.far = Tt.far),
        (_t !== vt.near || yt !== vt.far) &&
          (c.updateRenderState({ depthNear: vt.near, depthFar: vt.far }),
          (_t = vt.near),
          (yt = vt.far))
      const It = Tt.parent,
        $t = vt.cameras
      Mt(vt, It)
      for (let Xt = 0; Xt < $t.length; Xt++) Mt($t[Xt], It)
      $t.length === 2
        ? Dt(vt, ht, dt)
        : vt.projectionMatrix.copy(ht.projectionMatrix),
        wt(Tt, vt, It)
    }
    function wt(Tt, It, $t) {
      $t === null
        ? Tt.matrix.copy(It.matrixWorld)
        : (Tt.matrix.copy($t.matrixWorld),
          Tt.matrix.invert(),
          Tt.matrix.multiply(It.matrixWorld)),
        Tt.matrix.decompose(Tt.position, Tt.quaternion, Tt.scale),
        Tt.updateMatrixWorld(!0),
        Tt.projectionMatrix.copy(It.projectionMatrix),
        Tt.projectionMatrixInverse.copy(It.projectionMatrixInverse),
        Tt.isPerspectiveCamera &&
          ((Tt.fov =
            RAD2DEG * 2 * Math.atan(1 / Tt.projectionMatrix.elements[5])),
          (Tt.zoom = 1))
    }
    ;(this.getCamera = function () {
      return vt
    }),
      (this.getFoveation = function () {
        if (!(tt === null && st === null)) return b
      }),
      (this.setFoveation = function (Tt) {
        ;(b = Tt),
          tt !== null && (tt.fixedFoveation = Tt),
          st !== null &&
            st.fixedFoveation !== void 0 &&
            (st.fixedFoveation = Tt)
      })
    let gt = null
    function At(Tt, It) {
      if ((($ = It.getViewerPose(j || g)), (at = It), $ !== null)) {
        const $t = $.views
        st !== null &&
          (e.setRenderTargetFramebuffer(it, st.framebuffer),
          e.setRenderTarget(it))
        let Xt = !1
        $t.length !== vt.cameras.length && ((vt.cameras.length = 0), (Xt = !0))
        for (let qt = 0; qt < $t.length; qt++) {
          const en = $t[qt]
          let yn = null
          if (st !== null) yn = st.getViewport(en)
          else {
            const $n = _e.getViewSubImage(tt, en)
            ;(yn = $n.viewport),
              qt === 0 &&
                (e.setRenderTargetTextures(
                  it,
                  $n.colorTexture,
                  tt.ignoreDepthValues ? void 0 : $n.depthStencilTexture
                ),
                e.setRenderTarget(it))
          }
          let Tn = pt[qt]
          Tn === void 0 &&
            ((Tn = new PerspectiveCamera()),
            Tn.layers.enable(qt),
            (Tn.viewport = new Vector4()),
            (pt[qt] = Tn)),
            Tn.matrix.fromArray(en.transform.matrix),
            Tn.matrix.decompose(Tn.position, Tn.quaternion, Tn.scale),
            Tn.projectionMatrix.fromArray(en.projectionMatrix),
            Tn.projectionMatrixInverse.copy(Tn.projectionMatrix).invert(),
            Tn.viewport.set(yn.x, yn.y, yn.width, yn.height),
            qt === 0 &&
              (vt.matrix.copy(Tn.matrix),
              vt.matrix.decompose(vt.position, vt.quaternion, vt.scale)),
            Xt === !0 && vt.cameras.push(Tn)
        }
      }
      for (let $t = 0; $t < ct.length; $t++) {
        const Xt = lt[$t],
          qt = ct[$t]
        Xt !== null && qt !== void 0 && qt.update(Xt, It, j || g)
      }
      gt && gt(Tt, It),
        It.detectedPlanes &&
          o.dispatchEvent({ type: "planesdetected", data: It }),
        (at = null)
    }
    const bt = new WebGLAnimation()
    bt.setAnimationLoop(At),
      (this.setAnimationLoop = function (Tt) {
        gt = Tt
      }),
      (this.dispose = function () {})
  }
}
function WebGLMaterials(s, e) {
  function a(ut, it) {
    ut.matrixAutoUpdate === !0 && ut.updateMatrix(), it.value.copy(ut.matrix)
  }
  function o(ut, it) {
    it.color.getRGB(ut.fogColor.value, getUnlitUniformColorSpace(s)),
      it.isFog
        ? ((ut.fogNear.value = it.near), (ut.fogFar.value = it.far))
        : it.isFogExp2 && (ut.fogDensity.value = it.density)
  }
  function c(ut, it, ct, lt, ht) {
    it.isMeshBasicMaterial || it.isMeshLambertMaterial
      ? d(ut, it)
      : it.isMeshToonMaterial
      ? (d(ut, it), _e(ut, it))
      : it.isMeshPhongMaterial
      ? (d(ut, it), $(ut, it))
      : it.isMeshStandardMaterial
      ? (d(ut, it), tt(ut, it), it.isMeshPhysicalMaterial && st(ut, it, ht))
      : it.isMeshMatcapMaterial
      ? (d(ut, it), at(ut, it))
      : it.isMeshDepthMaterial
      ? d(ut, it)
      : it.isMeshDistanceMaterial
      ? (d(ut, it), ot(ut, it))
      : it.isMeshNormalMaterial
      ? d(ut, it)
      : it.isLineBasicMaterial
      ? (g(ut, it), it.isLineDashedMaterial && _(ut, it))
      : it.isPointsMaterial
      ? b(ut, it, ct, lt)
      : it.isSpriteMaterial
      ? j(ut, it)
      : it.isShadowMaterial
      ? (ut.color.value.copy(it.color), (ut.opacity.value = it.opacity))
      : it.isShaderMaterial && (it.uniformsNeedUpdate = !1)
  }
  function d(ut, it) {
    ;(ut.opacity.value = it.opacity),
      it.color && ut.diffuse.value.copy(it.color),
      it.emissive &&
        ut.emissive.value
          .copy(it.emissive)
          .multiplyScalar(it.emissiveIntensity),
      it.map && ((ut.map.value = it.map), a(it.map, ut.mapTransform)),
      it.alphaMap &&
        ((ut.alphaMap.value = it.alphaMap),
        a(it.alphaMap, ut.alphaMapTransform)),
      it.bumpMap &&
        ((ut.bumpMap.value = it.bumpMap),
        a(it.bumpMap, ut.bumpMapTransform),
        (ut.bumpScale.value = it.bumpScale),
        it.side === BackSide && (ut.bumpScale.value *= -1)),
      it.normalMap &&
        ((ut.normalMap.value = it.normalMap),
        a(it.normalMap, ut.normalMapTransform),
        ut.normalScale.value.copy(it.normalScale),
        it.side === BackSide && ut.normalScale.value.negate()),
      it.displacementMap &&
        ((ut.displacementMap.value = it.displacementMap),
        a(it.displacementMap, ut.displacementMapTransform),
        (ut.displacementScale.value = it.displacementScale),
        (ut.displacementBias.value = it.displacementBias)),
      it.emissiveMap &&
        ((ut.emissiveMap.value = it.emissiveMap),
        a(it.emissiveMap, ut.emissiveMapTransform)),
      it.specularMap &&
        ((ut.specularMap.value = it.specularMap),
        a(it.specularMap, ut.specularMapTransform)),
      it.alphaTest > 0 && (ut.alphaTest.value = it.alphaTest)
    const ct = e.get(it).envMap
    if (
      (ct &&
        ((ut.envMap.value = ct),
        (ut.flipEnvMap.value =
          ct.isCubeTexture && ct.isRenderTargetTexture === !1 ? -1 : 1),
        (ut.reflectivity.value = it.reflectivity),
        (ut.ior.value = it.ior),
        (ut.refractionRatio.value = it.refractionRatio)),
      it.lightMap)
    ) {
      ut.lightMap.value = it.lightMap
      const lt = s._useLegacyLights === !0 ? Math.PI : 1
      ;(ut.lightMapIntensity.value = it.lightMapIntensity * lt),
        a(it.lightMap, ut.lightMapTransform)
    }
    it.aoMap &&
      ((ut.aoMap.value = it.aoMap),
      (ut.aoMapIntensity.value = it.aoMapIntensity),
      a(it.aoMap, ut.aoMapTransform))
  }
  function g(ut, it) {
    ut.diffuse.value.copy(it.color),
      (ut.opacity.value = it.opacity),
      it.map && ((ut.map.value = it.map), a(it.map, ut.mapTransform))
  }
  function _(ut, it) {
    ;(ut.dashSize.value = it.dashSize),
      (ut.totalSize.value = it.dashSize + it.gapSize),
      (ut.scale.value = it.scale)
  }
  function b(ut, it, ct, lt) {
    ut.diffuse.value.copy(it.color),
      (ut.opacity.value = it.opacity),
      (ut.size.value = it.size * ct),
      (ut.scale.value = lt * 0.5),
      it.map && ((ut.map.value = it.map), a(it.map, ut.uvTransform)),
      it.alphaMap &&
        ((ut.alphaMap.value = it.alphaMap),
        a(it.alphaMap, ut.alphaMapTransform)),
      it.alphaTest > 0 && (ut.alphaTest.value = it.alphaTest)
  }
  function j(ut, it) {
    ut.diffuse.value.copy(it.color),
      (ut.opacity.value = it.opacity),
      (ut.rotation.value = it.rotation),
      it.map && ((ut.map.value = it.map), a(it.map, ut.mapTransform)),
      it.alphaMap &&
        ((ut.alphaMap.value = it.alphaMap),
        a(it.alphaMap, ut.alphaMapTransform)),
      it.alphaTest > 0 && (ut.alphaTest.value = it.alphaTest)
  }
  function $(ut, it) {
    ut.specular.value.copy(it.specular),
      (ut.shininess.value = Math.max(it.shininess, 1e-4))
  }
  function _e(ut, it) {
    it.gradientMap && (ut.gradientMap.value = it.gradientMap)
  }
  function tt(ut, it) {
    ;(ut.metalness.value = it.metalness),
      it.metalnessMap &&
        ((ut.metalnessMap.value = it.metalnessMap),
        a(it.metalnessMap, ut.metalnessMapTransform)),
      (ut.roughness.value = it.roughness),
      it.roughnessMap &&
        ((ut.roughnessMap.value = it.roughnessMap),
        a(it.roughnessMap, ut.roughnessMapTransform)),
      e.get(it).envMap && (ut.envMapIntensity.value = it.envMapIntensity)
  }
  function st(ut, it, ct) {
    ;(ut.ior.value = it.ior),
      it.sheen > 0 &&
        (ut.sheenColor.value.copy(it.sheenColor).multiplyScalar(it.sheen),
        (ut.sheenRoughness.value = it.sheenRoughness),
        it.sheenColorMap &&
          ((ut.sheenColorMap.value = it.sheenColorMap),
          a(it.sheenColorMap, ut.sheenColorMapTransform)),
        it.sheenRoughnessMap &&
          ((ut.sheenRoughnessMap.value = it.sheenRoughnessMap),
          a(it.sheenRoughnessMap, ut.sheenRoughnessMapTransform))),
      it.clearcoat > 0 &&
        ((ut.clearcoat.value = it.clearcoat),
        (ut.clearcoatRoughness.value = it.clearcoatRoughness),
        it.clearcoatMap &&
          ((ut.clearcoatMap.value = it.clearcoatMap),
          a(it.clearcoatMap, ut.clearcoatMapTransform)),
        it.clearcoatRoughnessMap &&
          ((ut.clearcoatRoughnessMap.value = it.clearcoatRoughnessMap),
          a(it.clearcoatRoughnessMap, ut.clearcoatRoughnessMapTransform)),
        it.clearcoatNormalMap &&
          ((ut.clearcoatNormalMap.value = it.clearcoatNormalMap),
          a(it.clearcoatNormalMap, ut.clearcoatNormalMapTransform),
          ut.clearcoatNormalScale.value.copy(it.clearcoatNormalScale),
          it.side === BackSide && ut.clearcoatNormalScale.value.negate())),
      it.iridescence > 0 &&
        ((ut.iridescence.value = it.iridescence),
        (ut.iridescenceIOR.value = it.iridescenceIOR),
        (ut.iridescenceThicknessMinimum.value =
          it.iridescenceThicknessRange[0]),
        (ut.iridescenceThicknessMaximum.value =
          it.iridescenceThicknessRange[1]),
        it.iridescenceMap &&
          ((ut.iridescenceMap.value = it.iridescenceMap),
          a(it.iridescenceMap, ut.iridescenceMapTransform)),
        it.iridescenceThicknessMap &&
          ((ut.iridescenceThicknessMap.value = it.iridescenceThicknessMap),
          a(it.iridescenceThicknessMap, ut.iridescenceThicknessMapTransform))),
      it.transmission > 0 &&
        ((ut.transmission.value = it.transmission),
        (ut.transmissionSamplerMap.value = ct.texture),
        ut.transmissionSamplerSize.value.set(ct.width, ct.height),
        it.transmissionMap &&
          ((ut.transmissionMap.value = it.transmissionMap),
          a(it.transmissionMap, ut.transmissionMapTransform)),
        (ut.thickness.value = it.thickness),
        it.thicknessMap &&
          ((ut.thicknessMap.value = it.thicknessMap),
          a(it.thicknessMap, ut.thicknessMapTransform)),
        (ut.attenuationDistance.value = it.attenuationDistance),
        ut.attenuationColor.value.copy(it.attenuationColor)),
      it.anisotropy > 0 &&
        (ut.anisotropyVector.value.set(
          it.anisotropy * Math.cos(it.anisotropyRotation),
          it.anisotropy * Math.sin(it.anisotropyRotation)
        ),
        it.anisotropyMap &&
          ((ut.anisotropyMap.value = it.anisotropyMap),
          a(it.anisotropyMap, ut.anisotropyMapTransform))),
      (ut.specularIntensity.value = it.specularIntensity),
      ut.specularColor.value.copy(it.specularColor),
      it.specularColorMap &&
        ((ut.specularColorMap.value = it.specularColorMap),
        a(it.specularColorMap, ut.specularColorMapTransform)),
      it.specularIntensityMap &&
        ((ut.specularIntensityMap.value = it.specularIntensityMap),
        a(it.specularIntensityMap, ut.specularIntensityMapTransform))
  }
  function at(ut, it) {
    it.matcap && (ut.matcap.value = it.matcap)
  }
  function ot(ut, it) {
    const ct = e.get(it).light
    ut.referencePosition.value.setFromMatrixPosition(ct.matrixWorld),
      (ut.nearDistance.value = ct.shadow.camera.near),
      (ut.farDistance.value = ct.shadow.camera.far)
  }
  return { refreshFogUniforms: o, refreshMaterialUniforms: c }
}
function WebGLUniformsGroups(s, e, a, o) {
  let c = {},
    d = {},
    g = []
  const _ = a.isWebGL2 ? s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS) : 0
  function b(ct, lt) {
    const ht = lt.program
    o.uniformBlockBinding(ct, ht)
  }
  function j(ct, lt) {
    let ht = c[ct.id]
    ht === void 0 &&
      (at(ct),
      (ht = $(ct)),
      (c[ct.id] = ht),
      ct.addEventListener("dispose", ut))
    const dt = lt.program
    o.updateUBOMapping(ct, dt)
    const pt = e.render.frame
    d[ct.id] !== pt && (tt(ct), (d[ct.id] = pt))
  }
  function $(ct) {
    const lt = _e()
    ct.__bindingPointIndex = lt
    const ht = s.createBuffer(),
      dt = ct.__size,
      pt = ct.usage
    return (
      s.bindBuffer(s.UNIFORM_BUFFER, ht),
      s.bufferData(s.UNIFORM_BUFFER, dt, pt),
      s.bindBuffer(s.UNIFORM_BUFFER, null),
      s.bindBufferBase(s.UNIFORM_BUFFER, lt, ht),
      ht
    )
  }
  function _e() {
    for (let ct = 0; ct < _; ct++)
      if (g.indexOf(ct) === -1) return g.push(ct), ct
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    )
  }
  function tt(ct) {
    const lt = c[ct.id],
      ht = ct.uniforms,
      dt = ct.__cache
    s.bindBuffer(s.UNIFORM_BUFFER, lt)
    for (let pt = 0, vt = ht.length; pt < vt; pt++) {
      const _t = ht[pt]
      if (st(_t, pt, dt) === !0) {
        const yt = _t.__offset,
          Et = Array.isArray(_t.value) ? _t.value : [_t.value]
        let Rt = 0
        for (let Ft = 0; Ft < Et.length; Ft++) {
          const kt = Et[Ft],
            Nt = ot(kt)
          typeof kt == "number"
            ? ((_t.__data[0] = kt),
              s.bufferSubData(s.UNIFORM_BUFFER, yt + Rt, _t.__data))
            : kt.isMatrix3
            ? ((_t.__data[0] = kt.elements[0]),
              (_t.__data[1] = kt.elements[1]),
              (_t.__data[2] = kt.elements[2]),
              (_t.__data[3] = kt.elements[0]),
              (_t.__data[4] = kt.elements[3]),
              (_t.__data[5] = kt.elements[4]),
              (_t.__data[6] = kt.elements[5]),
              (_t.__data[7] = kt.elements[0]),
              (_t.__data[8] = kt.elements[6]),
              (_t.__data[9] = kt.elements[7]),
              (_t.__data[10] = kt.elements[8]),
              (_t.__data[11] = kt.elements[0]))
            : (kt.toArray(_t.__data, Rt),
              (Rt += Nt.storage / Float32Array.BYTES_PER_ELEMENT))
        }
        s.bufferSubData(s.UNIFORM_BUFFER, yt, _t.__data)
      }
    }
    s.bindBuffer(s.UNIFORM_BUFFER, null)
  }
  function st(ct, lt, ht) {
    const dt = ct.value
    if (ht[lt] === void 0) {
      if (typeof dt == "number") ht[lt] = dt
      else {
        const pt = Array.isArray(dt) ? dt : [dt],
          vt = []
        for (let _t = 0; _t < pt.length; _t++) vt.push(pt[_t].clone())
        ht[lt] = vt
      }
      return !0
    } else if (typeof dt == "number") {
      if (ht[lt] !== dt) return (ht[lt] = dt), !0
    } else {
      const pt = Array.isArray(ht[lt]) ? ht[lt] : [ht[lt]],
        vt = Array.isArray(dt) ? dt : [dt]
      for (let _t = 0; _t < pt.length; _t++) {
        const yt = pt[_t]
        if (yt.equals(vt[_t]) === !1) return yt.copy(vt[_t]), !0
      }
    }
    return !1
  }
  function at(ct) {
    const lt = ct.uniforms
    let ht = 0
    const dt = 16
    let pt = 0
    for (let vt = 0, _t = lt.length; vt < _t; vt++) {
      const yt = lt[vt],
        Et = { boundary: 0, storage: 0 },
        Rt = Array.isArray(yt.value) ? yt.value : [yt.value]
      for (let Ft = 0, kt = Rt.length; Ft < kt; Ft++) {
        const Nt = Rt[Ft],
          Dt = ot(Nt)
        ;(Et.boundary += Dt.boundary), (Et.storage += Dt.storage)
      }
      if (
        ((yt.__data = new Float32Array(
          Et.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (yt.__offset = ht),
        vt > 0)
      ) {
        pt = ht % dt
        const Ft = dt - pt
        pt !== 0 &&
          Ft - Et.boundary < 0 &&
          ((ht += dt - pt), (yt.__offset = ht))
      }
      ht += Et.storage
    }
    return (
      (pt = ht % dt),
      pt > 0 && (ht += dt - pt),
      (ct.__size = ht),
      (ct.__cache = {}),
      this
    )
  }
  function ot(ct) {
    const lt = { boundary: 0, storage: 0 }
    return (
      typeof ct == "number"
        ? ((lt.boundary = 4), (lt.storage = 4))
        : ct.isVector2
        ? ((lt.boundary = 8), (lt.storage = 8))
        : ct.isVector3 || ct.isColor
        ? ((lt.boundary = 16), (lt.storage = 12))
        : ct.isVector4
        ? ((lt.boundary = 16), (lt.storage = 16))
        : ct.isMatrix3
        ? ((lt.boundary = 48), (lt.storage = 48))
        : ct.isMatrix4
        ? ((lt.boundary = 64), (lt.storage = 64))
        : ct.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            ct
          ),
      lt
    )
  }
  function ut(ct) {
    const lt = ct.target
    lt.removeEventListener("dispose", ut)
    const ht = g.indexOf(lt.__bindingPointIndex)
    g.splice(ht, 1), s.deleteBuffer(c[lt.id]), delete c[lt.id], delete d[lt.id]
  }
  function it() {
    for (const ct in c) s.deleteBuffer(c[ct])
    ;(g = []), (c = {}), (d = {})
  }
  return { bind: b, update: j, dispose: it }
}
class WebGLRenderer {
  constructor(e = {}) {
    const {
      canvas: a = createCanvasElement(),
      context: o = null,
      depth: c = !0,
      stencil: d = !0,
      alpha: g = !1,
      antialias: _ = !1,
      premultipliedAlpha: b = !0,
      preserveDrawingBuffer: j = !1,
      powerPreference: $ = "default",
      failIfMajorPerformanceCaveat: _e = !1,
    } = e
    this.isWebGLRenderer = !0
    let tt
    o !== null ? (tt = o.getContextAttributes().alpha) : (tt = g)
    const st = new Uint32Array(4),
      at = new Int32Array(4)
    let ot = null,
      ut = null
    const it = [],
      ct = []
    ;(this.domElement = a),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputColorSpace = SRGBColorSpace),
      (this._useLegacyLights = !1),
      (this.toneMapping = NoToneMapping),
      (this.toneMappingExposure = 1)
    const lt = this
    let ht = !1,
      dt = 0,
      pt = 0,
      vt = null,
      _t = -1,
      yt = null
    const Et = new Vector4(),
      Rt = new Vector4()
    let Ft = null
    const kt = new Color(0)
    let Nt = 0,
      Dt = a.width,
      Mt = a.height,
      wt = 1,
      gt = null,
      At = null
    const bt = new Vector4(0, 0, Dt, Mt),
      Tt = new Vector4(0, 0, Dt, Mt)
    let It = !1
    const $t = new Frustum()
    let Xt = !1,
      qt = !1,
      en = null
    const yn = new Matrix4(),
      Tn = new Vector2(),
      $n = new Vector3(),
      Vn = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      }
    function gn() {
      return vt === null ? wt : 1
    }
    let Ht = o
    function on(St, Bt) {
      for (let Ut = 0; Ut < St.length; Ut++) {
        const Ot = St[Ut],
          zt = a.getContext(Ot, Bt)
        if (zt !== null) return zt
      }
      return null
    }
    try {
      const St = {
        alpha: !0,
        depth: c,
        stencil: d,
        antialias: _,
        premultipliedAlpha: b,
        preserveDrawingBuffer: j,
        powerPreference: $,
        failIfMajorPerformanceCaveat: _e,
      }
      if (
        ("setAttribute" in a &&
          a.setAttribute("data-engine", `three.js r${REVISION}`),
        a.addEventListener("webglcontextlost", Qt, !1),
        a.addEventListener("webglcontextrestored", nn, !1),
        a.addEventListener("webglcontextcreationerror", En, !1),
        Ht === null)
      ) {
        const Bt = ["webgl2", "webgl", "experimental-webgl"]
        if (
          (lt.isWebGL1Renderer === !0 && Bt.shift(),
          (Ht = on(Bt, St)),
          Ht === null)
        )
          throw on(Bt)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.")
      }
      typeof WebGLRenderingContext < "u" &&
        Ht instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        Ht.getShaderPrecisionFormat === void 0 &&
          (Ht.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 }
          })
    } catch (St) {
      throw (console.error("THREE.WebGLRenderer: " + St.message), St)
    }
    let Yt,
      _n,
      pn,
      Rn,
      bn,
      Pn,
      Gn,
      jn,
      ar,
      Vt,
      Lt,
      Zt,
      xn,
      vn,
      An,
      Nn,
      Sn,
      an,
      Jn,
      Hn,
      Fn,
      Un,
      Wt,
      un
    function Mn() {
      ;(Yt = new WebGLExtensions(Ht)),
        (_n = new WebGLCapabilities(Ht, Yt, e)),
        Yt.init(_n),
        (Un = new WebGLUtils(Ht, Yt, _n)),
        (pn = new WebGLState(Ht, Yt, _n)),
        (Rn = new WebGLInfo(Ht)),
        (bn = new WebGLProperties()),
        (Pn = new WebGLTextures(Ht, Yt, pn, bn, _n, Un, Rn)),
        (Gn = new WebGLCubeMaps(lt)),
        (jn = new WebGLCubeUVMaps(lt)),
        (ar = new WebGLAttributes(Ht, _n)),
        (Wt = new WebGLBindingStates(Ht, Yt, ar, _n)),
        (Vt = new WebGLGeometries(Ht, ar, Rn, Wt)),
        (Lt = new WebGLObjects(Ht, Vt, ar, Rn)),
        (Jn = new WebGLMorphtargets(Ht, _n, Pn)),
        (Nn = new WebGLClipping(bn)),
        (Zt = new WebGLPrograms(lt, Gn, jn, Yt, _n, Wt, Nn)),
        (xn = new WebGLMaterials(lt, bn)),
        (vn = new WebGLRenderLists()),
        (An = new WebGLRenderStates(Yt, _n)),
        (an = new WebGLBackground(lt, Gn, jn, pn, Lt, tt, b)),
        (Sn = new WebGLShadowMap(lt, Lt, _n)),
        (un = new WebGLUniformsGroups(Ht, Rn, _n, pn)),
        (Hn = new WebGLBufferRenderer(Ht, Yt, Rn, _n)),
        (Fn = new WebGLIndexedBufferRenderer(Ht, Yt, Rn, _n)),
        (Rn.programs = Zt.programs),
        (lt.capabilities = _n),
        (lt.extensions = Yt),
        (lt.properties = bn),
        (lt.renderLists = vn),
        (lt.shadowMap = Sn),
        (lt.state = pn),
        (lt.info = Rn)
    }
    Mn()
    const jt = new WebXRManager(lt, Ht)
    ;(this.xr = jt),
      (this.getContext = function () {
        return Ht
      }),
      (this.getContextAttributes = function () {
        return Ht.getContextAttributes()
      }),
      (this.forceContextLoss = function () {
        const St = Yt.get("WEBGL_lose_context")
        St && St.loseContext()
      }),
      (this.forceContextRestore = function () {
        const St = Yt.get("WEBGL_lose_context")
        St && St.restoreContext()
      }),
      (this.getPixelRatio = function () {
        return wt
      }),
      (this.setPixelRatio = function (St) {
        St !== void 0 && ((wt = St), this.setSize(Dt, Mt, !1))
      }),
      (this.getSize = function (St) {
        return St.set(Dt, Mt)
      }),
      (this.setSize = function (St, Bt, Ut = !0) {
        if (jt.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          )
          return
        }
        ;(Dt = St),
          (Mt = Bt),
          (a.width = Math.floor(St * wt)),
          (a.height = Math.floor(Bt * wt)),
          Ut === !0 &&
            ((a.style.width = St + "px"), (a.style.height = Bt + "px")),
          this.setViewport(0, 0, St, Bt)
      }),
      (this.getDrawingBufferSize = function (St) {
        return St.set(Dt * wt, Mt * wt).floor()
      }),
      (this.setDrawingBufferSize = function (St, Bt, Ut) {
        ;(Dt = St),
          (Mt = Bt),
          (wt = Ut),
          (a.width = Math.floor(St * Ut)),
          (a.height = Math.floor(Bt * Ut)),
          this.setViewport(0, 0, St, Bt)
      }),
      (this.getCurrentViewport = function (St) {
        return St.copy(Et)
      }),
      (this.getViewport = function (St) {
        return St.copy(bt)
      }),
      (this.setViewport = function (St, Bt, Ut, Ot) {
        St.isVector4 ? bt.set(St.x, St.y, St.z, St.w) : bt.set(St, Bt, Ut, Ot),
          pn.viewport(Et.copy(bt).multiplyScalar(wt).floor())
      }),
      (this.getScissor = function (St) {
        return St.copy(Tt)
      }),
      (this.setScissor = function (St, Bt, Ut, Ot) {
        St.isVector4 ? Tt.set(St.x, St.y, St.z, St.w) : Tt.set(St, Bt, Ut, Ot),
          pn.scissor(Rt.copy(Tt).multiplyScalar(wt).floor())
      }),
      (this.getScissorTest = function () {
        return It
      }),
      (this.setScissorTest = function (St) {
        pn.setScissorTest((It = St))
      }),
      (this.setOpaqueSort = function (St) {
        gt = St
      }),
      (this.setTransparentSort = function (St) {
        At = St
      }),
      (this.getClearColor = function (St) {
        return St.copy(an.getClearColor())
      }),
      (this.setClearColor = function () {
        an.setClearColor.apply(an, arguments)
      }),
      (this.getClearAlpha = function () {
        return an.getClearAlpha()
      }),
      (this.setClearAlpha = function () {
        an.setClearAlpha.apply(an, arguments)
      }),
      (this.clear = function (St = !0, Bt = !0, Ut = !0) {
        let Ot = 0
        if (St) {
          let zt = !1
          if (vt !== null) {
            const tn = vt.texture.format
            zt =
              tn === RGBAIntegerFormat ||
              tn === RGIntegerFormat ||
              tn === RedIntegerFormat
          }
          if (zt) {
            const tn = vt.texture.type,
              sn =
                tn === UnsignedByteType ||
                tn === UnsignedIntType ||
                tn === UnsignedShortType ||
                tn === UnsignedInt248Type ||
                tn === UnsignedShort4444Type ||
                tn === UnsignedShort5551Type,
              dn = an.getClearColor(),
              hn = an.getClearAlpha(),
              mn = dn.r,
              cn = dn.g,
              On = dn.b
            sn
              ? ((st[0] = mn),
                (st[1] = cn),
                (st[2] = On),
                (st[3] = hn),
                Ht.clearBufferuiv(Ht.COLOR, 0, st))
              : ((at[0] = mn),
                (at[1] = cn),
                (at[2] = On),
                (at[3] = hn),
                Ht.clearBufferiv(Ht.COLOR, 0, at))
          } else Ot |= Ht.COLOR_BUFFER_BIT
        }
        Bt && (Ot |= Ht.DEPTH_BUFFER_BIT),
          Ut && (Ot |= Ht.STENCIL_BUFFER_BIT),
          Ht.clear(Ot)
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1)
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1)
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0)
      }),
      (this.dispose = function () {
        a.removeEventListener("webglcontextlost", Qt, !1),
          a.removeEventListener("webglcontextrestored", nn, !1),
          a.removeEventListener("webglcontextcreationerror", En, !1),
          vn.dispose(),
          An.dispose(),
          bn.dispose(),
          Gn.dispose(),
          jn.dispose(),
          Lt.dispose(),
          Wt.dispose(),
          un.dispose(),
          Zt.dispose(),
          jt.dispose(),
          jt.removeEventListener("sessionstart", dr),
          jt.removeEventListener("sessionend", Br),
          en && (en.dispose(), (en = null)),
          Tr.stop()
      })
    function Qt(St) {
      St.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (ht = !0)
    }
    function nn() {
      console.log("THREE.WebGLRenderer: Context Restored."), (ht = !1)
      const St = Rn.autoReset,
        Bt = Sn.enabled,
        Ut = Sn.autoUpdate,
        Ot = Sn.needsUpdate,
        zt = Sn.type
      Mn(),
        (Rn.autoReset = St),
        (Sn.enabled = Bt),
        (Sn.autoUpdate = Ut),
        (Sn.needsUpdate = Ot),
        (Sn.type = zt)
    }
    function En(St) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        St.statusMessage
      )
    }
    function In(St) {
      const Bt = St.target
      Bt.removeEventListener("dispose", In), or(Bt)
    }
    function or(St) {
      hr(St), bn.remove(St)
    }
    function hr(St) {
      const Bt = bn.get(St).programs
      Bt !== void 0 &&
        (Bt.forEach(function (Ut) {
          Zt.releaseProgram(Ut)
        }),
        St.isShaderMaterial && Zt.releaseShaderCache(St))
    }
    ;(this.renderBufferDirect = function (St, Bt, Ut, Ot, zt, tn) {
      Bt === null && (Bt = Vn)
      const sn = zt.isMesh && zt.matrixWorld.determinant() < 0,
        dn = Ks(St, Bt, Ut, Ot, zt)
      pn.setMaterial(Ot, sn)
      let hn = Ut.index,
        mn = 1
      if (Ot.wireframe === !0) {
        if (((hn = Vt.getWireframeAttribute(Ut)), hn === void 0)) return
        mn = 2
      }
      const cn = Ut.drawRange,
        On = Ut.attributes.position
      let wn = cn.start * mn,
        Bn = (cn.start + cn.count) * mn
      tn !== null &&
        ((wn = Math.max(wn, tn.start * mn)),
        (Bn = Math.min(Bn, (tn.start + tn.count) * mn))),
        hn !== null
          ? ((wn = Math.max(wn, 0)), (Bn = Math.min(Bn, hn.count)))
          : On != null &&
            ((wn = Math.max(wn, 0)), (Bn = Math.min(Bn, On.count)))
      const Yn = Bn - wn
      if (Yn < 0 || Yn === 1 / 0) return
      Wt.setup(zt, Ot, dn, Ut, hn)
      let Zn,
        qn = Hn
      if (
        (hn !== null && ((Zn = ar.get(hn)), (qn = Fn), qn.setIndex(Zn)),
        zt.isMesh)
      )
        Ot.wireframe === !0
          ? (pn.setLineWidth(Ot.wireframeLinewidth * gn()),
            qn.setMode(Ht.LINES))
          : qn.setMode(Ht.TRIANGLES)
      else if (zt.isLine) {
        let Dn = Ot.linewidth
        Dn === void 0 && (Dn = 1),
          pn.setLineWidth(Dn * gn()),
          zt.isLineSegments
            ? qn.setMode(Ht.LINES)
            : zt.isLineLoop
            ? qn.setMode(Ht.LINE_LOOP)
            : qn.setMode(Ht.LINE_STRIP)
      } else
        zt.isPoints
          ? qn.setMode(Ht.POINTS)
          : zt.isSprite && qn.setMode(Ht.TRIANGLES)
      if (zt.isInstancedMesh) qn.renderInstances(wn, Yn, zt.count)
      else if (Ut.isInstancedBufferGeometry) {
        const Dn =
            Ut._maxInstanceCount !== void 0 ? Ut._maxInstanceCount : 1 / 0,
          er = Math.min(Ut.instanceCount, Dn)
        qn.renderInstances(wn, Yn, er)
      } else qn.render(wn, Yn)
    }),
      (this.compile = function (St, Bt) {
        function Ut(Ot, zt, tn) {
          Ot.transparent === !0 &&
          Ot.side === DoubleSide &&
          Ot.forceSinglePass === !1
            ? ((Ot.side = BackSide),
              (Ot.needsUpdate = !0),
              zr(Ot, zt, tn),
              (Ot.side = FrontSide),
              (Ot.needsUpdate = !0),
              zr(Ot, zt, tn),
              (Ot.side = DoubleSide))
            : zr(Ot, zt, tn)
        }
        ;(ut = An.get(St)),
          ut.init(),
          ct.push(ut),
          St.traverseVisible(function (Ot) {
            Ot.isLight &&
              Ot.layers.test(Bt.layers) &&
              (ut.pushLight(Ot), Ot.castShadow && ut.pushShadow(Ot))
          }),
          ut.setupLights(lt._useLegacyLights),
          St.traverse(function (Ot) {
            const zt = Ot.material
            if (zt)
              if (Array.isArray(zt))
                for (let tn = 0; tn < zt.length; tn++) {
                  const sn = zt[tn]
                  Ut(sn, St, Ot)
                }
              else Ut(zt, St, Ot)
          }),
          ct.pop(),
          (ut = null)
      })
    let mr = null
    function kr(St) {
      mr && mr(St)
    }
    function dr() {
      Tr.stop()
    }
    function Br() {
      Tr.start()
    }
    const Tr = new WebGLAnimation()
    Tr.setAnimationLoop(kr),
      typeof self < "u" && Tr.setContext(self),
      (this.setAnimationLoop = function (St) {
        ;(mr = St),
          jt.setAnimationLoop(St),
          St === null ? Tr.stop() : Tr.start()
      }),
      jt.addEventListener("sessionstart", dr),
      jt.addEventListener("sessionend", Br),
      (this.render = function (St, Bt) {
        if (Bt !== void 0 && Bt.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          )
          return
        }
        if (ht === !0) return
        St.matrixWorldAutoUpdate === !0 && St.updateMatrixWorld(),
          Bt.parent === null &&
            Bt.matrixWorldAutoUpdate === !0 &&
            Bt.updateMatrixWorld(),
          jt.enabled === !0 &&
            jt.isPresenting === !0 &&
            (jt.cameraAutoUpdate === !0 && jt.updateCamera(Bt),
            (Bt = jt.getCamera())),
          St.isScene === !0 && St.onBeforeRender(lt, St, Bt, vt),
          (ut = An.get(St, ct.length)),
          ut.init(),
          ct.push(ut),
          yn.multiplyMatrices(Bt.projectionMatrix, Bt.matrixWorldInverse),
          $t.setFromProjectionMatrix(yn),
          (qt = this.localClippingEnabled),
          (Xt = Nn.init(this.clippingPlanes, qt)),
          (ot = vn.get(St, it.length)),
          ot.init(),
          it.push(ot),
          Js(St, Bt, 0, lt.sortObjects),
          ot.finish(),
          lt.sortObjects === !0 && ot.sort(gt, At),
          this.info.render.frame++,
          Xt === !0 && Nn.beginShadows()
        const Ut = ut.state.shadowsArray
        if (
          (Sn.render(Ut, St, Bt),
          Xt === !0 && Nn.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          an.render(ot, St),
          ut.setupLights(lt._useLegacyLights),
          Bt.isArrayCamera)
        ) {
          const Ot = Bt.cameras
          for (let zt = 0, tn = Ot.length; zt < tn; zt++) {
            const sn = Ot[zt]
            Ys(ot, St, sn, sn.viewport)
          }
        } else Ys(ot, St, Bt)
        vt !== null &&
          (Pn.updateMultisampleRenderTarget(vt),
          Pn.updateRenderTargetMipmap(vt)),
          St.isScene === !0 && St.onAfterRender(lt, St, Bt),
          Wt.resetDefaultState(),
          (_t = -1),
          (yt = null),
          ct.pop(),
          ct.length > 0 ? (ut = ct[ct.length - 1]) : (ut = null),
          it.pop(),
          it.length > 0 ? (ot = it[it.length - 1]) : (ot = null)
      })
    function Js(St, Bt, Ut, Ot) {
      if (St.visible === !1) return
      if (St.layers.test(Bt.layers)) {
        if (St.isGroup) Ut = St.renderOrder
        else if (St.isLOD) St.autoUpdate === !0 && St.update(Bt)
        else if (St.isLight)
          ut.pushLight(St), St.castShadow && ut.pushShadow(St)
        else if (St.isSprite) {
          if (!St.frustumCulled || $t.intersectsSprite(St)) {
            Ot && $n.setFromMatrixPosition(St.matrixWorld).applyMatrix4(yn)
            const sn = Lt.update(St),
              dn = St.material
            dn.visible && ot.push(St, sn, dn, Ut, $n.z, null)
          }
        } else if (
          (St.isMesh || St.isLine || St.isPoints) &&
          (!St.frustumCulled || $t.intersectsObject(St))
        ) {
          const sn = Lt.update(St),
            dn = St.material
          if (
            (Ot &&
              (St.boundingSphere !== void 0
                ? (St.boundingSphere === null && St.computeBoundingSphere(),
                  $n.copy(St.boundingSphere.center))
                : (sn.boundingSphere === null && sn.computeBoundingSphere(),
                  $n.copy(sn.boundingSphere.center)),
              $n.applyMatrix4(St.matrixWorld).applyMatrix4(yn)),
            Array.isArray(dn))
          ) {
            const hn = sn.groups
            for (let mn = 0, cn = hn.length; mn < cn; mn++) {
              const On = hn[mn],
                wn = dn[On.materialIndex]
              wn && wn.visible && ot.push(St, sn, wn, Ut, $n.z, On)
            }
          } else dn.visible && ot.push(St, sn, dn, Ut, $n.z, null)
        }
      }
      const tn = St.children
      for (let sn = 0, dn = tn.length; sn < dn; sn++) Js(tn[sn], Bt, Ut, Ot)
    }
    function Ys(St, Bt, Ut, Ot) {
      const zt = St.opaque,
        tn = St.transmissive,
        sn = St.transparent
      ut.setupLightsView(Ut),
        Xt === !0 && Nn.setGlobalState(lt.clippingPlanes, Ut),
        tn.length > 0 && Es(zt, tn, Bt, Ut),
        Ot && pn.viewport(Et.copy(Ot)),
        zt.length > 0 && ds(zt, Bt, Ut),
        tn.length > 0 && ds(tn, Bt, Ut),
        sn.length > 0 && ds(sn, Bt, Ut),
        pn.buffers.depth.setTest(!0),
        pn.buffers.depth.setMask(!0),
        pn.buffers.color.setMask(!0),
        pn.setPolygonOffset(!1)
    }
    function Es(St, Bt, Ut, Ot) {
      const zt = _n.isWebGL2
      en === null &&
        (en = new WebGLRenderTarget(1, 1, {
          generateMipmaps: !0,
          type: Yt.has("EXT_color_buffer_half_float")
            ? HalfFloatType
            : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: zt ? 4 : 0,
        })),
        lt.getDrawingBufferSize(Tn),
        zt
          ? en.setSize(Tn.x, Tn.y)
          : en.setSize(floorPowerOfTwo(Tn.x), floorPowerOfTwo(Tn.y))
      const tn = lt.getRenderTarget()
      lt.setRenderTarget(en),
        lt.getClearColor(kt),
        (Nt = lt.getClearAlpha()),
        Nt < 1 && lt.setClearColor(16777215, 0.5),
        lt.clear()
      const sn = lt.toneMapping
      ;(lt.toneMapping = NoToneMapping),
        ds(St, Ut, Ot),
        Pn.updateMultisampleRenderTarget(en),
        Pn.updateRenderTargetMipmap(en)
      let dn = !1
      for (let hn = 0, mn = Bt.length; hn < mn; hn++) {
        const cn = Bt[hn],
          On = cn.object,
          wn = cn.geometry,
          Bn = cn.material,
          Yn = cn.group
        if (Bn.side === DoubleSide && On.layers.test(Ot.layers)) {
          const Zn = Bn.side
          ;(Bn.side = BackSide),
            (Bn.needsUpdate = !0),
            ps(On, Ut, Ot, wn, Bn, Yn),
            (Bn.side = Zn),
            (Bn.needsUpdate = !0),
            (dn = !0)
        }
      }
      dn === !0 &&
        (Pn.updateMultisampleRenderTarget(en), Pn.updateRenderTargetMipmap(en)),
        lt.setRenderTarget(tn),
        lt.setClearColor(kt, Nt),
        (lt.toneMapping = sn)
    }
    function ds(St, Bt, Ut) {
      const Ot = Bt.isScene === !0 ? Bt.overrideMaterial : null
      for (let zt = 0, tn = St.length; zt < tn; zt++) {
        const sn = St[zt],
          dn = sn.object,
          hn = sn.geometry,
          mn = Ot === null ? sn.material : Ot,
          cn = sn.group
        dn.layers.test(Ut.layers) && ps(dn, Bt, Ut, hn, mn, cn)
      }
    }
    function ps(St, Bt, Ut, Ot, zt, tn) {
      St.onBeforeRender(lt, Bt, Ut, Ot, zt, tn),
        St.modelViewMatrix.multiplyMatrices(
          Ut.matrixWorldInverse,
          St.matrixWorld
        ),
        St.normalMatrix.getNormalMatrix(St.modelViewMatrix),
        zt.onBeforeRender(lt, Bt, Ut, Ot, St, tn),
        zt.transparent === !0 &&
        zt.side === DoubleSide &&
        zt.forceSinglePass === !1
          ? ((zt.side = BackSide),
            (zt.needsUpdate = !0),
            lt.renderBufferDirect(Ut, Bt, Ot, zt, St, tn),
            (zt.side = FrontSide),
            (zt.needsUpdate = !0),
            lt.renderBufferDirect(Ut, Bt, Ot, zt, St, tn),
            (zt.side = DoubleSide))
          : lt.renderBufferDirect(Ut, Bt, Ot, zt, St, tn),
        St.onAfterRender(lt, Bt, Ut, Ot, zt, tn)
    }
    function zr(St, Bt, Ut) {
      Bt.isScene !== !0 && (Bt = Vn)
      const Ot = bn.get(St),
        zt = ut.state.lights,
        tn = ut.state.shadowsArray,
        sn = zt.state.version,
        dn = Zt.getParameters(St, zt.state, tn, Bt, Ut),
        hn = Zt.getProgramCacheKey(dn)
      let mn = Ot.programs
      ;(Ot.environment = St.isMeshStandardMaterial ? Bt.environment : null),
        (Ot.fog = Bt.fog),
        (Ot.envMap = (St.isMeshStandardMaterial ? jn : Gn).get(
          St.envMap || Ot.environment
        )),
        mn === void 0 &&
          (St.addEventListener("dispose", In),
          (mn = new Map()),
          (Ot.programs = mn))
      let cn = mn.get(hn)
      if (cn !== void 0) {
        if (Ot.currentProgram === cn && Ot.lightsStateVersion === sn)
          return lr(St, dn), cn
      } else
        (dn.uniforms = Zt.getUniforms(St)),
          St.onBuild(Ut, dn, lt),
          St.onBeforeCompile(dn, lt),
          (cn = Zt.acquireProgram(dn, hn)),
          mn.set(hn, cn),
          (Ot.uniforms = dn.uniforms)
      const On = Ot.uniforms
      ;((!St.isShaderMaterial && !St.isRawShaderMaterial) ||
        St.clipping === !0) &&
        (On.clippingPlanes = Nn.uniform),
        lr(St, dn),
        (Ot.needsLights = Pt(St)),
        (Ot.lightsStateVersion = sn),
        Ot.needsLights &&
          ((On.ambientLightColor.value = zt.state.ambient),
          (On.lightProbe.value = zt.state.probe),
          (On.directionalLights.value = zt.state.directional),
          (On.directionalLightShadows.value = zt.state.directionalShadow),
          (On.spotLights.value = zt.state.spot),
          (On.spotLightShadows.value = zt.state.spotShadow),
          (On.rectAreaLights.value = zt.state.rectArea),
          (On.ltc_1.value = zt.state.rectAreaLTC1),
          (On.ltc_2.value = zt.state.rectAreaLTC2),
          (On.pointLights.value = zt.state.point),
          (On.pointLightShadows.value = zt.state.pointShadow),
          (On.hemisphereLights.value = zt.state.hemi),
          (On.directionalShadowMap.value = zt.state.directionalShadowMap),
          (On.directionalShadowMatrix.value = zt.state.directionalShadowMatrix),
          (On.spotShadowMap.value = zt.state.spotShadowMap),
          (On.spotLightMatrix.value = zt.state.spotLightMatrix),
          (On.spotLightMap.value = zt.state.spotLightMap),
          (On.pointShadowMap.value = zt.state.pointShadowMap),
          (On.pointShadowMatrix.value = zt.state.pointShadowMatrix))
      const wn = cn.getUniforms(),
        Bn = WebGLUniforms.seqWithValue(wn.seq, On)
      return (Ot.currentProgram = cn), (Ot.uniformsList = Bn), cn
    }
    function lr(St, Bt) {
      const Ut = bn.get(St)
      ;(Ut.outputColorSpace = Bt.outputColorSpace),
        (Ut.instancing = Bt.instancing),
        (Ut.instancingColor = Bt.instancingColor),
        (Ut.skinning = Bt.skinning),
        (Ut.morphTargets = Bt.morphTargets),
        (Ut.morphNormals = Bt.morphNormals),
        (Ut.morphColors = Bt.morphColors),
        (Ut.morphTargetsCount = Bt.morphTargetsCount),
        (Ut.numClippingPlanes = Bt.numClippingPlanes),
        (Ut.numIntersection = Bt.numClipIntersection),
        (Ut.vertexAlphas = Bt.vertexAlphas),
        (Ut.vertexTangents = Bt.vertexTangents),
        (Ut.toneMapping = Bt.toneMapping)
    }
    function Ks(St, Bt, Ut, Ot, zt) {
      Bt.isScene !== !0 && (Bt = Vn), Pn.resetTextureUnits()
      const tn = Bt.fog,
        sn = Ot.isMeshStandardMaterial ? Bt.environment : null,
        dn =
          vt === null
            ? lt.outputColorSpace
            : vt.isXRRenderTarget === !0
            ? vt.texture.colorSpace
            : LinearSRGBColorSpace,
        hn = (Ot.isMeshStandardMaterial ? jn : Gn).get(Ot.envMap || sn),
        mn =
          Ot.vertexColors === !0 &&
          !!Ut.attributes.color &&
          Ut.attributes.color.itemSize === 4,
        cn = !!Ut.attributes.tangent && (!!Ot.normalMap || Ot.anisotropy > 0),
        On = !!Ut.morphAttributes.position,
        wn = !!Ut.morphAttributes.normal,
        Bn = !!Ut.morphAttributes.color
      let Yn = NoToneMapping
      Ot.toneMapped &&
        (vt === null || vt.isXRRenderTarget === !0) &&
        (Yn = lt.toneMapping)
      const Zn =
          Ut.morphAttributes.position ||
          Ut.morphAttributes.normal ||
          Ut.morphAttributes.color,
        qn = Zn !== void 0 ? Zn.length : 0,
        Dn = bn.get(Ot),
        er = ut.state.lights
      if (Xt === !0 && (qt === !0 || St !== yt)) {
        const nr = St === yt && Ot.id === _t
        Nn.setState(Ot, St, nr)
      }
      let Wn = !1
      Ot.version === Dn.__version
        ? ((Dn.needsLights && Dn.lightsStateVersion !== er.state.version) ||
            Dn.outputColorSpace !== dn ||
            (zt.isInstancedMesh && Dn.instancing === !1) ||
            (!zt.isInstancedMesh && Dn.instancing === !0) ||
            (zt.isSkinnedMesh && Dn.skinning === !1) ||
            (!zt.isSkinnedMesh && Dn.skinning === !0) ||
            (zt.isInstancedMesh &&
              Dn.instancingColor === !0 &&
              zt.instanceColor === null) ||
            (zt.isInstancedMesh &&
              Dn.instancingColor === !1 &&
              zt.instanceColor !== null) ||
            Dn.envMap !== hn ||
            (Ot.fog === !0 && Dn.fog !== tn) ||
            (Dn.numClippingPlanes !== void 0 &&
              (Dn.numClippingPlanes !== Nn.numPlanes ||
                Dn.numIntersection !== Nn.numIntersection)) ||
            Dn.vertexAlphas !== mn ||
            Dn.vertexTangents !== cn ||
            Dn.morphTargets !== On ||
            Dn.morphNormals !== wn ||
            Dn.morphColors !== Bn ||
            Dn.toneMapping !== Yn ||
            (_n.isWebGL2 === !0 && Dn.morphTargetsCount !== qn)) &&
          (Wn = !0)
        : ((Wn = !0), (Dn.__version = Ot.version))
      let rr = Dn.currentProgram
      Wn === !0 && (rr = zr(Ot, Bt, zt))
      let Ar = !1,
        tr = !1,
        Sr = !1
      const gr = rr.getUniforms(),
        Er = Dn.uniforms
      if (
        (pn.useProgram(rr.program) && ((Ar = !0), (tr = !0), (Sr = !0)),
        Ot.id !== _t && ((_t = Ot.id), (tr = !0)),
        Ar || yt !== St)
      ) {
        gr.setValue(Ht, "projectionMatrix", St.projectionMatrix),
          gr.setValue(Ht, "viewMatrix", St.matrixWorldInverse)
        const nr = gr.map.cameraPosition
        nr !== void 0 &&
          nr.setValue(Ht, $n.setFromMatrixPosition(St.matrixWorld)),
          _n.logarithmicDepthBuffer &&
            gr.setValue(
              Ht,
              "logDepthBufFC",
              2 / (Math.log(St.far + 1) / Math.LN2)
            ),
          (Ot.isMeshPhongMaterial ||
            Ot.isMeshToonMaterial ||
            Ot.isMeshLambertMaterial ||
            Ot.isMeshBasicMaterial ||
            Ot.isMeshStandardMaterial ||
            Ot.isShaderMaterial) &&
            gr.setValue(Ht, "isOrthographic", St.isOrthographicCamera === !0),
          yt !== St && ((yt = St), (tr = !0), (Sr = !0))
      }
      if (zt.isSkinnedMesh) {
        gr.setOptional(Ht, zt, "bindMatrix"),
          gr.setOptional(Ht, zt, "bindMatrixInverse")
        const nr = zt.skeleton
        nr &&
          (_n.floatVertexTextures
            ? (nr.boneTexture === null && nr.computeBoneTexture(),
              gr.setValue(Ht, "boneTexture", nr.boneTexture, Pn),
              gr.setValue(Ht, "boneTextureSize", nr.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ))
      }
      const Ir = Ut.morphAttributes
      if (
        ((Ir.position !== void 0 ||
          Ir.normal !== void 0 ||
          (Ir.color !== void 0 && _n.isWebGL2 === !0)) &&
          Jn.update(zt, Ut, rr),
        (tr || Dn.receiveShadow !== zt.receiveShadow) &&
          ((Dn.receiveShadow = zt.receiveShadow),
          gr.setValue(Ht, "receiveShadow", zt.receiveShadow)),
        Ot.isMeshGouraudMaterial &&
          Ot.envMap !== null &&
          ((Er.envMap.value = hn),
          (Er.flipEnvMap.value =
            hn.isCubeTexture && hn.isRenderTargetTexture === !1 ? -1 : 1)),
        tr &&
          (gr.setValue(Ht, "toneMappingExposure", lt.toneMappingExposure),
          Dn.needsLights && io(Er, Sr),
          tn && Ot.fog === !0 && xn.refreshFogUniforms(Er, tn),
          xn.refreshMaterialUniforms(Er, Ot, wt, Mt, en),
          WebGLUniforms.upload(Ht, Dn.uniformsList, Er, Pn)),
        Ot.isShaderMaterial &&
          Ot.uniformsNeedUpdate === !0 &&
          (WebGLUniforms.upload(Ht, Dn.uniformsList, Er, Pn),
          (Ot.uniformsNeedUpdate = !1)),
        Ot.isSpriteMaterial && gr.setValue(Ht, "center", zt.center),
        gr.setValue(Ht, "modelViewMatrix", zt.modelViewMatrix),
        gr.setValue(Ht, "normalMatrix", zt.normalMatrix),
        gr.setValue(Ht, "modelMatrix", zt.matrixWorld),
        Ot.isShaderMaterial || Ot.isRawShaderMaterial)
      ) {
        const nr = Ot.uniformsGroups
        for (let wr = 0, xr = nr.length; wr < xr; wr++)
          if (_n.isWebGL2) {
            const pr = nr[wr]
            un.update(pr, rr), un.bind(pr, rr)
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            )
      }
      return rr
    }
    function io(St, Bt) {
      ;(St.ambientLightColor.needsUpdate = Bt),
        (St.lightProbe.needsUpdate = Bt),
        (St.directionalLights.needsUpdate = Bt),
        (St.directionalLightShadows.needsUpdate = Bt),
        (St.pointLights.needsUpdate = Bt),
        (St.pointLightShadows.needsUpdate = Bt),
        (St.spotLights.needsUpdate = Bt),
        (St.spotLightShadows.needsUpdate = Bt),
        (St.rectAreaLights.needsUpdate = Bt),
        (St.hemisphereLights.needsUpdate = Bt)
    }
    function Pt(St) {
      return (
        St.isMeshLambertMaterial ||
        St.isMeshToonMaterial ||
        St.isMeshPhongMaterial ||
        St.isMeshStandardMaterial ||
        St.isShadowMaterial ||
        (St.isShaderMaterial && St.lights === !0)
      )
    }
    ;(this.getActiveCubeFace = function () {
      return dt
    }),
      (this.getActiveMipmapLevel = function () {
        return pt
      }),
      (this.getRenderTarget = function () {
        return vt
      }),
      (this.setRenderTargetTextures = function (St, Bt, Ut) {
        ;(bn.get(St.texture).__webglTexture = Bt),
          (bn.get(St.depthTexture).__webglTexture = Ut)
        const Ot = bn.get(St)
        ;(Ot.__hasExternalTextures = !0),
          Ot.__hasExternalTextures &&
            ((Ot.__autoAllocateDepthBuffer = Ut === void 0),
            Ot.__autoAllocateDepthBuffer ||
              (Yt.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (Ot.__useRenderToTexture = !1))))
      }),
      (this.setRenderTargetFramebuffer = function (St, Bt) {
        const Ut = bn.get(St)
        ;(Ut.__webglFramebuffer = Bt),
          (Ut.__useDefaultFramebuffer = Bt === void 0)
      }),
      (this.setRenderTarget = function (St, Bt = 0, Ut = 0) {
        ;(vt = St), (dt = Bt), (pt = Ut)
        let Ot = !0,
          zt = null,
          tn = !1,
          sn = !1
        if (St) {
          const hn = bn.get(St)
          hn.__useDefaultFramebuffer !== void 0
            ? (pn.bindFramebuffer(Ht.FRAMEBUFFER, null), (Ot = !1))
            : hn.__webglFramebuffer === void 0
            ? Pn.setupRenderTarget(St)
            : hn.__hasExternalTextures &&
              Pn.rebindTextures(
                St,
                bn.get(St.texture).__webglTexture,
                bn.get(St.depthTexture).__webglTexture
              )
          const mn = St.texture
          ;(mn.isData3DTexture ||
            mn.isDataArrayTexture ||
            mn.isCompressedArrayTexture) &&
            (sn = !0)
          const cn = bn.get(St).__webglFramebuffer
          St.isWebGLCubeRenderTarget
            ? (Array.isArray(cn[Bt]) ? (zt = cn[Bt][Ut]) : (zt = cn[Bt]),
              (tn = !0))
            : _n.isWebGL2 && St.samples > 0 && Pn.useMultisampledRTT(St) === !1
            ? (zt = bn.get(St).__webglMultisampledFramebuffer)
            : Array.isArray(cn)
            ? (zt = cn[Ut])
            : (zt = cn),
            Et.copy(St.viewport),
            Rt.copy(St.scissor),
            (Ft = St.scissorTest)
        } else
          Et.copy(bt).multiplyScalar(wt).floor(),
            Rt.copy(Tt).multiplyScalar(wt).floor(),
            (Ft = It)
        if (
          (pn.bindFramebuffer(Ht.FRAMEBUFFER, zt) &&
            _n.drawBuffers &&
            Ot &&
            pn.drawBuffers(St, zt),
          pn.viewport(Et),
          pn.scissor(Rt),
          pn.setScissorTest(Ft),
          tn)
        ) {
          const hn = bn.get(St.texture)
          Ht.framebufferTexture2D(
            Ht.FRAMEBUFFER,
            Ht.COLOR_ATTACHMENT0,
            Ht.TEXTURE_CUBE_MAP_POSITIVE_X + Bt,
            hn.__webglTexture,
            Ut
          )
        } else if (sn) {
          const hn = bn.get(St.texture),
            mn = Bt || 0
          Ht.framebufferTextureLayer(
            Ht.FRAMEBUFFER,
            Ht.COLOR_ATTACHMENT0,
            hn.__webglTexture,
            Ut || 0,
            mn
          )
        }
        _t = -1
      }),
      (this.readRenderTargetPixels = function (St, Bt, Ut, Ot, zt, tn, sn) {
        if (!(St && St.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          )
          return
        }
        let dn = bn.get(St).__webglFramebuffer
        if (
          (St.isWebGLCubeRenderTarget && sn !== void 0 && (dn = dn[sn]), dn)
        ) {
          pn.bindFramebuffer(Ht.FRAMEBUFFER, dn)
          try {
            const hn = St.texture,
              mn = hn.format,
              cn = hn.type
            if (
              mn !== RGBAFormat &&
              Un.convert(mn) !==
                Ht.getParameter(Ht.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              )
              return
            }
            const On =
              cn === HalfFloatType &&
              (Yt.has("EXT_color_buffer_half_float") ||
                (_n.isWebGL2 && Yt.has("EXT_color_buffer_float")))
            if (
              cn !== UnsignedByteType &&
              Un.convert(cn) !==
                Ht.getParameter(Ht.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                cn === FloatType &&
                (_n.isWebGL2 ||
                  Yt.has("OES_texture_float") ||
                  Yt.has("WEBGL_color_buffer_float"))
              ) &&
              !On
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              )
              return
            }
            Bt >= 0 &&
              Bt <= St.width - Ot &&
              Ut >= 0 &&
              Ut <= St.height - zt &&
              Ht.readPixels(Bt, Ut, Ot, zt, Un.convert(mn), Un.convert(cn), tn)
          } finally {
            const hn = vt !== null ? bn.get(vt).__webglFramebuffer : null
            pn.bindFramebuffer(Ht.FRAMEBUFFER, hn)
          }
        }
      }),
      (this.copyFramebufferToTexture = function (St, Bt, Ut = 0) {
        const Ot = Math.pow(2, -Ut),
          zt = Math.floor(Bt.image.width * Ot),
          tn = Math.floor(Bt.image.height * Ot)
        Pn.setTexture2D(Bt, 0),
          Ht.copyTexSubImage2D(Ht.TEXTURE_2D, Ut, 0, 0, St.x, St.y, zt, tn),
          pn.unbindTexture()
      }),
      (this.copyTextureToTexture = function (St, Bt, Ut, Ot = 0) {
        const zt = Bt.image.width,
          tn = Bt.image.height,
          sn = Un.convert(Ut.format),
          dn = Un.convert(Ut.type)
        Pn.setTexture2D(Ut, 0),
          Ht.pixelStorei(Ht.UNPACK_FLIP_Y_WEBGL, Ut.flipY),
          Ht.pixelStorei(
            Ht.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            Ut.premultiplyAlpha
          ),
          Ht.pixelStorei(Ht.UNPACK_ALIGNMENT, Ut.unpackAlignment),
          Bt.isDataTexture
            ? Ht.texSubImage2D(
                Ht.TEXTURE_2D,
                Ot,
                St.x,
                St.y,
                zt,
                tn,
                sn,
                dn,
                Bt.image.data
              )
            : Bt.isCompressedTexture
            ? Ht.compressedTexSubImage2D(
                Ht.TEXTURE_2D,
                Ot,
                St.x,
                St.y,
                Bt.mipmaps[0].width,
                Bt.mipmaps[0].height,
                sn,
                Bt.mipmaps[0].data
              )
            : Ht.texSubImage2D(Ht.TEXTURE_2D, Ot, St.x, St.y, sn, dn, Bt.image),
          Ot === 0 && Ut.generateMipmaps && Ht.generateMipmap(Ht.TEXTURE_2D),
          pn.unbindTexture()
      }),
      (this.copyTextureToTexture3D = function (St, Bt, Ut, Ot, zt = 0) {
        if (lt.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          )
          return
        }
        const tn = St.max.x - St.min.x + 1,
          sn = St.max.y - St.min.y + 1,
          dn = St.max.z - St.min.z + 1,
          hn = Un.convert(Ot.format),
          mn = Un.convert(Ot.type)
        let cn
        if (Ot.isData3DTexture) Pn.setTexture3D(Ot, 0), (cn = Ht.TEXTURE_3D)
        else if (Ot.isDataArrayTexture)
          Pn.setTexture2DArray(Ot, 0), (cn = Ht.TEXTURE_2D_ARRAY)
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          )
          return
        }
        Ht.pixelStorei(Ht.UNPACK_FLIP_Y_WEBGL, Ot.flipY),
          Ht.pixelStorei(
            Ht.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
            Ot.premultiplyAlpha
          ),
          Ht.pixelStorei(Ht.UNPACK_ALIGNMENT, Ot.unpackAlignment)
        const On = Ht.getParameter(Ht.UNPACK_ROW_LENGTH),
          wn = Ht.getParameter(Ht.UNPACK_IMAGE_HEIGHT),
          Bn = Ht.getParameter(Ht.UNPACK_SKIP_PIXELS),
          Yn = Ht.getParameter(Ht.UNPACK_SKIP_ROWS),
          Zn = Ht.getParameter(Ht.UNPACK_SKIP_IMAGES),
          qn = Ut.isCompressedTexture ? Ut.mipmaps[0] : Ut.image
        Ht.pixelStorei(Ht.UNPACK_ROW_LENGTH, qn.width),
          Ht.pixelStorei(Ht.UNPACK_IMAGE_HEIGHT, qn.height),
          Ht.pixelStorei(Ht.UNPACK_SKIP_PIXELS, St.min.x),
          Ht.pixelStorei(Ht.UNPACK_SKIP_ROWS, St.min.y),
          Ht.pixelStorei(Ht.UNPACK_SKIP_IMAGES, St.min.z),
          Ut.isDataTexture || Ut.isData3DTexture
            ? Ht.texSubImage3D(
                cn,
                zt,
                Bt.x,
                Bt.y,
                Bt.z,
                tn,
                sn,
                dn,
                hn,
                mn,
                qn.data
              )
            : Ut.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              Ht.compressedTexSubImage3D(
                cn,
                zt,
                Bt.x,
                Bt.y,
                Bt.z,
                tn,
                sn,
                dn,
                hn,
                qn.data
              ))
            : Ht.texSubImage3D(
                cn,
                zt,
                Bt.x,
                Bt.y,
                Bt.z,
                tn,
                sn,
                dn,
                hn,
                mn,
                qn
              ),
          Ht.pixelStorei(Ht.UNPACK_ROW_LENGTH, On),
          Ht.pixelStorei(Ht.UNPACK_IMAGE_HEIGHT, wn),
          Ht.pixelStorei(Ht.UNPACK_SKIP_PIXELS, Bn),
          Ht.pixelStorei(Ht.UNPACK_SKIP_ROWS, Yn),
          Ht.pixelStorei(Ht.UNPACK_SKIP_IMAGES, Zn),
          zt === 0 && Ot.generateMipmaps && Ht.generateMipmap(cn),
          pn.unbindTexture()
      }),
      (this.initTexture = function (St) {
        St.isCubeTexture
          ? Pn.setTextureCube(St, 0)
          : St.isData3DTexture
          ? Pn.setTexture3D(St, 0)
          : St.isDataArrayTexture || St.isCompressedArrayTexture
          ? Pn.setTexture2DArray(St, 0)
          : Pn.setTexture2D(St, 0),
          pn.unbindTexture()
      }),
      (this.resetState = function () {
        ;(dt = 0), (pt = 0), (vt = null), pn.reset(), Wt.reset()
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        )
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    )
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e)
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding
    )
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace =
        e === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace)
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    )
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = e)
  }
}
class WebGL1Renderer extends WebGLRenderer {}
WebGL1Renderer.prototype.isWebGL1Renderer = !0
class FogExp2 {
  constructor(e, a = 25e-5) {
    ;(this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Color(e)),
      (this.density = a)
  }
  clone() {
    return new FogExp2(this.color, this.density)
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density,
    }
  }
}
class Fog {
  constructor(e, a = 1, o = 1e3) {
    ;(this.isFog = !0),
      (this.name = ""),
      (this.color = new Color(e)),
      (this.near = a),
      (this.far = o)
  }
  clone() {
    return new Fog(this.color, this.near, this.far)
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    }
  }
}
class Scene extends Object3D {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        )
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    )
  }
  toJSON(e) {
    const a = super.toJSON(e)
    return (
      this.fog !== null && (a.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (a.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (a.object.backgroundIntensity = this.backgroundIntensity),
      a
    )
  }
}
class InterleavedBuffer {
  constructor(e, a) {
    ;(this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = a),
      (this.count = e !== void 0 ? e.length / a : 0),
      (this.usage = StaticDrawUsage),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = generateUUID())
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setUsage(e) {
    return (this.usage = e), this
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    )
  }
  copyAt(e, a, o) {
    ;(e *= this.stride), (o *= a.stride)
    for (let c = 0, d = this.stride; c < d; c++)
      this.array[e + c] = a.array[o + c]
    return this
  }
  set(e, a = 0) {
    return this.array.set(e, a), this
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 &&
        (this.array.buffer._uuid = generateUUID()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer)
    const a = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      o = new this.constructor(a, this.stride)
    return o.setUsage(this.usage), o
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 &&
        (this.array.buffer._uuid = generateUUID()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    )
  }
}
const _vector$5 = new Vector3()
class InterleavedBufferAttribute {
  constructor(e, a, o, c = !1) {
    ;(this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = a),
      (this.offset = o),
      (this.normalized = c)
  }
  get count() {
    return this.data.count
  }
  get array() {
    return this.data.array
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e
  }
  applyMatrix4(e) {
    for (let a = 0, o = this.data.count; a < o; a++)
      _vector$5.fromBufferAttribute(this, a),
        _vector$5.applyMatrix4(e),
        this.setXYZ(a, _vector$5.x, _vector$5.y, _vector$5.z)
    return this
  }
  applyNormalMatrix(e) {
    for (let a = 0, o = this.count; a < o; a++)
      _vector$5.fromBufferAttribute(this, a),
        _vector$5.applyNormalMatrix(e),
        this.setXYZ(a, _vector$5.x, _vector$5.y, _vector$5.z)
    return this
  }
  transformDirection(e) {
    for (let a = 0, o = this.count; a < o; a++)
      _vector$5.fromBufferAttribute(this, a),
        _vector$5.transformDirection(e),
        this.setXYZ(a, _vector$5.x, _vector$5.y, _vector$5.z)
    return this
  }
  setX(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = a),
      this
    )
  }
  setY(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = a),
      this
    )
  }
  setZ(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = a),
      this
    )
  }
  setW(e, a) {
    return (
      this.normalized && (a = normalize$1(a, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = a),
      this
    )
  }
  getX(e) {
    let a = this.data.array[e * this.data.stride + this.offset]
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  getY(e) {
    let a = this.data.array[e * this.data.stride + this.offset + 1]
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  getZ(e) {
    let a = this.data.array[e * this.data.stride + this.offset + 2]
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  getW(e) {
    let a = this.data.array[e * this.data.stride + this.offset + 3]
    return this.normalized && (a = denormalize(a, this.array)), a
  }
  setXY(e, a, o) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((a = normalize$1(a, this.array)), (o = normalize$1(o, this.array))),
      (this.data.array[e + 0] = a),
      (this.data.array[e + 1] = o),
      this
    )
  }
  setXYZ(e, a, o, c) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((a = normalize$1(a, this.array)),
        (o = normalize$1(o, this.array)),
        (c = normalize$1(c, this.array))),
      (this.data.array[e + 0] = a),
      (this.data.array[e + 1] = o),
      (this.data.array[e + 2] = c),
      this
    )
  }
  setXYZW(e, a, o, c, d) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((a = normalize$1(a, this.array)),
        (o = normalize$1(o, this.array)),
        (c = normalize$1(c, this.array)),
        (d = normalize$1(d, this.array))),
      (this.data.array[e + 0] = a),
      (this.data.array[e + 1] = o),
      (this.data.array[e + 2] = c),
      (this.data.array[e + 3] = d),
      this
    )
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      )
      const a = []
      for (let o = 0; o < this.count; o++) {
        const c = o * this.data.stride + this.offset
        for (let d = 0; d < this.itemSize; d++) a.push(this.data.array[c + d])
      }
      return new BufferAttribute(
        new this.array.constructor(a),
        this.itemSize,
        this.normalized
      )
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new InterleavedBufferAttribute(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      )
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      )
      const a = []
      for (let o = 0; o < this.count; o++) {
        const c = o * this.data.stride + this.offset
        for (let d = 0; d < this.itemSize; d++) a.push(this.data.array[c + d])
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: a,
        normalized: this.normalized,
      }
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      )
  }
}
class SpriteMaterial extends Material {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    )
  }
}
let _geometry
const _intersectPoint = new Vector3(),
  _worldScale = new Vector3(),
  _mvPosition = new Vector3(),
  _alignedPosition = new Vector2(),
  _rotatedPosition = new Vector2(),
  _viewWorldMatrix = new Matrix4(),
  _vA = new Vector3(),
  _vB = new Vector3(),
  _vC = new Vector3(),
  _uvA = new Vector2(),
  _uvB = new Vector2(),
  _uvC = new Vector2()
class Sprite extends Object3D {
  constructor(e) {
    if (
      (super(),
      (this.isSprite = !0),
      (this.type = "Sprite"),
      _geometry === void 0)
    ) {
      _geometry = new BufferGeometry()
      const a = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        o = new InterleavedBuffer(a, 5)
      _geometry.setIndex([0, 1, 2, 0, 2, 3]),
        _geometry.setAttribute(
          "position",
          new InterleavedBufferAttribute(o, 3, 0, !1)
        ),
        _geometry.setAttribute(
          "uv",
          new InterleavedBufferAttribute(o, 2, 3, !1)
        )
    }
    ;(this.geometry = _geometry),
      (this.material = e !== void 0 ? e : new SpriteMaterial()),
      (this.center = new Vector2(0.5, 0.5))
  }
  raycast(e, a) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      _worldScale.setFromMatrixScale(this.matrixWorld),
      _viewWorldMatrix.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      _mvPosition.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        _worldScale.multiplyScalar(-_mvPosition.z)
    const o = this.material.rotation
    let c, d
    o !== 0 && ((d = Math.cos(o)), (c = Math.sin(o)))
    const g = this.center
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, g, _worldScale, c, d),
      transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, g, _worldScale, c, d),
      transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, g, _worldScale, c, d),
      _uvA.set(0, 0),
      _uvB.set(1, 0),
      _uvC.set(1, 1)
    let _ = e.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint)
    if (
      _ === null &&
      (transformVertex(
        _vB.set(-0.5, 0.5, 0),
        _mvPosition,
        g,
        _worldScale,
        c,
        d
      ),
      _uvB.set(0, 1),
      (_ = e.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint)),
      _ === null)
    )
      return
    const b = e.ray.origin.distanceTo(_intersectPoint)
    b < e.near ||
      b > e.far ||
      a.push({
        distance: b,
        point: _intersectPoint.clone(),
        uv: Triangle.getInterpolation(
          _intersectPoint,
          _vA,
          _vB,
          _vC,
          _uvA,
          _uvB,
          _uvC,
          new Vector2()
        ),
        face: null,
        object: this,
      })
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    )
  }
}
function transformVertex(s, e, a, o, c, d) {
  _alignedPosition.subVectors(s, a).addScalar(0.5).multiply(o),
    c !== void 0
      ? ((_rotatedPosition.x = d * _alignedPosition.x - c * _alignedPosition.y),
        (_rotatedPosition.y = c * _alignedPosition.x + d * _alignedPosition.y))
      : _rotatedPosition.copy(_alignedPosition),
    s.copy(e),
    (s.x += _rotatedPosition.x),
    (s.y += _rotatedPosition.y),
    s.applyMatrix4(_viewWorldMatrix)
}
const _v1$2 = new Vector3(),
  _v2$1 = new Vector3()
class LOD extends Object3D {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0)
  }
  copy(e) {
    super.copy(e, !1)
    const a = e.levels
    for (let o = 0, c = a.length; o < c; o++) {
      const d = a[o]
      this.addLevel(d.object.clone(), d.distance, d.hysteresis)
    }
    return (this.autoUpdate = e.autoUpdate), this
  }
  addLevel(e, a = 0, o = 0) {
    a = Math.abs(a)
    const c = this.levels
    let d
    for (d = 0; d < c.length && !(a < c[d].distance); d++);
    return (
      c.splice(d, 0, { distance: a, hysteresis: o, object: e }),
      this.add(e),
      this
    )
  }
  getCurrentLevel() {
    return this._currentLevel
  }
  getObjectForDistance(e) {
    const a = this.levels
    if (a.length > 0) {
      let o, c
      for (o = 1, c = a.length; o < c; o++) {
        let d = a[o].distance
        if ((a[o].object.visible && (d -= d * a[o].hysteresis), e < d)) break
      }
      return a[o - 1].object
    }
    return null
  }
  raycast(e, a) {
    if (this.levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld)
      const c = e.ray.origin.distanceTo(_v1$2)
      this.getObjectForDistance(c).raycast(e, a)
    }
  }
  update(e) {
    const a = this.levels
    if (a.length > 1) {
      _v1$2.setFromMatrixPosition(e.matrixWorld),
        _v2$1.setFromMatrixPosition(this.matrixWorld)
      const o = _v1$2.distanceTo(_v2$1) / e.zoom
      a[0].object.visible = !0
      let c, d
      for (c = 1, d = a.length; c < d; c++) {
        let g = a[c].distance
        if ((a[c].object.visible && (g -= g * a[c].hysteresis), o >= g))
          (a[c - 1].object.visible = !1), (a[c].object.visible = !0)
        else break
      }
      for (this._currentLevel = c - 1; c < d; c++) a[c].object.visible = !1
    }
  }
  toJSON(e) {
    const a = super.toJSON(e)
    this.autoUpdate === !1 && (a.object.autoUpdate = !1), (a.object.levels = [])
    const o = this.levels
    for (let c = 0, d = o.length; c < d; c++) {
      const g = o[c]
      a.object.levels.push({
        object: g.object.uuid,
        distance: g.distance,
        hysteresis: g.hysteresis,
      })
    }
    return a
  }
}
const _basePosition = new Vector3(),
  _skinIndex = new Vector4(),
  _skinWeight = new Vector4(),
  _vector3 = new Vector3(),
  _matrix4 = new Matrix4(),
  _vertex = new Vector3(),
  _sphere$3 = new Sphere(),
  _inverseMatrix$2 = new Matrix4(),
  _ray$2 = new Ray()
class SkinnedMesh extends Mesh {
  constructor(e, a) {
    super(e, a),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new Matrix4()),
      (this.bindMatrixInverse = new Matrix4()),
      (this.boundingBox = null),
      (this.boundingSphere = null)
  }
  computeBoundingBox() {
    const e = this.geometry
    this.boundingBox === null && (this.boundingBox = new Box3()),
      this.boundingBox.makeEmpty()
    const a = e.getAttribute("position")
    for (let o = 0; o < a.count; o++)
      _vertex.fromBufferAttribute(a, o),
        this.applyBoneTransform(o, _vertex),
        this.boundingBox.expandByPoint(_vertex)
  }
  computeBoundingSphere() {
    const e = this.geometry
    this.boundingSphere === null && (this.boundingSphere = new Sphere()),
      this.boundingSphere.makeEmpty()
    const a = e.getAttribute("position")
    for (let o = 0; o < a.count; o++)
      _vertex.fromBufferAttribute(a, o),
        this.applyBoneTransform(o, _vertex),
        this.boundingSphere.expandByPoint(_vertex)
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    )
  }
  raycast(e, a) {
    const o = this.material,
      c = this.matrixWorld
    o !== void 0 &&
      (this.boundingSphere === null && this.computeBoundingSphere(),
      _sphere$3.copy(this.boundingSphere),
      _sphere$3.applyMatrix4(c),
      e.ray.intersectsSphere(_sphere$3) !== !1 &&
        (_inverseMatrix$2.copy(c).invert(),
        _ray$2.copy(e.ray).applyMatrix4(_inverseMatrix$2),
        !(
          this.boundingBox !== null &&
          _ray$2.intersectsBox(this.boundingBox) === !1
        ) && this._computeIntersections(e, a, _ray$2)))
  }
  getVertexPosition(e, a) {
    return super.getVertexPosition(e, a), this.applyBoneTransform(e, a), a
  }
  bind(e, a) {
    ;(this.skeleton = e),
      a === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (a = this.matrixWorld)),
      this.bindMatrix.copy(a),
      this.bindMatrixInverse.copy(a).invert()
  }
  pose() {
    this.skeleton.pose()
  }
  normalizeSkinWeights() {
    const e = new Vector4(),
      a = this.geometry.attributes.skinWeight
    for (let o = 0, c = a.count; o < c; o++) {
      e.fromBufferAttribute(a, o)
      const d = 1 / e.manhattanLength()
      d !== 1 / 0 ? e.multiplyScalar(d) : e.set(1, 0, 0, 0),
        a.setXYZW(o, e.x, e.y, e.z, e.w)
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          )
  }
  applyBoneTransform(e, a) {
    const o = this.skeleton,
      c = this.geometry
    _skinIndex.fromBufferAttribute(c.attributes.skinIndex, e),
      _skinWeight.fromBufferAttribute(c.attributes.skinWeight, e),
      _basePosition.copy(a).applyMatrix4(this.bindMatrix),
      a.set(0, 0, 0)
    for (let d = 0; d < 4; d++) {
      const g = _skinWeight.getComponent(d)
      if (g !== 0) {
        const _ = _skinIndex.getComponent(d)
        _matrix4.multiplyMatrices(o.bones[_].matrixWorld, o.boneInverses[_]),
          a.addScaledVector(
            _vector3.copy(_basePosition).applyMatrix4(_matrix4),
            g
          )
      }
    }
    return a.applyMatrix4(this.bindMatrixInverse)
  }
  boneTransform(e, a) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, a)
    )
  }
}
class Bone extends Object3D {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone")
  }
}
class DataTexture extends Texture {
  constructor(
    e = null,
    a = 1,
    o = 1,
    c,
    d,
    g,
    _,
    b,
    j = NearestFilter,
    $ = NearestFilter,
    _e,
    tt
  ) {
    super(null, g, _, b, j, $, c, d, _e, tt),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: a, height: o }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1)
  }
}
const _offsetMatrix = new Matrix4(),
  _identityMatrix$1 = new Matrix4()
class Skeleton {
  constructor(e = [], a = []) {
    ;(this.uuid = generateUUID()),
      (this.bones = e.slice(0)),
      (this.boneInverses = a),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      this.init()
  }
  init() {
    const e = this.bones,
      a = this.boneInverses
    if (((this.boneMatrices = new Float32Array(e.length * 16)), a.length === 0))
      this.calculateInverses()
    else if (e.length !== a.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = [])
      for (let o = 0, c = this.bones.length; o < c; o++)
        this.boneInverses.push(new Matrix4())
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0
    for (let e = 0, a = this.bones.length; e < a; e++) {
      const o = new Matrix4()
      this.bones[e] && o.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(o)
    }
  }
  pose() {
    for (let e = 0, a = this.bones.length; e < a; e++) {
      const o = this.bones[e]
      o && o.matrixWorld.copy(this.boneInverses[e]).invert()
    }
    for (let e = 0, a = this.bones.length; e < a; e++) {
      const o = this.bones[e]
      o &&
        (o.parent && o.parent.isBone
          ? (o.matrix.copy(o.parent.matrixWorld).invert(),
            o.matrix.multiply(o.matrixWorld))
          : o.matrix.copy(o.matrixWorld),
        o.matrix.decompose(o.position, o.quaternion, o.scale))
    }
  }
  update() {
    const e = this.bones,
      a = this.boneInverses,
      o = this.boneMatrices,
      c = this.boneTexture
    for (let d = 0, g = e.length; d < g; d++) {
      const _ = e[d] ? e[d].matrixWorld : _identityMatrix$1
      _offsetMatrix.multiplyMatrices(_, a[d]), _offsetMatrix.toArray(o, d * 16)
    }
    c !== null && (c.needsUpdate = !0)
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses)
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4)
    ;(e = ceilPowerOfTwo(e)), (e = Math.max(e, 4))
    const a = new Float32Array(e * e * 4)
    a.set(this.boneMatrices)
    const o = new DataTexture(a, e, e, RGBAFormat, FloatType)
    return (
      (o.needsUpdate = !0),
      (this.boneMatrices = a),
      (this.boneTexture = o),
      (this.boneTextureSize = e),
      this
    )
  }
  getBoneByName(e) {
    for (let a = 0, o = this.bones.length; a < o; a++) {
      const c = this.bones[a]
      if (c.name === e) return c
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null))
  }
  fromJSON(e, a) {
    this.uuid = e.uuid
    for (let o = 0, c = e.bones.length; o < c; o++) {
      const d = e.bones[o]
      let g = a[d]
      g === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", d),
        (g = new Bone())),
        this.bones.push(g),
        this.boneInverses.push(new Matrix4().fromArray(e.boneInverses[o]))
    }
    return this.init(), this
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    }
    e.uuid = this.uuid
    const a = this.bones,
      o = this.boneInverses
    for (let c = 0, d = a.length; c < d; c++) {
      const g = a[c]
      e.bones.push(g.uuid)
      const _ = o[c]
      e.boneInverses.push(_.toArray())
    }
    return e
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(e, a, o, c = 1) {
    super(e, a, o),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = c)
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    )
  }
}
const _instanceLocalMatrix = new Matrix4(),
  _instanceWorldMatrix = new Matrix4(),
  _instanceIntersects = [],
  _box3 = new Box3(),
  _identity = new Matrix4(),
  _mesh = new Mesh(),
  _sphere$2 = new Sphere()
class InstancedMesh extends Mesh {
  constructor(e, a, o) {
    super(e, a),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new InstancedBufferAttribute(
        new Float32Array(o * 16),
        16
      )),
      (this.instanceColor = null),
      (this.count = o),
      (this.boundingBox = null),
      (this.boundingSphere = null)
    for (let c = 0; c < o; c++) this.setMatrixAt(c, _identity)
  }
  computeBoundingBox() {
    const e = this.geometry,
      a = this.count
    this.boundingBox === null && (this.boundingBox = new Box3()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty()
    for (let o = 0; o < a; o++)
      this.getMatrixAt(o, _instanceLocalMatrix),
        _box3.copy(e.boundingBox).applyMatrix4(_instanceLocalMatrix),
        this.boundingBox.union(_box3)
  }
  computeBoundingSphere() {
    const e = this.geometry,
      a = this.count
    this.boundingSphere === null && (this.boundingSphere = new Sphere()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty()
    for (let o = 0; o < a; o++)
      this.getMatrixAt(o, _instanceLocalMatrix),
        _sphere$2.copy(e.boundingSphere).applyMatrix4(_instanceLocalMatrix),
        this.boundingSphere.union(_sphere$2)
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
      e.boundingSphere !== null &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    )
  }
  getColorAt(e, a) {
    a.fromArray(this.instanceColor.array, e * 3)
  }
  getMatrixAt(e, a) {
    a.fromArray(this.instanceMatrix.array, e * 16)
  }
  raycast(e, a) {
    const o = this.matrixWorld,
      c = this.count
    if (
      ((_mesh.geometry = this.geometry),
      (_mesh.material = this.material),
      _mesh.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        _sphere$2.copy(this.boundingSphere),
        _sphere$2.applyMatrix4(o),
        e.ray.intersectsSphere(_sphere$2) !== !1))
    )
      for (let d = 0; d < c; d++) {
        this.getMatrixAt(d, _instanceLocalMatrix),
          _instanceWorldMatrix.multiplyMatrices(o, _instanceLocalMatrix),
          (_mesh.matrixWorld = _instanceWorldMatrix),
          _mesh.raycast(e, _instanceIntersects)
        for (let g = 0, _ = _instanceIntersects.length; g < _; g++) {
          const b = _instanceIntersects[g]
          ;(b.instanceId = d), (b.object = this), a.push(b)
        }
        _instanceIntersects.length = 0
      }
  }
  setColorAt(e, a) {
    this.instanceColor === null &&
      (this.instanceColor = new InstancedBufferAttribute(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      a.toArray(this.instanceColor.array, e * 3)
  }
  setMatrixAt(e, a) {
    a.toArray(this.instanceMatrix.array, e * 16)
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" })
  }
}
class LineBasicMaterial extends Material {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    )
  }
}
const _start$1 = new Vector3(),
  _end$1 = new Vector3(),
  _inverseMatrix$1 = new Matrix4(),
  _ray$1 = new Ray(),
  _sphere$1 = new Sphere()
class Line extends Object3D {
  constructor(e = new BufferGeometry(), a = new LineBasicMaterial()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = a),
      this.updateMorphTargets()
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  computeLineDistances() {
    const e = this.geometry
    if (e.index === null) {
      const a = e.attributes.position,
        o = [0]
      for (let c = 1, d = a.count; c < d; c++)
        _start$1.fromBufferAttribute(a, c - 1),
          _end$1.fromBufferAttribute(a, c),
          (o[c] = o[c - 1]),
          (o[c] += _start$1.distanceTo(_end$1))
      e.setAttribute("lineDistance", new Float32BufferAttribute(o, 1))
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      )
    return this
  }
  raycast(e, a) {
    const o = this.geometry,
      c = this.matrixWorld,
      d = e.params.Line.threshold,
      g = o.drawRange
    if (
      (o.boundingSphere === null && o.computeBoundingSphere(),
      _sphere$1.copy(o.boundingSphere),
      _sphere$1.applyMatrix4(c),
      (_sphere$1.radius += d),
      e.ray.intersectsSphere(_sphere$1) === !1)
    )
      return
    _inverseMatrix$1.copy(c).invert(),
      _ray$1.copy(e.ray).applyMatrix4(_inverseMatrix$1)
    const _ = d / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      b = _ * _,
      j = new Vector3(),
      $ = new Vector3(),
      _e = new Vector3(),
      tt = new Vector3(),
      st = this.isLineSegments ? 2 : 1,
      at = o.index,
      ut = o.attributes.position
    if (at !== null) {
      const it = Math.max(0, g.start),
        ct = Math.min(at.count, g.start + g.count)
      for (let lt = it, ht = ct - 1; lt < ht; lt += st) {
        const dt = at.getX(lt),
          pt = at.getX(lt + 1)
        if (
          (j.fromBufferAttribute(ut, dt),
          $.fromBufferAttribute(ut, pt),
          _ray$1.distanceSqToSegment(j, $, tt, _e) > b)
        )
          continue
        tt.applyMatrix4(this.matrixWorld)
        const _t = e.ray.origin.distanceTo(tt)
        _t < e.near ||
          _t > e.far ||
          a.push({
            distance: _t,
            point: _e.clone().applyMatrix4(this.matrixWorld),
            index: lt,
            face: null,
            faceIndex: null,
            object: this,
          })
      }
    } else {
      const it = Math.max(0, g.start),
        ct = Math.min(ut.count, g.start + g.count)
      for (let lt = it, ht = ct - 1; lt < ht; lt += st) {
        if (
          (j.fromBufferAttribute(ut, lt),
          $.fromBufferAttribute(ut, lt + 1),
          _ray$1.distanceSqToSegment(j, $, tt, _e) > b)
        )
          continue
        tt.applyMatrix4(this.matrixWorld)
        const pt = e.ray.origin.distanceTo(tt)
        pt < e.near ||
          pt > e.far ||
          a.push({
            distance: pt,
            point: _e.clone().applyMatrix4(this.matrixWorld),
            index: lt,
            face: null,
            faceIndex: null,
            object: this,
          })
      }
    }
  }
  updateMorphTargets() {
    const a = this.geometry.morphAttributes,
      o = Object.keys(a)
    if (o.length > 0) {
      const c = a[o[0]]
      if (c !== void 0) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let d = 0, g = c.length; d < g; d++) {
          const _ = c[d].name || String(d)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[_] = d)
        }
      }
    }
  }
}
const _start = new Vector3(),
  _end = new Vector3()
class LineSegments extends Line {
  constructor(e, a) {
    super(e, a), (this.isLineSegments = !0), (this.type = "LineSegments")
  }
  computeLineDistances() {
    const e = this.geometry
    if (e.index === null) {
      const a = e.attributes.position,
        o = []
      for (let c = 0, d = a.count; c < d; c += 2)
        _start.fromBufferAttribute(a, c),
          _end.fromBufferAttribute(a, c + 1),
          (o[c] = c === 0 ? 0 : o[c - 1]),
          (o[c + 1] = o[c] + _start.distanceTo(_end))
      e.setAttribute("lineDistance", new Float32BufferAttribute(o, 1))
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      )
    return this
  }
}
class LineLoop extends Line {
  constructor(e, a) {
    super(e, a), (this.isLineLoop = !0), (this.type = "LineLoop")
  }
}
class PointsMaterial extends Material {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    )
  }
}
const _inverseMatrix = new Matrix4(),
  _ray$4 = new Ray(),
  _sphere = new Sphere(),
  _position$2 = new Vector3()
let Points$1 = class extends Object3D {
  constructor(e = new BufferGeometry(), a = new PointsMaterial()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = a),
      this.updateMorphTargets()
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    )
  }
  raycast(e, a) {
    const o = this.geometry,
      c = this.matrixWorld,
      d = e.params.Points.threshold,
      g = o.drawRange
    if (
      (o.boundingSphere === null && o.computeBoundingSphere(),
      _sphere.copy(o.boundingSphere),
      _sphere.applyMatrix4(c),
      (_sphere.radius += d),
      e.ray.intersectsSphere(_sphere) === !1)
    )
      return
    _inverseMatrix.copy(c).invert(),
      _ray$4.copy(e.ray).applyMatrix4(_inverseMatrix)
    const _ = d / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      b = _ * _,
      j = o.index,
      _e = o.attributes.position
    if (j !== null) {
      const tt = Math.max(0, g.start),
        st = Math.min(j.count, g.start + g.count)
      for (let at = tt, ot = st; at < ot; at++) {
        const ut = j.getX(at)
        _position$2.fromBufferAttribute(_e, ut),
          testPoint(_position$2, ut, b, c, e, a, this)
      }
    } else {
      const tt = Math.max(0, g.start),
        st = Math.min(_e.count, g.start + g.count)
      for (let at = tt, ot = st; at < ot; at++)
        _position$2.fromBufferAttribute(_e, at),
          testPoint(_position$2, at, b, c, e, a, this)
    }
  }
  updateMorphTargets() {
    const a = this.geometry.morphAttributes,
      o = Object.keys(a)
    if (o.length > 0) {
      const c = a[o[0]]
      if (c !== void 0) {
        ;(this.morphTargetInfluences = []), (this.morphTargetDictionary = {})
        for (let d = 0, g = c.length; d < g; d++) {
          const _ = c[d].name || String(d)
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[_] = d)
        }
      }
    }
  }
}
function testPoint(s, e, a, o, c, d, g) {
  const _ = _ray$4.distanceSqToPoint(s)
  if (_ < a) {
    const b = new Vector3()
    _ray$4.closestPointToPoint(s, b), b.applyMatrix4(o)
    const j = c.ray.origin.distanceTo(b)
    if (j < c.near || j > c.far) return
    d.push({
      distance: j,
      distanceToRay: Math.sqrt(_),
      point: b,
      index: e,
      face: null,
      object: g,
    })
  }
}
class VideoTexture extends Texture {
  constructor(e, a, o, c, d, g, _, b, j) {
    super(e, a, o, c, d, g, _, b, j),
      (this.isVideoTexture = !0),
      (this.minFilter = g !== void 0 ? g : LinearFilter),
      (this.magFilter = d !== void 0 ? d : LinearFilter),
      (this.generateMipmaps = !1)
    const $ = this
    function _e() {
      ;($.needsUpdate = !0), e.requestVideoFrameCallback(_e)
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(_e)
  }
  clone() {
    return new this.constructor(this.image).copy(this)
  }
  update() {
    const e = this.image
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0)
  }
}
class FramebufferTexture extends Texture {
  constructor(e, a) {
    super({ width: e, height: a }),
      (this.isFramebufferTexture = !0),
      (this.magFilter = NearestFilter),
      (this.minFilter = NearestFilter),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0)
  }
}
class CompressedTexture extends Texture {
  constructor(e, a, o, c, d, g, _, b, j, $, _e, tt) {
    super(null, g, _, b, j, $, c, d, _e, tt),
      (this.isCompressedTexture = !0),
      (this.image = { width: a, height: o }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1)
  }
}
class CompressedArrayTexture extends CompressedTexture {
  constructor(e, a, o, c, d, g) {
    super(e, a, o, d, g),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = c),
      (this.wrapR = ClampToEdgeWrapping)
  }
}
class CompressedCubeTexture extends CompressedTexture {
  constructor(e, a, o) {
    super(void 0, e[0].width, e[0].height, a, o, CubeReflectionMapping),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e)
  }
}
class CanvasTexture extends Texture {
  constructor(e, a, o, c, d, g, _, b, j) {
    super(e, a, o, c, d, g, _, b, j),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0)
  }
}
class Curve {
  constructor() {
    ;(this.type = "Curve"), (this.arcLengthDivisions = 200)
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null
  }
  getPointAt(e, a) {
    const o = this.getUtoTmapping(e)
    return this.getPoint(o, a)
  }
  getPoints(e = 5) {
    const a = []
    for (let o = 0; o <= e; o++) a.push(this.getPoint(o / e))
    return a
  }
  getSpacedPoints(e = 5) {
    const a = []
    for (let o = 0; o <= e; o++) a.push(this.getPointAt(o / e))
    return a
  }
  getLength() {
    const e = this.getLengths()
    return e[e.length - 1]
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths
    this.needsUpdate = !1
    const a = []
    let o,
      c = this.getPoint(0),
      d = 0
    a.push(0)
    for (let g = 1; g <= e; g++)
      (o = this.getPoint(g / e)), (d += o.distanceTo(c)), a.push(d), (c = o)
    return (this.cacheArcLengths = a), a
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), this.getLengths()
  }
  getUtoTmapping(e, a) {
    const o = this.getLengths()
    let c = 0
    const d = o.length
    let g
    a ? (g = a) : (g = e * o[d - 1])
    let _ = 0,
      b = d - 1,
      j
    for (; _ <= b; )
      if (((c = Math.floor(_ + (b - _) / 2)), (j = o[c] - g), j < 0)) _ = c + 1
      else if (j > 0) b = c - 1
      else {
        b = c
        break
      }
    if (((c = b), o[c] === g)) return c / (d - 1)
    const $ = o[c],
      tt = o[c + 1] - $,
      st = (g - $) / tt
    return (c + st) / (d - 1)
  }
  getTangent(e, a) {
    let c = e - 1e-4,
      d = e + 1e-4
    c < 0 && (c = 0), d > 1 && (d = 1)
    const g = this.getPoint(c),
      _ = this.getPoint(d),
      b = a || (g.isVector2 ? new Vector2() : new Vector3())
    return b.copy(_).sub(g).normalize(), b
  }
  getTangentAt(e, a) {
    const o = this.getUtoTmapping(e)
    return this.getTangent(o, a)
  }
  computeFrenetFrames(e, a) {
    const o = new Vector3(),
      c = [],
      d = [],
      g = [],
      _ = new Vector3(),
      b = new Matrix4()
    for (let st = 0; st <= e; st++) {
      const at = st / e
      c[st] = this.getTangentAt(at, new Vector3())
    }
    ;(d[0] = new Vector3()), (g[0] = new Vector3())
    let j = Number.MAX_VALUE
    const $ = Math.abs(c[0].x),
      _e = Math.abs(c[0].y),
      tt = Math.abs(c[0].z)
    $ <= j && ((j = $), o.set(1, 0, 0)),
      _e <= j && ((j = _e), o.set(0, 1, 0)),
      tt <= j && o.set(0, 0, 1),
      _.crossVectors(c[0], o).normalize(),
      d[0].crossVectors(c[0], _),
      g[0].crossVectors(c[0], d[0])
    for (let st = 1; st <= e; st++) {
      if (
        ((d[st] = d[st - 1].clone()),
        (g[st] = g[st - 1].clone()),
        _.crossVectors(c[st - 1], c[st]),
        _.length() > Number.EPSILON)
      ) {
        _.normalize()
        const at = Math.acos(clamp$2(c[st - 1].dot(c[st]), -1, 1))
        d[st].applyMatrix4(b.makeRotationAxis(_, at))
      }
      g[st].crossVectors(c[st], d[st])
    }
    if (a === !0) {
      let st = Math.acos(clamp$2(d[0].dot(d[e]), -1, 1))
      ;(st /= e), c[0].dot(_.crossVectors(d[0], d[e])) > 0 && (st = -st)
      for (let at = 1; at <= e; at++)
        d[at].applyMatrix4(b.makeRotationAxis(c[at], st * at)),
          g[at].crossVectors(c[at], d[at])
    }
    return { tangents: c, normals: d, binormals: g }
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    }
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    )
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this
  }
}
class EllipseCurve extends Curve {
  constructor(
    e = 0,
    a = 0,
    o = 1,
    c = 1,
    d = 0,
    g = Math.PI * 2,
    _ = !1,
    b = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = a),
      (this.xRadius = o),
      (this.yRadius = c),
      (this.aStartAngle = d),
      (this.aEndAngle = g),
      (this.aClockwise = _),
      (this.aRotation = b)
  }
  getPoint(e, a) {
    const o = a || new Vector2(),
      c = Math.PI * 2
    let d = this.aEndAngle - this.aStartAngle
    const g = Math.abs(d) < Number.EPSILON
    for (; d < 0; ) d += c
    for (; d > c; ) d -= c
    d < Number.EPSILON && (g ? (d = 0) : (d = c)),
      this.aClockwise === !0 && !g && (d === c ? (d = -c) : (d = d - c))
    const _ = this.aStartAngle + e * d
    let b = this.aX + this.xRadius * Math.cos(_),
      j = this.aY + this.yRadius * Math.sin(_)
    if (this.aRotation !== 0) {
      const $ = Math.cos(this.aRotation),
        _e = Math.sin(this.aRotation),
        tt = b - this.aX,
        st = j - this.aY
      ;(b = tt * $ - st * _e + this.aX), (j = tt * _e + st * $ + this.aY)
    }
    return o.set(b, j)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    )
  }
}
class ArcCurve extends EllipseCurve {
  constructor(e, a, o, c, d, g) {
    super(e, a, o, o, c, d, g), (this.isArcCurve = !0), (this.type = "ArcCurve")
  }
}
function CubicPoly() {
  let s = 0,
    e = 0,
    a = 0,
    o = 0
  function c(d, g, _, b) {
    ;(s = d),
      (e = _),
      (a = -3 * d + 3 * g - 2 * _ - b),
      (o = 2 * d - 2 * g + _ + b)
  }
  return {
    initCatmullRom: function (d, g, _, b, j) {
      c(g, _, j * (_ - d), j * (b - g))
    },
    initNonuniformCatmullRom: function (d, g, _, b, j, $, _e) {
      let tt = (g - d) / j - (_ - d) / (j + $) + (_ - g) / $,
        st = (_ - g) / $ - (b - g) / ($ + _e) + (b - _) / _e
      ;(tt *= $), (st *= $), c(g, _, tt, st)
    },
    calc: function (d) {
      const g = d * d,
        _ = g * d
      return s + e * d + a * g + o * _
    },
  }
}
const tmp = new Vector3(),
  px$1 = new CubicPoly(),
  py = new CubicPoly(),
  pz = new CubicPoly()
class CatmullRomCurve3 extends Curve {
  constructor(e = [], a = !1, o = "centripetal", c = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = a),
      (this.curveType = o),
      (this.tension = c)
  }
  getPoint(e, a = new Vector3()) {
    const o = a,
      c = this.points,
      d = c.length,
      g = (d - (this.closed ? 0 : 1)) * e
    let _ = Math.floor(g),
      b = g - _
    this.closed
      ? (_ += _ > 0 ? 0 : (Math.floor(Math.abs(_) / d) + 1) * d)
      : b === 0 && _ === d - 1 && ((_ = d - 2), (b = 1))
    let j, $
    this.closed || _ > 0
      ? (j = c[(_ - 1) % d])
      : (tmp.subVectors(c[0], c[1]).add(c[0]), (j = tmp))
    const _e = c[_ % d],
      tt = c[(_ + 1) % d]
    if (
      (this.closed || _ + 2 < d
        ? ($ = c[(_ + 2) % d])
        : (tmp.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), ($ = tmp)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const st = this.curveType === "chordal" ? 0.5 : 0.25
      let at = Math.pow(j.distanceToSquared(_e), st),
        ot = Math.pow(_e.distanceToSquared(tt), st),
        ut = Math.pow(tt.distanceToSquared($), st)
      ot < 1e-4 && (ot = 1),
        at < 1e-4 && (at = ot),
        ut < 1e-4 && (ut = ot),
        px$1.initNonuniformCatmullRom(j.x, _e.x, tt.x, $.x, at, ot, ut),
        py.initNonuniformCatmullRom(j.y, _e.y, tt.y, $.y, at, ot, ut),
        pz.initNonuniformCatmullRom(j.z, _e.z, tt.z, $.z, at, ot, ut)
    } else
      this.curveType === "catmullrom" &&
        (px$1.initCatmullRom(j.x, _e.x, tt.x, $.x, this.tension),
        py.initCatmullRom(j.y, _e.y, tt.y, $.y, this.tension),
        pz.initCatmullRom(j.z, _e.z, tt.z, $.z, this.tension))
    return o.set(px$1.calc(b), py.calc(b), pz.calc(b)), o
  }
  copy(e) {
    super.copy(e), (this.points = [])
    for (let a = 0, o = e.points.length; a < o; a++) {
      const c = e.points[a]
      this.points.push(c.clone())
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    e.points = []
    for (let a = 0, o = this.points.length; a < o; a++) {
      const c = this.points[a]
      e.points.push(c.toArray())
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    )
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = [])
    for (let a = 0, o = e.points.length; a < o; a++) {
      const c = e.points[a]
      this.points.push(new Vector3().fromArray(c))
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    )
  }
}
function CatmullRom(s, e, a, o, c) {
  const d = (o - e) * 0.5,
    g = (c - a) * 0.5,
    _ = s * s,
    b = s * _
  return (
    (2 * a - 2 * o + d + g) * b + (-3 * a + 3 * o - 2 * d - g) * _ + d * s + a
  )
}
function QuadraticBezierP0(s, e) {
  const a = 1 - s
  return a * a * e
}
function QuadraticBezierP1(s, e) {
  return 2 * (1 - s) * s * e
}
function QuadraticBezierP2(s, e) {
  return s * s * e
}
function QuadraticBezier(s, e, a, o) {
  return (
    QuadraticBezierP0(s, e) + QuadraticBezierP1(s, a) + QuadraticBezierP2(s, o)
  )
}
function CubicBezierP0(s, e) {
  const a = 1 - s
  return a * a * a * e
}
function CubicBezierP1(s, e) {
  const a = 1 - s
  return 3 * a * a * s * e
}
function CubicBezierP2(s, e) {
  return 3 * (1 - s) * s * s * e
}
function CubicBezierP3(s, e) {
  return s * s * s * e
}
function CubicBezier(s, e, a, o, c) {
  return (
    CubicBezierP0(s, e) +
    CubicBezierP1(s, a) +
    CubicBezierP2(s, o) +
    CubicBezierP3(s, c)
  )
}
class CubicBezierCurve extends Curve {
  constructor(
    e = new Vector2(),
    a = new Vector2(),
    o = new Vector2(),
    c = new Vector2()
  ) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = a),
      (this.v2 = o),
      (this.v3 = c)
  }
  getPoint(e, a = new Vector2()) {
    const o = a,
      c = this.v0,
      d = this.v1,
      g = this.v2,
      _ = this.v3
    return (
      o.set(
        CubicBezier(e, c.x, d.x, g.x, _.x),
        CubicBezier(e, c.y, d.y, g.y, _.y)
      ),
      o
    )
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    )
  }
}
class CubicBezierCurve3 extends Curve {
  constructor(
    e = new Vector3(),
    a = new Vector3(),
    o = new Vector3(),
    c = new Vector3()
  ) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = a),
      (this.v2 = o),
      (this.v3 = c)
  }
  getPoint(e, a = new Vector3()) {
    const o = a,
      c = this.v0,
      d = this.v1,
      g = this.v2,
      _ = this.v3
    return (
      o.set(
        CubicBezier(e, c.x, d.x, g.x, _.x),
        CubicBezier(e, c.y, d.y, g.y, _.y),
        CubicBezier(e, c.z, d.z, g.z, _.z)
      ),
      o
    )
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    )
  }
}
class LineCurve extends Curve {
  constructor(e = new Vector2(), a = new Vector2()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = a)
  }
  getPoint(e, a = new Vector2()) {
    const o = a
    return (
      e === 1
        ? o.copy(this.v2)
        : (o.copy(this.v2).sub(this.v1), o.multiplyScalar(e).add(this.v1)),
      o
    )
  }
  getPointAt(e, a) {
    return this.getPoint(e, a)
  }
  getTangent(e, a = new Vector2()) {
    return a.subVectors(this.v2, this.v1).normalize()
  }
  getTangentAt(e, a) {
    return this.getTangent(e, a)
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
  }
  toJSON() {
    const e = super.toJSON()
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    )
  }
}
class LineCurve3 extends Curve {
  constructor(e = new Vector3(), a = new Vector3()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = a)
  }
  getPoint(e, a = new Vector3()) {
    const o = a
    return (
      e === 1
        ? o.copy(this.v2)
        : (o.copy(this.v2).sub(this.v1), o.multiplyScalar(e).add(this.v1)),
      o
    )
  }
  getPointAt(e, a) {
    return this.getPoint(e, a)
  }
  getTangent(e, a = new Vector3()) {
    return a.subVectors(this.v2, this.v1).normalize()
  }
  getTangentAt(e, a) {
    return this.getTangent(e, a)
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
  }
  toJSON() {
    const e = super.toJSON()
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    )
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(e = new Vector2(), a = new Vector2(), o = new Vector2()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = a),
      (this.v2 = o)
  }
  getPoint(e, a = new Vector2()) {
    const o = a,
      c = this.v0,
      d = this.v1,
      g = this.v2
    return (
      o.set(
        QuadraticBezier(e, c.x, d.x, g.x),
        QuadraticBezier(e, c.y, d.y, g.y)
      ),
      o
    )
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    )
  }
}
class QuadraticBezierCurve3 extends Curve {
  constructor(e = new Vector3(), a = new Vector3(), o = new Vector3()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = a),
      (this.v2 = o)
  }
  getPoint(e, a = new Vector3()) {
    const o = a,
      c = this.v0,
      d = this.v1,
      g = this.v2
    return (
      o.set(
        QuadraticBezier(e, c.x, d.x, g.x),
        QuadraticBezier(e, c.y, d.y, g.y),
        QuadraticBezier(e, c.z, d.z, g.z)
      ),
      o
    )
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    )
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    )
  }
}
class SplineCurve extends Curve {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e)
  }
  getPoint(e, a = new Vector2()) {
    const o = a,
      c = this.points,
      d = (c.length - 1) * e,
      g = Math.floor(d),
      _ = d - g,
      b = c[g === 0 ? g : g - 1],
      j = c[g],
      $ = c[g > c.length - 2 ? c.length - 1 : g + 1],
      _e = c[g > c.length - 3 ? c.length - 1 : g + 2]
    return (
      o.set(
        CatmullRom(_, b.x, j.x, $.x, _e.x),
        CatmullRom(_, b.y, j.y, $.y, _e.y)
      ),
      o
    )
  }
  copy(e) {
    super.copy(e), (this.points = [])
    for (let a = 0, o = e.points.length; a < o; a++) {
      const c = e.points[a]
      this.points.push(c.clone())
    }
    return this
  }
  toJSON() {
    const e = super.toJSON()
    e.points = []
    for (let a = 0, o = this.points.length; a < o; a++) {
      const c = this.points[a]
      e.points.push(c.toArray())
    }
    return e
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = [])
    for (let a = 0, o = e.points.length; a < o; a++) {
      const c = e.points[a]
      this.points.push(new Vector2().fromArray(c))
    }
    return this
  }
}
var Curves = Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve,
})
class CurvePath extends Curve {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1)
  }
  add(e) {
    this.curves.push(e)
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      a = this.curves[this.curves.length - 1].getPoint(1)
    e.equals(a) || this.curves.push(new LineCurve(a, e))
  }
  getPoint(e, a) {
    const o = e * this.getLength(),
      c = this.getCurveLengths()
    let d = 0
    for (; d < c.length; ) {
      if (c[d] >= o) {
        const g = c[d] - o,
          _ = this.curves[d],
          b = _.getLength(),
          j = b === 0 ? 0 : 1 - g / b
        return _.getPointAt(j, a)
      }
      d++
    }
    return null
  }
  getLength() {
    const e = this.getCurveLengths()
    return e[e.length - 1]
  }
  updateArcLengths() {
    ;(this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths()
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths
    const e = []
    let a = 0
    for (let o = 0, c = this.curves.length; o < c; o++)
      (a += this.curves[o].getLength()), e.push(a)
    return (this.cacheLengths = e), e
  }
  getSpacedPoints(e = 40) {
    const a = []
    for (let o = 0; o <= e; o++) a.push(this.getPoint(o / e))
    return this.autoClose && a.push(a[0]), a
  }
  getPoints(e = 12) {
    const a = []
    let o
    for (let c = 0, d = this.curves; c < d.length; c++) {
      const g = d[c],
        _ = g.isEllipseCurve
          ? e * 2
          : g.isLineCurve || g.isLineCurve3
          ? 1
          : g.isSplineCurve
          ? e * g.points.length
          : e,
        b = g.getPoints(_)
      for (let j = 0; j < b.length; j++) {
        const $ = b[j]
        ;(o && o.equals($)) || (a.push($), (o = $))
      }
    }
    return (
      this.autoClose &&
        a.length > 1 &&
        !a[a.length - 1].equals(a[0]) &&
        a.push(a[0]),
      a
    )
  }
  copy(e) {
    super.copy(e), (this.curves = [])
    for (let a = 0, o = e.curves.length; a < o; a++) {
      const c = e.curves[a]
      this.curves.push(c.clone())
    }
    return (this.autoClose = e.autoClose), this
  }
  toJSON() {
    const e = super.toJSON()
    ;(e.autoClose = this.autoClose), (e.curves = [])
    for (let a = 0, o = this.curves.length; a < o; a++) {
      const c = this.curves[a]
      e.curves.push(c.toJSON())
    }
    return e
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = [])
    for (let a = 0, o = e.curves.length; a < o; a++) {
      const c = e.curves[a]
      this.curves.push(new Curves[c.type]().fromJSON(c))
    }
    return this
  }
}
class Path extends CurvePath {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new Vector2()),
      e && this.setFromPoints(e)
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y)
    for (let a = 1, o = e.length; a < o; a++) this.lineTo(e[a].x, e[a].y)
    return this
  }
  moveTo(e, a) {
    return this.currentPoint.set(e, a), this
  }
  lineTo(e, a) {
    const o = new LineCurve(this.currentPoint.clone(), new Vector2(e, a))
    return this.curves.push(o), this.currentPoint.set(e, a), this
  }
  quadraticCurveTo(e, a, o, c) {
    const d = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, a),
      new Vector2(o, c)
    )
    return this.curves.push(d), this.currentPoint.set(o, c), this
  }
  bezierCurveTo(e, a, o, c, d, g) {
    const _ = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(e, a),
      new Vector2(o, c),
      new Vector2(d, g)
    )
    return this.curves.push(_), this.currentPoint.set(d, g), this
  }
  splineThru(e) {
    const a = [this.currentPoint.clone()].concat(e),
      o = new SplineCurve(a)
    return this.curves.push(o), this.currentPoint.copy(e[e.length - 1]), this
  }
  arc(e, a, o, c, d, g) {
    const _ = this.currentPoint.x,
      b = this.currentPoint.y
    return this.absarc(e + _, a + b, o, c, d, g), this
  }
  absarc(e, a, o, c, d, g) {
    return this.absellipse(e, a, o, o, c, d, g), this
  }
  ellipse(e, a, o, c, d, g, _, b) {
    const j = this.currentPoint.x,
      $ = this.currentPoint.y
    return this.absellipse(e + j, a + $, o, c, d, g, _, b), this
  }
  absellipse(e, a, o, c, d, g, _, b) {
    const j = new EllipseCurve(e, a, o, c, d, g, _, b)
    if (this.curves.length > 0) {
      const _e = j.getPoint(0)
      _e.equals(this.currentPoint) || this.lineTo(_e.x, _e.y)
    }
    this.curves.push(j)
    const $ = j.getPoint(1)
    return this.currentPoint.copy($), this
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this
  }
  toJSON() {
    const e = super.toJSON()
    return (e.currentPoint = this.currentPoint.toArray()), e
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(
    e = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)],
    a = 12,
    o = 0,
    c = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: a, phiStart: o, phiLength: c }),
      (a = Math.floor(a)),
      (c = clamp$2(c, 0, Math.PI * 2))
    const d = [],
      g = [],
      _ = [],
      b = [],
      j = [],
      $ = 1 / a,
      _e = new Vector3(),
      tt = new Vector2(),
      st = new Vector3(),
      at = new Vector3(),
      ot = new Vector3()
    let ut = 0,
      it = 0
    for (let ct = 0; ct <= e.length - 1; ct++)
      switch (ct) {
        case 0:
          ;(ut = e[ct + 1].x - e[ct].x),
            (it = e[ct + 1].y - e[ct].y),
            (st.x = it * 1),
            (st.y = -ut),
            (st.z = it * 0),
            ot.copy(st),
            st.normalize(),
            b.push(st.x, st.y, st.z)
          break
        case e.length - 1:
          b.push(ot.x, ot.y, ot.z)
          break
        default:
          ;(ut = e[ct + 1].x - e[ct].x),
            (it = e[ct + 1].y - e[ct].y),
            (st.x = it * 1),
            (st.y = -ut),
            (st.z = it * 0),
            at.copy(st),
            (st.x += ot.x),
            (st.y += ot.y),
            (st.z += ot.z),
            st.normalize(),
            b.push(st.x, st.y, st.z),
            ot.copy(at)
      }
    for (let ct = 0; ct <= a; ct++) {
      const lt = o + ct * $ * c,
        ht = Math.sin(lt),
        dt = Math.cos(lt)
      for (let pt = 0; pt <= e.length - 1; pt++) {
        ;(_e.x = e[pt].x * ht),
          (_e.y = e[pt].y),
          (_e.z = e[pt].x * dt),
          g.push(_e.x, _e.y, _e.z),
          (tt.x = ct / a),
          (tt.y = pt / (e.length - 1)),
          _.push(tt.x, tt.y)
        const vt = b[3 * pt + 0] * ht,
          _t = b[3 * pt + 1],
          yt = b[3 * pt + 0] * dt
        j.push(vt, _t, yt)
      }
    }
    for (let ct = 0; ct < a; ct++)
      for (let lt = 0; lt < e.length - 1; lt++) {
        const ht = lt + ct * e.length,
          dt = ht,
          pt = ht + e.length,
          vt = ht + e.length + 1,
          _t = ht + 1
        d.push(dt, pt, _t), d.push(vt, _t, pt)
      }
    this.setIndex(d),
      this.setAttribute("position", new Float32BufferAttribute(g, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(_, 2)),
      this.setAttribute("normal", new Float32BufferAttribute(j, 3))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new LatheGeometry(e.points, e.segments, e.phiStart, e.phiLength)
  }
}
class CapsuleGeometry extends LatheGeometry {
  constructor(e = 1, a = 1, o = 4, c = 8) {
    const d = new Path()
    d.absarc(0, -a / 2, e, Math.PI * 1.5, 0),
      d.absarc(0, a / 2, e, 0, Math.PI * 0.5),
      super(d.getPoints(o), c),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        length: a,
        capSegments: o,
        radialSegments: c,
      })
  }
  static fromJSON(e) {
    return new CapsuleGeometry(
      e.radius,
      e.length,
      e.capSegments,
      e.radialSegments
    )
  }
}
class CircleGeometry extends BufferGeometry {
  constructor(e = 1, a = 32, o = 0, c = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: a,
        thetaStart: o,
        thetaLength: c,
      }),
      (a = Math.max(3, a))
    const d = [],
      g = [],
      _ = [],
      b = [],
      j = new Vector3(),
      $ = new Vector2()
    g.push(0, 0, 0), _.push(0, 0, 1), b.push(0.5, 0.5)
    for (let _e = 0, tt = 3; _e <= a; _e++, tt += 3) {
      const st = o + (_e / a) * c
      ;(j.x = e * Math.cos(st)),
        (j.y = e * Math.sin(st)),
        g.push(j.x, j.y, j.z),
        _.push(0, 0, 1),
        ($.x = (g[tt] / e + 1) / 2),
        ($.y = (g[tt + 1] / e + 1) / 2),
        b.push($.x, $.y)
    }
    for (let _e = 1; _e <= a; _e++) d.push(_e, _e + 1, 0)
    this.setIndex(d),
      this.setAttribute("position", new Float32BufferAttribute(g, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(_, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(b, 2))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new CircleGeometry(e.radius, e.segments, e.thetaStart, e.thetaLength)
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(
    e = 1,
    a = 1,
    o = 1,
    c = 32,
    d = 1,
    g = !1,
    _ = 0,
    b = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: a,
        height: o,
        radialSegments: c,
        heightSegments: d,
        openEnded: g,
        thetaStart: _,
        thetaLength: b,
      })
    const j = this
    ;(c = Math.floor(c)), (d = Math.floor(d))
    const $ = [],
      _e = [],
      tt = [],
      st = []
    let at = 0
    const ot = [],
      ut = o / 2
    let it = 0
    ct(),
      g === !1 && (e > 0 && lt(!0), a > 0 && lt(!1)),
      this.setIndex($),
      this.setAttribute("position", new Float32BufferAttribute(_e, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(tt, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(st, 2))
    function ct() {
      const ht = new Vector3(),
        dt = new Vector3()
      let pt = 0
      const vt = (a - e) / o
      for (let _t = 0; _t <= d; _t++) {
        const yt = [],
          Et = _t / d,
          Rt = Et * (a - e) + e
        for (let Ft = 0; Ft <= c; Ft++) {
          const kt = Ft / c,
            Nt = kt * b + _,
            Dt = Math.sin(Nt),
            Mt = Math.cos(Nt)
          ;(dt.x = Rt * Dt),
            (dt.y = -Et * o + ut),
            (dt.z = Rt * Mt),
            _e.push(dt.x, dt.y, dt.z),
            ht.set(Dt, vt, Mt).normalize(),
            tt.push(ht.x, ht.y, ht.z),
            st.push(kt, 1 - Et),
            yt.push(at++)
        }
        ot.push(yt)
      }
      for (let _t = 0; _t < c; _t++)
        for (let yt = 0; yt < d; yt++) {
          const Et = ot[yt][_t],
            Rt = ot[yt + 1][_t],
            Ft = ot[yt + 1][_t + 1],
            kt = ot[yt][_t + 1]
          $.push(Et, Rt, kt), $.push(Rt, Ft, kt), (pt += 6)
        }
      j.addGroup(it, pt, 0), (it += pt)
    }
    function lt(ht) {
      const dt = at,
        pt = new Vector2(),
        vt = new Vector3()
      let _t = 0
      const yt = ht === !0 ? e : a,
        Et = ht === !0 ? 1 : -1
      for (let Ft = 1; Ft <= c; Ft++)
        _e.push(0, ut * Et, 0), tt.push(0, Et, 0), st.push(0.5, 0.5), at++
      const Rt = at
      for (let Ft = 0; Ft <= c; Ft++) {
        const Nt = (Ft / c) * b + _,
          Dt = Math.cos(Nt),
          Mt = Math.sin(Nt)
        ;(vt.x = yt * Mt),
          (vt.y = ut * Et),
          (vt.z = yt * Dt),
          _e.push(vt.x, vt.y, vt.z),
          tt.push(0, Et, 0),
          (pt.x = Dt * 0.5 + 0.5),
          (pt.y = Mt * 0.5 * Et + 0.5),
          st.push(pt.x, pt.y),
          at++
      }
      for (let Ft = 0; Ft < c; Ft++) {
        const kt = dt + Ft,
          Nt = Rt + Ft
        ht === !0 ? $.push(Nt, Nt + 1, kt) : $.push(Nt + 1, Nt, kt), (_t += 3)
      }
      j.addGroup(it, _t, ht === !0 ? 1 : 2), (it += _t)
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new CylinderGeometry(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(e = 1, a = 1, o = 32, c = 1, d = !1, g = 0, _ = Math.PI * 2) {
    super(0, e, a, o, c, d, g, _),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: a,
        radialSegments: o,
        heightSegments: c,
        openEnded: d,
        thetaStart: g,
        thetaLength: _,
      })
  }
  static fromJSON(e) {
    return new ConeGeometry(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(e = [], a = [], o = 1, c = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: a, radius: o, detail: c })
    const d = [],
      g = []
    _(c),
      j(o),
      $(),
      this.setAttribute("position", new Float32BufferAttribute(d, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(d.slice(), 3)),
      this.setAttribute("uv", new Float32BufferAttribute(g, 2)),
      c === 0 ? this.computeVertexNormals() : this.normalizeNormals()
    function _(ct) {
      const lt = new Vector3(),
        ht = new Vector3(),
        dt = new Vector3()
      for (let pt = 0; pt < a.length; pt += 3)
        st(a[pt + 0], lt),
          st(a[pt + 1], ht),
          st(a[pt + 2], dt),
          b(lt, ht, dt, ct)
    }
    function b(ct, lt, ht, dt) {
      const pt = dt + 1,
        vt = []
      for (let _t = 0; _t <= pt; _t++) {
        vt[_t] = []
        const yt = ct.clone().lerp(ht, _t / pt),
          Et = lt.clone().lerp(ht, _t / pt),
          Rt = pt - _t
        for (let Ft = 0; Ft <= Rt; Ft++)
          Ft === 0 && _t === pt
            ? (vt[_t][Ft] = yt)
            : (vt[_t][Ft] = yt.clone().lerp(Et, Ft / Rt))
      }
      for (let _t = 0; _t < pt; _t++)
        for (let yt = 0; yt < 2 * (pt - _t) - 1; yt++) {
          const Et = Math.floor(yt / 2)
          yt % 2 === 0
            ? (tt(vt[_t][Et + 1]), tt(vt[_t + 1][Et]), tt(vt[_t][Et]))
            : (tt(vt[_t][Et + 1]), tt(vt[_t + 1][Et + 1]), tt(vt[_t + 1][Et]))
        }
    }
    function j(ct) {
      const lt = new Vector3()
      for (let ht = 0; ht < d.length; ht += 3)
        (lt.x = d[ht + 0]),
          (lt.y = d[ht + 1]),
          (lt.z = d[ht + 2]),
          lt.normalize().multiplyScalar(ct),
          (d[ht + 0] = lt.x),
          (d[ht + 1] = lt.y),
          (d[ht + 2] = lt.z)
    }
    function $() {
      const ct = new Vector3()
      for (let lt = 0; lt < d.length; lt += 3) {
        ;(ct.x = d[lt + 0]), (ct.y = d[lt + 1]), (ct.z = d[lt + 2])
        const ht = ut(ct) / 2 / Math.PI + 0.5,
          dt = it(ct) / Math.PI + 0.5
        g.push(ht, 1 - dt)
      }
      at(), _e()
    }
    function _e() {
      for (let ct = 0; ct < g.length; ct += 6) {
        const lt = g[ct + 0],
          ht = g[ct + 2],
          dt = g[ct + 4],
          pt = Math.max(lt, ht, dt),
          vt = Math.min(lt, ht, dt)
        pt > 0.9 &&
          vt < 0.1 &&
          (lt < 0.2 && (g[ct + 0] += 1),
          ht < 0.2 && (g[ct + 2] += 1),
          dt < 0.2 && (g[ct + 4] += 1))
      }
    }
    function tt(ct) {
      d.push(ct.x, ct.y, ct.z)
    }
    function st(ct, lt) {
      const ht = ct * 3
      ;(lt.x = e[ht + 0]), (lt.y = e[ht + 1]), (lt.z = e[ht + 2])
    }
    function at() {
      const ct = new Vector3(),
        lt = new Vector3(),
        ht = new Vector3(),
        dt = new Vector3(),
        pt = new Vector2(),
        vt = new Vector2(),
        _t = new Vector2()
      for (let yt = 0, Et = 0; yt < d.length; yt += 9, Et += 6) {
        ct.set(d[yt + 0], d[yt + 1], d[yt + 2]),
          lt.set(d[yt + 3], d[yt + 4], d[yt + 5]),
          ht.set(d[yt + 6], d[yt + 7], d[yt + 8]),
          pt.set(g[Et + 0], g[Et + 1]),
          vt.set(g[Et + 2], g[Et + 3]),
          _t.set(g[Et + 4], g[Et + 5]),
          dt.copy(ct).add(lt).add(ht).divideScalar(3)
        const Rt = ut(dt)
        ot(pt, Et + 0, ct, Rt), ot(vt, Et + 2, lt, Rt), ot(_t, Et + 4, ht, Rt)
      }
    }
    function ot(ct, lt, ht, dt) {
      dt < 0 && ct.x === 1 && (g[lt] = ct.x - 1),
        ht.x === 0 && ht.z === 0 && (g[lt] = dt / 2 / Math.PI + 0.5)
    }
    function ut(ct) {
      return Math.atan2(ct.z, -ct.x)
    }
    function it(ct) {
      return Math.atan2(-ct.y, Math.sqrt(ct.x * ct.x + ct.z * ct.z))
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new PolyhedronGeometry(e.vertices, e.indices, e.radius, e.details)
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, a = 0) {
    const o = (1 + Math.sqrt(5)) / 2,
      c = 1 / o,
      d = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -c,
        -o,
        0,
        -c,
        o,
        0,
        c,
        -o,
        0,
        c,
        o,
        -c,
        -o,
        0,
        -c,
        o,
        0,
        c,
        -o,
        0,
        c,
        o,
        0,
        -o,
        0,
        -c,
        o,
        0,
        -c,
        -o,
        0,
        c,
        o,
        0,
        c,
      ],
      g = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ]
    super(d, g, e, a),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: a })
  }
  static fromJSON(e) {
    return new DodecahedronGeometry(e.radius, e.detail)
  }
}
const _v0 = new Vector3(),
  _v1$1 = new Vector3(),
  _normal = new Vector3(),
  _triangle = new Triangle()
class EdgesGeometry extends BufferGeometry {
  constructor(e = null, a = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: a }),
      e !== null)
    ) {
      const c = Math.pow(10, 4),
        d = Math.cos(DEG2RAD * a),
        g = e.getIndex(),
        _ = e.getAttribute("position"),
        b = g ? g.count : _.count,
        j = [0, 0, 0],
        $ = ["a", "b", "c"],
        _e = new Array(3),
        tt = {},
        st = []
      for (let at = 0; at < b; at += 3) {
        g
          ? ((j[0] = g.getX(at)),
            (j[1] = g.getX(at + 1)),
            (j[2] = g.getX(at + 2)))
          : ((j[0] = at), (j[1] = at + 1), (j[2] = at + 2))
        const { a: ot, b: ut, c: it } = _triangle
        if (
          (ot.fromBufferAttribute(_, j[0]),
          ut.fromBufferAttribute(_, j[1]),
          it.fromBufferAttribute(_, j[2]),
          _triangle.getNormal(_normal),
          (_e[0] = `${Math.round(ot.x * c)},${Math.round(
            ot.y * c
          )},${Math.round(ot.z * c)}`),
          (_e[1] = `${Math.round(ut.x * c)},${Math.round(
            ut.y * c
          )},${Math.round(ut.z * c)}`),
          (_e[2] = `${Math.round(it.x * c)},${Math.round(
            it.y * c
          )},${Math.round(it.z * c)}`),
          !(_e[0] === _e[1] || _e[1] === _e[2] || _e[2] === _e[0]))
        )
          for (let ct = 0; ct < 3; ct++) {
            const lt = (ct + 1) % 3,
              ht = _e[ct],
              dt = _e[lt],
              pt = _triangle[$[ct]],
              vt = _triangle[$[lt]],
              _t = `${ht}_${dt}`,
              yt = `${dt}_${ht}`
            yt in tt && tt[yt]
              ? (_normal.dot(tt[yt].normal) <= d &&
                  (st.push(pt.x, pt.y, pt.z), st.push(vt.x, vt.y, vt.z)),
                (tt[yt] = null))
              : _t in tt ||
                (tt[_t] = {
                  index0: j[ct],
                  index1: j[lt],
                  normal: _normal.clone(),
                })
          }
      }
      for (const at in tt)
        if (tt[at]) {
          const { index0: ot, index1: ut } = tt[at]
          _v0.fromBufferAttribute(_, ot),
            _v1$1.fromBufferAttribute(_, ut),
            st.push(_v0.x, _v0.y, _v0.z),
            st.push(_v1$1.x, _v1$1.y, _v1$1.z)
        }
      this.setAttribute("position", new Float32BufferAttribute(st, 3))
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
}
class Shape extends Path {
  constructor(e) {
    super(e),
      (this.uuid = generateUUID()),
      (this.type = "Shape"),
      (this.holes = [])
  }
  getPointsHoles(e) {
    const a = []
    for (let o = 0, c = this.holes.length; o < c; o++)
      a[o] = this.holes[o].getPoints(e)
    return a
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) }
  }
  copy(e) {
    super.copy(e), (this.holes = [])
    for (let a = 0, o = e.holes.length; a < o; a++) {
      const c = e.holes[a]
      this.holes.push(c.clone())
    }
    return this
  }
  toJSON() {
    const e = super.toJSON()
    ;(e.uuid = this.uuid), (e.holes = [])
    for (let a = 0, o = this.holes.length; a < o; a++) {
      const c = this.holes[a]
      e.holes.push(c.toJSON())
    }
    return e
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = [])
    for (let a = 0, o = e.holes.length; a < o; a++) {
      const c = e.holes[a]
      this.holes.push(new Path().fromJSON(c))
    }
    return this
  }
}
const Earcut = {
  triangulate: function (s, e, a = 2) {
    const o = e && e.length,
      c = o ? e[0] * a : s.length
    let d = linkedList(s, 0, c, a, !0)
    const g = []
    if (!d || d.next === d.prev) return g
    let _, b, j, $, _e, tt, st
    if ((o && (d = eliminateHoles(s, e, d, a)), s.length > 80 * a)) {
      ;(_ = j = s[0]), (b = $ = s[1])
      for (let at = a; at < c; at += a)
        (_e = s[at]),
          (tt = s[at + 1]),
          _e < _ && (_ = _e),
          tt < b && (b = tt),
          _e > j && (j = _e),
          tt > $ && ($ = tt)
      ;(st = Math.max(j - _, $ - b)), (st = st !== 0 ? 32767 / st : 0)
    }
    return earcutLinked(d, g, a, _, b, st, 0), g
  },
}
function linkedList(s, e, a, o, c) {
  let d, g
  if (c === signedArea(s, e, a, o) > 0)
    for (d = e; d < a; d += o) g = insertNode(d, s[d], s[d + 1], g)
  else for (d = a - o; d >= e; d -= o) g = insertNode(d, s[d], s[d + 1], g)
  return g && equals(g, g.next) && (removeNode(g), (g = g.next)), g
}
function filterPoints(s, e) {
  if (!s) return s
  e || (e = s)
  let a = s,
    o
  do
    if (
      ((o = !1),
      !a.steiner && (equals(a, a.next) || area(a.prev, a, a.next) === 0))
    ) {
      if ((removeNode(a), (a = e = a.prev), a === a.next)) break
      o = !0
    } else a = a.next
  while (o || a !== e)
  return e
}
function earcutLinked(s, e, a, o, c, d, g) {
  if (!s) return
  !g && d && indexCurve(s, o, c, d)
  let _ = s,
    b,
    j
  for (; s.prev !== s.next; ) {
    if (((b = s.prev), (j = s.next), d ? isEarHashed(s, o, c, d) : isEar(s))) {
      e.push((b.i / a) | 0),
        e.push((s.i / a) | 0),
        e.push((j.i / a) | 0),
        removeNode(s),
        (s = j.next),
        (_ = j.next)
      continue
    }
    if (((s = j), s === _)) {
      g
        ? g === 1
          ? ((s = cureLocalIntersections(filterPoints(s), e, a)),
            earcutLinked(s, e, a, o, c, d, 2))
          : g === 2 && splitEarcut(s, e, a, o, c, d)
        : earcutLinked(filterPoints(s), e, a, o, c, d, 1)
      break
    }
  }
}
function isEar(s) {
  const e = s.prev,
    a = s,
    o = s.next
  if (area(e, a, o) >= 0) return !1
  const c = e.x,
    d = a.x,
    g = o.x,
    _ = e.y,
    b = a.y,
    j = o.y,
    $ = c < d ? (c < g ? c : g) : d < g ? d : g,
    _e = _ < b ? (_ < j ? _ : j) : b < j ? b : j,
    tt = c > d ? (c > g ? c : g) : d > g ? d : g,
    st = _ > b ? (_ > j ? _ : j) : b > j ? b : j
  let at = o.next
  for (; at !== e; ) {
    if (
      at.x >= $ &&
      at.x <= tt &&
      at.y >= _e &&
      at.y <= st &&
      pointInTriangle(c, _, d, b, g, j, at.x, at.y) &&
      area(at.prev, at, at.next) >= 0
    )
      return !1
    at = at.next
  }
  return !0
}
function isEarHashed(s, e, a, o) {
  const c = s.prev,
    d = s,
    g = s.next
  if (area(c, d, g) >= 0) return !1
  const _ = c.x,
    b = d.x,
    j = g.x,
    $ = c.y,
    _e = d.y,
    tt = g.y,
    st = _ < b ? (_ < j ? _ : j) : b < j ? b : j,
    at = $ < _e ? ($ < tt ? $ : tt) : _e < tt ? _e : tt,
    ot = _ > b ? (_ > j ? _ : j) : b > j ? b : j,
    ut = $ > _e ? ($ > tt ? $ : tt) : _e > tt ? _e : tt,
    it = zOrder(st, at, e, a, o),
    ct = zOrder(ot, ut, e, a, o)
  let lt = s.prevZ,
    ht = s.nextZ
  for (; lt && lt.z >= it && ht && ht.z <= ct; ) {
    if (
      (lt.x >= st &&
        lt.x <= ot &&
        lt.y >= at &&
        lt.y <= ut &&
        lt !== c &&
        lt !== g &&
        pointInTriangle(_, $, b, _e, j, tt, lt.x, lt.y) &&
        area(lt.prev, lt, lt.next) >= 0) ||
      ((lt = lt.prevZ),
      ht.x >= st &&
        ht.x <= ot &&
        ht.y >= at &&
        ht.y <= ut &&
        ht !== c &&
        ht !== g &&
        pointInTriangle(_, $, b, _e, j, tt, ht.x, ht.y) &&
        area(ht.prev, ht, ht.next) >= 0)
    )
      return !1
    ht = ht.nextZ
  }
  for (; lt && lt.z >= it; ) {
    if (
      lt.x >= st &&
      lt.x <= ot &&
      lt.y >= at &&
      lt.y <= ut &&
      lt !== c &&
      lt !== g &&
      pointInTriangle(_, $, b, _e, j, tt, lt.x, lt.y) &&
      area(lt.prev, lt, lt.next) >= 0
    )
      return !1
    lt = lt.prevZ
  }
  for (; ht && ht.z <= ct; ) {
    if (
      ht.x >= st &&
      ht.x <= ot &&
      ht.y >= at &&
      ht.y <= ut &&
      ht !== c &&
      ht !== g &&
      pointInTriangle(_, $, b, _e, j, tt, ht.x, ht.y) &&
      area(ht.prev, ht, ht.next) >= 0
    )
      return !1
    ht = ht.nextZ
  }
  return !0
}
function cureLocalIntersections(s, e, a) {
  let o = s
  do {
    const c = o.prev,
      d = o.next.next
    !equals(c, d) &&
      intersects(c, o, o.next, d) &&
      locallyInside(c, d) &&
      locallyInside(d, c) &&
      (e.push((c.i / a) | 0),
      e.push((o.i / a) | 0),
      e.push((d.i / a) | 0),
      removeNode(o),
      removeNode(o.next),
      (o = s = d)),
      (o = o.next)
  } while (o !== s)
  return filterPoints(o)
}
function splitEarcut(s, e, a, o, c, d) {
  let g = s
  do {
    let _ = g.next.next
    for (; _ !== g.prev; ) {
      if (g.i !== _.i && isValidDiagonal(g, _)) {
        let b = splitPolygon(g, _)
        ;(g = filterPoints(g, g.next)),
          (b = filterPoints(b, b.next)),
          earcutLinked(g, e, a, o, c, d, 0),
          earcutLinked(b, e, a, o, c, d, 0)
        return
      }
      _ = _.next
    }
    g = g.next
  } while (g !== s)
}
function eliminateHoles(s, e, a, o) {
  const c = []
  let d, g, _, b, j
  for (d = 0, g = e.length; d < g; d++)
    (_ = e[d] * o),
      (b = d < g - 1 ? e[d + 1] * o : s.length),
      (j = linkedList(s, _, b, o, !1)),
      j === j.next && (j.steiner = !0),
      c.push(getLeftmost(j))
  for (c.sort(compareX), d = 0; d < c.length; d++) a = eliminateHole(c[d], a)
  return a
}
function compareX(s, e) {
  return s.x - e.x
}
function eliminateHole(s, e) {
  const a = findHoleBridge(s, e)
  if (!a) return e
  const o = splitPolygon(a, s)
  return filterPoints(o, o.next), filterPoints(a, a.next)
}
function findHoleBridge(s, e) {
  let a = e,
    o = -1 / 0,
    c
  const d = s.x,
    g = s.y
  do {
    if (g <= a.y && g >= a.next.y && a.next.y !== a.y) {
      const tt = a.x + ((g - a.y) * (a.next.x - a.x)) / (a.next.y - a.y)
      if (
        tt <= d &&
        tt > o &&
        ((o = tt), (c = a.x < a.next.x ? a : a.next), tt === d)
      )
        return c
    }
    a = a.next
  } while (a !== e)
  if (!c) return null
  const _ = c,
    b = c.x,
    j = c.y
  let $ = 1 / 0,
    _e
  a = c
  do
    d >= a.x &&
      a.x >= b &&
      d !== a.x &&
      pointInTriangle(g < j ? d : o, g, b, j, g < j ? o : d, g, a.x, a.y) &&
      ((_e = Math.abs(g - a.y) / (d - a.x)),
      locallyInside(a, s) &&
        (_e < $ ||
          (_e === $ &&
            (a.x > c.x || (a.x === c.x && sectorContainsSector(c, a))))) &&
        ((c = a), ($ = _e))),
      (a = a.next)
  while (a !== _)
  return c
}
function sectorContainsSector(s, e) {
  return area(s.prev, s, e.prev) < 0 && area(e.next, s, s.next) < 0
}
function indexCurve(s, e, a, o) {
  let c = s
  do
    c.z === 0 && (c.z = zOrder(c.x, c.y, e, a, o)),
      (c.prevZ = c.prev),
      (c.nextZ = c.next),
      (c = c.next)
  while (c !== s)
  ;(c.prevZ.nextZ = null), (c.prevZ = null), sortLinked(c)
}
function sortLinked(s) {
  let e,
    a,
    o,
    c,
    d,
    g,
    _,
    b,
    j = 1
  do {
    for (a = s, s = null, d = null, g = 0; a; ) {
      for (g++, o = a, _ = 0, e = 0; e < j && (_++, (o = o.nextZ), !!o); e++);
      for (b = j; _ > 0 || (b > 0 && o); )
        _ !== 0 && (b === 0 || !o || a.z <= o.z)
          ? ((c = a), (a = a.nextZ), _--)
          : ((c = o), (o = o.nextZ), b--),
          d ? (d.nextZ = c) : (s = c),
          (c.prevZ = d),
          (d = c)
      a = o
    }
    ;(d.nextZ = null), (j *= 2)
  } while (g > 1)
  return s
}
function zOrder(s, e, a, o, c) {
  return (
    (s = ((s - a) * c) | 0),
    (e = ((e - o) * c) | 0),
    (s = (s | (s << 8)) & 16711935),
    (s = (s | (s << 4)) & 252645135),
    (s = (s | (s << 2)) & 858993459),
    (s = (s | (s << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    s | (e << 1)
  )
}
function getLeftmost(s) {
  let e = s,
    a = s
  do (e.x < a.x || (e.x === a.x && e.y < a.y)) && (a = e), (e = e.next)
  while (e !== s)
  return a
}
function pointInTriangle(s, e, a, o, c, d, g, _) {
  return (
    (c - g) * (e - _) >= (s - g) * (d - _) &&
    (s - g) * (o - _) >= (a - g) * (e - _) &&
    (a - g) * (d - _) >= (c - g) * (o - _)
  )
}
function isValidDiagonal(s, e) {
  return (
    s.next.i !== e.i &&
    s.prev.i !== e.i &&
    !intersectsPolygon(s, e) &&
    ((locallyInside(s, e) &&
      locallyInside(e, s) &&
      middleInside(s, e) &&
      (area(s.prev, s, e.prev) || area(s, e.prev, e))) ||
      (equals(s, e) &&
        area(s.prev, s, s.next) > 0 &&
        area(e.prev, e, e.next) > 0))
  )
}
function area(s, e, a) {
  return (e.y - s.y) * (a.x - e.x) - (e.x - s.x) * (a.y - e.y)
}
function equals(s, e) {
  return s.x === e.x && s.y === e.y
}
function intersects(s, e, a, o) {
  const c = sign(area(s, e, a)),
    d = sign(area(s, e, o)),
    g = sign(area(a, o, s)),
    _ = sign(area(a, o, e))
  return !!(
    (c !== d && g !== _) ||
    (c === 0 && onSegment(s, a, e)) ||
    (d === 0 && onSegment(s, o, e)) ||
    (g === 0 && onSegment(a, s, o)) ||
    (_ === 0 && onSegment(a, e, o))
  )
}
function onSegment(s, e, a) {
  return (
    e.x <= Math.max(s.x, a.x) &&
    e.x >= Math.min(s.x, a.x) &&
    e.y <= Math.max(s.y, a.y) &&
    e.y >= Math.min(s.y, a.y)
  )
}
function sign(s) {
  return s > 0 ? 1 : s < 0 ? -1 : 0
}
function intersectsPolygon(s, e) {
  let a = s
  do {
    if (
      a.i !== s.i &&
      a.next.i !== s.i &&
      a.i !== e.i &&
      a.next.i !== e.i &&
      intersects(a, a.next, s, e)
    )
      return !0
    a = a.next
  } while (a !== s)
  return !1
}
function locallyInside(s, e) {
  return area(s.prev, s, s.next) < 0
    ? area(s, e, s.next) >= 0 && area(s, s.prev, e) >= 0
    : area(s, e, s.prev) < 0 || area(s, s.next, e) < 0
}
function middleInside(s, e) {
  let a = s,
    o = !1
  const c = (s.x + e.x) / 2,
    d = (s.y + e.y) / 2
  do
    a.y > d != a.next.y > d &&
      a.next.y !== a.y &&
      c < ((a.next.x - a.x) * (d - a.y)) / (a.next.y - a.y) + a.x &&
      (o = !o),
      (a = a.next)
  while (a !== s)
  return o
}
function splitPolygon(s, e) {
  const a = new Node(s.i, s.x, s.y),
    o = new Node(e.i, e.x, e.y),
    c = s.next,
    d = e.prev
  return (
    (s.next = e),
    (e.prev = s),
    (a.next = c),
    (c.prev = a),
    (o.next = a),
    (a.prev = o),
    (d.next = o),
    (o.prev = d),
    o
  )
}
function insertNode(s, e, a, o) {
  const c = new Node(s, e, a)
  return (
    o
      ? ((c.next = o.next), (c.prev = o), (o.next.prev = c), (o.next = c))
      : ((c.prev = c), (c.next = c)),
    c
  )
}
function removeNode(s) {
  ;(s.next.prev = s.prev),
    (s.prev.next = s.next),
    s.prevZ && (s.prevZ.nextZ = s.nextZ),
    s.nextZ && (s.nextZ.prevZ = s.prevZ)
}
function Node(s, e, a) {
  ;(this.i = s),
    (this.x = e),
    (this.y = a),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1)
}
function signedArea(s, e, a, o) {
  let c = 0
  for (let d = e, g = a - o; d < a; d += o)
    (c += (s[g] - s[d]) * (s[d + 1] + s[g + 1])), (g = d)
  return c
}
class ShapeUtils {
  static area(e) {
    const a = e.length
    let o = 0
    for (let c = a - 1, d = 0; d < a; c = d++)
      o += e[c].x * e[d].y - e[d].x * e[c].y
    return o * 0.5
  }
  static isClockWise(e) {
    return ShapeUtils.area(e) < 0
  }
  static triangulateShape(e, a) {
    const o = [],
      c = [],
      d = []
    removeDupEndPts(e), addContour(o, e)
    let g = e.length
    a.forEach(removeDupEndPts)
    for (let b = 0; b < a.length; b++)
      c.push(g), (g += a[b].length), addContour(o, a[b])
    const _ = Earcut.triangulate(o, c)
    for (let b = 0; b < _.length; b += 3) d.push(_.slice(b, b + 3))
    return d
  }
}
function removeDupEndPts(s) {
  const e = s.length
  e > 2 && s[e - 1].equals(s[0]) && s.pop()
}
function addContour(s, e) {
  for (let a = 0; a < e.length; a++) s.push(e[a].x), s.push(e[a].y)
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(
    e = new Shape([
      new Vector2(0.5, 0.5),
      new Vector2(-0.5, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    a = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: a }),
      (e = Array.isArray(e) ? e : [e])
    const o = this,
      c = [],
      d = []
    for (let _ = 0, b = e.length; _ < b; _++) {
      const j = e[_]
      g(j)
    }
    this.setAttribute("position", new Float32BufferAttribute(c, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(d, 2)),
      this.computeVertexNormals()
    function g(_) {
      const b = [],
        j = a.curveSegments !== void 0 ? a.curveSegments : 12,
        $ = a.steps !== void 0 ? a.steps : 1,
        _e = a.depth !== void 0 ? a.depth : 1
      let tt = a.bevelEnabled !== void 0 ? a.bevelEnabled : !0,
        st = a.bevelThickness !== void 0 ? a.bevelThickness : 0.2,
        at = a.bevelSize !== void 0 ? a.bevelSize : st - 0.1,
        ot = a.bevelOffset !== void 0 ? a.bevelOffset : 0,
        ut = a.bevelSegments !== void 0 ? a.bevelSegments : 3
      const it = a.extrudePath,
        ct = a.UVGenerator !== void 0 ? a.UVGenerator : WorldUVGenerator
      let lt,
        ht = !1,
        dt,
        pt,
        vt,
        _t
      it &&
        ((lt = it.getSpacedPoints($)),
        (ht = !0),
        (tt = !1),
        (dt = it.computeFrenetFrames($, !1)),
        (pt = new Vector3()),
        (vt = new Vector3()),
        (_t = new Vector3())),
        tt || ((ut = 0), (st = 0), (at = 0), (ot = 0))
      const yt = _.extractPoints(j)
      let Et = yt.shape
      const Rt = yt.holes
      if (!ShapeUtils.isClockWise(Et)) {
        Et = Et.reverse()
        for (let Ht = 0, on = Rt.length; Ht < on; Ht++) {
          const Yt = Rt[Ht]
          ShapeUtils.isClockWise(Yt) && (Rt[Ht] = Yt.reverse())
        }
      }
      const kt = ShapeUtils.triangulateShape(Et, Rt),
        Nt = Et
      for (let Ht = 0, on = Rt.length; Ht < on; Ht++) {
        const Yt = Rt[Ht]
        Et = Et.concat(Yt)
      }
      function Dt(Ht, on, Yt) {
        return (
          on || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          Ht.clone().addScaledVector(on, Yt)
        )
      }
      const Mt = Et.length,
        wt = kt.length
      function gt(Ht, on, Yt) {
        let _n, pn, Rn
        const bn = Ht.x - on.x,
          Pn = Ht.y - on.y,
          Gn = Yt.x - Ht.x,
          jn = Yt.y - Ht.y,
          ar = bn * bn + Pn * Pn,
          Vt = bn * jn - Pn * Gn
        if (Math.abs(Vt) > Number.EPSILON) {
          const Lt = Math.sqrt(ar),
            Zt = Math.sqrt(Gn * Gn + jn * jn),
            xn = on.x - Pn / Lt,
            vn = on.y + bn / Lt,
            An = Yt.x - jn / Zt,
            Nn = Yt.y + Gn / Zt,
            Sn = ((An - xn) * jn - (Nn - vn) * Gn) / (bn * jn - Pn * Gn)
          ;(_n = xn + bn * Sn - Ht.x), (pn = vn + Pn * Sn - Ht.y)
          const an = _n * _n + pn * pn
          if (an <= 2) return new Vector2(_n, pn)
          Rn = Math.sqrt(an / 2)
        } else {
          let Lt = !1
          bn > Number.EPSILON
            ? Gn > Number.EPSILON && (Lt = !0)
            : bn < -Number.EPSILON
            ? Gn < -Number.EPSILON && (Lt = !0)
            : Math.sign(Pn) === Math.sign(jn) && (Lt = !0),
            Lt
              ? ((_n = -Pn), (pn = bn), (Rn = Math.sqrt(ar)))
              : ((_n = bn), (pn = Pn), (Rn = Math.sqrt(ar / 2)))
        }
        return new Vector2(_n / Rn, pn / Rn)
      }
      const At = []
      for (
        let Ht = 0, on = Nt.length, Yt = on - 1, _n = Ht + 1;
        Ht < on;
        Ht++, Yt++, _n++
      )
        Yt === on && (Yt = 0),
          _n === on && (_n = 0),
          (At[Ht] = gt(Nt[Ht], Nt[Yt], Nt[_n]))
      const bt = []
      let Tt,
        It = At.concat()
      for (let Ht = 0, on = Rt.length; Ht < on; Ht++) {
        const Yt = Rt[Ht]
        Tt = []
        for (
          let _n = 0, pn = Yt.length, Rn = pn - 1, bn = _n + 1;
          _n < pn;
          _n++, Rn++, bn++
        )
          Rn === pn && (Rn = 0),
            bn === pn && (bn = 0),
            (Tt[_n] = gt(Yt[_n], Yt[Rn], Yt[bn]))
        bt.push(Tt), (It = It.concat(Tt))
      }
      for (let Ht = 0; Ht < ut; Ht++) {
        const on = Ht / ut,
          Yt = st * Math.cos((on * Math.PI) / 2),
          _n = at * Math.sin((on * Math.PI) / 2) + ot
        for (let pn = 0, Rn = Nt.length; pn < Rn; pn++) {
          const bn = Dt(Nt[pn], At[pn], _n)
          yn(bn.x, bn.y, -Yt)
        }
        for (let pn = 0, Rn = Rt.length; pn < Rn; pn++) {
          const bn = Rt[pn]
          Tt = bt[pn]
          for (let Pn = 0, Gn = bn.length; Pn < Gn; Pn++) {
            const jn = Dt(bn[Pn], Tt[Pn], _n)
            yn(jn.x, jn.y, -Yt)
          }
        }
      }
      const $t = at + ot
      for (let Ht = 0; Ht < Mt; Ht++) {
        const on = tt ? Dt(Et[Ht], It[Ht], $t) : Et[Ht]
        ht
          ? (vt.copy(dt.normals[0]).multiplyScalar(on.x),
            pt.copy(dt.binormals[0]).multiplyScalar(on.y),
            _t.copy(lt[0]).add(vt).add(pt),
            yn(_t.x, _t.y, _t.z))
          : yn(on.x, on.y, 0)
      }
      for (let Ht = 1; Ht <= $; Ht++)
        for (let on = 0; on < Mt; on++) {
          const Yt = tt ? Dt(Et[on], It[on], $t) : Et[on]
          ht
            ? (vt.copy(dt.normals[Ht]).multiplyScalar(Yt.x),
              pt.copy(dt.binormals[Ht]).multiplyScalar(Yt.y),
              _t.copy(lt[Ht]).add(vt).add(pt),
              yn(_t.x, _t.y, _t.z))
            : yn(Yt.x, Yt.y, (_e / $) * Ht)
        }
      for (let Ht = ut - 1; Ht >= 0; Ht--) {
        const on = Ht / ut,
          Yt = st * Math.cos((on * Math.PI) / 2),
          _n = at * Math.sin((on * Math.PI) / 2) + ot
        for (let pn = 0, Rn = Nt.length; pn < Rn; pn++) {
          const bn = Dt(Nt[pn], At[pn], _n)
          yn(bn.x, bn.y, _e + Yt)
        }
        for (let pn = 0, Rn = Rt.length; pn < Rn; pn++) {
          const bn = Rt[pn]
          Tt = bt[pn]
          for (let Pn = 0, Gn = bn.length; Pn < Gn; Pn++) {
            const jn = Dt(bn[Pn], Tt[Pn], _n)
            ht
              ? yn(jn.x, jn.y + lt[$ - 1].y, lt[$ - 1].x + Yt)
              : yn(jn.x, jn.y, _e + Yt)
          }
        }
      }
      Xt(), qt()
      function Xt() {
        const Ht = c.length / 3
        if (tt) {
          let on = 0,
            Yt = Mt * on
          for (let _n = 0; _n < wt; _n++) {
            const pn = kt[_n]
            Tn(pn[2] + Yt, pn[1] + Yt, pn[0] + Yt)
          }
          ;(on = $ + ut * 2), (Yt = Mt * on)
          for (let _n = 0; _n < wt; _n++) {
            const pn = kt[_n]
            Tn(pn[0] + Yt, pn[1] + Yt, pn[2] + Yt)
          }
        } else {
          for (let on = 0; on < wt; on++) {
            const Yt = kt[on]
            Tn(Yt[2], Yt[1], Yt[0])
          }
          for (let on = 0; on < wt; on++) {
            const Yt = kt[on]
            Tn(Yt[0] + Mt * $, Yt[1] + Mt * $, Yt[2] + Mt * $)
          }
        }
        o.addGroup(Ht, c.length / 3 - Ht, 0)
      }
      function qt() {
        const Ht = c.length / 3
        let on = 0
        en(Nt, on), (on += Nt.length)
        for (let Yt = 0, _n = Rt.length; Yt < _n; Yt++) {
          const pn = Rt[Yt]
          en(pn, on), (on += pn.length)
        }
        o.addGroup(Ht, c.length / 3 - Ht, 1)
      }
      function en(Ht, on) {
        let Yt = Ht.length
        for (; --Yt >= 0; ) {
          const _n = Yt
          let pn = Yt - 1
          pn < 0 && (pn = Ht.length - 1)
          for (let Rn = 0, bn = $ + ut * 2; Rn < bn; Rn++) {
            const Pn = Mt * Rn,
              Gn = Mt * (Rn + 1),
              jn = on + _n + Pn,
              ar = on + pn + Pn,
              Vt = on + pn + Gn,
              Lt = on + _n + Gn
            $n(jn, ar, Vt, Lt)
          }
        }
      }
      function yn(Ht, on, Yt) {
        b.push(Ht), b.push(on), b.push(Yt)
      }
      function Tn(Ht, on, Yt) {
        Vn(Ht), Vn(on), Vn(Yt)
        const _n = c.length / 3,
          pn = ct.generateTopUV(o, c, _n - 3, _n - 2, _n - 1)
        gn(pn[0]), gn(pn[1]), gn(pn[2])
      }
      function $n(Ht, on, Yt, _n) {
        Vn(Ht), Vn(on), Vn(_n), Vn(on), Vn(Yt), Vn(_n)
        const pn = c.length / 3,
          Rn = ct.generateSideWallUV(o, c, pn - 6, pn - 3, pn - 2, pn - 1)
        gn(Rn[0]), gn(Rn[1]), gn(Rn[3]), gn(Rn[1]), gn(Rn[2]), gn(Rn[3])
      }
      function Vn(Ht) {
        c.push(b[Ht * 3 + 0]), c.push(b[Ht * 3 + 1]), c.push(b[Ht * 3 + 2])
      }
      function gn(Ht) {
        d.push(Ht.x), d.push(Ht.y)
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  toJSON() {
    const e = super.toJSON(),
      a = this.parameters.shapes,
      o = this.parameters.options
    return toJSON$1(a, o, e)
  }
  static fromJSON(e, a) {
    const o = []
    for (let d = 0, g = e.shapes.length; d < g; d++) {
      const _ = a[e.shapes[d]]
      o.push(_)
    }
    const c = e.options.extrudePath
    return (
      c !== void 0 &&
        (e.options.extrudePath = new Curves[c.type]().fromJSON(c)),
      new ExtrudeGeometry(o, e.options)
    )
  }
}
const WorldUVGenerator = {
  generateTopUV: function (s, e, a, o, c) {
    const d = e[a * 3],
      g = e[a * 3 + 1],
      _ = e[o * 3],
      b = e[o * 3 + 1],
      j = e[c * 3],
      $ = e[c * 3 + 1]
    return [new Vector2(d, g), new Vector2(_, b), new Vector2(j, $)]
  },
  generateSideWallUV: function (s, e, a, o, c, d) {
    const g = e[a * 3],
      _ = e[a * 3 + 1],
      b = e[a * 3 + 2],
      j = e[o * 3],
      $ = e[o * 3 + 1],
      _e = e[o * 3 + 2],
      tt = e[c * 3],
      st = e[c * 3 + 1],
      at = e[c * 3 + 2],
      ot = e[d * 3],
      ut = e[d * 3 + 1],
      it = e[d * 3 + 2]
    return Math.abs(_ - $) < Math.abs(g - j)
      ? [
          new Vector2(g, 1 - b),
          new Vector2(j, 1 - _e),
          new Vector2(tt, 1 - at),
          new Vector2(ot, 1 - it),
        ]
      : [
          new Vector2(_, 1 - b),
          new Vector2($, 1 - _e),
          new Vector2(st, 1 - at),
          new Vector2(ut, 1 - it),
        ]
  },
}
function toJSON$1(s, e, a) {
  if (((a.shapes = []), Array.isArray(s)))
    for (let o = 0, c = s.length; o < c; o++) {
      const d = s[o]
      a.shapes.push(d.uuid)
    }
  else a.shapes.push(s.uuid)
  return (
    (a.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (a.options.extrudePath = e.extrudePath.toJSON()),
    a
  )
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, a = 0) {
    const o = (1 + Math.sqrt(5)) / 2,
      c = [
        -1,
        o,
        0,
        1,
        o,
        0,
        -1,
        -o,
        0,
        1,
        -o,
        0,
        0,
        -1,
        o,
        0,
        1,
        o,
        0,
        -1,
        -o,
        0,
        1,
        -o,
        o,
        0,
        -1,
        o,
        0,
        1,
        -o,
        0,
        -1,
        -o,
        0,
        1,
      ],
      d = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ]
    super(c, d, e, a),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: a })
  }
  static fromJSON(e) {
    return new IcosahedronGeometry(e.radius, e.detail)
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, a = 0) {
    const o = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      c = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ]
    super(o, c, e, a),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: a })
  }
  static fromJSON(e) {
    return new OctahedronGeometry(e.radius, e.detail)
  }
}
class RingGeometry extends BufferGeometry {
  constructor(e = 0.5, a = 1, o = 32, c = 1, d = 0, g = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: a,
        thetaSegments: o,
        phiSegments: c,
        thetaStart: d,
        thetaLength: g,
      }),
      (o = Math.max(3, o)),
      (c = Math.max(1, c))
    const _ = [],
      b = [],
      j = [],
      $ = []
    let _e = e
    const tt = (a - e) / c,
      st = new Vector3(),
      at = new Vector2()
    for (let ot = 0; ot <= c; ot++) {
      for (let ut = 0; ut <= o; ut++) {
        const it = d + (ut / o) * g
        ;(st.x = _e * Math.cos(it)),
          (st.y = _e * Math.sin(it)),
          b.push(st.x, st.y, st.z),
          j.push(0, 0, 1),
          (at.x = (st.x / a + 1) / 2),
          (at.y = (st.y / a + 1) / 2),
          $.push(at.x, at.y)
      }
      _e += tt
    }
    for (let ot = 0; ot < c; ot++) {
      const ut = ot * (o + 1)
      for (let it = 0; it < o; it++) {
        const ct = it + ut,
          lt = ct,
          ht = ct + o + 1,
          dt = ct + o + 2,
          pt = ct + 1
        _.push(lt, ht, pt), _.push(ht, dt, pt)
      }
    }
    this.setIndex(_),
      this.setAttribute("position", new Float32BufferAttribute(b, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(j, 3)),
      this.setAttribute("uv", new Float32BufferAttribute($, 2))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new RingGeometry(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(
    e = new Shape([
      new Vector2(0, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    a = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: a })
    const o = [],
      c = [],
      d = [],
      g = []
    let _ = 0,
      b = 0
    if (Array.isArray(e) === !1) j(e)
    else
      for (let $ = 0; $ < e.length; $++)
        j(e[$]), this.addGroup(_, b, $), (_ += b), (b = 0)
    this.setIndex(o),
      this.setAttribute("position", new Float32BufferAttribute(c, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(d, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(g, 2))
    function j($) {
      const _e = c.length / 3,
        tt = $.extractPoints(a)
      let st = tt.shape
      const at = tt.holes
      ShapeUtils.isClockWise(st) === !1 && (st = st.reverse())
      for (let ut = 0, it = at.length; ut < it; ut++) {
        const ct = at[ut]
        ShapeUtils.isClockWise(ct) === !0 && (at[ut] = ct.reverse())
      }
      const ot = ShapeUtils.triangulateShape(st, at)
      for (let ut = 0, it = at.length; ut < it; ut++) {
        const ct = at[ut]
        st = st.concat(ct)
      }
      for (let ut = 0, it = st.length; ut < it; ut++) {
        const ct = st[ut]
        c.push(ct.x, ct.y, 0), d.push(0, 0, 1), g.push(ct.x, ct.y)
      }
      for (let ut = 0, it = ot.length; ut < it; ut++) {
        const ct = ot[ut],
          lt = ct[0] + _e,
          ht = ct[1] + _e,
          dt = ct[2] + _e
        o.push(lt, ht, dt), (b += 3)
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  toJSON() {
    const e = super.toJSON(),
      a = this.parameters.shapes
    return toJSON(a, e)
  }
  static fromJSON(e, a) {
    const o = []
    for (let c = 0, d = e.shapes.length; c < d; c++) {
      const g = a[e.shapes[c]]
      o.push(g)
    }
    return new ShapeGeometry(o, e.curveSegments)
  }
}
function toJSON(s, e) {
  if (((e.shapes = []), Array.isArray(s)))
    for (let a = 0, o = s.length; a < o; a++) {
      const c = s[a]
      e.shapes.push(c.uuid)
    }
  else e.shapes.push(s.uuid)
  return e
}
class SphereGeometry extends BufferGeometry {
  constructor(
    e = 1,
    a = 32,
    o = 16,
    c = 0,
    d = Math.PI * 2,
    g = 0,
    _ = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: a,
        heightSegments: o,
        phiStart: c,
        phiLength: d,
        thetaStart: g,
        thetaLength: _,
      }),
      (a = Math.max(3, Math.floor(a))),
      (o = Math.max(2, Math.floor(o)))
    const b = Math.min(g + _, Math.PI)
    let j = 0
    const $ = [],
      _e = new Vector3(),
      tt = new Vector3(),
      st = [],
      at = [],
      ot = [],
      ut = []
    for (let it = 0; it <= o; it++) {
      const ct = [],
        lt = it / o
      let ht = 0
      it === 0 && g === 0
        ? (ht = 0.5 / a)
        : it === o && b === Math.PI && (ht = -0.5 / a)
      for (let dt = 0; dt <= a; dt++) {
        const pt = dt / a
        ;(_e.x = -e * Math.cos(c + pt * d) * Math.sin(g + lt * _)),
          (_e.y = e * Math.cos(g + lt * _)),
          (_e.z = e * Math.sin(c + pt * d) * Math.sin(g + lt * _)),
          at.push(_e.x, _e.y, _e.z),
          tt.copy(_e).normalize(),
          ot.push(tt.x, tt.y, tt.z),
          ut.push(pt + ht, 1 - lt),
          ct.push(j++)
      }
      $.push(ct)
    }
    for (let it = 0; it < o; it++)
      for (let ct = 0; ct < a; ct++) {
        const lt = $[it][ct + 1],
          ht = $[it][ct],
          dt = $[it + 1][ct],
          pt = $[it + 1][ct + 1]
        ;(it !== 0 || g > 0) && st.push(lt, ht, pt),
          (it !== o - 1 || b < Math.PI) && st.push(ht, dt, pt)
      }
    this.setIndex(st),
      this.setAttribute("position", new Float32BufferAttribute(at, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(ot, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(ut, 2))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new SphereGeometry(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    )
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(e = 1, a = 0) {
    const o = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      c = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]
    super(o, c, e, a),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: a })
  }
  static fromJSON(e) {
    return new TetrahedronGeometry(e.radius, e.detail)
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(e = 1, a = 0.4, o = 12, c = 48, d = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: a,
        radialSegments: o,
        tubularSegments: c,
        arc: d,
      }),
      (o = Math.floor(o)),
      (c = Math.floor(c))
    const g = [],
      _ = [],
      b = [],
      j = [],
      $ = new Vector3(),
      _e = new Vector3(),
      tt = new Vector3()
    for (let st = 0; st <= o; st++)
      for (let at = 0; at <= c; at++) {
        const ot = (at / c) * d,
          ut = (st / o) * Math.PI * 2
        ;(_e.x = (e + a * Math.cos(ut)) * Math.cos(ot)),
          (_e.y = (e + a * Math.cos(ut)) * Math.sin(ot)),
          (_e.z = a * Math.sin(ut)),
          _.push(_e.x, _e.y, _e.z),
          ($.x = e * Math.cos(ot)),
          ($.y = e * Math.sin(ot)),
          tt.subVectors(_e, $).normalize(),
          b.push(tt.x, tt.y, tt.z),
          j.push(at / c),
          j.push(st / o)
      }
    for (let st = 1; st <= o; st++)
      for (let at = 1; at <= c; at++) {
        const ot = (c + 1) * st + at - 1,
          ut = (c + 1) * (st - 1) + at - 1,
          it = (c + 1) * (st - 1) + at,
          ct = (c + 1) * st + at
        g.push(ot, ut, ct), g.push(ut, it, ct)
      }
    this.setIndex(g),
      this.setAttribute("position", new Float32BufferAttribute(_, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(b, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(j, 2))
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new TorusGeometry(
      e.radius,
      e.tube,
      e.radialSegments,
      e.tubularSegments,
      e.arc
    )
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(e = 1, a = 0.4, o = 64, c = 8, d = 2, g = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: a,
        tubularSegments: o,
        radialSegments: c,
        p: d,
        q: g,
      }),
      (o = Math.floor(o)),
      (c = Math.floor(c))
    const _ = [],
      b = [],
      j = [],
      $ = [],
      _e = new Vector3(),
      tt = new Vector3(),
      st = new Vector3(),
      at = new Vector3(),
      ot = new Vector3(),
      ut = new Vector3(),
      it = new Vector3()
    for (let lt = 0; lt <= o; ++lt) {
      const ht = (lt / o) * d * Math.PI * 2
      ct(ht, d, g, e, st),
        ct(ht + 0.01, d, g, e, at),
        ut.subVectors(at, st),
        it.addVectors(at, st),
        ot.crossVectors(ut, it),
        it.crossVectors(ot, ut),
        ot.normalize(),
        it.normalize()
      for (let dt = 0; dt <= c; ++dt) {
        const pt = (dt / c) * Math.PI * 2,
          vt = -a * Math.cos(pt),
          _t = a * Math.sin(pt)
        ;(_e.x = st.x + (vt * it.x + _t * ot.x)),
          (_e.y = st.y + (vt * it.y + _t * ot.y)),
          (_e.z = st.z + (vt * it.z + _t * ot.z)),
          b.push(_e.x, _e.y, _e.z),
          tt.subVectors(_e, st).normalize(),
          j.push(tt.x, tt.y, tt.z),
          $.push(lt / o),
          $.push(dt / c)
      }
    }
    for (let lt = 1; lt <= o; lt++)
      for (let ht = 1; ht <= c; ht++) {
        const dt = (c + 1) * (lt - 1) + (ht - 1),
          pt = (c + 1) * lt + (ht - 1),
          vt = (c + 1) * lt + ht,
          _t = (c + 1) * (lt - 1) + ht
        _.push(dt, pt, _t), _.push(pt, vt, _t)
      }
    this.setIndex(_),
      this.setAttribute("position", new Float32BufferAttribute(b, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(j, 3)),
      this.setAttribute("uv", new Float32BufferAttribute($, 2))
    function ct(lt, ht, dt, pt, vt) {
      const _t = Math.cos(lt),
        yt = Math.sin(lt),
        Et = (dt / ht) * lt,
        Rt = Math.cos(Et)
      ;(vt.x = pt * (2 + Rt) * 0.5 * _t),
        (vt.y = pt * (2 + Rt) * yt * 0.5),
        (vt.z = pt * Math.sin(Et) * 0.5)
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  static fromJSON(e) {
    return new TorusKnotGeometry(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    )
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(
    e = new QuadraticBezierCurve3(
      new Vector3(-1, -1, 0),
      new Vector3(-1, 1, 0),
      new Vector3(1, 1, 0)
    ),
    a = 64,
    o = 1,
    c = 8,
    d = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: a,
        radius: o,
        radialSegments: c,
        closed: d,
      })
    const g = e.computeFrenetFrames(a, d)
    ;(this.tangents = g.tangents),
      (this.normals = g.normals),
      (this.binormals = g.binormals)
    const _ = new Vector3(),
      b = new Vector3(),
      j = new Vector2()
    let $ = new Vector3()
    const _e = [],
      tt = [],
      st = [],
      at = []
    ot(),
      this.setIndex(at),
      this.setAttribute("position", new Float32BufferAttribute(_e, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(tt, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(st, 2))
    function ot() {
      for (let lt = 0; lt < a; lt++) ut(lt)
      ut(d === !1 ? a : 0), ct(), it()
    }
    function ut(lt) {
      $ = e.getPointAt(lt / a, $)
      const ht = g.normals[lt],
        dt = g.binormals[lt]
      for (let pt = 0; pt <= c; pt++) {
        const vt = (pt / c) * Math.PI * 2,
          _t = Math.sin(vt),
          yt = -Math.cos(vt)
        ;(b.x = yt * ht.x + _t * dt.x),
          (b.y = yt * ht.y + _t * dt.y),
          (b.z = yt * ht.z + _t * dt.z),
          b.normalize(),
          tt.push(b.x, b.y, b.z),
          (_.x = $.x + o * b.x),
          (_.y = $.y + o * b.y),
          (_.z = $.z + o * b.z),
          _e.push(_.x, _.y, _.z)
      }
    }
    function it() {
      for (let lt = 1; lt <= a; lt++)
        for (let ht = 1; ht <= c; ht++) {
          const dt = (c + 1) * (lt - 1) + (ht - 1),
            pt = (c + 1) * lt + (ht - 1),
            vt = (c + 1) * lt + ht,
            _t = (c + 1) * (lt - 1) + ht
          at.push(dt, pt, _t), at.push(pt, vt, _t)
        }
    }
    function ct() {
      for (let lt = 0; lt <= a; lt++)
        for (let ht = 0; ht <= c; ht++)
          (j.x = lt / a), (j.y = ht / c), st.push(j.x, j.y)
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
  toJSON() {
    const e = super.toJSON()
    return (e.path = this.parameters.path.toJSON()), e
  }
  static fromJSON(e) {
    return new TubeGeometry(
      new Curves[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    )
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const a = [],
        o = new Set(),
        c = new Vector3(),
        d = new Vector3()
      if (e.index !== null) {
        const g = e.attributes.position,
          _ = e.index
        let b = e.groups
        b.length === 0 && (b = [{ start: 0, count: _.count, materialIndex: 0 }])
        for (let j = 0, $ = b.length; j < $; ++j) {
          const _e = b[j],
            tt = _e.start,
            st = _e.count
          for (let at = tt, ot = tt + st; at < ot; at += 3)
            for (let ut = 0; ut < 3; ut++) {
              const it = _.getX(at + ut),
                ct = _.getX(at + ((ut + 1) % 3))
              c.fromBufferAttribute(g, it),
                d.fromBufferAttribute(g, ct),
                isUniqueEdge(c, d, o) === !0 &&
                  (a.push(c.x, c.y, c.z), a.push(d.x, d.y, d.z))
            }
        }
      } else {
        const g = e.attributes.position
        for (let _ = 0, b = g.count / 3; _ < b; _++)
          for (let j = 0; j < 3; j++) {
            const $ = 3 * _ + j,
              _e = 3 * _ + ((j + 1) % 3)
            c.fromBufferAttribute(g, $),
              d.fromBufferAttribute(g, _e),
              isUniqueEdge(c, d, o) === !0 &&
                (a.push(c.x, c.y, c.z), a.push(d.x, d.y, d.z))
          }
      }
      this.setAttribute("position", new Float32BufferAttribute(a, 3))
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    )
  }
}
function isUniqueEdge(s, e, a) {
  const o = `${s.x},${s.y},${s.z}-${e.x},${e.y},${e.z}`,
    c = `${e.x},${e.y},${e.z}-${s.x},${s.y},${s.z}`
  return a.has(o) === !0 || a.has(c) === !0 ? !1 : (a.add(o), a.add(c), !0)
}
var Geometries$1 = Object.freeze({
  __proto__: null,
  BoxGeometry,
  CapsuleGeometry,
  CircleGeometry,
  ConeGeometry,
  CylinderGeometry,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  IcosahedronGeometry,
  LatheGeometry,
  OctahedronGeometry,
  PlaneGeometry,
  PolyhedronGeometry,
  RingGeometry,
  ShapeGeometry,
  SphereGeometry,
  TetrahedronGeometry,
  TorusGeometry,
  TorusKnotGeometry,
  TubeGeometry,
  WireframeGeometry,
})
class ShadowMaterial extends Material {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Color(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this
  }
}
class RawShaderMaterial extends ShaderMaterial {
  constructor(e) {
    super(e), (this.isRawShaderMaterial = !0), (this.type = "RawShaderMaterial")
  }
}
class MeshStandardMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Color(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    )
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Vector2(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return clamp$2((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1)
        },
        set: function (a) {
          this.ior = (1 + 0.4 * a) / (1 - 0.4 * a)
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Color(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Color(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Color(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e)
  }
  get anisotropy() {
    return this._anisotropy
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e)
  }
  get clearcoat() {
    return this._clearcoat
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e)
  }
  get iridescence() {
    return this._iridescence
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e)
  }
  get sheen() {
    return this._sheen
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e)
  }
  get transmission() {
    return this._transmission
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    )
  }
}
class MeshPhongMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Color(16777215)),
      (this.specular = new Color(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    )
  }
}
class MeshToonMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    )
  }
}
class MeshNormalMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    )
  }
}
class MeshLambertMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = MultiplyOperation),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    )
  }
}
class MeshMatcapMaterial extends Material {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Color(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = TangentSpaceNormalMap),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    )
  }
}
class LineDashedMaterial extends LineBasicMaterial {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e)
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    )
  }
}
function arraySlice(s, e, a) {
  return isTypedArray(s)
    ? new s.constructor(s.subarray(e, a !== void 0 ? a : s.length))
    : s.slice(e, a)
}
function convertArray(s, e, a) {
  return !s || (!a && s.constructor === e)
    ? s
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(s)
    : Array.prototype.slice.call(s)
}
function isTypedArray(s) {
  return ArrayBuffer.isView(s) && !(s instanceof DataView)
}
function getKeyframeOrder(s) {
  function e(c, d) {
    return s[c] - s[d]
  }
  const a = s.length,
    o = new Array(a)
  for (let c = 0; c !== a; ++c) o[c] = c
  return o.sort(e), o
}
function sortedArray(s, e, a) {
  const o = s.length,
    c = new s.constructor(o)
  for (let d = 0, g = 0; g !== o; ++d) {
    const _ = a[d] * e
    for (let b = 0; b !== e; ++b) c[g++] = s[_ + b]
  }
  return c
}
function flattenJSON(s, e, a, o) {
  let c = 1,
    d = s[0]
  for (; d !== void 0 && d[o] === void 0; ) d = s[c++]
  if (d === void 0) return
  let g = d[o]
  if (g !== void 0)
    if (Array.isArray(g))
      do
        (g = d[o]),
          g !== void 0 && (e.push(d.time), a.push.apply(a, g)),
          (d = s[c++])
      while (d !== void 0)
    else if (g.toArray !== void 0)
      do
        (g = d[o]),
          g !== void 0 && (e.push(d.time), g.toArray(a, a.length)),
          (d = s[c++])
      while (d !== void 0)
    else
      do (g = d[o]), g !== void 0 && (e.push(d.time), a.push(g)), (d = s[c++])
      while (d !== void 0)
}
function subclip(s, e, a, o, c = 30) {
  const d = s.clone()
  d.name = e
  const g = []
  for (let b = 0; b < d.tracks.length; ++b) {
    const j = d.tracks[b],
      $ = j.getValueSize(),
      _e = [],
      tt = []
    for (let st = 0; st < j.times.length; ++st) {
      const at = j.times[st] * c
      if (!(at < a || at >= o)) {
        _e.push(j.times[st])
        for (let ot = 0; ot < $; ++ot) tt.push(j.values[st * $ + ot])
      }
    }
    _e.length !== 0 &&
      ((j.times = convertArray(_e, j.times.constructor)),
      (j.values = convertArray(tt, j.values.constructor)),
      g.push(j))
  }
  d.tracks = g
  let _ = 1 / 0
  for (let b = 0; b < d.tracks.length; ++b)
    _ > d.tracks[b].times[0] && (_ = d.tracks[b].times[0])
  for (let b = 0; b < d.tracks.length; ++b) d.tracks[b].shift(-1 * _)
  return d.resetDuration(), d
}
function makeClipAdditive(s, e = 0, a = s, o = 30) {
  o <= 0 && (o = 30)
  const c = a.tracks.length,
    d = e / o
  for (let g = 0; g < c; ++g) {
    const _ = a.tracks[g],
      b = _.ValueTypeName
    if (b === "bool" || b === "string") continue
    const j = s.tracks.find(function (it) {
      return it.name === _.name && it.ValueTypeName === b
    })
    if (j === void 0) continue
    let $ = 0
    const _e = _.getValueSize()
    _.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      ($ = _e / 3)
    let tt = 0
    const st = j.getValueSize()
    j.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (tt = st / 3)
    const at = _.times.length - 1
    let ot
    if (d <= _.times[0]) {
      const it = $,
        ct = _e - $
      ot = arraySlice(_.values, it, ct)
    } else if (d >= _.times[at]) {
      const it = at * _e + $,
        ct = it + _e - $
      ot = arraySlice(_.values, it, ct)
    } else {
      const it = _.createInterpolant(),
        ct = $,
        lt = _e - $
      it.evaluate(d), (ot = arraySlice(it.resultBuffer, ct, lt))
    }
    b === "quaternion" &&
      new Quaternion().fromArray(ot).normalize().conjugate().toArray(ot)
    const ut = j.times.length
    for (let it = 0; it < ut; ++it) {
      const ct = it * st + tt
      if (b === "quaternion")
        Quaternion.multiplyQuaternionsFlat(j.values, ct, ot, 0, j.values, ct)
      else {
        const lt = st - tt * 2
        for (let ht = 0; ht < lt; ++ht) j.values[ct + ht] -= ot[ht]
      }
    }
  }
  return (s.blendMode = AdditiveAnimationBlendMode), s
}
const AnimationUtils = {
  arraySlice,
  convertArray,
  isTypedArray,
  getKeyframeOrder,
  sortedArray,
  flattenJSON,
  subclip,
  makeClipAdditive,
}
class Interpolant {
  constructor(e, a, o, c) {
    ;(this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = c !== void 0 ? c : new a.constructor(o)),
      (this.sampleValues = a),
      (this.valueSize = o),
      (this.settings = null),
      (this.DefaultSettings_ = {})
  }
  evaluate(e) {
    const a = this.parameterPositions
    let o = this._cachedIndex,
      c = a[o],
      d = a[o - 1]
    e: {
      t: {
        let g
        n: {
          r: if (!(e < c)) {
            for (let _ = o + 2; ; ) {
              if (c === void 0) {
                if (e < d) break r
                return (
                  (o = a.length),
                  (this._cachedIndex = o),
                  this.copySampleValue_(o - 1)
                )
              }
              if (o === _) break
              if (((d = c), (c = a[++o]), e < c)) break t
            }
            g = a.length
            break n
          }
          if (!(e >= d)) {
            const _ = a[1]
            e < _ && ((o = 2), (d = _))
            for (let b = o - 2; ; ) {
              if (d === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0)
              if (o === b) break
              if (((c = d), (d = a[--o - 1]), e >= d)) break t
            }
            ;(g = o), (o = 0)
            break n
          }
          break e
        }
        for (; o < g; ) {
          const _ = (o + g) >>> 1
          e < a[_] ? (g = _) : (o = _ + 1)
        }
        if (((c = a[o]), (d = a[o - 1]), d === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0)
        if (c === void 0)
          return (
            (o = a.length),
            (this._cachedIndex = o),
            this.copySampleValue_(o - 1)
          )
      }
      ;(this._cachedIndex = o), this.intervalChanged_(o, d, c)
    }
    return this.interpolate_(o, d, e, c)
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_
  }
  copySampleValue_(e) {
    const a = this.resultBuffer,
      o = this.sampleValues,
      c = this.valueSize,
      d = e * c
    for (let g = 0; g !== c; ++g) a[g] = o[d + g]
    return a
  }
  interpolate_() {
    throw new Error("call to abstract method")
  }
  intervalChanged_() {}
}
class CubicInterpolant extends Interpolant {
  constructor(e, a, o, c) {
    super(e, a, o, c),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding,
      })
  }
  intervalChanged_(e, a, o) {
    const c = this.parameterPositions
    let d = e - 2,
      g = e + 1,
      _ = c[d],
      b = c[g]
    if (_ === void 0)
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          ;(d = e), (_ = 2 * a - o)
          break
        case WrapAroundEnding:
          ;(d = c.length - 2), (_ = a + c[d] - c[d + 1])
          break
        default:
          ;(d = e), (_ = o)
      }
    if (b === void 0)
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          ;(g = e), (b = 2 * o - a)
          break
        case WrapAroundEnding:
          ;(g = 1), (b = o + c[1] - c[0])
          break
        default:
          ;(g = e - 1), (b = a)
      }
    const j = (o - a) * 0.5,
      $ = this.valueSize
    ;(this._weightPrev = j / (a - _)),
      (this._weightNext = j / (b - o)),
      (this._offsetPrev = d * $),
      (this._offsetNext = g * $)
  }
  interpolate_(e, a, o, c) {
    const d = this.resultBuffer,
      g = this.sampleValues,
      _ = this.valueSize,
      b = e * _,
      j = b - _,
      $ = this._offsetPrev,
      _e = this._offsetNext,
      tt = this._weightPrev,
      st = this._weightNext,
      at = (o - a) / (c - a),
      ot = at * at,
      ut = ot * at,
      it = -tt * ut + 2 * tt * ot - tt * at,
      ct = (1 + tt) * ut + (-1.5 - 2 * tt) * ot + (-0.5 + tt) * at + 1,
      lt = (-1 - st) * ut + (1.5 + st) * ot + 0.5 * at,
      ht = st * ut - st * ot
    for (let dt = 0; dt !== _; ++dt)
      d[dt] = it * g[$ + dt] + ct * g[j + dt] + lt * g[b + dt] + ht * g[_e + dt]
    return d
  }
}
class LinearInterpolant extends Interpolant {
  constructor(e, a, o, c) {
    super(e, a, o, c)
  }
  interpolate_(e, a, o, c) {
    const d = this.resultBuffer,
      g = this.sampleValues,
      _ = this.valueSize,
      b = e * _,
      j = b - _,
      $ = (o - a) / (c - a),
      _e = 1 - $
    for (let tt = 0; tt !== _; ++tt) d[tt] = g[j + tt] * _e + g[b + tt] * $
    return d
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(e, a, o, c) {
    super(e, a, o, c)
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1)
  }
}
class KeyframeTrack {
  constructor(e, a, o, c) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined")
    if (a === void 0 || a.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e)
    ;(this.name = e),
      (this.times = convertArray(a, this.TimeBufferType)),
      (this.values = convertArray(o, this.ValueBufferType)),
      this.setInterpolation(c || this.DefaultInterpolation)
  }
  static toJSON(e) {
    const a = e.constructor
    let o
    if (a.toJSON !== this.toJSON) o = a.toJSON(e)
    else {
      o = {
        name: e.name,
        times: convertArray(e.times, Array),
        values: convertArray(e.values, Array),
      }
      const c = e.getInterpolation()
      c !== e.DefaultInterpolation && (o.interpolation = c)
    }
    return (o.type = e.ValueTypeName), o
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new DiscreteInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    )
  }
  InterpolantFactoryMethodLinear(e) {
    return new LinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    )
  }
  InterpolantFactoryMethodSmooth(e) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), e)
  }
  setInterpolation(e) {
    let a
    switch (e) {
      case InterpolateDiscrete:
        a = this.InterpolantFactoryMethodDiscrete
        break
      case InterpolateLinear:
        a = this.InterpolantFactoryMethodLinear
        break
      case InterpolateSmooth:
        a = this.InterpolantFactoryMethodSmooth
        break
    }
    if (a === void 0) {
      const o =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation)
        else throw new Error(o)
      return console.warn("THREE.KeyframeTrack:", o), this
    }
    return (this.createInterpolant = a), this
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth
    }
  }
  getValueSize() {
    return this.values.length / this.times.length
  }
  shift(e) {
    if (e !== 0) {
      const a = this.times
      for (let o = 0, c = a.length; o !== c; ++o) a[o] += e
    }
    return this
  }
  scale(e) {
    if (e !== 1) {
      const a = this.times
      for (let o = 0, c = a.length; o !== c; ++o) a[o] *= e
    }
    return this
  }
  trim(e, a) {
    const o = this.times,
      c = o.length
    let d = 0,
      g = c - 1
    for (; d !== c && o[d] < e; ) ++d
    for (; g !== -1 && o[g] > a; ) --g
    if ((++g, d !== 0 || g !== c)) {
      d >= g && ((g = Math.max(g, 1)), (d = g - 1))
      const _ = this.getValueSize()
      ;(this.times = arraySlice(o, d, g)),
        (this.values = arraySlice(this.values, d * _, g * _))
    }
    return this
  }
  validate() {
    let e = !0
    const a = this.getValueSize()
    a - Math.floor(a) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1))
    const o = this.times,
      c = this.values,
      d = o.length
    d === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1))
    let g = null
    for (let _ = 0; _ !== d; _++) {
      const b = o[_]
      if (typeof b == "number" && isNaN(b)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          _,
          b
        ),
          (e = !1)
        break
      }
      if (g !== null && g > b) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, _, b, g),
          (e = !1)
        break
      }
      g = b
    }
    if (c !== void 0 && isTypedArray(c))
      for (let _ = 0, b = c.length; _ !== b; ++_) {
        const j = c[_]
        if (isNaN(j)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            _,
            j
          ),
            (e = !1)
          break
        }
      }
    return e
  }
  optimize() {
    const e = arraySlice(this.times),
      a = arraySlice(this.values),
      o = this.getValueSize(),
      c = this.getInterpolation() === InterpolateSmooth,
      d = e.length - 1
    let g = 1
    for (let _ = 1; _ < d; ++_) {
      let b = !1
      const j = e[_],
        $ = e[_ + 1]
      if (j !== $ && (_ !== 1 || j !== e[0]))
        if (c) b = !0
        else {
          const _e = _ * o,
            tt = _e - o,
            st = _e + o
          for (let at = 0; at !== o; ++at) {
            const ot = a[_e + at]
            if (ot !== a[tt + at] || ot !== a[st + at]) {
              b = !0
              break
            }
          }
        }
      if (b) {
        if (_ !== g) {
          e[g] = e[_]
          const _e = _ * o,
            tt = g * o
          for (let st = 0; st !== o; ++st) a[tt + st] = a[_e + st]
        }
        ++g
      }
    }
    if (d > 0) {
      e[g] = e[d]
      for (let _ = d * o, b = g * o, j = 0; j !== o; ++j) a[b + j] = a[_ + j]
      ++g
    }
    return (
      g !== e.length
        ? ((this.times = arraySlice(e, 0, g)),
          (this.values = arraySlice(a, 0, g * o)))
        : ((this.times = e), (this.values = a)),
      this
    )
  }
  clone() {
    const e = arraySlice(this.times, 0),
      a = arraySlice(this.values, 0),
      o = this.constructor,
      c = new o(this.name, e, a)
    return (c.createInterpolant = this.createInterpolant), c
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array
KeyframeTrack.prototype.ValueBufferType = Float32Array
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear
class BooleanKeyframeTrack extends KeyframeTrack {}
BooleanKeyframeTrack.prototype.ValueTypeName = "bool"
BooleanKeyframeTrack.prototype.ValueBufferType = Array
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0
class ColorKeyframeTrack extends KeyframeTrack {}
ColorKeyframeTrack.prototype.ValueTypeName = "color"
class NumberKeyframeTrack extends KeyframeTrack {}
NumberKeyframeTrack.prototype.ValueTypeName = "number"
class QuaternionLinearInterpolant extends Interpolant {
  constructor(e, a, o, c) {
    super(e, a, o, c)
  }
  interpolate_(e, a, o, c) {
    const d = this.resultBuffer,
      g = this.sampleValues,
      _ = this.valueSize,
      b = (o - a) / (c - a)
    let j = e * _
    for (let $ = j + _; j !== $; j += 4)
      Quaternion.slerpFlat(d, 0, g, j - _, g, j, b)
    return d
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(e) {
    return new QuaternionLinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      e
    )
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion"
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0
class StringKeyframeTrack extends KeyframeTrack {}
StringKeyframeTrack.prototype.ValueTypeName = "string"
StringKeyframeTrack.prototype.ValueBufferType = Array
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0
class VectorKeyframeTrack extends KeyframeTrack {}
VectorKeyframeTrack.prototype.ValueTypeName = "vector"
class AnimationClip {
  constructor(e, a = -1, o, c = NormalAnimationBlendMode) {
    ;(this.name = e),
      (this.tracks = o),
      (this.duration = a),
      (this.blendMode = c),
      (this.uuid = generateUUID()),
      this.duration < 0 && this.resetDuration()
  }
  static parse(e) {
    const a = [],
      o = e.tracks,
      c = 1 / (e.fps || 1)
    for (let g = 0, _ = o.length; g !== _; ++g)
      a.push(parseKeyframeTrack(o[g]).scale(c))
    const d = new this(e.name, e.duration, a, e.blendMode)
    return (d.uuid = e.uuid), d
  }
  static toJSON(e) {
    const a = [],
      o = e.tracks,
      c = {
        name: e.name,
        duration: e.duration,
        tracks: a,
        uuid: e.uuid,
        blendMode: e.blendMode,
      }
    for (let d = 0, g = o.length; d !== g; ++d)
      a.push(KeyframeTrack.toJSON(o[d]))
    return c
  }
  static CreateFromMorphTargetSequence(e, a, o, c) {
    const d = a.length,
      g = []
    for (let _ = 0; _ < d; _++) {
      let b = [],
        j = []
      b.push((_ + d - 1) % d, _, (_ + 1) % d), j.push(0, 1, 0)
      const $ = getKeyframeOrder(b)
      ;(b = sortedArray(b, 1, $)),
        (j = sortedArray(j, 1, $)),
        !c && b[0] === 0 && (b.push(d), j.push(j[0])),
        g.push(
          new NumberKeyframeTrack(
            ".morphTargetInfluences[" + a[_].name + "]",
            b,
            j
          ).scale(1 / o)
        )
    }
    return new this(e, -1, g)
  }
  static findByName(e, a) {
    let o = e
    if (!Array.isArray(e)) {
      const c = e
      o = (c.geometry && c.geometry.animations) || c.animations
    }
    for (let c = 0; c < o.length; c++) if (o[c].name === a) return o[c]
    return null
  }
  static CreateClipsFromMorphTargetSequences(e, a, o) {
    const c = {},
      d = /^([\w-]*?)([\d]+)$/
    for (let _ = 0, b = e.length; _ < b; _++) {
      const j = e[_],
        $ = j.name.match(d)
      if ($ && $.length > 1) {
        const _e = $[1]
        let tt = c[_e]
        tt || (c[_e] = tt = []), tt.push(j)
      }
    }
    const g = []
    for (const _ in c) g.push(this.CreateFromMorphTargetSequence(_, c[_], a, o))
    return g
  }
  static parseAnimation(e, a) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      )
    const o = function (_e, tt, st, at, ot) {
        if (st.length !== 0) {
          const ut = [],
            it = []
          flattenJSON(st, ut, it, at),
            ut.length !== 0 && ot.push(new _e(tt, ut, it))
        }
      },
      c = [],
      d = e.name || "default",
      g = e.fps || 30,
      _ = e.blendMode
    let b = e.length || -1
    const j = e.hierarchy || []
    for (let _e = 0; _e < j.length; _e++) {
      const tt = j[_e].keys
      if (!(!tt || tt.length === 0))
        if (tt[0].morphTargets) {
          const st = {}
          let at
          for (at = 0; at < tt.length; at++)
            if (tt[at].morphTargets)
              for (let ot = 0; ot < tt[at].morphTargets.length; ot++)
                st[tt[at].morphTargets[ot]] = -1
          for (const ot in st) {
            const ut = [],
              it = []
            for (let ct = 0; ct !== tt[at].morphTargets.length; ++ct) {
              const lt = tt[at]
              ut.push(lt.time), it.push(lt.morphTarget === ot ? 1 : 0)
            }
            c.push(
              new NumberKeyframeTrack(
                ".morphTargetInfluence[" + ot + "]",
                ut,
                it
              )
            )
          }
          b = st.length * g
        } else {
          const st = ".bones[" + a[_e].name + "]"
          o(VectorKeyframeTrack, st + ".position", tt, "pos", c),
            o(QuaternionKeyframeTrack, st + ".quaternion", tt, "rot", c),
            o(VectorKeyframeTrack, st + ".scale", tt, "scl", c)
        }
    }
    return c.length === 0 ? null : new this(d, b, c, _)
  }
  resetDuration() {
    const e = this.tracks
    let a = 0
    for (let o = 0, c = e.length; o !== c; ++o) {
      const d = this.tracks[o]
      a = Math.max(a, d.times[d.times.length - 1])
    }
    return (this.duration = a), this
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration)
    return this
  }
  validate() {
    let e = !0
    for (let a = 0; a < this.tracks.length; a++)
      e = e && this.tracks[a].validate()
    return e
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize()
    return this
  }
  clone() {
    const e = []
    for (let a = 0; a < this.tracks.length; a++) e.push(this.tracks[a].clone())
    return new this.constructor(this.name, this.duration, e, this.blendMode)
  }
  toJSON() {
    return this.constructor.toJSON(this)
  }
}
function getTrackTypeForValueTypeName(s) {
  switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack
    case "color":
      return ColorKeyframeTrack
    case "quaternion":
      return QuaternionKeyframeTrack
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack
    case "string":
      return StringKeyframeTrack
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s)
}
function parseKeyframeTrack(s) {
  if (s.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse")
  const e = getTrackTypeForValueTypeName(s.type)
  if (s.times === void 0) {
    const a = [],
      o = []
    flattenJSON(s.keys, a, o, "value"), (s.times = a), (s.values = o)
  }
  return e.parse !== void 0
    ? e.parse(s)
    : new e(s.name, s.times, s.values, s.interpolation)
}
const Cache = {
  enabled: !1,
  files: {},
  add: function (s, e) {
    this.enabled !== !1 && (this.files[s] = e)
  },
  get: function (s) {
    if (this.enabled !== !1) return this.files[s]
  },
  remove: function (s) {
    delete this.files[s]
  },
  clear: function () {
    this.files = {}
  },
}
class LoadingManager {
  constructor(e, a, o) {
    const c = this
    let d = !1,
      g = 0,
      _ = 0,
      b
    const j = []
    ;(this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = a),
      (this.onError = o),
      (this.itemStart = function ($) {
        _++, d === !1 && c.onStart !== void 0 && c.onStart($, g, _), (d = !0)
      }),
      (this.itemEnd = function ($) {
        g++,
          c.onProgress !== void 0 && c.onProgress($, g, _),
          g === _ && ((d = !1), c.onLoad !== void 0 && c.onLoad())
      }),
      (this.itemError = function ($) {
        c.onError !== void 0 && c.onError($)
      }),
      (this.resolveURL = function ($) {
        return b ? b($) : $
      }),
      (this.setURLModifier = function ($) {
        return (b = $), this
      }),
      (this.addHandler = function ($, _e) {
        return j.push($, _e), this
      }),
      (this.removeHandler = function ($) {
        const _e = j.indexOf($)
        return _e !== -1 && j.splice(_e, 2), this
      }),
      (this.getHandler = function ($) {
        for (let _e = 0, tt = j.length; _e < tt; _e += 2) {
          const st = j[_e],
            at = j[_e + 1]
          if ((st.global && (st.lastIndex = 0), st.test($))) return at
        }
        return null
      })
  }
}
const DefaultLoadingManager = new LoadingManager()
let Loader$1 = class {
  constructor(e) {
    ;(this.manager = e !== void 0 ? e : DefaultLoadingManager),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {})
  }
  load() {}
  loadAsync(e, a) {
    const o = this
    return new Promise(function (c, d) {
      o.load(e, c, a, d)
    })
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this
  }
  setPath(e) {
    return (this.path = e), this
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this
  }
}
Loader$1.DEFAULT_MATERIAL_NAME = "__DEFAULT"
const loading = {}
class HttpError extends Error {
  constructor(e, a) {
    super(e), (this.response = a)
  }
}
class FileLoader extends Loader$1 {
  constructor(e) {
    super(e)
  }
  load(e, a, o, c) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e))
    const d = Cache.get(e)
    if (d !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          a && a(d), this.manager.itemEnd(e)
        }, 0),
        d
      )
    if (loading[e] !== void 0) {
      loading[e].push({ onLoad: a, onProgress: o, onError: c })
      return
    }
    ;(loading[e] = []),
      loading[e].push({ onLoad: a, onProgress: o, onError: c })
    const g = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      _ = this.mimeType,
      b = this.responseType
    fetch(g)
      .then((j) => {
        if (j.status === 200 || j.status === 0) {
          if (
            (j.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              j.body === void 0 ||
              j.body.getReader === void 0)
          )
            return j
          const $ = loading[e],
            _e = j.body.getReader(),
            tt =
              j.headers.get("Content-Length") || j.headers.get("X-File-Size"),
            st = tt ? parseInt(tt) : 0,
            at = st !== 0
          let ot = 0
          const ut = new ReadableStream({
            start(it) {
              ct()
              function ct() {
                _e.read().then(({ done: lt, value: ht }) => {
                  if (lt) it.close()
                  else {
                    ot += ht.byteLength
                    const dt = new ProgressEvent("progress", {
                      lengthComputable: at,
                      loaded: ot,
                      total: st,
                    })
                    for (let pt = 0, vt = $.length; pt < vt; pt++) {
                      const _t = $[pt]
                      _t.onProgress && _t.onProgress(dt)
                    }
                    it.enqueue(ht), ct()
                  }
                })
              }
            },
          })
          return new Response(ut)
        } else
          throw new HttpError(
            `fetch for "${j.url}" responded with ${j.status}: ${j.statusText}`,
            j
          )
      })
      .then((j) => {
        switch (b) {
          case "arraybuffer":
            return j.arrayBuffer()
          case "blob":
            return j.blob()
          case "document":
            return j.text().then(($) => new DOMParser().parseFromString($, _))
          case "json":
            return j.json()
          default:
            if (_ === void 0) return j.text()
            {
              const _e = /charset="?([^;"\s]*)"?/i.exec(_),
                tt = _e && _e[1] ? _e[1].toLowerCase() : void 0,
                st = new TextDecoder(tt)
              return j.arrayBuffer().then((at) => st.decode(at))
            }
        }
      })
      .then((j) => {
        Cache.add(e, j)
        const $ = loading[e]
        delete loading[e]
        for (let _e = 0, tt = $.length; _e < tt; _e++) {
          const st = $[_e]
          st.onLoad && st.onLoad(j)
        }
      })
      .catch((j) => {
        const $ = loading[e]
        if ($ === void 0) throw (this.manager.itemError(e), j)
        delete loading[e]
        for (let _e = 0, tt = $.length; _e < tt; _e++) {
          const st = $[_e]
          st.onError && st.onError(j)
        }
        this.manager.itemError(e)
      })
      .finally(() => {
        this.manager.itemEnd(e)
      }),
      this.manager.itemStart(e)
  }
  setResponseType(e) {
    return (this.responseType = e), this
  }
  setMimeType(e) {
    return (this.mimeType = e), this
  }
}
class AnimationLoader extends Loader$1 {
  constructor(e) {
    super(e)
  }
  load(e, a, o, c) {
    const d = this,
      g = new FileLoader(this.manager)
    g.setPath(this.path),
      g.setRequestHeader(this.requestHeader),
      g.setWithCredentials(this.withCredentials),
      g.load(
        e,
        function (_) {
          try {
            a(d.parse(JSON.parse(_)))
          } catch (b) {
            c ? c(b) : console.error(b), d.manager.itemError(e)
          }
        },
        o,
        c
      )
  }
  parse(e) {
    const a = []
    for (let o = 0; o < e.length; o++) {
      const c = AnimationClip.parse(e[o])
      a.push(c)
    }
    return a
  }
}
class CompressedTextureLoader extends Loader$1 {
  constructor(e) {
    super(e)
  }
  load(e, a, o, c) {
    const d = this,
      g = [],
      _ = new CompressedTexture(),
      b = new FileLoader(this.manager)
    b.setPath(this.path),
      b.setResponseType("arraybuffer"),
      b.setRequestHeader(this.requestHeader),
      b.setWithCredentials(d.withCredentials)
    let j = 0
    function $(_e) {
      b.load(
        e[_e],
        function (tt) {
          const st = d.parse(tt, !0)
          ;(g[_e] = {
            width: st.width,
            height: st.height,
            format: st.format,
            mipmaps: st.mipmaps,
          }),
            (j += 1),
            j === 6 &&
              (st.mipmapCount === 1 && (_.minFilter = LinearFilter),
              (_.image = g),
              (_.format = st.format),
              (_.needsUpdate = !0),
              a && a(_))
        },
        o,
        c
      )
    }
    if (Array.isArray(e)) for (let _e = 0, tt = e.length; _e < tt; ++_e) $(_e)
    else
      b.load(
        e,
        function (_e) {
          const tt = d.parse(_e, !0)
          if (tt.isCubemap) {
            const st = tt.mipmaps.length / tt.mipmapCount
            for (let at = 0; at < st; at++) {
              g[at] = { mipmaps: [] }
              for (let ot = 0; ot < tt.mipmapCount; ot++)
                g[at].mipmaps.push(tt.mipmaps[at * tt.mipmapCount + ot]),
                  (g[at].format = tt.format),
                  (g[at].width = tt.width),
                  (g[at].height = tt.height)
            }
            _.image = g
          } else
            (_.image.width = tt.width),
              (_.image.height = tt.height),
              (_.mipmaps = tt.mipmaps)
          tt.mipmapCount === 1 && (_.minFilter = LinearFilter),
            (_.format = tt.format),
            (_.needsUpdate = !0),
            a && a(_)
        },
        o,
        c
      )
    return _
  }
}
class ImageLoader extends Loader$1 {
  constructor(e) {
    super(e)
  }
  load(e, a, o, c) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e))
    const d = this,
      g = Cache.get(e)
    if (g !== void 0)
      return (
        d.manager.itemStart(e),
        setTimeout(function () {
          a && a(g), d.manager.itemEnd(e)
        }, 0),
        g
      )
    const _ = createElementNS("img")
    function b() {
      $(), Cache.add(e, this), a && a(this), d.manager.itemEnd(e)
    }
    function j(_e) {
      $(), c && c(_e), d.manager.itemError(e), d.manager.itemEnd(e)
    }
    function $() {
      _.removeEventListener("load", b, !1),
        _.removeEventListener("error", j, !1)
    }
    return (
      _.addEventListener("load", b, !1),
      _.addEventListener("error", j, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (_.crossOrigin = this.crossOrigin),
      d.manager.itemStart(e),
      (_.src = e),
      _
    )
  }
}
class CubeTextureLoader extends Loader$1 {
  constructor(e) {
    super(e)
  }
  load(e, a, o, c) {
    const d = new CubeTexture()
    d.colorSpace = SRGBColorSpace
    const g = new ImageLoader(this.manager)
    g.setCrossOrigin(this.crossOrigin), g.setPath(this.path)
    let _ = 0
    function b(j) {
      g.load(
        e[j],
        function ($) {
          ;(d.images[j] = $), _++, _ === 6 && ((d.needsUpdate = !0), a && a(d))
        },
        void 0,
        c
      )
    }
    for (let j = 0; j < e.length; ++j) b(j)
    return d
  }
}
class DataTextureLoader extends Loader$1 {
  constructor(e) {
    super(e)
  }
  load(e, a, o, c) {
    const d = this,
      g = new DataTexture(),
      _ = new FileLoader(this.manager)
    return (
      _.setResponseType("arraybuffer"),
      _.setRequestHeader(this.requestHeader),
      _.setPath(this.path),
      _.setWithCredentials(d.withCredentials),
      _.load(
        e,
        function (b) {
          let j
          try {
            j = d.parse(b)
          } catch ($) {
            if (c !== void 0) c($)
            else {
              console.error($)
              return
            }
          }
          j.image !== void 0
            ? (g.image = j.image)
            : j.data !== void 0 &&
              ((g.image.width = j.width),
              (g.image.height = j.height),
              (g.image.data = j.data)),
            (g.wrapS = j.wrapS !== void 0 ? j.wrapS : ClampToEdgeWrapping),
            (g.wrapT = j.wrapT !== void 0 ? j.wrapT : ClampToEdgeWrapping),
            (g.magFilter = j.magFilter !== void 0 ? j.magFilter : LinearFilter),
            (g.minFilter = j.minFilter !== void 0 ? j.minFilter : LinearFilter),
            (g.anisotropy = j.anisotropy !== void 0 ? j.anisotropy : 1),
            j.colorSpace !== void 0
              ? (g.colorSpace = j.colorSpace)
              : j.encoding !== void 0 && (g.encoding = j.encoding),
            j.flipY !== void 0 && (g.flipY = j.flipY),
            j.format !== void 0 && (g.format = j.format),
            j.type !== void 0 && (g.type = j.type),
            j.mipmaps !== void 0 &&
              ((g.mipmaps = j.mipmaps),
              (g.minFilter = LinearMipmapLinearFilter)),
            j.mipmapCount === 1 && (g.minFilter = LinearFilter),
            j.generateMipmaps !== void 0 &&
              (g.generateMipmaps = j.generateMipmaps),
            (g.needsUpdate = !0),
            a && a(g, j)
        },
        o,
        c
      ),
      g
    )
  }
}
class TextureLoader extends Loader$1 {
  constructor(e) {
    super(e)
  }
  load(e, a, o, c) {
    const d = new Texture(),
      g = new ImageLoader(this.manager)
    return (
      g.setCrossOrigin(this.crossOrigin),
      g.setPath(this.path),
      g.load(
        e,
        function (_) {
          ;(d.image = _), (d.needsUpdate = !0), a !== void 0 && a(d)
        },
        o,
        c
      ),
      d
    )
  }
}
class Light extends Object3D {
  constructor(e, a = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Color(e)),
      (this.intensity = a)
  }
  dispose() {}
  copy(e, a) {
    return (
      super.copy(e, a),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    )
  }
  toJSON(e) {
    const a = super.toJSON(e)
    return (
      (a.object.color = this.color.getHex()),
      (a.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (a.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (a.object.distance = this.distance),
      this.angle !== void 0 && (a.object.angle = this.angle),
      this.decay !== void 0 && (a.object.decay = this.decay),
      this.penumbra !== void 0 && (a.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (a.object.shadow = this.shadow.toJSON()),
      a
    )
  }
}
class HemisphereLight extends Light {
  constructor(e, a, o) {
    super(e, o),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Color(a))
  }
  copy(e, a) {
    return super.copy(e, a), this.groundColor.copy(e.groundColor), this
  }
}
const _projScreenMatrix$1 = new Matrix4(),
  _lightPositionWorld$1 = new Vector3(),
  _lookTarget$1 = new Vector3()
class LightShadow {
  constructor(e) {
    ;(this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Vector2(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Matrix4()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Frustum()),
      (this._frameExtents = new Vector2(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Vector4(0, 0, 1, 1)])
  }
  getViewportCount() {
    return this._viewportCount
  }
  getFrustum() {
    return this._frustum
  }
  updateMatrices(e) {
    const a = this.camera,
      o = this.matrix
    _lightPositionWorld$1.setFromMatrixPosition(e.matrixWorld),
      a.position.copy(_lightPositionWorld$1),
      _lookTarget$1.setFromMatrixPosition(e.target.matrixWorld),
      a.lookAt(_lookTarget$1),
      a.updateMatrixWorld(),
      _projScreenMatrix$1.multiplyMatrices(
        a.projectionMatrix,
        a.matrixWorldInverse
      ),
      this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),
      o.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      o.multiply(_projScreenMatrix$1)
  }
  getViewport(e) {
    return this._viewports[e]
  }
  getFrameExtents() {
    return this._frameExtents
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const e = {}
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    )
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1)
  }
  updateMatrices(e) {
    const a = this.camera,
      o = RAD2DEG * 2 * e.angle * this.focus,
      c = this.mapSize.width / this.mapSize.height,
      d = e.distance || a.far
    ;(o !== a.fov || c !== a.aspect || d !== a.far) &&
      ((a.fov = o), (a.aspect = c), (a.far = d), a.updateProjectionMatrix()),
      super.updateMatrices(e)
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this
  }
}
class SpotLight extends Light {
  constructor(e, a, o = 0, c = Math.PI / 3, d = 0, g = 2) {
    super(e, a),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Object3D()),
      (this.distance = o),
      (this.angle = c),
      (this.penumbra = d),
      (this.decay = g),
      (this.map = null),
      (this.shadow = new SpotLightShadow())
  }
  get power() {
    return this.intensity * Math.PI
  }
  set power(e) {
    this.intensity = e / Math.PI
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
const _projScreenMatrix = new Matrix4(),
  _lightPositionWorld = new Vector3(),
  _lookTarget = new Vector3()
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Vector2(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Vector4(2, 1, 1, 1),
        new Vector4(0, 1, 1, 1),
        new Vector4(3, 1, 1, 1),
        new Vector4(1, 1, 1, 1),
        new Vector4(3, 0, 1, 1),
        new Vector4(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
      ])
  }
  updateMatrices(e, a = 0) {
    const o = this.camera,
      c = this.matrix,
      d = e.distance || o.far
    d !== o.far && ((o.far = d), o.updateProjectionMatrix()),
      _lightPositionWorld.setFromMatrixPosition(e.matrixWorld),
      o.position.copy(_lightPositionWorld),
      _lookTarget.copy(o.position),
      _lookTarget.add(this._cubeDirections[a]),
      o.up.copy(this._cubeUps[a]),
      o.lookAt(_lookTarget),
      o.updateMatrixWorld(),
      c.makeTranslation(
        -_lightPositionWorld.x,
        -_lightPositionWorld.y,
        -_lightPositionWorld.z
      ),
      _projScreenMatrix.multiplyMatrices(
        o.projectionMatrix,
        o.matrixWorldInverse
      ),
      this._frustum.setFromProjectionMatrix(_projScreenMatrix)
  }
}
class PointLight extends Light {
  constructor(e, a, o = 0, c = 2) {
    super(e, a),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = o),
      (this.decay = c),
      (this.shadow = new PointLightShadow())
  }
  get power() {
    return this.intensity * 4 * Math.PI
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI)
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e, a) {
    return (
      super.copy(e, a),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)),
      (this.isDirectionalLightShadow = !0)
  }
}
class DirectionalLight extends Light {
  constructor(e, a) {
    super(e, a),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Object3D()),
      (this.shadow = new DirectionalLightShadow())
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    )
  }
}
class AmbientLight extends Light {
  constructor(e, a) {
    super(e, a), (this.isAmbientLight = !0), (this.type = "AmbientLight")
  }
}
class RectAreaLight extends Light {
  constructor(e, a, o = 10, c = 10) {
    super(e, a),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = o),
      (this.height = c)
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI)
  }
  copy(e) {
    return super.copy(e), (this.width = e.width), (this.height = e.height), this
  }
  toJSON(e) {
    const a = super.toJSON(e)
    return (a.object.width = this.width), (a.object.height = this.height), a
  }
}
class SphericalHarmonics3 {
  constructor() {
    ;(this.isSphericalHarmonics3 = !0), (this.coefficients = [])
    for (let e = 0; e < 9; e++) this.coefficients.push(new Vector3())
  }
  set(e) {
    for (let a = 0; a < 9; a++) this.coefficients[a].copy(e[a])
    return this
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0)
    return this
  }
  getAt(e, a) {
    const o = e.x,
      c = e.y,
      d = e.z,
      g = this.coefficients
    return (
      a.copy(g[0]).multiplyScalar(0.282095),
      a.addScaledVector(g[1], 0.488603 * c),
      a.addScaledVector(g[2], 0.488603 * d),
      a.addScaledVector(g[3], 0.488603 * o),
      a.addScaledVector(g[4], 1.092548 * (o * c)),
      a.addScaledVector(g[5], 1.092548 * (c * d)),
      a.addScaledVector(g[6], 0.315392 * (3 * d * d - 1)),
      a.addScaledVector(g[7], 1.092548 * (o * d)),
      a.addScaledVector(g[8], 0.546274 * (o * o - c * c)),
      a
    )
  }
  getIrradianceAt(e, a) {
    const o = e.x,
      c = e.y,
      d = e.z,
      g = this.coefficients
    return (
      a.copy(g[0]).multiplyScalar(0.886227),
      a.addScaledVector(g[1], 2 * 0.511664 * c),
      a.addScaledVector(g[2], 2 * 0.511664 * d),
      a.addScaledVector(g[3], 2 * 0.511664 * o),
      a.addScaledVector(g[4], 2 * 0.429043 * o * c),
      a.addScaledVector(g[5], 2 * 0.429043 * c * d),
      a.addScaledVector(g[6], 0.743125 * d * d - 0.247708),
      a.addScaledVector(g[7], 2 * 0.429043 * o * d),
      a.addScaledVector(g[8], 0.429043 * (o * o - c * c)),
      a
    )
  }
  add(e) {
    for (let a = 0; a < 9; a++) this.coefficients[a].add(e.coefficients[a])
    return this
  }
  addScaledSH(e, a) {
    for (let o = 0; o < 9; o++)
      this.coefficients[o].addScaledVector(e.coefficients[o], a)
    return this
  }
  scale(e) {
    for (let a = 0; a < 9; a++) this.coefficients[a].multiplyScalar(e)
    return this
  }
  lerp(e, a) {
    for (let o = 0; o < 9; o++) this.coefficients[o].lerp(e.coefficients[o], a)
    return this
  }
  equals(e) {
    for (let a = 0; a < 9; a++)
      if (!this.coefficients[a].equals(e.coefficients[a])) return !1
    return !0
  }
  copy(e) {
    return this.set(e.coefficients)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  fromArray(e, a = 0) {
    const o = this.coefficients
    for (let c = 0; c < 9; c++) o[c].fromArray(e, a + c * 3)
    return this
  }
  toArray(e = [], a = 0) {
    const o = this.coefficients
    for (let c = 0; c < 9; c++) o[c].toArray(e, a + c * 3)
    return e
  }
  static getBasisAt(e, a) {
    const o = e.x,
      c = e.y,
      d = e.z
    ;(a[0] = 0.282095),
      (a[1] = 0.488603 * c),
      (a[2] = 0.488603 * d),
      (a[3] = 0.488603 * o),
      (a[4] = 1.092548 * o * c),
      (a[5] = 1.092548 * c * d),
      (a[6] = 0.315392 * (3 * d * d - 1)),
      (a[7] = 1.092548 * o * d),
      (a[8] = 0.546274 * (o * o - c * c))
  }
}
class LightProbe extends Light {
  constructor(e = new SphericalHarmonics3(), a = 1) {
    super(void 0, a), (this.isLightProbe = !0), (this.sh = e)
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this
  }
  toJSON(e) {
    const a = super.toJSON(e)
    return (a.object.sh = this.sh.toArray()), a
  }
}
class MaterialLoader extends Loader$1 {
  constructor(e) {
    super(e), (this.textures = {})
  }
  load(e, a, o, c) {
    const d = this,
      g = new FileLoader(d.manager)
    g.setPath(d.path),
      g.setRequestHeader(d.requestHeader),
      g.setWithCredentials(d.withCredentials),
      g.load(
        e,
        function (_) {
          try {
            a(d.parse(JSON.parse(_)))
          } catch (b) {
            c ? c(b) : console.error(b), d.manager.itemError(e)
          }
        },
        o,
        c
      )
  }
  parse(e) {
    const a = this.textures
    function o(d) {
      return (
        a[d] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", d),
        a[d]
      )
    }
    const c = MaterialLoader.createMaterialFromType(e.type)
    if (
      (e.uuid !== void 0 && (c.uuid = e.uuid),
      e.name !== void 0 && (c.name = e.name),
      e.color !== void 0 && c.color !== void 0 && c.color.setHex(e.color),
      e.roughness !== void 0 && (c.roughness = e.roughness),
      e.metalness !== void 0 && (c.metalness = e.metalness),
      e.sheen !== void 0 && (c.sheen = e.sheen),
      e.sheenColor !== void 0 &&
        (c.sheenColor = new Color().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (c.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        c.emissive !== void 0 &&
        c.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        c.specular !== void 0 &&
        c.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (c.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        c.specularColor !== void 0 &&
        c.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (c.shininess = e.shininess),
      e.clearcoat !== void 0 && (c.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (c.clearcoatRoughness = e.clearcoatRoughness),
      e.iridescence !== void 0 && (c.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (c.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (c.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (c.transmission = e.transmission),
      e.thickness !== void 0 && (c.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (c.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        c.attenuationColor !== void 0 &&
        c.attenuationColor.setHex(e.attenuationColor),
      e.anisotropy !== void 0 && (c.anisotropy = e.anisotropy),
      e.anisotropyRotation !== void 0 &&
        (c.anisotropyRotation = e.anisotropyRotation),
      e.fog !== void 0 && (c.fog = e.fog),
      e.flatShading !== void 0 && (c.flatShading = e.flatShading),
      e.blending !== void 0 && (c.blending = e.blending),
      e.combine !== void 0 && (c.combine = e.combine),
      e.side !== void 0 && (c.side = e.side),
      e.shadowSide !== void 0 && (c.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (c.opacity = e.opacity),
      e.transparent !== void 0 && (c.transparent = e.transparent),
      e.alphaTest !== void 0 && (c.alphaTest = e.alphaTest),
      e.alphaHash !== void 0 && (c.alphaHash = e.alphaHash),
      e.depthTest !== void 0 && (c.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (c.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (c.colorWrite = e.colorWrite),
      e.stencilWrite !== void 0 && (c.stencilWrite = e.stencilWrite),
      e.stencilWriteMask !== void 0 &&
        (c.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (c.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (c.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (c.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (c.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (c.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (c.stencilZPass = e.stencilZPass),
      e.wireframe !== void 0 && (c.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (c.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (c.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (c.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (c.rotation = e.rotation),
      e.linewidth !== 1 && (c.linewidth = e.linewidth),
      e.dashSize !== void 0 && (c.dashSize = e.dashSize),
      e.gapSize !== void 0 && (c.gapSize = e.gapSize),
      e.scale !== void 0 && (c.scale = e.scale),
      e.polygonOffset !== void 0 && (c.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (c.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (c.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (c.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (c.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (c.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (c.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (c.visible = e.visible),
      e.toneMapped !== void 0 && (c.toneMapped = e.toneMapped),
      e.userData !== void 0 && (c.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (c.vertexColors = e.vertexColors > 0)
          : (c.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const d in e.uniforms) {
        const g = e.uniforms[d]
        switch (((c.uniforms[d] = {}), g.type)) {
          case "t":
            c.uniforms[d].value = o(g.value)
            break
          case "c":
            c.uniforms[d].value = new Color().setHex(g.value)
            break
          case "v2":
            c.uniforms[d].value = new Vector2().fromArray(g.value)
            break
          case "v3":
            c.uniforms[d].value = new Vector3().fromArray(g.value)
            break
          case "v4":
            c.uniforms[d].value = new Vector4().fromArray(g.value)
            break
          case "m3":
            c.uniforms[d].value = new Matrix3().fromArray(g.value)
            break
          case "m4":
            c.uniforms[d].value = new Matrix4().fromArray(g.value)
            break
          default:
            c.uniforms[d].value = g.value
        }
      }
    if (
      (e.defines !== void 0 && (c.defines = e.defines),
      e.vertexShader !== void 0 && (c.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (c.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (c.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const d in e.extensions) c.extensions[d] = e.extensions[d]
    if (
      (e.lights !== void 0 && (c.lights = e.lights),
      e.clipping !== void 0 && (c.clipping = e.clipping),
      e.size !== void 0 && (c.size = e.size),
      e.sizeAttenuation !== void 0 && (c.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (c.map = o(e.map)),
      e.matcap !== void 0 && (c.matcap = o(e.matcap)),
      e.alphaMap !== void 0 && (c.alphaMap = o(e.alphaMap)),
      e.bumpMap !== void 0 && (c.bumpMap = o(e.bumpMap)),
      e.bumpScale !== void 0 && (c.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (c.normalMap = o(e.normalMap)),
      e.normalMapType !== void 0 && (c.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let d = e.normalScale
      Array.isArray(d) === !1 && (d = [d, d]),
        (c.normalScale = new Vector2().fromArray(d))
    }
    return (
      e.displacementMap !== void 0 &&
        (c.displacementMap = o(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (c.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (c.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (c.roughnessMap = o(e.roughnessMap)),
      e.metalnessMap !== void 0 && (c.metalnessMap = o(e.metalnessMap)),
      e.emissiveMap !== void 0 && (c.emissiveMap = o(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (c.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (c.specularMap = o(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (c.specularIntensityMap = o(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (c.specularColorMap = o(e.specularColorMap)),
      e.envMap !== void 0 && (c.envMap = o(e.envMap)),
      e.envMapIntensity !== void 0 && (c.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (c.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (c.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (c.lightMap = o(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (c.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (c.aoMap = o(e.aoMap)),
      e.aoMapIntensity !== void 0 && (c.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (c.gradientMap = o(e.gradientMap)),
      e.clearcoatMap !== void 0 && (c.clearcoatMap = o(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (c.clearcoatRoughnessMap = o(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (c.clearcoatNormalMap = o(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (c.clearcoatNormalScale = new Vector2().fromArray(
          e.clearcoatNormalScale
        )),
      e.iridescenceMap !== void 0 && (c.iridescenceMap = o(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (c.iridescenceThicknessMap = o(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (c.transmissionMap = o(e.transmissionMap)),
      e.thicknessMap !== void 0 && (c.thicknessMap = o(e.thicknessMap)),
      e.anisotropyMap !== void 0 && (c.anisotropyMap = o(e.anisotropyMap)),
      e.sheenColorMap !== void 0 && (c.sheenColorMap = o(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (c.sheenRoughnessMap = o(e.sheenRoughnessMap)),
      c
    )
  }
  setTextures(e) {
    return (this.textures = e), this
  }
  static createMaterialFromType(e) {
    const a = {
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material,
    }
    return new a[e]()
  }
}
class LoaderUtils {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e)
    let a = ""
    for (let o = 0, c = e.length; o < c; o++) a += String.fromCharCode(e[o])
    try {
      return decodeURIComponent(escape(a))
    } catch {
      return a
    }
  }
  static extractUrlBase(e) {
    const a = e.lastIndexOf("/")
    return a === -1 ? "./" : e.slice(0, a + 1)
  }
  static resolveURL(e, a) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(a) &&
          /^\//.test(e) &&
          (a = a.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : a + e)
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0)
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this
  }
  toJSON() {
    const e = super.toJSON()
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    )
  }
}
class BufferGeometryLoader extends Loader$1 {
  constructor(e) {
    super(e)
  }
  load(e, a, o, c) {
    const d = this,
      g = new FileLoader(d.manager)
    g.setPath(d.path),
      g.setRequestHeader(d.requestHeader),
      g.setWithCredentials(d.withCredentials),
      g.load(
        e,
        function (_) {
          try {
            a(d.parse(JSON.parse(_)))
          } catch (b) {
            c ? c(b) : console.error(b), d.manager.itemError(e)
          }
        },
        o,
        c
      )
  }
  parse(e) {
    const a = {},
      o = {}
    function c(st, at) {
      if (a[at] !== void 0) return a[at]
      const ut = st.interleavedBuffers[at],
        it = d(st, ut.buffer),
        ct = getTypedArray(ut.type, it),
        lt = new InterleavedBuffer(ct, ut.stride)
      return (lt.uuid = ut.uuid), (a[at] = lt), lt
    }
    function d(st, at) {
      if (o[at] !== void 0) return o[at]
      const ut = st.arrayBuffers[at],
        it = new Uint32Array(ut).buffer
      return (o[at] = it), it
    }
    const g = e.isInstancedBufferGeometry
        ? new InstancedBufferGeometry()
        : new BufferGeometry(),
      _ = e.data.index
    if (_ !== void 0) {
      const st = getTypedArray(_.type, _.array)
      g.setIndex(new BufferAttribute(st, 1))
    }
    const b = e.data.attributes
    for (const st in b) {
      const at = b[st]
      let ot
      if (at.isInterleavedBufferAttribute) {
        const ut = c(e.data, at.data)
        ot = new InterleavedBufferAttribute(
          ut,
          at.itemSize,
          at.offset,
          at.normalized
        )
      } else {
        const ut = getTypedArray(at.type, at.array),
          it = at.isInstancedBufferAttribute
            ? InstancedBufferAttribute
            : BufferAttribute
        ot = new it(ut, at.itemSize, at.normalized)
      }
      at.name !== void 0 && (ot.name = at.name),
        at.usage !== void 0 && ot.setUsage(at.usage),
        at.updateRange !== void 0 &&
          ((ot.updateRange.offset = at.updateRange.offset),
          (ot.updateRange.count = at.updateRange.count)),
        g.setAttribute(st, ot)
    }
    const j = e.data.morphAttributes
    if (j)
      for (const st in j) {
        const at = j[st],
          ot = []
        for (let ut = 0, it = at.length; ut < it; ut++) {
          const ct = at[ut]
          let lt
          if (ct.isInterleavedBufferAttribute) {
            const ht = c(e.data, ct.data)
            lt = new InterleavedBufferAttribute(
              ht,
              ct.itemSize,
              ct.offset,
              ct.normalized
            )
          } else {
            const ht = getTypedArray(ct.type, ct.array)
            lt = new BufferAttribute(ht, ct.itemSize, ct.normalized)
          }
          ct.name !== void 0 && (lt.name = ct.name), ot.push(lt)
        }
        g.morphAttributes[st] = ot
      }
    e.data.morphTargetsRelative && (g.morphTargetsRelative = !0)
    const _e = e.data.groups || e.data.drawcalls || e.data.offsets
    if (_e !== void 0)
      for (let st = 0, at = _e.length; st !== at; ++st) {
        const ot = _e[st]
        g.addGroup(ot.start, ot.count, ot.materialIndex)
      }
    const tt = e.data.boundingSphere
    if (tt !== void 0) {
      const st = new Vector3()
      tt.center !== void 0 && st.fromArray(tt.center),
        (g.boundingSphere = new Sphere(st, tt.radius))
    }
    return (
      e.name && (g.name = e.name), e.userData && (g.userData = e.userData), g
    )
  }
}
class ObjectLoader extends Loader$1 {
  constructor(e) {
    super(e)
  }
  load(e, a, o, c) {
    const d = this,
      g = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path
    this.resourcePath = this.resourcePath || g
    const _ = new FileLoader(this.manager)
    _.setPath(this.path),
      _.setRequestHeader(this.requestHeader),
      _.setWithCredentials(this.withCredentials),
      _.load(
        e,
        function (b) {
          let j = null
          try {
            j = JSON.parse(b)
          } catch (_e) {
            c !== void 0 && c(_e),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                _e.message
              )
            return
          }
          const $ = j.metadata
          if (
            $ === void 0 ||
            $.type === void 0 ||
            $.type.toLowerCase() === "geometry"
          ) {
            c !== void 0 && c(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e)
            return
          }
          d.parse(j, a)
        },
        o,
        c
      )
  }
  async loadAsync(e, a) {
    const o = this,
      c = this.path === "" ? LoaderUtils.extractUrlBase(e) : this.path
    this.resourcePath = this.resourcePath || c
    const d = new FileLoader(this.manager)
    d.setPath(this.path),
      d.setRequestHeader(this.requestHeader),
      d.setWithCredentials(this.withCredentials)
    const g = await d.loadAsync(e, a),
      _ = JSON.parse(g),
      b = _.metadata
    if (
      b === void 0 ||
      b.type === void 0 ||
      b.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e)
    return await o.parseAsync(_)
  }
  parse(e, a) {
    const o = this.parseAnimations(e.animations),
      c = this.parseShapes(e.shapes),
      d = this.parseGeometries(e.geometries, c),
      g = this.parseImages(e.images, function () {
        a !== void 0 && a(j)
      }),
      _ = this.parseTextures(e.textures, g),
      b = this.parseMaterials(e.materials, _),
      j = this.parseObject(e.object, d, b, _, o),
      $ = this.parseSkeletons(e.skeletons, j)
    if ((this.bindSkeletons(j, $), a !== void 0)) {
      let _e = !1
      for (const tt in g)
        if (g[tt].data instanceof HTMLImageElement) {
          _e = !0
          break
        }
      _e === !1 && a(j)
    }
    return j
  }
  async parseAsync(e) {
    const a = this.parseAnimations(e.animations),
      o = this.parseShapes(e.shapes),
      c = this.parseGeometries(e.geometries, o),
      d = await this.parseImagesAsync(e.images),
      g = this.parseTextures(e.textures, d),
      _ = this.parseMaterials(e.materials, g),
      b = this.parseObject(e.object, c, _, g, a),
      j = this.parseSkeletons(e.skeletons, b)
    return this.bindSkeletons(b, j), b
  }
  parseShapes(e) {
    const a = {}
    if (e !== void 0)
      for (let o = 0, c = e.length; o < c; o++) {
        const d = new Shape().fromJSON(e[o])
        a[d.uuid] = d
      }
    return a
  }
  parseSkeletons(e, a) {
    const o = {},
      c = {}
    if (
      (a.traverse(function (d) {
        d.isBone && (c[d.uuid] = d)
      }),
      e !== void 0)
    )
      for (let d = 0, g = e.length; d < g; d++) {
        const _ = new Skeleton().fromJSON(e[d], c)
        o[_.uuid] = _
      }
    return o
  }
  parseGeometries(e, a) {
    const o = {}
    if (e !== void 0) {
      const c = new BufferGeometryLoader()
      for (let d = 0, g = e.length; d < g; d++) {
        let _
        const b = e[d]
        switch (b.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            _ = c.parse(b)
            break
          default:
            b.type in Geometries$1
              ? (_ = Geometries$1[b.type].fromJSON(b, a))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${b.type}"`
                )
        }
        ;(_.uuid = b.uuid),
          b.name !== void 0 && (_.name = b.name),
          b.userData !== void 0 && (_.userData = b.userData),
          (o[b.uuid] = _)
      }
    }
    return o
  }
  parseMaterials(e, a) {
    const o = {},
      c = {}
    if (e !== void 0) {
      const d = new MaterialLoader()
      d.setTextures(a)
      for (let g = 0, _ = e.length; g < _; g++) {
        const b = e[g]
        o[b.uuid] === void 0 && (o[b.uuid] = d.parse(b)),
          (c[b.uuid] = o[b.uuid])
      }
    }
    return c
  }
  parseAnimations(e) {
    const a = {}
    if (e !== void 0)
      for (let o = 0; o < e.length; o++) {
        const c = e[o],
          d = AnimationClip.parse(c)
        a[d.uuid] = d
      }
    return a
  }
  parseImages(e, a) {
    const o = this,
      c = {}
    let d
    function g(b) {
      return (
        o.manager.itemStart(b),
        d.load(
          b,
          function () {
            o.manager.itemEnd(b)
          },
          void 0,
          function () {
            o.manager.itemError(b), o.manager.itemEnd(b)
          }
        )
      )
    }
    function _(b) {
      if (typeof b == "string") {
        const j = b,
          $ = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(j) ? j : o.resourcePath + j
        return g($)
      } else
        return b.data
          ? {
              data: getTypedArray(b.type, b.data),
              width: b.width,
              height: b.height,
            }
          : null
    }
    if (e !== void 0 && e.length > 0) {
      const b = new LoadingManager(a)
      ;(d = new ImageLoader(b)), d.setCrossOrigin(this.crossOrigin)
      for (let j = 0, $ = e.length; j < $; j++) {
        const _e = e[j],
          tt = _e.url
        if (Array.isArray(tt)) {
          const st = []
          for (let at = 0, ot = tt.length; at < ot; at++) {
            const ut = tt[at],
              it = _(ut)
            it !== null &&
              (it instanceof HTMLImageElement
                ? st.push(it)
                : st.push(new DataTexture(it.data, it.width, it.height)))
          }
          c[_e.uuid] = new Source(st)
        } else {
          const st = _(_e.url)
          c[_e.uuid] = new Source(st)
        }
      }
    }
    return c
  }
  async parseImagesAsync(e) {
    const a = this,
      o = {}
    let c
    async function d(g) {
      if (typeof g == "string") {
        const _ = g,
          b = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(_) ? _ : a.resourcePath + _
        return await c.loadAsync(b)
      } else
        return g.data
          ? {
              data: getTypedArray(g.type, g.data),
              width: g.width,
              height: g.height,
            }
          : null
    }
    if (e !== void 0 && e.length > 0) {
      ;(c = new ImageLoader(this.manager)), c.setCrossOrigin(this.crossOrigin)
      for (let g = 0, _ = e.length; g < _; g++) {
        const b = e[g],
          j = b.url
        if (Array.isArray(j)) {
          const $ = []
          for (let _e = 0, tt = j.length; _e < tt; _e++) {
            const st = j[_e],
              at = await d(st)
            at !== null &&
              (at instanceof HTMLImageElement
                ? $.push(at)
                : $.push(new DataTexture(at.data, at.width, at.height)))
          }
          o[b.uuid] = new Source($)
        } else {
          const $ = await d(b.url)
          o[b.uuid] = new Source($)
        }
      }
    }
    return o
  }
  parseTextures(e, a) {
    function o(d, g) {
      return typeof d == "number"
        ? d
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            d
          ),
          g[d])
    }
    const c = {}
    if (e !== void 0)
      for (let d = 0, g = e.length; d < g; d++) {
        const _ = e[d]
        _.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', _.uuid),
          a[_.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", _.image)
        const b = a[_.image],
          j = b.data
        let $
        Array.isArray(j)
          ? (($ = new CubeTexture()), j.length === 6 && ($.needsUpdate = !0))
          : (j && j.data ? ($ = new DataTexture()) : ($ = new Texture()),
            j && ($.needsUpdate = !0)),
          ($.source = b),
          ($.uuid = _.uuid),
          _.name !== void 0 && ($.name = _.name),
          _.mapping !== void 0 && ($.mapping = o(_.mapping, TEXTURE_MAPPING)),
          _.channel !== void 0 && ($.channel = _.channel),
          _.offset !== void 0 && $.offset.fromArray(_.offset),
          _.repeat !== void 0 && $.repeat.fromArray(_.repeat),
          _.center !== void 0 && $.center.fromArray(_.center),
          _.rotation !== void 0 && ($.rotation = _.rotation),
          _.wrap !== void 0 &&
            (($.wrapS = o(_.wrap[0], TEXTURE_WRAPPING)),
            ($.wrapT = o(_.wrap[1], TEXTURE_WRAPPING))),
          _.format !== void 0 && ($.format = _.format),
          _.internalFormat !== void 0 && ($.internalFormat = _.internalFormat),
          _.type !== void 0 && ($.type = _.type),
          _.colorSpace !== void 0 && ($.colorSpace = _.colorSpace),
          _.encoding !== void 0 && ($.encoding = _.encoding),
          _.minFilter !== void 0 &&
            ($.minFilter = o(_.minFilter, TEXTURE_FILTER)),
          _.magFilter !== void 0 &&
            ($.magFilter = o(_.magFilter, TEXTURE_FILTER)),
          _.anisotropy !== void 0 && ($.anisotropy = _.anisotropy),
          _.flipY !== void 0 && ($.flipY = _.flipY),
          _.generateMipmaps !== void 0 &&
            ($.generateMipmaps = _.generateMipmaps),
          _.premultiplyAlpha !== void 0 &&
            ($.premultiplyAlpha = _.premultiplyAlpha),
          _.unpackAlignment !== void 0 &&
            ($.unpackAlignment = _.unpackAlignment),
          _.compareFunction !== void 0 &&
            ($.compareFunction = _.compareFunction),
          _.userData !== void 0 && ($.userData = _.userData),
          (c[_.uuid] = $)
      }
    return c
  }
  parseObject(e, a, o, c, d) {
    let g
    function _(tt) {
      return (
        a[tt] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", tt),
        a[tt]
      )
    }
    function b(tt) {
      if (tt !== void 0) {
        if (Array.isArray(tt)) {
          const st = []
          for (let at = 0, ot = tt.length; at < ot; at++) {
            const ut = tt[at]
            o[ut] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", ut),
              st.push(o[ut])
          }
          return st
        }
        return (
          o[tt] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", tt),
          o[tt]
        )
      }
    }
    function j(tt) {
      return (
        c[tt] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", tt),
        c[tt]
      )
    }
    let $, _e
    switch (e.type) {
      case "Scene":
        ;(g = new Scene()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (g.background = new Color(e.background))
              : (g.background = j(e.background))),
          e.environment !== void 0 && (g.environment = j(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (g.fog = new Fog(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (g.fog = new FogExp2(e.fog.color, e.fog.density))),
          e.backgroundBlurriness !== void 0 &&
            (g.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (g.backgroundIntensity = e.backgroundIntensity)
        break
      case "PerspectiveCamera":
        ;(g = new PerspectiveCamera(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (g.focus = e.focus),
          e.zoom !== void 0 && (g.zoom = e.zoom),
          e.filmGauge !== void 0 && (g.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (g.filmOffset = e.filmOffset),
          e.view !== void 0 && (g.view = Object.assign({}, e.view))
        break
      case "OrthographicCamera":
        ;(g = new OrthographicCamera(
          e.left,
          e.right,
          e.top,
          e.bottom,
          e.near,
          e.far
        )),
          e.zoom !== void 0 && (g.zoom = e.zoom),
          e.view !== void 0 && (g.view = Object.assign({}, e.view))
        break
      case "AmbientLight":
        g = new AmbientLight(e.color, e.intensity)
        break
      case "DirectionalLight":
        g = new DirectionalLight(e.color, e.intensity)
        break
      case "PointLight":
        g = new PointLight(e.color, e.intensity, e.distance, e.decay)
        break
      case "RectAreaLight":
        g = new RectAreaLight(e.color, e.intensity, e.width, e.height)
        break
      case "SpotLight":
        g = new SpotLight(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        )
        break
      case "HemisphereLight":
        g = new HemisphereLight(e.color, e.groundColor, e.intensity)
        break
      case "LightProbe":
        g = new LightProbe().fromJSON(e)
        break
      case "SkinnedMesh":
        ;($ = _(e.geometry)),
          (_e = b(e.material)),
          (g = new SkinnedMesh($, _e)),
          e.bindMode !== void 0 && (g.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && g.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (g.skeleton = e.skeleton)
        break
      case "Mesh":
        ;($ = _(e.geometry)), (_e = b(e.material)), (g = new Mesh($, _e))
        break
      case "InstancedMesh":
        ;($ = _(e.geometry)), (_e = b(e.material))
        const tt = e.count,
          st = e.instanceMatrix,
          at = e.instanceColor
        ;(g = new InstancedMesh($, _e, tt)),
          (g.instanceMatrix = new InstancedBufferAttribute(
            new Float32Array(st.array),
            16
          )),
          at !== void 0 &&
            (g.instanceColor = new InstancedBufferAttribute(
              new Float32Array(at.array),
              at.itemSize
            ))
        break
      case "LOD":
        g = new LOD()
        break
      case "Line":
        g = new Line(_(e.geometry), b(e.material))
        break
      case "LineLoop":
        g = new LineLoop(_(e.geometry), b(e.material))
        break
      case "LineSegments":
        g = new LineSegments(_(e.geometry), b(e.material))
        break
      case "PointCloud":
      case "Points":
        g = new Points$1(_(e.geometry), b(e.material))
        break
      case "Sprite":
        g = new Sprite(b(e.material))
        break
      case "Group":
        g = new Group()
        break
      case "Bone":
        g = new Bone()
        break
      default:
        g = new Object3D()
    }
    if (
      ((g.uuid = e.uuid),
      e.name !== void 0 && (g.name = e.name),
      e.matrix !== void 0
        ? (g.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (g.matrixAutoUpdate = e.matrixAutoUpdate),
          g.matrixAutoUpdate &&
            g.matrix.decompose(g.position, g.quaternion, g.scale))
        : (e.position !== void 0 && g.position.fromArray(e.position),
          e.rotation !== void 0 && g.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && g.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && g.scale.fromArray(e.scale)),
      e.up !== void 0 && g.up.fromArray(e.up),
      e.castShadow !== void 0 && (g.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (g.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (g.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (g.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (g.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          g.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (g.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (g.visible = e.visible),
      e.frustumCulled !== void 0 && (g.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (g.renderOrder = e.renderOrder),
      e.userData !== void 0 && (g.userData = e.userData),
      e.layers !== void 0 && (g.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const tt = e.children
      for (let st = 0; st < tt.length; st++)
        g.add(this.parseObject(tt[st], a, o, c, d))
    }
    if (e.animations !== void 0) {
      const tt = e.animations
      for (let st = 0; st < tt.length; st++) {
        const at = tt[st]
        g.animations.push(d[at])
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (g.autoUpdate = e.autoUpdate)
      const tt = e.levels
      for (let st = 0; st < tt.length; st++) {
        const at = tt[st],
          ot = g.getObjectByProperty("uuid", at.object)
        ot !== void 0 && g.addLevel(ot, at.distance, at.hysteresis)
      }
    }
    return g
  }
  bindSkeletons(e, a) {
    Object.keys(a).length !== 0 &&
      e.traverse(function (o) {
        if (o.isSkinnedMesh === !0 && o.skeleton !== void 0) {
          const c = a[o.skeleton]
          c === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                o.skeleton
              )
            : o.bind(c, o.bindMatrix)
        }
      })
  }
}
const TEXTURE_MAPPING = {
    UVMapping,
    CubeReflectionMapping,
    CubeRefractionMapping,
    EquirectangularReflectionMapping,
    EquirectangularRefractionMapping,
    CubeUVReflectionMapping,
  },
  TEXTURE_WRAPPING = {
    RepeatWrapping,
    ClampToEdgeWrapping,
    MirroredRepeatWrapping,
  },
  TEXTURE_FILTER = {
    NearestFilter,
    NearestMipmapNearestFilter,
    NearestMipmapLinearFilter,
    LinearFilter,
    LinearMipmapNearestFilter,
    LinearMipmapLinearFilter,
  }
class ImageBitmapLoader extends Loader$1 {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" })
  }
  setOptions(e) {
    return (this.options = e), this
  }
  load(e, a, o, c) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e))
    const d = this,
      g = Cache.get(e)
    if (g !== void 0)
      return (
        d.manager.itemStart(e),
        setTimeout(function () {
          a && a(g), d.manager.itemEnd(e)
        }, 0),
        g
      )
    const _ = {}
    ;(_.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (_.headers = this.requestHeader),
      fetch(e, _)
        .then(function (b) {
          return b.blob()
        })
        .then(function (b) {
          return createImageBitmap(
            b,
            Object.assign(d.options, { colorSpaceConversion: "none" })
          )
        })
        .then(function (b) {
          Cache.add(e, b), a && a(b), d.manager.itemEnd(e)
        })
        .catch(function (b) {
          c && c(b), d.manager.itemError(e), d.manager.itemEnd(e)
        }),
      d.manager.itemStart(e)
  }
}
let _context$1
class AudioContext {
  static getContext() {
    return (
      _context$1 === void 0 &&
        (_context$1 = new (window.AudioContext || window.webkitAudioContext)()),
      _context$1
    )
  }
  static setContext(e) {
    _context$1 = e
  }
}
class AudioLoader extends Loader$1 {
  constructor(e) {
    super(e)
  }
  load(e, a, o, c) {
    const d = this,
      g = new FileLoader(this.manager)
    g.setResponseType("arraybuffer"),
      g.setPath(this.path),
      g.setRequestHeader(this.requestHeader),
      g.setWithCredentials(this.withCredentials),
      g.load(
        e,
        function (b) {
          try {
            const j = b.slice(0)
            AudioContext.getContext().decodeAudioData(
              j,
              function (_e) {
                a(_e)
              },
              _
            )
          } catch (j) {
            _(j)
          }
        },
        o,
        c
      )
    function _(b) {
      c ? c(b) : console.error(b), d.manager.itemError(e)
    }
  }
}
class HemisphereLightProbe extends LightProbe {
  constructor(e, a, o = 1) {
    super(void 0, o), (this.isHemisphereLightProbe = !0)
    const c = new Color().set(e),
      d = new Color().set(a),
      g = new Vector3(c.r, c.g, c.b),
      _ = new Vector3(d.r, d.g, d.b),
      b = Math.sqrt(Math.PI),
      j = b * Math.sqrt(0.75)
    this.sh.coefficients[0].copy(g).add(_).multiplyScalar(b),
      this.sh.coefficients[1].copy(g).sub(_).multiplyScalar(j)
  }
}
class AmbientLightProbe extends LightProbe {
  constructor(e, a = 1) {
    super(void 0, a), (this.isAmbientLightProbe = !0)
    const o = new Color().set(e)
    this.sh.coefficients[0]
      .set(o.r, o.g, o.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI))
  }
}
const _eyeRight = new Matrix4(),
  _eyeLeft = new Matrix4(),
  _projectionMatrix = new Matrix4()
class StereoCamera {
  constructor() {
    ;(this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new PerspectiveCamera()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new PerspectiveCamera()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      })
  }
  update(e) {
    const a = this._cache
    if (
      a.focus !== e.focus ||
      a.fov !== e.fov ||
      a.aspect !== e.aspect * this.aspect ||
      a.near !== e.near ||
      a.far !== e.far ||
      a.zoom !== e.zoom ||
      a.eyeSep !== this.eyeSep
    ) {
      ;(a.focus = e.focus),
        (a.fov = e.fov),
        (a.aspect = e.aspect * this.aspect),
        (a.near = e.near),
        (a.far = e.far),
        (a.zoom = e.zoom),
        (a.eyeSep = this.eyeSep),
        _projectionMatrix.copy(e.projectionMatrix)
      const c = a.eyeSep / 2,
        d = (c * a.near) / a.focus,
        g = (a.near * Math.tan(DEG2RAD * a.fov * 0.5)) / a.zoom
      let _, b
      ;(_eyeLeft.elements[12] = -c),
        (_eyeRight.elements[12] = c),
        (_ = -g * a.aspect + d),
        (b = g * a.aspect + d),
        (_projectionMatrix.elements[0] = (2 * a.near) / (b - _)),
        (_projectionMatrix.elements[8] = (b + _) / (b - _)),
        this.cameraL.projectionMatrix.copy(_projectionMatrix),
        (_ = -g * a.aspect - d),
        (b = g * a.aspect - d),
        (_projectionMatrix.elements[0] = (2 * a.near) / (b - _)),
        (_projectionMatrix.elements[8] = (b + _) / (b - _)),
        this.cameraR.projectionMatrix.copy(_projectionMatrix)
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(_eyeLeft),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_eyeRight)
  }
}
class Clock {
  constructor(e = !0) {
    ;(this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1)
  }
  start() {
    ;(this.startTime = now()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0)
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1)
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime
  }
  getDelta() {
    let e = 0
    if (this.autoStart && !this.running) return this.start(), 0
    if (this.running) {
      const a = now()
      ;(e = (a - this.oldTime) / 1e3),
        (this.oldTime = a),
        (this.elapsedTime += e)
    }
    return e
  }
}
function now() {
  return (typeof performance > "u" ? Date : performance).now()
}
const _position$1 = new Vector3(),
  _quaternion$1 = new Quaternion(),
  _scale$1 = new Vector3(),
  _orientation$1 = new Vector3()
class AudioListener extends Object3D {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = AudioContext.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new Clock())
  }
  getInput() {
    return this.gain
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    )
  }
  getFilter() {
    return this.filter
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    )
  }
  getMasterVolume() {
    return this.gain.gain.value
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    )
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e)
    const a = this.context.listener,
      o = this.up
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1),
      _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1),
      a.positionX)
    ) {
      const c = this.context.currentTime + this.timeDelta
      a.positionX.linearRampToValueAtTime(_position$1.x, c),
        a.positionY.linearRampToValueAtTime(_position$1.y, c),
        a.positionZ.linearRampToValueAtTime(_position$1.z, c),
        a.forwardX.linearRampToValueAtTime(_orientation$1.x, c),
        a.forwardY.linearRampToValueAtTime(_orientation$1.y, c),
        a.forwardZ.linearRampToValueAtTime(_orientation$1.z, c),
        a.upX.linearRampToValueAtTime(o.x, c),
        a.upY.linearRampToValueAtTime(o.y, c),
        a.upZ.linearRampToValueAtTime(o.z, c)
    } else
      a.setPosition(_position$1.x, _position$1.y, _position$1.z),
        a.setOrientation(
          _orientation$1.x,
          _orientation$1.y,
          _orientation$1.z,
          o.x,
          o.y,
          o.z
        )
  }
}
let Audio$1 = class extends Object3D {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = [])
  }
  getOutput() {
    return this.gain
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    )
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    )
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    )
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    )
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.")
      return
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.")
      return
    }
    this._startedAt = this.context.currentTime + e
    const a = this.context.createBufferSource()
    return (
      (a.buffer = this.buffer),
      (a.loop = this.loop),
      (a.loopStart = this.loopStart),
      (a.loopEnd = this.loopEnd),
      (a.onended = this.onEnded.bind(this)),
      a.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = a),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    )
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.")
      return
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    )
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.")
      return
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    )
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0])
      for (let e = 1, a = this.filters.length; e < a; e++)
        this.filters[e - 1].connect(this.filters[e])
      this.filters[this.filters.length - 1].connect(this.getOutput())
    } else this.source.connect(this.getOutput())
    return (this._connected = !0), this
  }
  disconnect() {
    if (this._connected !== !1) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0])
        for (let e = 1, a = this.filters.length; e < a; e++)
          this.filters[e - 1].disconnect(this.filters[e])
        this.filters[this.filters.length - 1].disconnect(this.getOutput())
      } else this.source.disconnect(this.getOutput())
      return (this._connected = !1), this
    }
  }
  getFilters() {
    return this.filters
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    )
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      )
  }
  getDetune() {
    return this.detune
  }
  getFilter() {
    return this.getFilters()[0]
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : [])
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.")
      return
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    )
  }
  getPlaybackRate() {
    return this.playbackRate
  }
  onEnded() {
    this.isPlaying = !1
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.")
      return
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    )
  }
  setLoopStart(e) {
    return (this.loopStart = e), this
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this
  }
  getVolume() {
    return this.gain.gain.value
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    )
  }
}
const _position = new Vector3(),
  _quaternion = new Quaternion(),
  _scale = new Vector3(),
  _orientation = new Vector3()
class PositionalAudio extends Audio$1 {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain)
  }
  connect() {
    super.connect(), this.panner.connect(this.gain)
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain)
  }
  getOutput() {
    return this.panner
  }
  getRefDistance() {
    return this.panner.refDistance
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this
  }
  getDistanceModel() {
    return this.panner.distanceModel
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this
  }
  getMaxDistance() {
    return this.panner.maxDistance
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this
  }
  setDirectionalCone(e, a, o) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = a),
      (this.panner.coneOuterGain = o),
      this
    )
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return
    this.matrixWorld.decompose(_position, _quaternion, _scale),
      _orientation.set(0, 0, 1).applyQuaternion(_quaternion)
    const a = this.panner
    if (a.positionX) {
      const o = this.context.currentTime + this.listener.timeDelta
      a.positionX.linearRampToValueAtTime(_position.x, o),
        a.positionY.linearRampToValueAtTime(_position.y, o),
        a.positionZ.linearRampToValueAtTime(_position.z, o),
        a.orientationX.linearRampToValueAtTime(_orientation.x, o),
        a.orientationY.linearRampToValueAtTime(_orientation.y, o),
        a.orientationZ.linearRampToValueAtTime(_orientation.z, o)
    } else
      a.setPosition(_position.x, _position.y, _position.z),
        a.setOrientation(_orientation.x, _orientation.y, _orientation.z)
  }
}
class AudioAnalyser {
  constructor(e, a = 2048) {
    ;(this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = a),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser)
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data
  }
  getAverageFrequency() {
    let e = 0
    const a = this.getFrequencyData()
    for (let o = 0; o < a.length; o++) e += a[o]
    return e / a.length
  }
}
class PropertyMixer {
  constructor(e, a, o) {
    ;(this.binding = e), (this.valueSize = o)
    let c, d, g
    switch (a) {
      case "quaternion":
        ;(c = this._slerp),
          (d = this._slerpAdditive),
          (g = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(o * 6)),
          (this._workIndex = 5)
        break
      case "string":
      case "bool":
        ;(c = this._select),
          (d = this._select),
          (g = this._setAdditiveIdentityOther),
          (this.buffer = new Array(o * 5))
        break
      default:
        ;(c = this._lerp),
          (d = this._lerpAdditive),
          (g = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(o * 5))
    }
    ;(this._mixBufferRegion = c),
      (this._mixBufferRegionAdditive = d),
      (this._setIdentity = g),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0)
  }
  accumulate(e, a) {
    const o = this.buffer,
      c = this.valueSize,
      d = e * c + c
    let g = this.cumulativeWeight
    if (g === 0) {
      for (let _ = 0; _ !== c; ++_) o[d + _] = o[_]
      g = a
    } else {
      g += a
      const _ = a / g
      this._mixBufferRegion(o, d, 0, _, c)
    }
    this.cumulativeWeight = g
  }
  accumulateAdditive(e) {
    const a = this.buffer,
      o = this.valueSize,
      c = o * this._addIndex
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(a, c, 0, e, o),
      (this.cumulativeWeightAdditive += e)
  }
  apply(e) {
    const a = this.valueSize,
      o = this.buffer,
      c = e * a + a,
      d = this.cumulativeWeight,
      g = this.cumulativeWeightAdditive,
      _ = this.binding
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), d < 1)
    ) {
      const b = a * this._origIndex
      this._mixBufferRegion(o, c, b, 1 - d, a)
    }
    g > 0 && this._mixBufferRegionAdditive(o, c, this._addIndex * a, 1, a)
    for (let b = a, j = a + a; b !== j; ++b)
      if (o[b] !== o[b + a]) {
        _.setValue(o, c)
        break
      }
  }
  saveOriginalState() {
    const e = this.binding,
      a = this.buffer,
      o = this.valueSize,
      c = o * this._origIndex
    e.getValue(a, c)
    for (let d = o, g = c; d !== g; ++d) a[d] = a[c + (d % o)]
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0)
  }
  restoreOriginalState() {
    const e = this.valueSize * 3
    this.binding.setValue(this.buffer, e)
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      a = e + this.valueSize
    for (let o = e; o < a; o++) this.buffer[o] = 0
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1)
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      a = this._addIndex * this.valueSize
    for (let o = 0; o < this.valueSize; o++)
      this.buffer[a + o] = this.buffer[e + o]
  }
  _select(e, a, o, c, d) {
    if (c >= 0.5) for (let g = 0; g !== d; ++g) e[a + g] = e[o + g]
  }
  _slerp(e, a, o, c) {
    Quaternion.slerpFlat(e, a, e, a, e, o, c)
  }
  _slerpAdditive(e, a, o, c, d) {
    const g = this._workIndex * d
    Quaternion.multiplyQuaternionsFlat(e, g, e, a, e, o),
      Quaternion.slerpFlat(e, a, e, a, e, g, c)
  }
  _lerp(e, a, o, c, d) {
    const g = 1 - c
    for (let _ = 0; _ !== d; ++_) {
      const b = a + _
      e[b] = e[b] * g + e[o + _] * c
    }
  }
  _lerpAdditive(e, a, o, c, d) {
    for (let g = 0; g !== d; ++g) {
      const _ = a + g
      e[_] = e[_] + e[o + g] * c
    }
  }
}
const _RESERVED_CHARS_RE = "\\[\\]\\.:\\/",
  _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g"),
  _wordChar = "[^" + _RESERVED_CHARS_RE + "]",
  _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]",
  _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar),
  _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot),
  _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar),
  _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar),
  _trackRe = new RegExp(
    "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
  ),
  _supportedObjectNames = ["material", "materials", "bones", "map"]
class Composite {
  constructor(e, a, o) {
    const c = o || PropertyBinding.parseTrackName(a)
    ;(this._targetGroup = e), (this._bindings = e.subscribe_(a, c))
  }
  getValue(e, a) {
    this.bind()
    const o = this._targetGroup.nCachedObjects_,
      c = this._bindings[o]
    c !== void 0 && c.getValue(e, a)
  }
  setValue(e, a) {
    const o = this._bindings
    for (let c = this._targetGroup.nCachedObjects_, d = o.length; c !== d; ++c)
      o[c].setValue(e, a)
  }
  bind() {
    const e = this._bindings
    for (let a = this._targetGroup.nCachedObjects_, o = e.length; a !== o; ++a)
      e[a].bind()
  }
  unbind() {
    const e = this._bindings
    for (let a = this._targetGroup.nCachedObjects_, o = e.length; a !== o; ++a)
      e[a].unbind()
  }
}
class PropertyBinding {
  constructor(e, a, o) {
    ;(this.path = a),
      (this.parsedPath = o || PropertyBinding.parseTrackName(a)),
      (this.node = PropertyBinding.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
  static create(e, a, o) {
    return e && e.isAnimationObjectGroup
      ? new PropertyBinding.Composite(e, a, o)
      : new PropertyBinding(e, a, o)
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(_reservedRe, "")
  }
  static parseTrackName(e) {
    const a = _trackRe.exec(e)
    if (a === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e)
    const o = {
        nodeName: a[2],
        objectName: a[3],
        objectIndex: a[4],
        propertyName: a[5],
        propertyIndex: a[6],
      },
      c = o.nodeName && o.nodeName.lastIndexOf(".")
    if (c !== void 0 && c !== -1) {
      const d = o.nodeName.substring(c + 1)
      _supportedObjectNames.indexOf(d) !== -1 &&
        ((o.nodeName = o.nodeName.substring(0, c)), (o.objectName = d))
    }
    if (o.propertyName === null || o.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      )
    return o
  }
  static findNode(e, a) {
    if (
      a === void 0 ||
      a === "" ||
      a === "." ||
      a === -1 ||
      a === e.name ||
      a === e.uuid
    )
      return e
    if (e.skeleton) {
      const o = e.skeleton.getBoneByName(a)
      if (o !== void 0) return o
    }
    if (e.children) {
      const o = function (d) {
          for (let g = 0; g < d.length; g++) {
            const _ = d[g]
            if (_.name === a || _.uuid === a) return _
            const b = o(_.children)
            if (b) return b
          }
          return null
        },
        c = o(e.children)
      if (c) return c
    }
    return null
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, a) {
    e[a] = this.targetObject[this.propertyName]
  }
  _getValue_array(e, a) {
    const o = this.resolvedProperty
    for (let c = 0, d = o.length; c !== d; ++c) e[a++] = o[c]
  }
  _getValue_arrayElement(e, a) {
    e[a] = this.resolvedProperty[this.propertyIndex]
  }
  _getValue_toArray(e, a) {
    this.resolvedProperty.toArray(e, a)
  }
  _setValue_direct(e, a) {
    this.targetObject[this.propertyName] = e[a]
  }
  _setValue_direct_setNeedsUpdate(e, a) {
    ;(this.targetObject[this.propertyName] = e[a]),
      (this.targetObject.needsUpdate = !0)
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, a) {
    ;(this.targetObject[this.propertyName] = e[a]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_array(e, a) {
    const o = this.resolvedProperty
    for (let c = 0, d = o.length; c !== d; ++c) o[c] = e[a++]
  }
  _setValue_array_setNeedsUpdate(e, a) {
    const o = this.resolvedProperty
    for (let c = 0, d = o.length; c !== d; ++c) o[c] = e[a++]
    this.targetObject.needsUpdate = !0
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, a) {
    const o = this.resolvedProperty
    for (let c = 0, d = o.length; c !== d; ++c) o[c] = e[a++]
    this.targetObject.matrixWorldNeedsUpdate = !0
  }
  _setValue_arrayElement(e, a) {
    this.resolvedProperty[this.propertyIndex] = e[a]
  }
  _setValue_arrayElement_setNeedsUpdate(e, a) {
    ;(this.resolvedProperty[this.propertyIndex] = e[a]),
      (this.targetObject.needsUpdate = !0)
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, a) {
    ;(this.resolvedProperty[this.propertyIndex] = e[a]),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _setValue_fromArray(e, a) {
    this.resolvedProperty.fromArray(e, a)
  }
  _setValue_fromArray_setNeedsUpdate(e, a) {
    this.resolvedProperty.fromArray(e, a), (this.targetObject.needsUpdate = !0)
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, a) {
    this.resolvedProperty.fromArray(e, a),
      (this.targetObject.matrixWorldNeedsUpdate = !0)
  }
  _getValue_unbound(e, a) {
    this.bind(), this.getValue(e, a)
  }
  _setValue_unbound(e, a) {
    this.bind(), this.setValue(e, a)
  }
  bind() {
    let e = this.node
    const a = this.parsedPath,
      o = a.objectName,
      c = a.propertyName
    let d = a.propertyIndex
    if (
      (e ||
        ((e = PropertyBinding.findNode(this.rootNode, a.nodeName)),
        (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      )
      return
    }
    if (o) {
      let j = a.objectIndex
      switch (o) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            )
            return
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            )
            return
          }
          e = e.material.materials
          break
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            )
            return
          }
          e = e.skeleton.bones
          for (let $ = 0; $ < e.length; $++)
            if (e[$].name === j) {
              j = $
              break
            }
          break
        case "map":
          if ("map" in e) {
            e = e.map
            break
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            )
            return
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            )
            return
          }
          e = e.material.map
          break
        default:
          if (e[o] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            )
            return
          }
          e = e[o]
      }
      if (j !== void 0) {
        if (e[j] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          )
          return
        }
        e = e[j]
      }
    }
    const g = e[c]
    if (g === void 0) {
      const j = a.nodeName
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          j +
          "." +
          c +
          " but it wasn't found.",
        e
      )
      return
    }
    let _ = this.Versioning.None
    ;(this.targetObject = e),
      e.needsUpdate !== void 0
        ? (_ = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (_ = this.Versioning.MatrixWorldNeedsUpdate)
    let b = this.BindingType.Direct
    if (d !== void 0) {
      if (c === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          )
          return
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          )
          return
        }
        e.morphTargetDictionary[d] !== void 0 &&
          (d = e.morphTargetDictionary[d])
      }
      ;(b = this.BindingType.ArrayElement),
        (this.resolvedProperty = g),
        (this.propertyIndex = d)
    } else
      g.fromArray !== void 0 && g.toArray !== void 0
        ? ((b = this.BindingType.HasFromToArray), (this.resolvedProperty = g))
        : Array.isArray(g)
        ? ((b = this.BindingType.EntireArray), (this.resolvedProperty = g))
        : (this.propertyName = c)
    ;(this.getValue = this.GetterByBindingType[b]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[b][_])
  }
  unbind() {
    ;(this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound)
  }
}
PropertyBinding.Composite = Composite
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
}
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
}
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray,
]
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
]
class AnimationObjectGroup {
  constructor() {
    ;(this.isAnimationObjectGroup = !0),
      (this.uuid = generateUUID()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0)
    const e = {}
    this._indicesByUUID = e
    for (let o = 0, c = arguments.length; o !== c; ++o) e[arguments[o].uuid] = o
    ;(this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {})
    const a = this
    this.stats = {
      objects: {
        get total() {
          return a._objects.length
        },
        get inUse() {
          return this.total - a.nCachedObjects_
        },
      },
      get bindingsPerObject() {
        return a._bindings.length
      },
    }
  }
  add() {
    const e = this._objects,
      a = this._indicesByUUID,
      o = this._paths,
      c = this._parsedPaths,
      d = this._bindings,
      g = d.length
    let _,
      b = e.length,
      j = this.nCachedObjects_
    for (let $ = 0, _e = arguments.length; $ !== _e; ++$) {
      const tt = arguments[$],
        st = tt.uuid
      let at = a[st]
      if (at === void 0) {
        ;(at = b++), (a[st] = at), e.push(tt)
        for (let ot = 0, ut = g; ot !== ut; ++ot)
          d[ot].push(new PropertyBinding(tt, o[ot], c[ot]))
      } else if (at < j) {
        _ = e[at]
        const ot = --j,
          ut = e[ot]
        ;(a[ut.uuid] = at), (e[at] = ut), (a[st] = ot), (e[ot] = tt)
        for (let it = 0, ct = g; it !== ct; ++it) {
          const lt = d[it],
            ht = lt[ot]
          let dt = lt[at]
          ;(lt[at] = ht),
            dt === void 0 && (dt = new PropertyBinding(tt, o[it], c[it])),
            (lt[ot] = dt)
        }
      } else
        e[at] !== _ &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          )
    }
    this.nCachedObjects_ = j
  }
  remove() {
    const e = this._objects,
      a = this._indicesByUUID,
      o = this._bindings,
      c = o.length
    let d = this.nCachedObjects_
    for (let g = 0, _ = arguments.length; g !== _; ++g) {
      const b = arguments[g],
        j = b.uuid,
        $ = a[j]
      if ($ !== void 0 && $ >= d) {
        const _e = d++,
          tt = e[_e]
        ;(a[tt.uuid] = $), (e[$] = tt), (a[j] = _e), (e[_e] = b)
        for (let st = 0, at = c; st !== at; ++st) {
          const ot = o[st],
            ut = ot[_e],
            it = ot[$]
          ;(ot[$] = ut), (ot[_e] = it)
        }
      }
    }
    this.nCachedObjects_ = d
  }
  uncache() {
    const e = this._objects,
      a = this._indicesByUUID,
      o = this._bindings,
      c = o.length
    let d = this.nCachedObjects_,
      g = e.length
    for (let _ = 0, b = arguments.length; _ !== b; ++_) {
      const j = arguments[_],
        $ = j.uuid,
        _e = a[$]
      if (_e !== void 0)
        if ((delete a[$], _e < d)) {
          const tt = --d,
            st = e[tt],
            at = --g,
            ot = e[at]
          ;(a[st.uuid] = _e),
            (e[_e] = st),
            (a[ot.uuid] = tt),
            (e[tt] = ot),
            e.pop()
          for (let ut = 0, it = c; ut !== it; ++ut) {
            const ct = o[ut],
              lt = ct[tt],
              ht = ct[at]
            ;(ct[_e] = lt), (ct[tt] = ht), ct.pop()
          }
        } else {
          const tt = --g,
            st = e[tt]
          tt > 0 && (a[st.uuid] = _e), (e[_e] = st), e.pop()
          for (let at = 0, ot = c; at !== ot; ++at) {
            const ut = o[at]
            ;(ut[_e] = ut[tt]), ut.pop()
          }
        }
    }
    this.nCachedObjects_ = d
  }
  subscribe_(e, a) {
    const o = this._bindingsIndicesByPath
    let c = o[e]
    const d = this._bindings
    if (c !== void 0) return d[c]
    const g = this._paths,
      _ = this._parsedPaths,
      b = this._objects,
      j = b.length,
      $ = this.nCachedObjects_,
      _e = new Array(j)
    ;(c = d.length), (o[e] = c), g.push(e), _.push(a), d.push(_e)
    for (let tt = $, st = b.length; tt !== st; ++tt) {
      const at = b[tt]
      _e[tt] = new PropertyBinding(at, e, a)
    }
    return _e
  }
  unsubscribe_(e) {
    const a = this._bindingsIndicesByPath,
      o = a[e]
    if (o !== void 0) {
      const c = this._paths,
        d = this._parsedPaths,
        g = this._bindings,
        _ = g.length - 1,
        b = g[_],
        j = e[_]
      ;(a[j] = o),
        (g[o] = b),
        g.pop(),
        (d[o] = d[_]),
        d.pop(),
        (c[o] = c[_]),
        c.pop()
    }
  }
}
class AnimationAction {
  constructor(e, a, o = null, c = a.blendMode) {
    ;(this._mixer = e),
      (this._clip = a),
      (this._localRoot = o),
      (this.blendMode = c)
    const d = a.tracks,
      g = d.length,
      _ = new Array(g),
      b = { endingStart: ZeroCurvatureEnding, endingEnd: ZeroCurvatureEnding }
    for (let j = 0; j !== g; ++j) {
      const $ = d[j].createInterpolant(null)
      ;(_[j] = $), ($.settings = b)
    }
    ;(this._interpolantSettings = b),
      (this._interpolants = _),
      (this._propertyBindings = new Array(g)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = LoopRepeat),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0)
  }
  play() {
    return this._mixer._activateAction(this), this
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset()
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    )
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    )
  }
  isScheduled() {
    return this._mixer._isActiveAction(this)
  }
  startAt(e) {
    return (this._startTime = e), this
  }
  setLoop(e, a) {
    return (this.loop = e), (this.repetitions = a), this
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    )
  }
  getEffectiveWeight() {
    return this._effectiveWeight
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1)
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0)
  }
  crossFadeFrom(e, a, o) {
    if ((e.fadeOut(a), this.fadeIn(a), o)) {
      const c = this._clip.duration,
        d = e._clip.duration,
        g = d / c,
        _ = c / d
      e.warp(1, g, a), this.warp(_, 1, a)
    }
    return this
  }
  crossFadeTo(e, a, o) {
    return e.crossFadeFrom(this, a, o)
  }
  stopFading() {
    const e = this._weightInterpolant
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    )
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    )
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping()
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    )
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e)
  }
  warp(e, a, o) {
    const c = this._mixer,
      d = c.time,
      g = this.timeScale
    let _ = this._timeScaleInterpolant
    _ === null &&
      ((_ = c._lendControlInterpolant()), (this._timeScaleInterpolant = _))
    const b = _.parameterPositions,
      j = _.sampleValues
    return (b[0] = d), (b[1] = d + o), (j[0] = e / g), (j[1] = a / g), this
  }
  stopWarping() {
    const e = this._timeScaleInterpolant
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    )
  }
  getMixer() {
    return this._mixer
  }
  getClip() {
    return this._clip
  }
  getRoot() {
    return this._localRoot || this._mixer._root
  }
  _update(e, a, o, c) {
    if (!this.enabled) {
      this._updateWeight(e)
      return
    }
    const d = this._startTime
    if (d !== null) {
      const b = (e - d) * o
      b < 0 || o === 0 ? (a = 0) : ((this._startTime = null), (a = o * b))
    }
    a *= this._updateTimeScale(e)
    const g = this._updateTime(a),
      _ = this._updateWeight(e)
    if (_ > 0) {
      const b = this._interpolants,
        j = this._propertyBindings
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let $ = 0, _e = b.length; $ !== _e; ++$)
            b[$].evaluate(g), j[$].accumulateAdditive(_)
          break
        case NormalAnimationBlendMode:
        default:
          for (let $ = 0, _e = b.length; $ !== _e; ++$)
            b[$].evaluate(g), j[$].accumulate(c, _)
      }
    }
  }
  _updateWeight(e) {
    let a = 0
    if (this.enabled) {
      a = this.weight
      const o = this._weightInterpolant
      if (o !== null) {
        const c = o.evaluate(e)[0]
        ;(a *= c),
          e > o.parameterPositions[1] &&
            (this.stopFading(), c === 0 && (this.enabled = !1))
      }
    }
    return (this._effectiveWeight = a), a
  }
  _updateTimeScale(e) {
    let a = 0
    if (!this.paused) {
      a = this.timeScale
      const o = this._timeScaleInterpolant
      if (o !== null) {
        const c = o.evaluate(e)[0]
        ;(a *= c),
          e > o.parameterPositions[1] &&
            (this.stopWarping(),
            a === 0 ? (this.paused = !0) : (this.timeScale = a))
      }
    }
    return (this._effectiveTimeScale = a), a
  }
  _updateTime(e) {
    const a = this._clip.duration,
      o = this.loop
    let c = this.time + e,
      d = this._loopCount
    const g = o === LoopPingPong
    if (e === 0) return d === -1 ? c : g && (d & 1) === 1 ? a - c : c
    if (o === LoopOnce) {
      d === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1))
      e: {
        if (c >= a) c = a
        else if (c < 0) c = 0
        else {
          this.time = c
          break e
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = c),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          })
      }
    } else {
      if (
        (d === -1 &&
          (e >= 0
            ? ((d = 0), this._setEndings(!0, this.repetitions === 0, g))
            : this._setEndings(this.repetitions === 0, !0, g)),
        c >= a || c < 0)
      ) {
        const _ = Math.floor(c / a)
        ;(c -= a * _), (d += Math.abs(_))
        const b = this.repetitions - d
        if (b <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (c = e > 0 ? a : 0),
            (this.time = c),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            })
        else {
          if (b === 1) {
            const j = e < 0
            this._setEndings(j, !j, g)
          } else this._setEndings(!1, !1, g)
          ;(this._loopCount = d),
            (this.time = c),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: _,
            })
        }
      } else this.time = c
      if (g && (d & 1) === 1) return a - c
    }
    return c
  }
  _setEndings(e, a, o) {
    const c = this._interpolantSettings
    o
      ? ((c.endingStart = ZeroSlopeEnding), (c.endingEnd = ZeroSlopeEnding))
      : (e
          ? (c.endingStart = this.zeroSlopeAtStart
              ? ZeroSlopeEnding
              : ZeroCurvatureEnding)
          : (c.endingStart = WrapAroundEnding),
        a
          ? (c.endingEnd = this.zeroSlopeAtEnd
              ? ZeroSlopeEnding
              : ZeroCurvatureEnding)
          : (c.endingEnd = WrapAroundEnding))
  }
  _scheduleFading(e, a, o) {
    const c = this._mixer,
      d = c.time
    let g = this._weightInterpolant
    g === null &&
      ((g = c._lendControlInterpolant()), (this._weightInterpolant = g))
    const _ = g.parameterPositions,
      b = g.sampleValues
    return (_[0] = d), (b[0] = a), (_[1] = d + e), (b[1] = o), this
  }
}
const _controlInterpolantsResultBuffer = new Float32Array(1)
class AnimationMixer extends EventDispatcher {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1)
  }
  _bindAction(e, a) {
    const o = e._localRoot || this._root,
      c = e._clip.tracks,
      d = c.length,
      g = e._propertyBindings,
      _ = e._interpolants,
      b = o.uuid,
      j = this._bindingsByRootAndName
    let $ = j[b]
    $ === void 0 && (($ = {}), (j[b] = $))
    for (let _e = 0; _e !== d; ++_e) {
      const tt = c[_e],
        st = tt.name
      let at = $[st]
      if (at !== void 0) ++at.referenceCount, (g[_e] = at)
      else {
        if (((at = g[_e]), at !== void 0)) {
          at._cacheIndex === null &&
            (++at.referenceCount, this._addInactiveBinding(at, b, st))
          continue
        }
        const ot = a && a._propertyBindings[_e].binding.parsedPath
        ;(at = new PropertyMixer(
          PropertyBinding.create(o, st, ot),
          tt.ValueTypeName,
          tt.getValueSize()
        )),
          ++at.referenceCount,
          this._addInactiveBinding(at, b, st),
          (g[_e] = at)
      }
      _[_e].resultBuffer = at.buffer
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const o = (e._localRoot || this._root).uuid,
          c = e._clip.uuid,
          d = this._actionsByClip[c]
        this._bindAction(e, d && d.knownActions[0]),
          this._addInactiveAction(e, c, o)
      }
      const a = e._propertyBindings
      for (let o = 0, c = a.length; o !== c; ++o) {
        const d = a[o]
        d.useCount++ === 0 && (this._lendBinding(d), d.saveOriginalState())
      }
      this._lendAction(e)
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const a = e._propertyBindings
      for (let o = 0, c = a.length; o !== c; ++o) {
        const d = a[o]
        --d.useCount === 0 &&
          (d.restoreOriginalState(), this._takeBackBinding(d))
      }
      this._takeBackAction(e)
    }
  }
  _initMemoryManager() {
    ;(this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0)
    const e = this
    this.stats = {
      actions: {
        get total() {
          return e._actions.length
        },
        get inUse() {
          return e._nActiveActions
        },
      },
      bindings: {
        get total() {
          return e._bindings.length
        },
        get inUse() {
          return e._nActiveBindings
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length
        },
        get inUse() {
          return e._nActiveControlInterpolants
        },
      },
    }
  }
  _isActiveAction(e) {
    const a = e._cacheIndex
    return a !== null && a < this._nActiveActions
  }
  _addInactiveAction(e, a, o) {
    const c = this._actions,
      d = this._actionsByClip
    let g = d[a]
    if (g === void 0)
      (g = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (d[a] = g)
    else {
      const _ = g.knownActions
      ;(e._byClipCacheIndex = _.length), _.push(e)
    }
    ;(e._cacheIndex = c.length), c.push(e), (g.actionByRoot[o] = e)
  }
  _removeInactiveAction(e) {
    const a = this._actions,
      o = a[a.length - 1],
      c = e._cacheIndex
    ;(o._cacheIndex = c), (a[c] = o), a.pop(), (e._cacheIndex = null)
    const d = e._clip.uuid,
      g = this._actionsByClip,
      _ = g[d],
      b = _.knownActions,
      j = b[b.length - 1],
      $ = e._byClipCacheIndex
    ;(j._byClipCacheIndex = $),
      (b[$] = j),
      b.pop(),
      (e._byClipCacheIndex = null)
    const _e = _.actionByRoot,
      tt = (e._localRoot || this._root).uuid
    delete _e[tt],
      b.length === 0 && delete g[d],
      this._removeInactiveBindingsForAction(e)
  }
  _removeInactiveBindingsForAction(e) {
    const a = e._propertyBindings
    for (let o = 0, c = a.length; o !== c; ++o) {
      const d = a[o]
      --d.referenceCount === 0 && this._removeInactiveBinding(d)
    }
  }
  _lendAction(e) {
    const a = this._actions,
      o = e._cacheIndex,
      c = this._nActiveActions++,
      d = a[c]
    ;(e._cacheIndex = c), (a[c] = e), (d._cacheIndex = o), (a[o] = d)
  }
  _takeBackAction(e) {
    const a = this._actions,
      o = e._cacheIndex,
      c = --this._nActiveActions,
      d = a[c]
    ;(e._cacheIndex = c), (a[c] = e), (d._cacheIndex = o), (a[o] = d)
  }
  _addInactiveBinding(e, a, o) {
    const c = this._bindingsByRootAndName,
      d = this._bindings
    let g = c[a]
    g === void 0 && ((g = {}), (c[a] = g)),
      (g[o] = e),
      (e._cacheIndex = d.length),
      d.push(e)
  }
  _removeInactiveBinding(e) {
    const a = this._bindings,
      o = e.binding,
      c = o.rootNode.uuid,
      d = o.path,
      g = this._bindingsByRootAndName,
      _ = g[c],
      b = a[a.length - 1],
      j = e._cacheIndex
    ;(b._cacheIndex = j),
      (a[j] = b),
      a.pop(),
      delete _[d],
      Object.keys(_).length === 0 && delete g[c]
  }
  _lendBinding(e) {
    const a = this._bindings,
      o = e._cacheIndex,
      c = this._nActiveBindings++,
      d = a[c]
    ;(e._cacheIndex = c), (a[c] = e), (d._cacheIndex = o), (a[o] = d)
  }
  _takeBackBinding(e) {
    const a = this._bindings,
      o = e._cacheIndex,
      c = --this._nActiveBindings,
      d = a[c]
    ;(e._cacheIndex = c), (a[c] = e), (d._cacheIndex = o), (a[o] = d)
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      a = this._nActiveControlInterpolants++
    let o = e[a]
    return (
      o === void 0 &&
        ((o = new LinearInterpolant(
          new Float32Array(2),
          new Float32Array(2),
          1,
          _controlInterpolantsResultBuffer
        )),
        (o.__cacheIndex = a),
        (e[a] = o)),
      o
    )
  }
  _takeBackControlInterpolant(e) {
    const a = this._controlInterpolants,
      o = e.__cacheIndex,
      c = --this._nActiveControlInterpolants,
      d = a[c]
    ;(e.__cacheIndex = c), (a[c] = e), (d.__cacheIndex = o), (a[o] = d)
  }
  clipAction(e, a, o) {
    const c = a || this._root,
      d = c.uuid
    let g = typeof e == "string" ? AnimationClip.findByName(c, e) : e
    const _ = g !== null ? g.uuid : e,
      b = this._actionsByClip[_]
    let j = null
    if (
      (o === void 0 &&
        (g !== null ? (o = g.blendMode) : (o = NormalAnimationBlendMode)),
      b !== void 0)
    ) {
      const _e = b.actionByRoot[d]
      if (_e !== void 0 && _e.blendMode === o) return _e
      ;(j = b.knownActions[0]), g === null && (g = j._clip)
    }
    if (g === null) return null
    const $ = new AnimationAction(this, g, a, o)
    return this._bindAction($, j), this._addInactiveAction($, _, d), $
  }
  existingAction(e, a) {
    const o = a || this._root,
      c = o.uuid,
      d = typeof e == "string" ? AnimationClip.findByName(o, e) : e,
      g = d ? d.uuid : e,
      _ = this._actionsByClip[g]
    return (_ !== void 0 && _.actionByRoot[c]) || null
  }
  stopAllAction() {
    const e = this._actions,
      a = this._nActiveActions
    for (let o = a - 1; o >= 0; --o) e[o].stop()
    return this
  }
  update(e) {
    e *= this.timeScale
    const a = this._actions,
      o = this._nActiveActions,
      c = (this.time += e),
      d = Math.sign(e),
      g = (this._accuIndex ^= 1)
    for (let j = 0; j !== o; ++j) a[j]._update(c, e, d, g)
    const _ = this._bindings,
      b = this._nActiveBindings
    for (let j = 0; j !== b; ++j) _[j].apply(g)
    return this
  }
  setTime(e) {
    this.time = 0
    for (let a = 0; a < this._actions.length; a++) this._actions[a].time = 0
    return this.update(e)
  }
  getRoot() {
    return this._root
  }
  uncacheClip(e) {
    const a = this._actions,
      o = e.uuid,
      c = this._actionsByClip,
      d = c[o]
    if (d !== void 0) {
      const g = d.knownActions
      for (let _ = 0, b = g.length; _ !== b; ++_) {
        const j = g[_]
        this._deactivateAction(j)
        const $ = j._cacheIndex,
          _e = a[a.length - 1]
        ;(j._cacheIndex = null),
          (j._byClipCacheIndex = null),
          (_e._cacheIndex = $),
          (a[$] = _e),
          a.pop(),
          this._removeInactiveBindingsForAction(j)
      }
      delete c[o]
    }
  }
  uncacheRoot(e) {
    const a = e.uuid,
      o = this._actionsByClip
    for (const g in o) {
      const _ = o[g].actionByRoot,
        b = _[a]
      b !== void 0 && (this._deactivateAction(b), this._removeInactiveAction(b))
    }
    const c = this._bindingsByRootAndName,
      d = c[a]
    if (d !== void 0)
      for (const g in d) {
        const _ = d[g]
        _.restoreOriginalState(), this._removeInactiveBinding(_)
      }
  }
  uncacheAction(e, a) {
    const o = this.existingAction(e, a)
    o !== null && (this._deactivateAction(o), this._removeInactiveAction(o))
  }
}
class Uniform {
  constructor(e) {
    this.value = e
  }
  clone() {
    return new Uniform(
      this.value.clone === void 0 ? this.value : this.value.clone()
    )
  }
}
let _id = 0
class UniformsGroup extends EventDispatcher {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: _id++ }),
      (this.name = ""),
      (this.usage = StaticDrawUsage),
      (this.uniforms = [])
  }
  add(e) {
    return this.uniforms.push(e), this
  }
  remove(e) {
    const a = this.uniforms.indexOf(e)
    return a !== -1 && this.uniforms.splice(a, 1), this
  }
  setName(e) {
    return (this.name = e), this
  }
  setUsage(e) {
    return (this.usage = e), this
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this
  }
  copy(e) {
    ;(this.name = e.name), (this.usage = e.usage)
    const a = e.uniforms
    this.uniforms.length = 0
    for (let o = 0, c = a.length; o < c; o++) this.uniforms.push(a[o].clone())
    return this
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(e, a, o = 1) {
    super(e, a),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = o)
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
  }
  clone(e) {
    const a = super.clone(e)
    return (a.meshPerAttribute = this.meshPerAttribute), a
  }
  toJSON(e) {
    const a = super.toJSON(e)
    return (
      (a.isInstancedInterleavedBuffer = !0),
      (a.meshPerAttribute = this.meshPerAttribute),
      a
    )
  }
}
class GLBufferAttribute {
  constructor(e, a, o, c, d) {
    ;(this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = a),
      (this.itemSize = o),
      (this.elementSize = c),
      (this.count = d),
      (this.version = 0)
  }
  set needsUpdate(e) {
    e === !0 && this.version++
  }
  setBuffer(e) {
    return (this.buffer = e), this
  }
  setType(e, a) {
    return (this.type = e), (this.elementSize = a), this
  }
  setItemSize(e) {
    return (this.itemSize = e), this
  }
  setCount(e) {
    return (this.count = e), this
  }
}
class Raycaster {
  constructor(e, a, o = 0, c = 1 / 0) {
    ;(this.ray = new Ray(e, a)),
      (this.near = o),
      (this.far = c),
      (this.camera = null),
      (this.layers = new Layers()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      })
  }
  set(e, a) {
    this.ray.set(e, a)
  }
  setFromCamera(e, a) {
    a.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(a.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(a)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = a))
      : a.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (a.near + a.far) / (a.near - a.far))
          .unproject(a),
        this.ray.direction.set(0, 0, -1).transformDirection(a.matrixWorld),
        (this.camera = a))
      : console.error("THREE.Raycaster: Unsupported camera type: " + a.type)
  }
  intersectObject(e, a = !0, o = []) {
    return intersectObject(e, this, o, a), o.sort(ascSort), o
  }
  intersectObjects(e, a = !0, o = []) {
    for (let c = 0, d = e.length; c < d; c++) intersectObject(e[c], this, o, a)
    return o.sort(ascSort), o
  }
}
function ascSort(s, e) {
  return s.distance - e.distance
}
function intersectObject(s, e, a, o) {
  if ((s.layers.test(e.layers) && s.raycast(e, a), o === !0)) {
    const c = s.children
    for (let d = 0, g = c.length; d < g; d++) intersectObject(c[d], e, a, !0)
  }
}
class Spherical {
  constructor(e = 1, a = 0, o = 0) {
    return (this.radius = e), (this.phi = a), (this.theta = o), this
  }
  set(e, a, o) {
    return (this.radius = e), (this.phi = a), (this.theta = o), this
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    )
  }
  makeSafe() {
    return (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z)
  }
  setFromCartesianCoords(e, a, o) {
    return (
      (this.radius = Math.sqrt(e * e + a * a + o * o)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, o)),
          (this.phi = Math.acos(clamp$2(a / this.radius, -1, 1)))),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class Cylindrical {
  constructor(e = 1, a = 0, o = 0) {
    return (this.radius = e), (this.theta = a), (this.y = o), this
  }
  set(e, a, o) {
    return (this.radius = e), (this.theta = a), (this.y = o), this
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    )
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z)
  }
  setFromCartesianCoords(e, a, o) {
    return (
      (this.radius = Math.sqrt(e * e + o * o)),
      (this.theta = Math.atan2(e, o)),
      (this.y = a),
      this
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const _vector$4 = new Vector2()
class Box2 {
  constructor(e = new Vector2(1 / 0, 1 / 0), a = new Vector2(-1 / 0, -1 / 0)) {
    ;(this.isBox2 = !0), (this.min = e), (this.max = a)
  }
  set(e, a) {
    return this.min.copy(e), this.max.copy(a), this
  }
  setFromPoints(e) {
    this.makeEmpty()
    for (let a = 0, o = e.length; a < o; a++) this.expandByPoint(e[a])
    return this
  }
  setFromCenterAndSize(e, a) {
    const o = _vector$4.copy(a).multiplyScalar(0.5)
    return this.min.copy(e).sub(o), this.max.copy(e).add(o), this
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    )
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    )
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    )
  }
  getParameter(e, a) {
    return a.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    )
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    )
  }
  clampPoint(e, a) {
    return a.copy(e).clamp(this.min, this.max)
  }
  distanceToPoint(e) {
    return this.clampPoint(e, _vector$4).distanceTo(e)
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    )
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max)
  }
}
const _startP = new Vector3(),
  _startEnd = new Vector3()
class Line3 {
  constructor(e = new Vector3(), a = new Vector3()) {
    ;(this.start = e), (this.end = a)
  }
  set(e, a) {
    return this.start.copy(e), this.end.copy(a), this
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5)
  }
  delta(e) {
    return e.subVectors(this.end, this.start)
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end)
  }
  distance() {
    return this.start.distanceTo(this.end)
  }
  at(e, a) {
    return this.delta(a).multiplyScalar(e).add(this.start)
  }
  closestPointToPointParameter(e, a) {
    _startP.subVectors(e, this.start),
      _startEnd.subVectors(this.end, this.start)
    const o = _startEnd.dot(_startEnd)
    let d = _startEnd.dot(_startP) / o
    return a && (d = clamp$2(d, 0, 1)), d
  }
  closestPointToPoint(e, a, o) {
    const c = this.closestPointToPointParameter(e, a)
    return this.delta(o).multiplyScalar(c).add(this.start)
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const _vector$3 = new Vector3()
class SpotLightHelper extends Object3D {
  constructor(e, a) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = a),
      (this.type = "SpotLightHelper")
    const o = new BufferGeometry(),
      c = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ]
    for (let g = 0, _ = 1, b = 32; g < b; g++, _++) {
      const j = (g / b) * Math.PI * 2,
        $ = (_ / b) * Math.PI * 2
      c.push(Math.cos(j), Math.sin(j), 1, Math.cos($), Math.sin($), 1)
    }
    o.setAttribute("position", new Float32BufferAttribute(c, 3))
    const d = new LineBasicMaterial({ fog: !1, toneMapped: !1 })
    ;(this.cone = new LineSegments(o, d)), this.add(this.cone), this.update()
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose()
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1)
    const e = this.light.distance ? this.light.distance : 1e3,
      a = e * Math.tan(this.light.angle)
    this.cone.scale.set(a, a, e),
      _vector$3.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(_vector$3),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color)
  }
}
const _vector$2 = new Vector3(),
  _boneMatrix = new Matrix4(),
  _matrixWorldInv = new Matrix4()
class SkeletonHelper extends LineSegments {
  constructor(e) {
    const a = getBoneList(e),
      o = new BufferGeometry(),
      c = [],
      d = [],
      g = new Color(0, 0, 1),
      _ = new Color(0, 1, 0)
    for (let j = 0; j < a.length; j++) {
      const $ = a[j]
      $.parent &&
        $.parent.isBone &&
        (c.push(0, 0, 0),
        c.push(0, 0, 0),
        d.push(g.r, g.g, g.b),
        d.push(_.r, _.g, _.b))
    }
    o.setAttribute("position", new Float32BufferAttribute(c, 3)),
      o.setAttribute("color", new Float32BufferAttribute(d, 3))
    const b = new LineBasicMaterial({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    })
    super(o, b),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = a),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1)
  }
  updateMatrixWorld(e) {
    const a = this.bones,
      o = this.geometry,
      c = o.getAttribute("position")
    _matrixWorldInv.copy(this.root.matrixWorld).invert()
    for (let d = 0, g = 0; d < a.length; d++) {
      const _ = a[d]
      _.parent &&
        _.parent.isBone &&
        (_boneMatrix.multiplyMatrices(_matrixWorldInv, _.matrixWorld),
        _vector$2.setFromMatrixPosition(_boneMatrix),
        c.setXYZ(g, _vector$2.x, _vector$2.y, _vector$2.z),
        _boneMatrix.multiplyMatrices(_matrixWorldInv, _.parent.matrixWorld),
        _vector$2.setFromMatrixPosition(_boneMatrix),
        c.setXYZ(g + 1, _vector$2.x, _vector$2.y, _vector$2.z),
        (g += 2))
    }
    ;(o.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e)
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
function getBoneList(s) {
  const e = []
  s.isBone === !0 && e.push(s)
  for (let a = 0; a < s.children.length; a++)
    e.push.apply(e, getBoneList(s.children[a]))
  return e
}
class PointLightHelper extends Mesh {
  constructor(e, a, o) {
    const c = new SphereGeometry(a, 4, 2),
      d = new MeshBasicMaterial({ wireframe: !0, fog: !1, toneMapped: !1 })
    super(c, d),
      (this.light = e),
      (this.color = o),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update()
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color)
  }
}
const _vector$1 = new Vector3(),
  _color1 = new Color(),
  _color2 = new Color()
class HemisphereLightHelper extends Object3D {
  constructor(e, a, o) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = o),
      (this.type = "HemisphereLightHelper")
    const c = new OctahedronGeometry(a)
    c.rotateY(Math.PI * 0.5),
      (this.material = new MeshBasicMaterial({
        wireframe: !0,
        fog: !1,
        toneMapped: !1,
      })),
      this.color === void 0 && (this.material.vertexColors = !0)
    const d = c.getAttribute("position"),
      g = new Float32Array(d.count * 3)
    c.setAttribute("color", new BufferAttribute(g, 3)),
      this.add(new Mesh(c, this.material)),
      this.update()
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose()
  }
  update() {
    const e = this.children[0]
    if (this.color !== void 0) this.material.color.set(this.color)
    else {
      const a = e.geometry.getAttribute("color")
      _color1.copy(this.light.color), _color2.copy(this.light.groundColor)
      for (let o = 0, c = a.count; o < c; o++) {
        const d = o < c / 2 ? _color1 : _color2
        a.setXYZ(o, d.r, d.g, d.b)
      }
      a.needsUpdate = !0
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate())
  }
}
class GridHelper extends LineSegments {
  constructor(e = 10, a = 10, o = 4473924, c = 8947848) {
    ;(o = new Color(o)), (c = new Color(c))
    const d = a / 2,
      g = e / a,
      _ = e / 2,
      b = [],
      j = []
    for (let tt = 0, st = 0, at = -_; tt <= a; tt++, at += g) {
      b.push(-_, 0, at, _, 0, at), b.push(at, 0, -_, at, 0, _)
      const ot = tt === d ? o : c
      ot.toArray(j, st),
        (st += 3),
        ot.toArray(j, st),
        (st += 3),
        ot.toArray(j, st),
        (st += 3),
        ot.toArray(j, st),
        (st += 3)
    }
    const $ = new BufferGeometry()
    $.setAttribute("position", new Float32BufferAttribute(b, 3)),
      $.setAttribute("color", new Float32BufferAttribute(j, 3))
    const _e = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 })
    super($, _e), (this.type = "GridHelper")
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class PolarGridHelper extends LineSegments {
  constructor(e = 10, a = 16, o = 8, c = 64, d = 4473924, g = 8947848) {
    ;(d = new Color(d)), (g = new Color(g))
    const _ = [],
      b = []
    if (a > 1)
      for (let _e = 0; _e < a; _e++) {
        const tt = (_e / a) * (Math.PI * 2),
          st = Math.sin(tt) * e,
          at = Math.cos(tt) * e
        _.push(0, 0, 0), _.push(st, 0, at)
        const ot = _e & 1 ? d : g
        b.push(ot.r, ot.g, ot.b), b.push(ot.r, ot.g, ot.b)
      }
    for (let _e = 0; _e < o; _e++) {
      const tt = _e & 1 ? d : g,
        st = e - (e / o) * _e
      for (let at = 0; at < c; at++) {
        let ot = (at / c) * (Math.PI * 2),
          ut = Math.sin(ot) * st,
          it = Math.cos(ot) * st
        _.push(ut, 0, it),
          b.push(tt.r, tt.g, tt.b),
          (ot = ((at + 1) / c) * (Math.PI * 2)),
          (ut = Math.sin(ot) * st),
          (it = Math.cos(ot) * st),
          _.push(ut, 0, it),
          b.push(tt.r, tt.g, tt.b)
      }
    }
    const j = new BufferGeometry()
    j.setAttribute("position", new Float32BufferAttribute(_, 3)),
      j.setAttribute("color", new Float32BufferAttribute(b, 3))
    const $ = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 })
    super(j, $), (this.type = "PolarGridHelper")
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
const _v1 = new Vector3(),
  _v2 = new Vector3(),
  _v3 = new Vector3()
class DirectionalLightHelper extends Object3D {
  constructor(e, a, o) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = o),
      (this.type = "DirectionalLightHelper"),
      a === void 0 && (a = 1)
    let c = new BufferGeometry()
    c.setAttribute(
      "position",
      new Float32BufferAttribute(
        [-a, a, 0, a, a, 0, a, -a, 0, -a, -a, 0, -a, a, 0],
        3
      )
    )
    const d = new LineBasicMaterial({ fog: !1, toneMapped: !1 })
    ;(this.lightPlane = new Line(c, d)),
      this.add(this.lightPlane),
      (c = new BufferGeometry()),
      c.setAttribute(
        "position",
        new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3)
      ),
      (this.targetLine = new Line(c, d)),
      this.add(this.targetLine),
      this.update()
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose()
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      _v1.setFromMatrixPosition(this.light.matrixWorld),
      _v2.setFromMatrixPosition(this.light.target.matrixWorld),
      _v3.subVectors(_v2, _v1),
      this.lightPlane.lookAt(_v2),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(_v2),
      (this.targetLine.scale.z = _v3.length())
  }
}
const _vector = new Vector3(),
  _camera = new Camera()
class CameraHelper extends LineSegments {
  constructor(e) {
    const a = new BufferGeometry(),
      o = new LineBasicMaterial({
        color: 16777215,
        vertexColors: !0,
        toneMapped: !1,
      }),
      c = [],
      d = [],
      g = {}
    _("n1", "n2"),
      _("n2", "n4"),
      _("n4", "n3"),
      _("n3", "n1"),
      _("f1", "f2"),
      _("f2", "f4"),
      _("f4", "f3"),
      _("f3", "f1"),
      _("n1", "f1"),
      _("n2", "f2"),
      _("n3", "f3"),
      _("n4", "f4"),
      _("p", "n1"),
      _("p", "n2"),
      _("p", "n3"),
      _("p", "n4"),
      _("u1", "u2"),
      _("u2", "u3"),
      _("u3", "u1"),
      _("c", "t"),
      _("p", "c"),
      _("cn1", "cn2"),
      _("cn3", "cn4"),
      _("cf1", "cf2"),
      _("cf3", "cf4")
    function _(at, ot) {
      b(at), b(ot)
    }
    function b(at) {
      c.push(0, 0, 0),
        d.push(0, 0, 0),
        g[at] === void 0 && (g[at] = []),
        g[at].push(c.length / 3 - 1)
    }
    a.setAttribute("position", new Float32BufferAttribute(c, 3)),
      a.setAttribute("color", new Float32BufferAttribute(d, 3)),
      super(a, o),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = g),
      this.update()
    const j = new Color(16755200),
      $ = new Color(16711680),
      _e = new Color(43775),
      tt = new Color(16777215),
      st = new Color(3355443)
    this.setColors(j, $, _e, tt, st)
  }
  setColors(e, a, o, c, d) {
    const _ = this.geometry.getAttribute("color")
    _.setXYZ(0, e.r, e.g, e.b),
      _.setXYZ(1, e.r, e.g, e.b),
      _.setXYZ(2, e.r, e.g, e.b),
      _.setXYZ(3, e.r, e.g, e.b),
      _.setXYZ(4, e.r, e.g, e.b),
      _.setXYZ(5, e.r, e.g, e.b),
      _.setXYZ(6, e.r, e.g, e.b),
      _.setXYZ(7, e.r, e.g, e.b),
      _.setXYZ(8, e.r, e.g, e.b),
      _.setXYZ(9, e.r, e.g, e.b),
      _.setXYZ(10, e.r, e.g, e.b),
      _.setXYZ(11, e.r, e.g, e.b),
      _.setXYZ(12, e.r, e.g, e.b),
      _.setXYZ(13, e.r, e.g, e.b),
      _.setXYZ(14, e.r, e.g, e.b),
      _.setXYZ(15, e.r, e.g, e.b),
      _.setXYZ(16, e.r, e.g, e.b),
      _.setXYZ(17, e.r, e.g, e.b),
      _.setXYZ(18, e.r, e.g, e.b),
      _.setXYZ(19, e.r, e.g, e.b),
      _.setXYZ(20, e.r, e.g, e.b),
      _.setXYZ(21, e.r, e.g, e.b),
      _.setXYZ(22, e.r, e.g, e.b),
      _.setXYZ(23, e.r, e.g, e.b),
      _.setXYZ(24, a.r, a.g, a.b),
      _.setXYZ(25, a.r, a.g, a.b),
      _.setXYZ(26, a.r, a.g, a.b),
      _.setXYZ(27, a.r, a.g, a.b),
      _.setXYZ(28, a.r, a.g, a.b),
      _.setXYZ(29, a.r, a.g, a.b),
      _.setXYZ(30, a.r, a.g, a.b),
      _.setXYZ(31, a.r, a.g, a.b),
      _.setXYZ(32, o.r, o.g, o.b),
      _.setXYZ(33, o.r, o.g, o.b),
      _.setXYZ(34, o.r, o.g, o.b),
      _.setXYZ(35, o.r, o.g, o.b),
      _.setXYZ(36, o.r, o.g, o.b),
      _.setXYZ(37, o.r, o.g, o.b),
      _.setXYZ(38, c.r, c.g, c.b),
      _.setXYZ(39, c.r, c.g, c.b),
      _.setXYZ(40, d.r, d.g, d.b),
      _.setXYZ(41, d.r, d.g, d.b),
      _.setXYZ(42, d.r, d.g, d.b),
      _.setXYZ(43, d.r, d.g, d.b),
      _.setXYZ(44, d.r, d.g, d.b),
      _.setXYZ(45, d.r, d.g, d.b),
      _.setXYZ(46, d.r, d.g, d.b),
      _.setXYZ(47, d.r, d.g, d.b),
      _.setXYZ(48, d.r, d.g, d.b),
      _.setXYZ(49, d.r, d.g, d.b),
      (_.needsUpdate = !0)
  }
  update() {
    const e = this.geometry,
      a = this.pointMap,
      o = 1,
      c = 1
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      setPoint("c", a, e, _camera, 0, 0, -1),
      setPoint("t", a, e, _camera, 0, 0, 1),
      setPoint("n1", a, e, _camera, -o, -c, -1),
      setPoint("n2", a, e, _camera, o, -c, -1),
      setPoint("n3", a, e, _camera, -o, c, -1),
      setPoint("n4", a, e, _camera, o, c, -1),
      setPoint("f1", a, e, _camera, -o, -c, 1),
      setPoint("f2", a, e, _camera, o, -c, 1),
      setPoint("f3", a, e, _camera, -o, c, 1),
      setPoint("f4", a, e, _camera, o, c, 1),
      setPoint("u1", a, e, _camera, o * 0.7, c * 1.1, -1),
      setPoint("u2", a, e, _camera, -o * 0.7, c * 1.1, -1),
      setPoint("u3", a, e, _camera, 0, c * 2, -1),
      setPoint("cf1", a, e, _camera, -o, 0, 1),
      setPoint("cf2", a, e, _camera, o, 0, 1),
      setPoint("cf3", a, e, _camera, 0, -c, 1),
      setPoint("cf4", a, e, _camera, 0, c, 1),
      setPoint("cn1", a, e, _camera, -o, 0, -1),
      setPoint("cn2", a, e, _camera, o, 0, -1),
      setPoint("cn3", a, e, _camera, 0, -c, -1),
      setPoint("cn4", a, e, _camera, 0, c, -1),
      (e.getAttribute("position").needsUpdate = !0)
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
function setPoint(s, e, a, o, c, d, g) {
  _vector.set(c, d, g).unproject(o)
  const _ = e[s]
  if (_ !== void 0) {
    const b = a.getAttribute("position")
    for (let j = 0, $ = _.length; j < $; j++)
      b.setXYZ(_[j], _vector.x, _vector.y, _vector.z)
  }
}
const _box = new Box3()
class BoxHelper extends LineSegments {
  constructor(e, a = 16776960) {
    const o = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      c = new Float32Array(8 * 3),
      d = new BufferGeometry()
    d.setIndex(new BufferAttribute(o, 1)),
      d.setAttribute("position", new BufferAttribute(c, 3)),
      super(d, new LineBasicMaterial({ color: a, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update()
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && _box.setFromObject(this.object),
      _box.isEmpty())
    )
      return
    const a = _box.min,
      o = _box.max,
      c = this.geometry.attributes.position,
      d = c.array
    ;(d[0] = o.x),
      (d[1] = o.y),
      (d[2] = o.z),
      (d[3] = a.x),
      (d[4] = o.y),
      (d[5] = o.z),
      (d[6] = a.x),
      (d[7] = a.y),
      (d[8] = o.z),
      (d[9] = o.x),
      (d[10] = a.y),
      (d[11] = o.z),
      (d[12] = o.x),
      (d[13] = o.y),
      (d[14] = a.z),
      (d[15] = a.x),
      (d[16] = o.y),
      (d[17] = a.z),
      (d[18] = a.x),
      (d[19] = a.y),
      (d[20] = a.z),
      (d[21] = o.x),
      (d[22] = a.y),
      (d[23] = a.z),
      (c.needsUpdate = !0),
      this.geometry.computeBoundingSphere()
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this
  }
  copy(e, a) {
    return super.copy(e, a), (this.object = e.object), this
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class Box3Helper extends LineSegments {
  constructor(e, a = 16776960) {
    const o = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      c = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      d = new BufferGeometry()
    d.setIndex(new BufferAttribute(o, 1)),
      d.setAttribute("position", new Float32BufferAttribute(c, 3)),
      super(d, new LineBasicMaterial({ color: a, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere()
  }
  updateMatrixWorld(e) {
    const a = this.box
    a.isEmpty() ||
      (a.getCenter(this.position),
      a.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e))
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class PlaneHelper extends Line {
  constructor(e, a = 1, o = 16776960) {
    const c = o,
      d = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      g = new BufferGeometry()
    g.setAttribute("position", new Float32BufferAttribute(d, 3)),
      g.computeBoundingSphere(),
      super(g, new LineBasicMaterial({ color: c, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = a)
    const _ = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      b = new BufferGeometry()
    b.setAttribute("position", new Float32BufferAttribute(_, 3)),
      b.computeBoundingSphere(),
      this.add(
        new Mesh(
          b,
          new MeshBasicMaterial({
            color: c,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      )
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e)
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose()
  }
}
const _axis = new Vector3()
let _lineGeometry, _coneGeometry
class ArrowHelper extends Object3D {
  constructor(
    e = new Vector3(0, 0, 1),
    a = new Vector3(0, 0, 0),
    o = 1,
    c = 16776960,
    d = o * 0.2,
    g = d * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      _lineGeometry === void 0 &&
        ((_lineGeometry = new BufferGeometry()),
        _lineGeometry.setAttribute(
          "position",
          new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3)
        ),
        (_coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1)),
        _coneGeometry.translate(0, -0.5, 0)),
      this.position.copy(a),
      (this.line = new Line(
        _lineGeometry,
        new LineBasicMaterial({ color: c, toneMapped: !1 })
      )),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Mesh(
        _coneGeometry,
        new MeshBasicMaterial({ color: c, toneMapped: !1 })
      )),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(o, d, g)
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1)
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0)
    else {
      _axis.set(e.z, 0, -e.x).normalize()
      const a = Math.acos(e.y)
      this.quaternion.setFromAxisAngle(_axis, a)
    }
  }
  setLength(e, a = e * 0.2, o = a * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - a), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(o, a, o),
      (this.cone.position.y = e),
      this.cone.updateMatrix()
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e)
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    )
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose()
  }
}
class AxesHelper extends LineSegments {
  constructor(e = 1) {
    const a = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      o = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      c = new BufferGeometry()
    c.setAttribute("position", new Float32BufferAttribute(a, 3)),
      c.setAttribute("color", new Float32BufferAttribute(o, 3))
    const d = new LineBasicMaterial({ vertexColors: !0, toneMapped: !1 })
    super(c, d), (this.type = "AxesHelper")
  }
  setColors(e, a, o) {
    const c = new Color(),
      d = this.geometry.attributes.color.array
    return (
      c.set(e),
      c.toArray(d, 0),
      c.toArray(d, 3),
      c.set(a),
      c.toArray(d, 6),
      c.toArray(d, 9),
      c.set(o),
      c.toArray(d, 12),
      c.toArray(d, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    )
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose()
  }
}
class ShapePath {
  constructor() {
    ;(this.type = "ShapePath"),
      (this.color = new Color()),
      (this.subPaths = []),
      (this.currentPath = null)
  }
  moveTo(e, a) {
    return (
      (this.currentPath = new Path()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, a),
      this
    )
  }
  lineTo(e, a) {
    return this.currentPath.lineTo(e, a), this
  }
  quadraticCurveTo(e, a, o, c) {
    return this.currentPath.quadraticCurveTo(e, a, o, c), this
  }
  bezierCurveTo(e, a, o, c, d, g) {
    return this.currentPath.bezierCurveTo(e, a, o, c, d, g), this
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this
  }
  toShapes(e) {
    function a(it) {
      const ct = []
      for (let lt = 0, ht = it.length; lt < ht; lt++) {
        const dt = it[lt],
          pt = new Shape()
        ;(pt.curves = dt.curves), ct.push(pt)
      }
      return ct
    }
    function o(it, ct) {
      const lt = ct.length
      let ht = !1
      for (let dt = lt - 1, pt = 0; pt < lt; dt = pt++) {
        let vt = ct[dt],
          _t = ct[pt],
          yt = _t.x - vt.x,
          Et = _t.y - vt.y
        if (Math.abs(Et) > Number.EPSILON) {
          if (
            (Et < 0 && ((vt = ct[pt]), (yt = -yt), (_t = ct[dt]), (Et = -Et)),
            it.y < vt.y || it.y > _t.y)
          )
            continue
          if (it.y === vt.y) {
            if (it.x === vt.x) return !0
          } else {
            const Rt = Et * (it.x - vt.x) - yt * (it.y - vt.y)
            if (Rt === 0) return !0
            if (Rt < 0) continue
            ht = !ht
          }
        } else {
          if (it.y !== vt.y) continue
          if ((_t.x <= it.x && it.x <= vt.x) || (vt.x <= it.x && it.x <= _t.x))
            return !0
        }
      }
      return ht
    }
    const c = ShapeUtils.isClockWise,
      d = this.subPaths
    if (d.length === 0) return []
    let g, _, b
    const j = []
    if (d.length === 1)
      return (_ = d[0]), (b = new Shape()), (b.curves = _.curves), j.push(b), j
    let $ = !c(d[0].getPoints())
    $ = e ? !$ : $
    const _e = [],
      tt = []
    let st = [],
      at = 0,
      ot
    ;(tt[at] = void 0), (st[at] = [])
    for (let it = 0, ct = d.length; it < ct; it++)
      (_ = d[it]),
        (ot = _.getPoints()),
        (g = c(ot)),
        (g = e ? !g : g),
        g
          ? (!$ && tt[at] && at++,
            (tt[at] = { s: new Shape(), p: ot }),
            (tt[at].s.curves = _.curves),
            $ && at++,
            (st[at] = []))
          : st[at].push({ h: _, p: ot[0] })
    if (!tt[0]) return a(d)
    if (tt.length > 1) {
      let it = !1,
        ct = 0
      for (let lt = 0, ht = tt.length; lt < ht; lt++) _e[lt] = []
      for (let lt = 0, ht = tt.length; lt < ht; lt++) {
        const dt = st[lt]
        for (let pt = 0; pt < dt.length; pt++) {
          const vt = dt[pt]
          let _t = !0
          for (let yt = 0; yt < tt.length; yt++)
            o(vt.p, tt[yt].p) &&
              (lt !== yt && ct++, _t ? ((_t = !1), _e[yt].push(vt)) : (it = !0))
          _t && _e[lt].push(vt)
        }
      }
      ct > 0 && it === !1 && (st = _e)
    }
    let ut
    for (let it = 0, ct = tt.length; it < ct; it++) {
      ;(b = tt[it].s), j.push(b), (ut = st[it])
      for (let lt = 0, ht = ut.length; lt < ht; lt++) b.holes.push(ut[lt].h)
    }
    return j
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: REVISION } })
  )
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = REVISION))
const THREE = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping,
      AddEquation,
      AddOperation,
      AdditiveAnimationBlendMode,
      AdditiveBlending,
      AlphaFormat,
      AlwaysCompare,
      AlwaysDepth,
      AlwaysStencilFunc,
      AmbientLight,
      AmbientLightProbe,
      AnimationAction,
      AnimationClip,
      AnimationLoader,
      AnimationMixer,
      AnimationObjectGroup,
      AnimationUtils,
      ArcCurve,
      ArrayCamera,
      ArrowHelper,
      Audio: Audio$1,
      AudioAnalyser,
      AudioContext,
      AudioListener,
      AudioLoader,
      AxesHelper,
      BackSide,
      BasicDepthPacking,
      BasicShadowMap,
      Bone,
      BooleanKeyframeTrack,
      Box2,
      Box3,
      Box3Helper,
      BoxGeometry,
      BoxHelper,
      BufferAttribute,
      BufferGeometry,
      BufferGeometryLoader,
      ByteType,
      Cache,
      Camera,
      CameraHelper,
      CanvasTexture,
      CapsuleGeometry,
      CatmullRomCurve3,
      CineonToneMapping,
      CircleGeometry,
      ClampToEdgeWrapping,
      Clock,
      Color,
      ColorKeyframeTrack,
      ColorManagement,
      CompressedArrayTexture,
      CompressedCubeTexture,
      CompressedTexture,
      CompressedTextureLoader,
      ConeGeometry,
      CubeCamera,
      CubeReflectionMapping,
      CubeRefractionMapping,
      CubeTexture,
      CubeTextureLoader,
      CubeUVReflectionMapping,
      CubicBezierCurve,
      CubicBezierCurve3,
      CubicInterpolant,
      CullFaceBack,
      CullFaceFront,
      CullFaceFrontBack,
      CullFaceNone,
      Curve,
      CurvePath,
      CustomBlending,
      CustomToneMapping,
      CylinderGeometry,
      Cylindrical,
      Data3DTexture,
      DataArrayTexture,
      DataTexture,
      DataTextureLoader,
      DataUtils,
      DecrementStencilOp,
      DecrementWrapStencilOp,
      DefaultLoadingManager,
      DepthFormat,
      DepthStencilFormat,
      DepthTexture,
      DirectionalLight,
      DirectionalLightHelper,
      DiscreteInterpolant,
      DisplayP3ColorSpace,
      DodecahedronGeometry,
      DoubleSide,
      DstAlphaFactor,
      DstColorFactor,
      DynamicCopyUsage,
      DynamicDrawUsage,
      DynamicReadUsage,
      EdgesGeometry,
      EllipseCurve,
      EqualCompare,
      EqualDepth,
      EqualStencilFunc,
      EquirectangularReflectionMapping,
      EquirectangularRefractionMapping,
      Euler,
      EventDispatcher,
      ExtrudeGeometry,
      FileLoader,
      Float16BufferAttribute,
      Float32BufferAttribute,
      Float64BufferAttribute,
      FloatType,
      Fog,
      FogExp2,
      FramebufferTexture,
      FrontSide,
      Frustum,
      GLBufferAttribute,
      GLSL1,
      GLSL3,
      GreaterCompare,
      GreaterDepth,
      GreaterEqualCompare,
      GreaterEqualDepth,
      GreaterEqualStencilFunc,
      GreaterStencilFunc,
      GridHelper,
      Group,
      HalfFloatType,
      HemisphereLight,
      HemisphereLightHelper,
      HemisphereLightProbe,
      IcosahedronGeometry,
      ImageBitmapLoader,
      ImageLoader,
      ImageUtils,
      IncrementStencilOp,
      IncrementWrapStencilOp,
      InstancedBufferAttribute,
      InstancedBufferGeometry,
      InstancedInterleavedBuffer,
      InstancedMesh,
      Int16BufferAttribute,
      Int32BufferAttribute,
      Int8BufferAttribute,
      IntType,
      InterleavedBuffer,
      InterleavedBufferAttribute,
      Interpolant,
      InterpolateDiscrete,
      InterpolateLinear,
      InterpolateSmooth,
      InvertStencilOp,
      KeepStencilOp,
      KeyframeTrack,
      LOD,
      LatheGeometry,
      Layers,
      LessCompare,
      LessDepth,
      LessEqualCompare,
      LessEqualDepth,
      LessEqualStencilFunc,
      LessStencilFunc,
      Light,
      LightProbe,
      Line,
      Line3,
      LineBasicMaterial,
      LineCurve,
      LineCurve3,
      LineDashedMaterial,
      LineLoop,
      LineSegments,
      LinearDisplayP3ColorSpace,
      LinearEncoding,
      LinearFilter,
      LinearInterpolant,
      LinearMipMapLinearFilter,
      LinearMipMapNearestFilter,
      LinearMipmapLinearFilter,
      LinearMipmapNearestFilter,
      LinearSRGBColorSpace,
      LinearToneMapping,
      Loader: Loader$1,
      LoaderUtils,
      LoadingManager,
      LoopOnce,
      LoopPingPong,
      LoopRepeat,
      LuminanceAlphaFormat,
      LuminanceFormat,
      MOUSE,
      Material,
      MaterialLoader,
      MathUtils,
      Matrix3,
      Matrix4,
      MaxEquation,
      Mesh,
      MeshBasicMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshLambertMaterial,
      MeshMatcapMaterial,
      MeshNormalMaterial,
      MeshPhongMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshToonMaterial,
      MinEquation,
      MirroredRepeatWrapping,
      MixOperation,
      MultiplyBlending,
      MultiplyOperation,
      NearestFilter,
      NearestMipMapLinearFilter,
      NearestMipMapNearestFilter,
      NearestMipmapLinearFilter,
      NearestMipmapNearestFilter,
      NeverCompare,
      NeverDepth,
      NeverStencilFunc,
      NoBlending,
      NoColorSpace,
      NoToneMapping,
      NormalAnimationBlendMode,
      NormalBlending,
      NotEqualCompare,
      NotEqualDepth,
      NotEqualStencilFunc,
      NumberKeyframeTrack,
      Object3D,
      ObjectLoader,
      ObjectSpaceNormalMap,
      OctahedronGeometry,
      OneFactor,
      OneMinusDstAlphaFactor,
      OneMinusDstColorFactor,
      OneMinusSrcAlphaFactor,
      OneMinusSrcColorFactor,
      OrthographicCamera,
      PCFShadowMap,
      PCFSoftShadowMap,
      PMREMGenerator,
      Path,
      PerspectiveCamera,
      Plane,
      PlaneGeometry,
      PlaneHelper,
      PointLight,
      PointLightHelper,
      Points: Points$1,
      PointsMaterial,
      PolarGridHelper,
      PolyhedronGeometry,
      PositionalAudio,
      PropertyBinding,
      PropertyMixer,
      QuadraticBezierCurve,
      QuadraticBezierCurve3,
      Quaternion,
      QuaternionKeyframeTrack,
      QuaternionLinearInterpolant,
      RED_GREEN_RGTC2_Format,
      RED_RGTC1_Format,
      REVISION,
      RGBADepthPacking,
      RGBAFormat,
      RGBAIntegerFormat,
      RGBA_ASTC_10x10_Format,
      RGBA_ASTC_10x5_Format,
      RGBA_ASTC_10x6_Format,
      RGBA_ASTC_10x8_Format,
      RGBA_ASTC_12x10_Format,
      RGBA_ASTC_12x12_Format,
      RGBA_ASTC_4x4_Format,
      RGBA_ASTC_5x4_Format,
      RGBA_ASTC_5x5_Format,
      RGBA_ASTC_6x5_Format,
      RGBA_ASTC_6x6_Format,
      RGBA_ASTC_8x5_Format,
      RGBA_ASTC_8x6_Format,
      RGBA_ASTC_8x8_Format,
      RGBA_BPTC_Format,
      RGBA_ETC2_EAC_Format,
      RGBA_PVRTC_2BPPV1_Format,
      RGBA_PVRTC_4BPPV1_Format,
      RGBA_S3TC_DXT1_Format,
      RGBA_S3TC_DXT3_Format,
      RGBA_S3TC_DXT5_Format,
      RGB_BPTC_SIGNED_Format,
      RGB_BPTC_UNSIGNED_Format,
      RGB_ETC1_Format,
      RGB_ETC2_Format,
      RGB_PVRTC_2BPPV1_Format,
      RGB_PVRTC_4BPPV1_Format,
      RGB_S3TC_DXT1_Format,
      RGFormat,
      RGIntegerFormat,
      RawShaderMaterial,
      Ray,
      Raycaster,
      RectAreaLight,
      RedFormat,
      RedIntegerFormat,
      ReinhardToneMapping,
      RenderTarget,
      RepeatWrapping,
      ReplaceStencilOp,
      ReverseSubtractEquation,
      RingGeometry,
      SIGNED_RED_GREEN_RGTC2_Format,
      SIGNED_RED_RGTC1_Format,
      SRGBColorSpace,
      Scene,
      ShaderChunk,
      ShaderLib,
      ShaderMaterial,
      ShadowMaterial,
      Shape,
      ShapeGeometry,
      ShapePath,
      ShapeUtils,
      ShortType,
      Skeleton,
      SkeletonHelper,
      SkinnedMesh,
      Source,
      Sphere,
      SphereGeometry,
      Spherical,
      SphericalHarmonics3,
      SplineCurve,
      SpotLight,
      SpotLightHelper,
      Sprite,
      SpriteMaterial,
      SrcAlphaFactor,
      SrcAlphaSaturateFactor,
      SrcColorFactor,
      StaticCopyUsage,
      StaticDrawUsage,
      StaticReadUsage,
      StereoCamera,
      StreamCopyUsage,
      StreamDrawUsage,
      StreamReadUsage,
      StringKeyframeTrack,
      SubtractEquation,
      SubtractiveBlending,
      TOUCH,
      TangentSpaceNormalMap,
      TetrahedronGeometry,
      Texture,
      TextureLoader,
      TorusGeometry,
      TorusKnotGeometry,
      Triangle,
      TriangleFanDrawMode,
      TriangleStripDrawMode,
      TrianglesDrawMode,
      TubeGeometry,
      TwoPassDoubleSide,
      UVMapping,
      Uint16BufferAttribute,
      Uint32BufferAttribute,
      Uint8BufferAttribute,
      Uint8ClampedBufferAttribute,
      Uniform,
      UniformsGroup,
      UniformsLib,
      UniformsUtils,
      UnsignedByteType,
      UnsignedInt248Type,
      UnsignedIntType,
      UnsignedShort4444Type,
      UnsignedShort5551Type,
      UnsignedShortType,
      VSMShadowMap,
      Vector2,
      Vector3,
      Vector4,
      VectorKeyframeTrack,
      VideoTexture,
      WebGL1Renderer,
      WebGL3DRenderTarget,
      WebGLArrayRenderTarget,
      WebGLCoordinateSystem,
      WebGLCubeRenderTarget,
      WebGLMultipleRenderTargets,
      WebGLRenderTarget,
      WebGLRenderer,
      WebGLUtils,
      WebGPUCoordinateSystem,
      WireframeGeometry,
      WrapAroundEnding,
      ZeroCurvatureEnding,
      ZeroFactor,
      ZeroSlopeEnding,
      ZeroStencilOp,
      _SRGBAFormat,
      createCanvasElement,
      sRGBEncoding,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
)
var constants = { exports: {} },
  reactReconcilerConstants_production_min = {}
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ reactReconcilerConstants_production_min.ConcurrentRoot = 1
reactReconcilerConstants_production_min.ContinuousEventPriority = 4
reactReconcilerConstants_production_min.DefaultEventPriority = 16
reactReconcilerConstants_production_min.DiscreteEventPriority = 1
reactReconcilerConstants_production_min.IdleEventPriority = 536870912
reactReconcilerConstants_production_min.LegacyRoot = 0
constants.exports = reactReconcilerConstants_production_min
var constantsExports = constants.exports
function createStore$1(s) {
  let e
  const a = new Set(),
    o = (j, $) => {
      const _e = typeof j == "function" ? j(e) : j
      if (_e !== e) {
        const tt = e
        ;(e = $ ? _e : Object.assign({}, e, _e)), a.forEach((st) => st(e, tt))
      }
    },
    c = () => e,
    d = (j, $ = c, _e = Object.is) => {
      console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware")
      let tt = $(e)
      function st() {
        const at = $(e)
        if (!_e(tt, at)) {
          const ot = tt
          j((tt = at), ot)
        }
      }
      return a.add(st), () => a.delete(st)
    },
    b = {
      setState: o,
      getState: c,
      subscribe: (j, $, _e) =>
        $ || _e ? d(j, $, _e) : (a.add(j), () => a.delete(j)),
      destroy: () => a.clear(),
    }
  return (e = s(o, c, b)), b
}
const isSSR =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  useIsomorphicLayoutEffect$2 = isSSR
    ? reactExports.useEffect
    : reactExports.useLayoutEffect
function create(s) {
  const e = typeof s == "function" ? createStore$1(s) : s,
    a = (o = e.getState, c = Object.is) => {
      const [, d] = reactExports.useReducer((ut) => ut + 1, 0),
        g = e.getState(),
        _ = reactExports.useRef(g),
        b = reactExports.useRef(o),
        j = reactExports.useRef(c),
        $ = reactExports.useRef(!1),
        _e = reactExports.useRef()
      _e.current === void 0 && (_e.current = o(g))
      let tt,
        st = !1
      ;(_.current !== g || b.current !== o || j.current !== c || $.current) &&
        ((tt = o(g)), (st = !c(_e.current, tt))),
        useIsomorphicLayoutEffect$2(() => {
          st && (_e.current = tt),
            (_.current = g),
            (b.current = o),
            (j.current = c),
            ($.current = !1)
        })
      const at = reactExports.useRef(g)
      useIsomorphicLayoutEffect$2(() => {
        const ut = () => {
            try {
              const ct = e.getState(),
                lt = b.current(ct)
              j.current(_e.current, lt) ||
                ((_.current = ct), (_e.current = lt), d())
            } catch {
              ;($.current = !0), d()
            }
          },
          it = e.subscribe(ut)
        return e.getState() !== at.current && ut(), it
      }, [])
      const ot = st ? tt : _e.current
      return reactExports.useDebugValue(ot), ot
    }
  return (
    Object.assign(a, e),
    (a[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      )
      const o = [a, e]
      return {
        next() {
          const c = o.length <= 0
          return { value: o.shift(), done: c }
        },
      }
    }),
    a
  )
}
var reactReconciler = { exports: {} },
  scheduler$1 = { exports: {} },
  scheduler_production_min$1 = {}
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var hasRequiredScheduler_production_min
function requireScheduler_production_min() {
  return (
    hasRequiredScheduler_production_min ||
      ((hasRequiredScheduler_production_min = 1),
      (function (s) {
        function e(gt, At) {
          var bt = gt.length
          gt.push(At)
          e: for (; 0 < bt; ) {
            var Tt = (bt - 1) >>> 1,
              It = gt[Tt]
            if (0 < c(It, At)) (gt[Tt] = At), (gt[bt] = It), (bt = Tt)
            else break e
          }
        }
        function a(gt) {
          return gt.length === 0 ? null : gt[0]
        }
        function o(gt) {
          if (gt.length === 0) return null
          var At = gt[0],
            bt = gt.pop()
          if (bt !== At) {
            gt[0] = bt
            e: for (var Tt = 0, It = gt.length, $t = It >>> 1; Tt < $t; ) {
              var Xt = 2 * (Tt + 1) - 1,
                qt = gt[Xt],
                en = Xt + 1,
                yn = gt[en]
              if (0 > c(qt, bt))
                en < It && 0 > c(yn, qt)
                  ? ((gt[Tt] = yn), (gt[en] = bt), (Tt = en))
                  : ((gt[Tt] = qt), (gt[Xt] = bt), (Tt = Xt))
              else if (en < It && 0 > c(yn, bt))
                (gt[Tt] = yn), (gt[en] = bt), (Tt = en)
              else break e
            }
          }
          return At
        }
        function c(gt, At) {
          var bt = gt.sortIndex - At.sortIndex
          return bt !== 0 ? bt : gt.id - At.id
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var d = performance
          s.unstable_now = function () {
            return d.now()
          }
        } else {
          var g = Date,
            _ = g.now()
          s.unstable_now = function () {
            return g.now() - _
          }
        }
        var b = [],
          j = [],
          $ = 1,
          _e = null,
          tt = 3,
          st = !1,
          at = !1,
          ot = !1,
          ut = typeof setTimeout == "function" ? setTimeout : null,
          it = typeof clearTimeout == "function" ? clearTimeout : null,
          ct = typeof setImmediate < "u" ? setImmediate : null
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling)
        function lt(gt) {
          for (var At = a(j); At !== null; ) {
            if (At.callback === null) o(j)
            else if (At.startTime <= gt)
              o(j), (At.sortIndex = At.expirationTime), e(b, At)
            else break
            At = a(j)
          }
        }
        function ht(gt) {
          if (((ot = !1), lt(gt), !at))
            if (a(b) !== null) (at = !0), Mt(dt)
            else {
              var At = a(j)
              At !== null && wt(ht, At.startTime - gt)
            }
        }
        function dt(gt, At) {
          ;(at = !1), ot && ((ot = !1), it(_t), (_t = -1)), (st = !0)
          var bt = tt
          try {
            for (
              lt(At), _e = a(b);
              _e !== null && (!(_e.expirationTime > At) || (gt && !Rt()));

            ) {
              var Tt = _e.callback
              if (typeof Tt == "function") {
                ;(_e.callback = null), (tt = _e.priorityLevel)
                var It = Tt(_e.expirationTime <= At)
                ;(At = s.unstable_now()),
                  typeof It == "function"
                    ? (_e.callback = It)
                    : _e === a(b) && o(b),
                  lt(At)
              } else o(b)
              _e = a(b)
            }
            if (_e !== null) var $t = !0
            else {
              var Xt = a(j)
              Xt !== null && wt(ht, Xt.startTime - At), ($t = !1)
            }
            return $t
          } finally {
            ;(_e = null), (tt = bt), (st = !1)
          }
        }
        var pt = !1,
          vt = null,
          _t = -1,
          yt = 5,
          Et = -1
        function Rt() {
          return !(s.unstable_now() - Et < yt)
        }
        function Ft() {
          if (vt !== null) {
            var gt = s.unstable_now()
            Et = gt
            var At = !0
            try {
              At = vt(!0, gt)
            } finally {
              At ? kt() : ((pt = !1), (vt = null))
            }
          } else pt = !1
        }
        var kt
        if (typeof ct == "function")
          kt = function () {
            ct(Ft)
          }
        else if (typeof MessageChannel < "u") {
          var Nt = new MessageChannel(),
            Dt = Nt.port2
          ;(Nt.port1.onmessage = Ft),
            (kt = function () {
              Dt.postMessage(null)
            })
        } else
          kt = function () {
            ut(Ft, 0)
          }
        function Mt(gt) {
          ;(vt = gt), pt || ((pt = !0), kt())
        }
        function wt(gt, At) {
          _t = ut(function () {
            gt(s.unstable_now())
          }, At)
        }
        ;(s.unstable_IdlePriority = 5),
          (s.unstable_ImmediatePriority = 1),
          (s.unstable_LowPriority = 4),
          (s.unstable_NormalPriority = 3),
          (s.unstable_Profiling = null),
          (s.unstable_UserBlockingPriority = 2),
          (s.unstable_cancelCallback = function (gt) {
            gt.callback = null
          }),
          (s.unstable_continueExecution = function () {
            at || st || ((at = !0), Mt(dt))
          }),
          (s.unstable_forceFrameRate = function (gt) {
            0 > gt || 125 < gt
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (yt = 0 < gt ? Math.floor(1e3 / gt) : 5)
          }),
          (s.unstable_getCurrentPriorityLevel = function () {
            return tt
          }),
          (s.unstable_getFirstCallbackNode = function () {
            return a(b)
          }),
          (s.unstable_next = function (gt) {
            switch (tt) {
              case 1:
              case 2:
              case 3:
                var At = 3
                break
              default:
                At = tt
            }
            var bt = tt
            tt = At
            try {
              return gt()
            } finally {
              tt = bt
            }
          }),
          (s.unstable_pauseExecution = function () {}),
          (s.unstable_requestPaint = function () {}),
          (s.unstable_runWithPriority = function (gt, At) {
            switch (gt) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break
              default:
                gt = 3
            }
            var bt = tt
            tt = gt
            try {
              return At()
            } finally {
              tt = bt
            }
          }),
          (s.unstable_scheduleCallback = function (gt, At, bt) {
            var Tt = s.unstable_now()
            switch (
              (typeof bt == "object" && bt !== null
                ? ((bt = bt.delay),
                  (bt = typeof bt == "number" && 0 < bt ? Tt + bt : Tt))
                : (bt = Tt),
              gt)
            ) {
              case 1:
                var It = -1
                break
              case 2:
                It = 250
                break
              case 5:
                It = 1073741823
                break
              case 4:
                It = 1e4
                break
              default:
                It = 5e3
            }
            return (
              (It = bt + It),
              (gt = {
                id: $++,
                callback: At,
                priorityLevel: gt,
                startTime: bt,
                expirationTime: It,
                sortIndex: -1,
              }),
              bt > Tt
                ? ((gt.sortIndex = bt),
                  e(j, gt),
                  a(b) === null &&
                    gt === a(j) &&
                    (ot ? (it(_t), (_t = -1)) : (ot = !0), wt(ht, bt - Tt)))
                : ((gt.sortIndex = It),
                  e(b, gt),
                  at || st || ((at = !0), Mt(dt))),
              gt
            )
          }),
          (s.unstable_shouldYield = Rt),
          (s.unstable_wrapCallback = function (gt) {
            var At = tt
            return function () {
              var bt = tt
              tt = At
              try {
                return gt.apply(this, arguments)
              } finally {
                tt = bt
              }
            }
          })
      })(scheduler_production_min$1)),
    scheduler_production_min$1
  )
}
var hasRequiredScheduler
function requireScheduler() {
  return (
    hasRequiredScheduler ||
      ((hasRequiredScheduler = 1),
      (scheduler$1.exports = requireScheduler_production_min())),
    scheduler$1.exports
  )
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var reactReconciler_production_min = function (e) {
  var a = {},
    o = reactExports,
    c = requireScheduler(),
    d = Object.assign
  function g(nt) {
    for (
      var rt = "https://reactjs.org/docs/error-decoder.html?invariant=" + nt,
        ft = 1;
      ft < arguments.length;
      ft++
    )
      rt += "&args[]=" + encodeURIComponent(arguments[ft])
    return (
      "Minified React error #" +
      nt +
      "; visit " +
      rt +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    )
  }
  var _ = o.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    b = Symbol.for("react.element"),
    j = Symbol.for("react.portal"),
    $ = Symbol.for("react.fragment"),
    _e = Symbol.for("react.strict_mode"),
    tt = Symbol.for("react.profiler"),
    st = Symbol.for("react.provider"),
    at = Symbol.for("react.context"),
    ot = Symbol.for("react.forward_ref"),
    ut = Symbol.for("react.suspense"),
    it = Symbol.for("react.suspense_list"),
    ct = Symbol.for("react.memo"),
    lt = Symbol.for("react.lazy"),
    ht = Symbol.for("react.offscreen"),
    dt = Symbol.iterator
  function pt(nt) {
    return nt === null || typeof nt != "object"
      ? null
      : ((nt = (dt && nt[dt]) || nt["@@iterator"]),
        typeof nt == "function" ? nt : null)
  }
  function vt(nt) {
    if (nt == null) return null
    if (typeof nt == "function") return nt.displayName || nt.name || null
    if (typeof nt == "string") return nt
    switch (nt) {
      case $:
        return "Fragment"
      case j:
        return "Portal"
      case tt:
        return "Profiler"
      case _e:
        return "StrictMode"
      case ut:
        return "Suspense"
      case it:
        return "SuspenseList"
    }
    if (typeof nt == "object")
      switch (nt.$$typeof) {
        case at:
          return (nt.displayName || "Context") + ".Consumer"
        case st:
          return (nt._context.displayName || "Context") + ".Provider"
        case ot:
          var rt = nt.render
          return (
            (nt = nt.displayName),
            nt ||
              ((nt = rt.displayName || rt.name || ""),
              (nt = nt !== "" ? "ForwardRef(" + nt + ")" : "ForwardRef")),
            nt
          )
        case ct:
          return (
            (rt = nt.displayName || null),
            rt !== null ? rt : vt(nt.type) || "Memo"
          )
        case lt:
          ;(rt = nt._payload), (nt = nt._init)
          try {
            return vt(nt(rt))
          } catch {}
      }
    return null
  }
  function _t(nt) {
    var rt = nt.type
    switch (nt.tag) {
      case 24:
        return "Cache"
      case 9:
        return (rt.displayName || "Context") + ".Consumer"
      case 10:
        return (rt._context.displayName || "Context") + ".Provider"
      case 18:
        return "DehydratedFragment"
      case 11:
        return (
          (nt = rt.render),
          (nt = nt.displayName || nt.name || ""),
          rt.displayName ||
            (nt !== "" ? "ForwardRef(" + nt + ")" : "ForwardRef")
        )
      case 7:
        return "Fragment"
      case 5:
        return rt
      case 4:
        return "Portal"
      case 3:
        return "Root"
      case 6:
        return "Text"
      case 16:
        return vt(rt)
      case 8:
        return rt === _e ? "StrictMode" : "Mode"
      case 22:
        return "Offscreen"
      case 12:
        return "Profiler"
      case 21:
        return "Scope"
      case 13:
        return "Suspense"
      case 19:
        return "SuspenseList"
      case 25:
        return "TracingMarker"
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof rt == "function") return rt.displayName || rt.name || null
        if (typeof rt == "string") return rt
    }
    return null
  }
  function yt(nt) {
    var rt = nt,
      ft = nt
    if (nt.alternate) for (; rt.return; ) rt = rt.return
    else {
      nt = rt
      do (rt = nt), rt.flags & 4098 && (ft = rt.return), (nt = rt.return)
      while (nt)
    }
    return rt.tag === 3 ? ft : null
  }
  function Et(nt) {
    if (yt(nt) !== nt) throw Error(g(188))
  }
  function Rt(nt) {
    var rt = nt.alternate
    if (!rt) {
      if (((rt = yt(nt)), rt === null)) throw Error(g(188))
      return rt !== nt ? null : nt
    }
    for (var ft = nt, mt = rt; ; ) {
      var xt = ft.return
      if (xt === null) break
      var Ct = xt.alternate
      if (Ct === null) {
        if (((mt = xt.return), mt !== null)) {
          ft = mt
          continue
        }
        break
      }
      if (xt.child === Ct.child) {
        for (Ct = xt.child; Ct; ) {
          if (Ct === ft) return Et(xt), nt
          if (Ct === mt) return Et(xt), rt
          Ct = Ct.sibling
        }
        throw Error(g(188))
      }
      if (ft.return !== mt.return) (ft = xt), (mt = Ct)
      else {
        for (var Gt = !1, Jt = xt.child; Jt; ) {
          if (Jt === ft) {
            ;(Gt = !0), (ft = xt), (mt = Ct)
            break
          }
          if (Jt === mt) {
            ;(Gt = !0), (mt = xt), (ft = Ct)
            break
          }
          Jt = Jt.sibling
        }
        if (!Gt) {
          for (Jt = Ct.child; Jt; ) {
            if (Jt === ft) {
              ;(Gt = !0), (ft = Ct), (mt = xt)
              break
            }
            if (Jt === mt) {
              ;(Gt = !0), (mt = Ct), (ft = xt)
              break
            }
            Jt = Jt.sibling
          }
          if (!Gt) throw Error(g(189))
        }
      }
      if (ft.alternate !== mt) throw Error(g(190))
    }
    if (ft.tag !== 3) throw Error(g(188))
    return ft.stateNode.current === ft ? nt : rt
  }
  function Ft(nt) {
    return (nt = Rt(nt)), nt !== null ? kt(nt) : null
  }
  function kt(nt) {
    if (nt.tag === 5 || nt.tag === 6) return nt
    for (nt = nt.child; nt !== null; ) {
      var rt = kt(nt)
      if (rt !== null) return rt
      nt = nt.sibling
    }
    return null
  }
  function Nt(nt) {
    if (nt.tag === 5 || nt.tag === 6) return nt
    for (nt = nt.child; nt !== null; ) {
      if (nt.tag !== 4) {
        var rt = Nt(nt)
        if (rt !== null) return rt
      }
      nt = nt.sibling
    }
    return null
  }
  var Dt = Array.isArray,
    Mt = e.getPublicInstance,
    wt = e.getRootHostContext,
    gt = e.getChildHostContext,
    At = e.prepareForCommit,
    bt = e.resetAfterCommit,
    Tt = e.createInstance,
    It = e.appendInitialChild,
    $t = e.finalizeInitialChildren,
    Xt = e.prepareUpdate,
    qt = e.shouldSetTextContent,
    en = e.createTextInstance,
    yn = e.scheduleTimeout,
    Tn = e.cancelTimeout,
    $n = e.noTimeout,
    Vn = e.isPrimaryRenderer,
    gn = e.supportsMutation,
    Ht = e.supportsPersistence,
    on = e.supportsHydration,
    Yt = e.getInstanceFromNode,
    _n = e.preparePortalMount,
    pn = e.getCurrentEventPriority,
    Rn = e.detachDeletedInstance,
    bn = e.supportsMicrotasks,
    Pn = e.scheduleMicrotask,
    Gn = e.supportsTestSelectors,
    jn = e.findFiberRoot,
    ar = e.getBoundingRect,
    Vt = e.getTextContent,
    Lt = e.isHiddenSubtree,
    Zt = e.matchAccessibilityRole,
    xn = e.setFocusIfFocusable,
    vn = e.setupIntersectionObserver,
    An = e.appendChild,
    Nn = e.appendChildToContainer,
    Sn = e.commitTextUpdate,
    an = e.commitMount,
    Jn = e.commitUpdate,
    Hn = e.insertBefore,
    Fn = e.insertInContainerBefore,
    Un = e.removeChild,
    Wt = e.removeChildFromContainer,
    un = e.resetTextContent,
    Mn = e.hideInstance,
    jt = e.hideTextInstance,
    Qt = e.unhideInstance,
    nn = e.unhideTextInstance,
    En = e.clearContainer,
    In = e.cloneInstance,
    or = e.createContainerChildSet,
    hr = e.appendChildToContainerChildSet,
    mr = e.finalizeContainerChildren,
    kr = e.replaceContainerChildren,
    dr = e.cloneHiddenInstance,
    Br = e.cloneHiddenTextInstance,
    Tr = e.canHydrateInstance,
    Js = e.canHydrateTextInstance,
    Ys = e.canHydrateSuspenseInstance,
    Es = e.isSuspenseInstancePending,
    ds = e.isSuspenseInstanceFallback,
    ps = e.registerSuspenseInstanceRetry,
    zr = e.getNextHydratableSibling,
    lr = e.getFirstHydratableChild,
    Ks = e.getFirstHydratableChildWithinContainer,
    io = e.getFirstHydratableChildWithinSuspenseInstance,
    Pt = e.hydrateInstance,
    St = e.hydrateTextInstance,
    Bt = e.hydrateSuspenseInstance,
    Ut = e.getNextHydratableInstanceAfterSuspenseInstance,
    Ot = e.commitHydratedContainer,
    zt = e.commitHydratedSuspenseInstance,
    tn = e.clearSuspenseBoundary,
    sn = e.clearSuspenseBoundaryFromContainer,
    dn = e.shouldDeleteUnhydratedTailInstances,
    hn = e.didNotMatchHydratedContainerTextInstance,
    mn = e.didNotMatchHydratedTextInstance,
    cn
  function On(nt) {
    if (cn === void 0)
      try {
        throw Error()
      } catch (ft) {
        var rt = ft.stack.trim().match(/\n( *(at )?)/)
        cn = (rt && rt[1]) || ""
      }
    return (
      `
` +
      cn +
      nt
    )
  }
  var wn = !1
  function Bn(nt, rt) {
    if (!nt || wn) return ""
    wn = !0
    var ft = Error.prepareStackTrace
    Error.prepareStackTrace = void 0
    try {
      if (rt)
        if (
          ((rt = function () {
            throw Error()
          }),
          Object.defineProperty(rt.prototype, "props", {
            set: function () {
              throw Error()
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(rt, [])
          } catch (Cn) {
            var mt = Cn
          }
          Reflect.construct(nt, [], rt)
        } else {
          try {
            rt.call()
          } catch (Cn) {
            mt = Cn
          }
          nt.call(rt.prototype)
        }
      else {
        try {
          throw Error()
        } catch (Cn) {
          mt = Cn
        }
        nt()
      }
    } catch (Cn) {
      if (Cn && mt && typeof Cn.stack == "string") {
        for (
          var xt = Cn.stack.split(`
`),
            Ct = mt.stack.split(`
`),
            Gt = xt.length - 1,
            Jt = Ct.length - 1;
          1 <= Gt && 0 <= Jt && xt[Gt] !== Ct[Jt];

        )
          Jt--
        for (; 1 <= Gt && 0 <= Jt; Gt--, Jt--)
          if (xt[Gt] !== Ct[Jt]) {
            if (Gt !== 1 || Jt !== 1)
              do
                if ((Gt--, Jt--, 0 > Jt || xt[Gt] !== Ct[Jt])) {
                  var fn =
                    `
` + xt[Gt].replace(" at new ", " at ")
                  return (
                    nt.displayName &&
                      fn.includes("<anonymous>") &&
                      (fn = fn.replace("<anonymous>", nt.displayName)),
                    fn
                  )
                }
              while (1 <= Gt && 0 <= Jt)
            break
          }
      }
    } finally {
      ;(wn = !1), (Error.prepareStackTrace = ft)
    }
    return (nt = nt ? nt.displayName || nt.name : "") ? On(nt) : ""
  }
  var Yn = Object.prototype.hasOwnProperty,
    Zn = [],
    qn = -1
  function Dn(nt) {
    return { current: nt }
  }
  function er(nt) {
    0 > qn || ((nt.current = Zn[qn]), (Zn[qn] = null), qn--)
  }
  function Wn(nt, rt) {
    qn++, (Zn[qn] = nt.current), (nt.current = rt)
  }
  var rr = {},
    Ar = Dn(rr),
    tr = Dn(!1),
    Sr = rr
  function gr(nt, rt) {
    var ft = nt.type.contextTypes
    if (!ft) return rr
    var mt = nt.stateNode
    if (mt && mt.__reactInternalMemoizedUnmaskedChildContext === rt)
      return mt.__reactInternalMemoizedMaskedChildContext
    var xt = {},
      Ct
    for (Ct in ft) xt[Ct] = rt[Ct]
    return (
      mt &&
        ((nt = nt.stateNode),
        (nt.__reactInternalMemoizedUnmaskedChildContext = rt),
        (nt.__reactInternalMemoizedMaskedChildContext = xt)),
      xt
    )
  }
  function Er(nt) {
    return (nt = nt.childContextTypes), nt != null
  }
  function Ir() {
    er(tr), er(Ar)
  }
  function nr(nt, rt, ft) {
    if (Ar.current !== rr) throw Error(g(168))
    Wn(Ar, rt), Wn(tr, ft)
  }
  function wr(nt, rt, ft) {
    var mt = nt.stateNode
    if (((rt = rt.childContextTypes), typeof mt.getChildContext != "function"))
      return ft
    mt = mt.getChildContext()
    for (var xt in mt)
      if (!(xt in rt)) throw Error(g(108, _t(nt) || "Unknown", xt))
    return d({}, ft, mt)
  }
  function xr(nt) {
    return (
      (nt =
        ((nt = nt.stateNode) && nt.__reactInternalMemoizedMergedChildContext) ||
        rr),
      (Sr = Ar.current),
      Wn(Ar, nt),
      Wn(tr, tr.current),
      !0
    )
  }
  function pr(nt, rt, ft) {
    var mt = nt.stateNode
    if (!mt) throw Error(g(169))
    ft
      ? ((nt = wr(nt, rt, Sr)),
        (mt.__reactInternalMemoizedMergedChildContext = nt),
        er(tr),
        er(Ar),
        Wn(Ar, nt))
      : er(tr),
      Wn(tr, ft)
  }
  var Cr = Math.clz32 ? Math.clz32 : ms,
    Ms = Math.log,
    Xr = Math.LN2
  function ms(nt) {
    return (nt >>>= 0), nt === 0 ? 32 : (31 - ((Ms(nt) / Xr) | 0)) | 0
  }
  var To = 64,
    Co = 4194304
  function so(nt) {
    switch (nt & -nt) {
      case 1:
        return 1
      case 2:
        return 2
      case 4:
        return 4
      case 8:
        return 8
      case 16:
        return 16
      case 32:
        return 32
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return nt & 4194240
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return nt & 130023424
      case 134217728:
        return 134217728
      case 268435456:
        return 268435456
      case 536870912:
        return 536870912
      case 1073741824:
        return 1073741824
      default:
        return nt
    }
  }
  function bo(nt, rt) {
    var ft = nt.pendingLanes
    if (ft === 0) return 0
    var mt = 0,
      xt = nt.suspendedLanes,
      Ct = nt.pingedLanes,
      Gt = ft & 268435455
    if (Gt !== 0) {
      var Jt = Gt & ~xt
      Jt !== 0 ? (mt = so(Jt)) : ((Ct &= Gt), Ct !== 0 && (mt = so(Ct)))
    } else (Gt = ft & ~xt), Gt !== 0 ? (mt = so(Gt)) : Ct !== 0 && (mt = so(Ct))
    if (mt === 0) return 0
    if (
      rt !== 0 &&
      rt !== mt &&
      !(rt & xt) &&
      ((xt = mt & -mt),
      (Ct = rt & -rt),
      xt >= Ct || (xt === 16 && (Ct & 4194240) !== 0))
    )
      return rt
    if ((mt & 4 && (mt |= ft & 16), (rt = nt.entangledLanes), rt !== 0))
      for (nt = nt.entanglements, rt &= mt; 0 < rt; )
        (ft = 31 - Cr(rt)), (xt = 1 << ft), (mt |= nt[ft]), (rt &= ~xt)
    return mt
  }
  function xm(nt, rt) {
    switch (nt) {
      case 1:
      case 2:
      case 4:
        return rt + 250
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return rt + 5e3
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1
      default:
        return -1
    }
  }
  function Am(nt, rt) {
    for (
      var ft = nt.suspendedLanes,
        mt = nt.pingedLanes,
        xt = nt.expirationTimes,
        Ct = nt.pendingLanes;
      0 < Ct;

    ) {
      var Gt = 31 - Cr(Ct),
        Jt = 1 << Gt,
        fn = xt[Gt]
      fn === -1
        ? (!(Jt & ft) || Jt & mt) && (xt[Gt] = xm(Jt, rt))
        : fn <= rt && (nt.expiredLanes |= Jt),
        (Ct &= ~Jt)
    }
  }
  function Ol(nt) {
    return (
      (nt = nt.pendingLanes & -1073741825),
      nt !== 0 ? nt : nt & 1073741824 ? 1073741824 : 0
    )
  }
  function Ul(nt) {
    for (var rt = [], ft = 0; 31 > ft; ft++) rt.push(nt)
    return rt
  }
  function ao(nt, rt, ft) {
    ;(nt.pendingLanes |= rt),
      rt !== 536870912 && ((nt.suspendedLanes = 0), (nt.pingedLanes = 0)),
      (nt = nt.eventTimes),
      (rt = 31 - Cr(rt)),
      (nt[rt] = ft)
  }
  function Sm(nt, rt) {
    var ft = nt.pendingLanes & ~rt
    ;(nt.pendingLanes = rt),
      (nt.suspendedLanes = 0),
      (nt.pingedLanes = 0),
      (nt.expiredLanes &= rt),
      (nt.mutableReadLanes &= rt),
      (nt.entangledLanes &= rt),
      (rt = nt.entanglements)
    var mt = nt.eventTimes
    for (nt = nt.expirationTimes; 0 < ft; ) {
      var xt = 31 - Cr(ft),
        Ct = 1 << xt
      ;(rt[xt] = 0), (mt[xt] = -1), (nt[xt] = -1), (ft &= ~Ct)
    }
  }
  function Vl(nt, rt) {
    var ft = (nt.entangledLanes |= rt)
    for (nt = nt.entanglements; ft; ) {
      var mt = 31 - Cr(ft),
        xt = 1 << mt
      ;(xt & rt) | (nt[mt] & rt) && (nt[mt] |= rt), (ft &= ~xt)
    }
  }
  var vr = 0
  function Hu(nt) {
    return (
      (nt &= -nt), 1 < nt ? (4 < nt ? (nt & 268435455 ? 16 : 536870912) : 4) : 1
    )
  }
  var Gl = c.unstable_scheduleCallback,
    Wu = c.unstable_cancelCallback,
    Em = c.unstable_shouldYield,
    Mm = c.unstable_requestPaint,
    Or = c.unstable_now,
    zl = c.unstable_ImmediatePriority,
    Tm = c.unstable_UserBlockingPriority,
    Hl = c.unstable_NormalPriority,
    Cm = c.unstable_IdlePriority,
    wo = null,
    gs = null
  function bm(nt) {
    if (gs && typeof gs.onCommitFiberRoot == "function")
      try {
        gs.onCommitFiberRoot(wo, nt, void 0, (nt.current.flags & 128) === 128)
      } catch {}
  }
  function wm(nt, rt) {
    return (
      (nt === rt && (nt !== 0 || 1 / nt === 1 / rt)) || (nt !== nt && rt !== rt)
    )
  }
  var vs = typeof Object.is == "function" ? Object.is : wm,
    Ts = null,
    Po = !1,
    Wl = !1
  function ju(nt) {
    Ts === null ? (Ts = [nt]) : Ts.push(nt)
  }
  function Pm(nt) {
    ;(Po = !0), ju(nt)
  }
  function ys() {
    if (!Wl && Ts !== null) {
      Wl = !0
      var nt = 0,
        rt = vr
      try {
        var ft = Ts
        for (vr = 1; nt < ft.length; nt++) {
          var mt = ft[nt]
          do mt = mt(!0)
          while (mt !== null)
        }
        ;(Ts = null), (Po = !1)
      } catch (xt) {
        throw (Ts !== null && (Ts = Ts.slice(nt + 1)), Gl(zl, ys), xt)
      } finally {
        ;(vr = rt), (Wl = !1)
      }
    }
    return null
  }
  var Rm = _.ReactCurrentBatchConfig
  function Ro(nt, rt) {
    if (vs(nt, rt)) return !0
    if (
      typeof nt != "object" ||
      nt === null ||
      typeof rt != "object" ||
      rt === null
    )
      return !1
    var ft = Object.keys(nt),
      mt = Object.keys(rt)
    if (ft.length !== mt.length) return !1
    for (mt = 0; mt < ft.length; mt++) {
      var xt = ft[mt]
      if (!Yn.call(rt, xt) || !vs(nt[xt], rt[xt])) return !1
    }
    return !0
  }
  function Bm(nt) {
    switch (nt.tag) {
      case 5:
        return On(nt.type)
      case 16:
        return On("Lazy")
      case 13:
        return On("Suspense")
      case 19:
        return On("SuspenseList")
      case 0:
      case 2:
      case 15:
        return (nt = Bn(nt.type, !1)), nt
      case 11:
        return (nt = Bn(nt.type.render, !1)), nt
      case 1:
        return (nt = Bn(nt.type, !0)), nt
      default:
        return ""
    }
  }
  function hs(nt, rt) {
    if (nt && nt.defaultProps) {
      ;(rt = d({}, rt)), (nt = nt.defaultProps)
      for (var ft in nt) rt[ft] === void 0 && (rt[ft] = nt[ft])
      return rt
    }
    return rt
  }
  var Bo = Dn(null),
    Io = null,
    qs = null,
    $l = null
  function Xl() {
    $l = qs = Io = null
  }
  function $u(nt, rt, ft) {
    Vn
      ? (Wn(Bo, rt._currentValue), (rt._currentValue = ft))
      : (Wn(Bo, rt._currentValue2), (rt._currentValue2 = ft))
  }
  function Jl(nt) {
    var rt = Bo.current
    er(Bo), Vn ? (nt._currentValue = rt) : (nt._currentValue2 = rt)
  }
  function Yl(nt, rt, ft) {
    for (; nt !== null; ) {
      var mt = nt.alternate
      if (
        ((nt.childLanes & rt) !== rt
          ? ((nt.childLanes |= rt), mt !== null && (mt.childLanes |= rt))
          : mt !== null && (mt.childLanes & rt) !== rt && (mt.childLanes |= rt),
        nt === ft)
      )
        break
      nt = nt.return
    }
  }
  function Zs(nt, rt) {
    ;(Io = nt),
      ($l = qs = null),
      (nt = nt.dependencies),
      nt !== null &&
        nt.firstContext !== null &&
        (nt.lanes & rt && (es = !0), (nt.firstContext = null))
  }
  function ns(nt) {
    var rt = Vn ? nt._currentValue : nt._currentValue2
    if ($l !== nt)
      if (
        ((nt = { context: nt, memoizedValue: rt, next: null }), qs === null)
      ) {
        if (Io === null) throw Error(g(308))
        ;(qs = nt), (Io.dependencies = { lanes: 0, firstContext: nt })
      } else qs = qs.next = nt
    return rt
  }
  var _s = null,
    Bs = !1
  function Kl(nt) {
    nt.updateQueue = {
      baseState: nt.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    }
  }
  function Xu(nt, rt) {
    ;(nt = nt.updateQueue),
      rt.updateQueue === nt &&
        (rt.updateQueue = {
          baseState: nt.baseState,
          firstBaseUpdate: nt.firstBaseUpdate,
          lastBaseUpdate: nt.lastBaseUpdate,
          shared: nt.shared,
          effects: nt.effects,
        })
  }
  function Cs(nt, rt) {
    return {
      eventTime: nt,
      lane: rt,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    }
  }
  function Is(nt, rt) {
    var ft = nt.updateQueue
    ft !== null &&
      ((ft = ft.shared),
      Fr !== null && nt.mode & 1 && !(ur & 2)
        ? ((nt = ft.interleaved),
          nt === null
            ? ((rt.next = rt), _s === null ? (_s = [ft]) : _s.push(ft))
            : ((rt.next = nt.next), (nt.next = rt)),
          (ft.interleaved = rt))
        : ((nt = ft.pending),
          nt === null ? (rt.next = rt) : ((rt.next = nt.next), (nt.next = rt)),
          (ft.pending = rt)))
  }
  function Lo(nt, rt, ft) {
    if (
      ((rt = rt.updateQueue),
      rt !== null && ((rt = rt.shared), (ft & 4194240) !== 0))
    ) {
      var mt = rt.lanes
      ;(mt &= nt.pendingLanes), (ft |= mt), (rt.lanes = ft), Vl(nt, ft)
    }
  }
  function Ju(nt, rt) {
    var ft = nt.updateQueue,
      mt = nt.alternate
    if (mt !== null && ((mt = mt.updateQueue), ft === mt)) {
      var xt = null,
        Ct = null
      if (((ft = ft.firstBaseUpdate), ft !== null)) {
        do {
          var Gt = {
            eventTime: ft.eventTime,
            lane: ft.lane,
            tag: ft.tag,
            payload: ft.payload,
            callback: ft.callback,
            next: null,
          }
          Ct === null ? (xt = Ct = Gt) : (Ct = Ct.next = Gt), (ft = ft.next)
        } while (ft !== null)
        Ct === null ? (xt = Ct = rt) : (Ct = Ct.next = rt)
      } else xt = Ct = rt
      ;(ft = {
        baseState: mt.baseState,
        firstBaseUpdate: xt,
        lastBaseUpdate: Ct,
        shared: mt.shared,
        effects: mt.effects,
      }),
        (nt.updateQueue = ft)
      return
    }
    ;(nt = ft.lastBaseUpdate),
      nt === null ? (ft.firstBaseUpdate = rt) : (nt.next = rt),
      (ft.lastBaseUpdate = rt)
  }
  function Fo(nt, rt, ft, mt) {
    var xt = nt.updateQueue
    Bs = !1
    var Ct = xt.firstBaseUpdate,
      Gt = xt.lastBaseUpdate,
      Jt = xt.shared.pending
    if (Jt !== null) {
      xt.shared.pending = null
      var fn = Jt,
        Cn = fn.next
      ;(fn.next = null), Gt === null ? (Ct = Cn) : (Gt.next = Cn), (Gt = fn)
      var zn = nt.alternate
      zn !== null &&
        ((zn = zn.updateQueue),
        (Jt = zn.lastBaseUpdate),
        Jt !== Gt &&
          (Jt === null ? (zn.firstBaseUpdate = Cn) : (Jt.next = Cn),
          (zn.lastBaseUpdate = fn)))
    }
    if (Ct !== null) {
      var ir = xt.baseState
      ;(Gt = 0), (zn = Cn = fn = null), (Jt = Ct)
      do {
        var Qn = Jt.lane,
          Mr = Jt.eventTime
        if ((mt & Qn) === Qn) {
          zn !== null &&
            (zn = zn.next =
              {
                eventTime: Mr,
                lane: 0,
                tag: Jt.tag,
                payload: Jt.payload,
                callback: Jt.callback,
                next: null,
              })
          e: {
            var Kn = nt,
              $r = Jt
            switch (((Qn = rt), (Mr = ft), $r.tag)) {
              case 1:
                if (((Kn = $r.payload), typeof Kn == "function")) {
                  ir = Kn.call(Mr, ir, Qn)
                  break e
                }
                ir = Kn
                break e
              case 3:
                Kn.flags = (Kn.flags & -65537) | 128
              case 0:
                if (
                  ((Kn = $r.payload),
                  (Qn = typeof Kn == "function" ? Kn.call(Mr, ir, Qn) : Kn),
                  Qn == null)
                )
                  break e
                ir = d({}, ir, Qn)
                break e
              case 2:
                Bs = !0
            }
          }
          Jt.callback !== null &&
            Jt.lane !== 0 &&
            ((nt.flags |= 64),
            (Qn = xt.effects),
            Qn === null ? (xt.effects = [Jt]) : Qn.push(Jt))
        } else
          (Mr = {
            eventTime: Mr,
            lane: Qn,
            tag: Jt.tag,
            payload: Jt.payload,
            callback: Jt.callback,
            next: null,
          }),
            zn === null ? ((Cn = zn = Mr), (fn = ir)) : (zn = zn.next = Mr),
            (Gt |= Qn)
        if (((Jt = Jt.next), Jt === null)) {
          if (((Jt = xt.shared.pending), Jt === null)) break
          ;(Qn = Jt),
            (Jt = Qn.next),
            (Qn.next = null),
            (xt.lastBaseUpdate = Qn),
            (xt.shared.pending = null)
        }
      } while (1)
      if (
        (zn === null && (fn = ir),
        (xt.baseState = fn),
        (xt.firstBaseUpdate = Cn),
        (xt.lastBaseUpdate = zn),
        (rt = xt.shared.interleaved),
        rt !== null)
      ) {
        xt = rt
        do (Gt |= xt.lane), (xt = xt.next)
        while (xt !== rt)
      } else Ct === null && (xt.shared.lanes = 0)
      ;(no |= Gt), (nt.lanes = Gt), (nt.memoizedState = ir)
    }
  }
  function Yu(nt, rt, ft) {
    if (((nt = rt.effects), (rt.effects = null), nt !== null))
      for (rt = 0; rt < nt.length; rt++) {
        var mt = nt[rt],
          xt = mt.callback
        if (xt !== null) {
          if (((mt.callback = null), (mt = ft), typeof xt != "function"))
            throw Error(g(191, xt))
          xt.call(mt)
        }
      }
  }
  var Ku = new o.Component().refs
  function Zl(nt, rt, ft, mt) {
    ;(rt = nt.memoizedState),
      (ft = ft(mt, rt)),
      (ft = ft == null ? rt : d({}, rt, ft)),
      (nt.memoizedState = ft),
      nt.lanes === 0 && (nt.updateQueue.baseState = ft)
  }
  var Do = {
    isMounted: function (nt) {
      return (nt = nt._reactInternals) ? yt(nt) === nt : !1
    },
    enqueueSetState: function (nt, rt, ft) {
      nt = nt._reactInternals
      var mt = Yr(),
        xt = Ds(nt),
        Ct = Cs(mt, xt)
      ;(Ct.payload = rt),
        ft != null && (Ct.callback = ft),
        Is(nt, Ct),
        (rt = ls(nt, xt, mt)),
        rt !== null && Lo(rt, nt, xt)
    },
    enqueueReplaceState: function (nt, rt, ft) {
      nt = nt._reactInternals
      var mt = Yr(),
        xt = Ds(nt),
        Ct = Cs(mt, xt)
      ;(Ct.tag = 1),
        (Ct.payload = rt),
        ft != null && (Ct.callback = ft),
        Is(nt, Ct),
        (rt = ls(nt, xt, mt)),
        rt !== null && Lo(rt, nt, xt)
    },
    enqueueForceUpdate: function (nt, rt) {
      nt = nt._reactInternals
      var ft = Yr(),
        mt = Ds(nt),
        xt = Cs(ft, mt)
      ;(xt.tag = 2),
        rt != null && (xt.callback = rt),
        Is(nt, xt),
        (rt = ls(nt, mt, ft)),
        rt !== null && Lo(rt, nt, mt)
    },
  }
  function qu(nt, rt, ft, mt, xt, Ct, Gt) {
    return (
      (nt = nt.stateNode),
      typeof nt.shouldComponentUpdate == "function"
        ? nt.shouldComponentUpdate(mt, Ct, Gt)
        : rt.prototype && rt.prototype.isPureReactComponent
        ? !Ro(ft, mt) || !Ro(xt, Ct)
        : !0
    )
  }
  function Zu(nt, rt, ft) {
    var mt = !1,
      xt = rr,
      Ct = rt.contextType
    return (
      typeof Ct == "object" && Ct !== null
        ? (Ct = ns(Ct))
        : ((xt = Er(rt) ? Sr : Ar.current),
          (mt = rt.contextTypes),
          (Ct = (mt = mt != null) ? gr(nt, xt) : rr)),
      (rt = new rt(ft, Ct)),
      (nt.memoizedState =
        rt.state !== null && rt.state !== void 0 ? rt.state : null),
      (rt.updater = Do),
      (nt.stateNode = rt),
      (rt._reactInternals = nt),
      mt &&
        ((nt = nt.stateNode),
        (nt.__reactInternalMemoizedUnmaskedChildContext = xt),
        (nt.__reactInternalMemoizedMaskedChildContext = Ct)),
      rt
    )
  }
  function Qu(nt, rt, ft, mt) {
    ;(nt = rt.state),
      typeof rt.componentWillReceiveProps == "function" &&
        rt.componentWillReceiveProps(ft, mt),
      typeof rt.UNSAFE_componentWillReceiveProps == "function" &&
        rt.UNSAFE_componentWillReceiveProps(ft, mt),
      rt.state !== nt && Do.enqueueReplaceState(rt, rt.state, null)
  }
  function Ql(nt, rt, ft, mt) {
    var xt = nt.stateNode
    ;(xt.props = ft), (xt.state = nt.memoizedState), (xt.refs = Ku), Kl(nt)
    var Ct = rt.contextType
    typeof Ct == "object" && Ct !== null
      ? (xt.context = ns(Ct))
      : ((Ct = Er(rt) ? Sr : Ar.current), (xt.context = gr(nt, Ct))),
      (xt.state = nt.memoizedState),
      (Ct = rt.getDerivedStateFromProps),
      typeof Ct == "function" &&
        (Zl(nt, rt, Ct, ft), (xt.state = nt.memoizedState)),
      typeof rt.getDerivedStateFromProps == "function" ||
        typeof xt.getSnapshotBeforeUpdate == "function" ||
        (typeof xt.UNSAFE_componentWillMount != "function" &&
          typeof xt.componentWillMount != "function") ||
        ((rt = xt.state),
        typeof xt.componentWillMount == "function" && xt.componentWillMount(),
        typeof xt.UNSAFE_componentWillMount == "function" &&
          xt.UNSAFE_componentWillMount(),
        rt !== xt.state && Do.enqueueReplaceState(xt, xt.state, null),
        Fo(nt, ft, xt, mt),
        (xt.state = nt.memoizedState)),
      typeof xt.componentDidMount == "function" && (nt.flags |= 4194308)
  }
  var Qs = [],
    na = 0,
    ko = null,
    No = 0,
    rs = [],
    ss = 0,
    Us = null,
    bs = 1,
    ws = ""
  function Vs(nt, rt) {
    ;(Qs[na++] = No), (Qs[na++] = ko), (ko = nt), (No = rt)
  }
  function _h(nt, rt, ft) {
    ;(rs[ss++] = bs), (rs[ss++] = ws), (rs[ss++] = Us), (Us = nt)
    var mt = bs
    nt = ws
    var xt = 32 - Cr(mt) - 1
    ;(mt &= ~(1 << xt)), (ft += 1)
    var Ct = 32 - Cr(rt) + xt
    if (30 < Ct) {
      var Gt = xt - (xt % 5)
      ;(Ct = (mt & ((1 << Gt) - 1)).toString(32)),
        (mt >>= Gt),
        (xt -= Gt),
        (bs = (1 << (32 - Cr(rt) + xt)) | (ft << xt) | mt),
        (ws = Ct + nt)
    } else (bs = (1 << Ct) | (ft << xt) | mt), (ws = nt)
  }
  function _c(nt) {
    nt.return !== null && (Vs(nt, 1), _h(nt, 1, 0))
  }
  function eu(nt) {
    for (; nt === ko; )
      (ko = Qs[--na]), (Qs[na] = null), (No = Qs[--na]), (Qs[na] = null)
    for (; nt === Us; )
      (Us = rs[--ss]),
        (rs[ss] = null),
        (ws = rs[--ss]),
        (rs[ss] = null),
        (bs = rs[--ss]),
        (rs[ss] = null)
  }
  var Qr = null,
    _i = null,
    br = !1,
    oo = !1,
    fs = null
  function _f(nt, rt) {
    var ft = cs(5, null, null, 0)
    ;(ft.elementType = "DELETED"),
      (ft.stateNode = rt),
      (ft.return = nt),
      (rt = nt.deletions),
      rt === null ? ((nt.deletions = [ft]), (nt.flags |= 16)) : rt.push(ft)
  }
  function _d(nt, rt) {
    switch (nt.tag) {
      case 5:
        return (
          (rt = Tr(rt, nt.type, nt.pendingProps)),
          rt !== null ? ((nt.stateNode = rt), (Qr = nt), (_i = lr(rt)), !0) : !1
        )
      case 6:
        return (
          (rt = Js(rt, nt.pendingProps)),
          rt !== null ? ((nt.stateNode = rt), (Qr = nt), (_i = null), !0) : !1
        )
      case 13:
        if (((rt = Ys(rt)), rt !== null)) {
          var ft = Us !== null ? { id: bs, overflow: ws } : null
          return (
            (nt.memoizedState = {
              dehydrated: rt,
              treeContext: ft,
              retryLane: 1073741824,
            }),
            (ft = cs(18, null, null, 0)),
            (ft.stateNode = rt),
            (ft.return = nt),
            (nt.child = ft),
            (Qr = nt),
            (_i = null),
            !0
          )
        }
        return !1
      default:
        return !1
    }
  }
  function tu(nt) {
    return (nt.mode & 1) !== 0 && (nt.flags & 128) === 0
  }
  function nu(nt) {
    if (br) {
      var rt = _i
      if (rt) {
        var ft = rt
        if (!_d(nt, rt)) {
          if (tu(nt)) throw Error(g(418))
          rt = zr(ft)
          var mt = Qr
          rt && _d(nt, rt)
            ? _f(mt, ft)
            : ((nt.flags = (nt.flags & -4097) | 2), (br = !1), (Qr = nt))
        }
      } else {
        if (tu(nt)) throw Error(g(418))
        ;(nt.flags = (nt.flags & -4097) | 2), (br = !1), (Qr = nt)
      }
    }
  }
  function ep(nt) {
    for (
      nt = nt.return;
      nt !== null && nt.tag !== 5 && nt.tag !== 3 && nt.tag !== 13;

    )
      nt = nt.return
    Qr = nt
  }
  function lo(nt) {
    if (!on || nt !== Qr) return !1
    if (!br) return ep(nt), (br = !0), !1
    if (
      nt.tag !== 3 &&
      (nt.tag !== 5 || (dn(nt.type) && !qt(nt.type, nt.memoizedProps)))
    ) {
      var rt = _i
      if (rt) {
        if (tu(nt)) {
          for (nt = _i; nt; ) nt = zr(nt)
          throw Error(g(418))
        }
        for (; rt; ) _f(nt, rt), (rt = zr(rt))
      }
    }
    if ((ep(nt), nt.tag === 13)) {
      if (!on) throw Error(g(316))
      if (
        ((nt = nt.memoizedState),
        (nt = nt !== null ? nt.dehydrated : null),
        !nt)
      )
        throw Error(g(317))
      _i = Ut(nt)
    } else _i = Qr ? zr(nt.stateNode) : null
    return !0
  }
  function ga() {
    on && ((_i = Qr = null), (oo = br = !1))
  }
  function ru(nt) {
    fs === null ? (fs = [nt]) : fs.push(nt)
  }
  function co(nt, rt, ft) {
    if (
      ((nt = ft.ref),
      nt !== null && typeof nt != "function" && typeof nt != "object")
    ) {
      if (ft._owner) {
        if (((ft = ft._owner), ft)) {
          if (ft.tag !== 1) throw Error(g(309))
          var mt = ft.stateNode
        }
        if (!mt) throw Error(g(147, nt))
        var xt = mt,
          Ct = "" + nt
        return rt !== null &&
          rt.ref !== null &&
          typeof rt.ref == "function" &&
          rt.ref._stringRef === Ct
          ? rt.ref
          : ((rt = function (Gt) {
              var Jt = xt.refs
              Jt === Ku && (Jt = xt.refs = {}),
                Gt === null ? delete Jt[Ct] : (Jt[Ct] = Gt)
            }),
            (rt._stringRef = Ct),
            rt)
      }
      if (typeof nt != "string") throw Error(g(284))
      if (!ft._owner) throw Error(g(290, nt))
    }
    return nt
  }
  function Oo(nt, rt) {
    throw (
      ((nt = Object.prototype.toString.call(rt)),
      Error(
        g(
          31,
          nt === "[object Object]"
            ? "object with keys {" + Object.keys(rt).join(", ") + "}"
            : nt
        )
      ))
    )
  }
  function tp(nt) {
    var rt = nt._init
    return rt(nt._payload)
  }
  function np(nt) {
    function rt(rn, Kt) {
      if (nt) {
        var ln = rn.deletions
        ln === null ? ((rn.deletions = [Kt]), (rn.flags |= 16)) : ln.push(Kt)
      }
    }
    function ft(rn, Kt) {
      if (!nt) return null
      for (; Kt !== null; ) rt(rn, Kt), (Kt = Kt.sibling)
      return null
    }
    function mt(rn, Kt) {
      for (rn = new Map(); Kt !== null; )
        Kt.key !== null ? rn.set(Kt.key, Kt) : rn.set(Kt.index, Kt),
          (Kt = Kt.sibling)
      return rn
    }
    function xt(rn, Kt) {
      return (rn = Ns(rn, Kt)), (rn.index = 0), (rn.sibling = null), rn
    }
    function Ct(rn, Kt, ln) {
      return (
        (rn.index = ln),
        nt
          ? ((ln = rn.alternate),
            ln !== null
              ? ((ln = ln.index), ln < Kt ? ((rn.flags |= 2), Kt) : ln)
              : ((rn.flags |= 2), Kt))
          : ((rn.flags |= 1048576), Kt)
      )
    }
    function Gt(rn) {
      return nt && rn.alternate === null && (rn.flags |= 2), rn
    }
    function Jt(rn, Kt, ln, kn) {
      return Kt === null || Kt.tag !== 6
        ? ((Kt = Vu(ln, rn.mode, kn)), (Kt.return = rn), Kt)
        : ((Kt = xt(Kt, ln)), (Kt.return = rn), Kt)
    }
    function fn(rn, Kt, ln, kn) {
      var Xn = ln.type
      return Xn === $
        ? zn(rn, Kt, ln.props.children, kn, ln.key)
        : Kt !== null &&
          (Kt.elementType === Xn ||
            (typeof Xn == "object" &&
              Xn !== null &&
              Xn.$$typeof === lt &&
              tp(Xn) === Kt.type))
        ? ((kn = xt(Kt, ln.props)),
          (kn.ref = co(rn, Kt, ln)),
          (kn.return = rn),
          kn)
        : ((kn = Dl(ln.type, ln.key, ln.props, null, rn.mode, kn)),
          (kn.ref = co(rn, Kt, ln)),
          (kn.return = rn),
          kn)
    }
    function Cn(rn, Kt, ln, kn) {
      return Kt === null ||
        Kt.tag !== 4 ||
        Kt.stateNode.containerInfo !== ln.containerInfo ||
        Kt.stateNode.implementation !== ln.implementation
        ? ((Kt = Gu(ln, rn.mode, kn)), (Kt.return = rn), Kt)
        : ((Kt = xt(Kt, ln.children || [])), (Kt.return = rn), Kt)
    }
    function zn(rn, Kt, ln, kn, Xn) {
      return Kt === null || Kt.tag !== 7
        ? ((Kt = Xs(ln, rn.mode, kn, Xn)), (Kt.return = rn), Kt)
        : ((Kt = xt(Kt, ln)), (Kt.return = rn), Kt)
    }
    function ir(rn, Kt, ln) {
      if ((typeof Kt == "string" && Kt !== "") || typeof Kt == "number")
        return (Kt = Vu("" + Kt, rn.mode, ln)), (Kt.return = rn), Kt
      if (typeof Kt == "object" && Kt !== null) {
        switch (Kt.$$typeof) {
          case b:
            return (
              (ln = Dl(Kt.type, Kt.key, Kt.props, null, rn.mode, ln)),
              (ln.ref = co(rn, null, Kt)),
              (ln.return = rn),
              ln
            )
          case j:
            return (Kt = Gu(Kt, rn.mode, ln)), (Kt.return = rn), Kt
          case lt:
            var kn = Kt._init
            return ir(rn, kn(Kt._payload), ln)
        }
        if (Dt(Kt) || pt(Kt))
          return (Kt = Xs(Kt, rn.mode, ln, null)), (Kt.return = rn), Kt
        Oo(rn, Kt)
      }
      return null
    }
    function Qn(rn, Kt, ln, kn) {
      var Xn = Kt !== null ? Kt.key : null
      if ((typeof ln == "string" && ln !== "") || typeof ln == "number")
        return Xn !== null ? null : Jt(rn, Kt, "" + ln, kn)
      if (typeof ln == "object" && ln !== null) {
        switch (ln.$$typeof) {
          case b:
            return ln.key === Xn ? fn(rn, Kt, ln, kn) : null
          case j:
            return ln.key === Xn ? Cn(rn, Kt, ln, kn) : null
          case lt:
            return (Xn = ln._init), Qn(rn, Kt, Xn(ln._payload), kn)
        }
        if (Dt(ln) || pt(ln))
          return Xn !== null ? null : zn(rn, Kt, ln, kn, null)
        Oo(rn, ln)
      }
      return null
    }
    function Mr(rn, Kt, ln, kn, Xn) {
      if ((typeof kn == "string" && kn !== "") || typeof kn == "number")
        return (rn = rn.get(ln) || null), Jt(Kt, rn, "" + kn, Xn)
      if (typeof kn == "object" && kn !== null) {
        switch (kn.$$typeof) {
          case b:
            return (
              (rn = rn.get(kn.key === null ? ln : kn.key) || null),
              fn(Kt, rn, kn, Xn)
            )
          case j:
            return (
              (rn = rn.get(kn.key === null ? ln : kn.key) || null),
              Cn(Kt, rn, kn, Xn)
            )
          case lt:
            var cr = kn._init
            return Mr(rn, Kt, ln, cr(kn._payload), Xn)
        }
        if (Dt(kn) || pt(kn))
          return (rn = rn.get(ln) || null), zn(Kt, rn, kn, Xn, null)
        Oo(Kt, kn)
      }
      return null
    }
    function Kn(rn, Kt, ln, kn) {
      for (
        var Xn = null, cr = null, sr = Kt, yr = (Kt = 0), Vr = null;
        sr !== null && yr < ln.length;
        yr++
      ) {
        sr.index > yr ? ((Vr = sr), (sr = null)) : (Vr = sr.sibling)
        var _r = Qn(rn, sr, ln[yr], kn)
        if (_r === null) {
          sr === null && (sr = Vr)
          break
        }
        nt && sr && _r.alternate === null && rt(rn, sr),
          (Kt = Ct(_r, Kt, yr)),
          cr === null ? (Xn = _r) : (cr.sibling = _r),
          (cr = _r),
          (sr = Vr)
      }
      if (yr === ln.length) return ft(rn, sr), br && Vs(rn, yr), Xn
      if (sr === null) {
        for (; yr < ln.length; yr++)
          (sr = ir(rn, ln[yr], kn)),
            sr !== null &&
              ((Kt = Ct(sr, Kt, yr)),
              cr === null ? (Xn = sr) : (cr.sibling = sr),
              (cr = sr))
        return br && Vs(rn, yr), Xn
      }
      for (sr = mt(rn, sr); yr < ln.length; yr++)
        (Vr = Mr(sr, rn, yr, ln[yr], kn)),
          Vr !== null &&
            (nt &&
              Vr.alternate !== null &&
              sr.delete(Vr.key === null ? yr : Vr.key),
            (Kt = Ct(Vr, Kt, yr)),
            cr === null ? (Xn = Vr) : (cr.sibling = Vr),
            (cr = Vr))
      return (
        nt &&
          sr.forEach(function (Os) {
            return rt(rn, Os)
          }),
        br && Vs(rn, yr),
        Xn
      )
    }
    function $r(rn, Kt, ln, kn) {
      var Xn = pt(ln)
      if (typeof Xn != "function") throw Error(g(150))
      if (((ln = Xn.call(ln)), ln == null)) throw Error(g(151))
      for (
        var cr = (Xn = null), sr = Kt, yr = (Kt = 0), Vr = null, _r = ln.next();
        sr !== null && !_r.done;
        yr++, _r = ln.next()
      ) {
        sr.index > yr ? ((Vr = sr), (sr = null)) : (Vr = sr.sibling)
        var Os = Qn(rn, sr, _r.value, kn)
        if (Os === null) {
          sr === null && (sr = Vr)
          break
        }
        nt && sr && Os.alternate === null && rt(rn, sr),
          (Kt = Ct(Os, Kt, yr)),
          cr === null ? (Xn = Os) : (cr.sibling = Os),
          (cr = Os),
          (sr = Vr)
      }
      if (_r.done) return ft(rn, sr), br && Vs(rn, yr), Xn
      if (sr === null) {
        for (; !_r.done; yr++, _r = ln.next())
          (_r = ir(rn, _r.value, kn)),
            _r !== null &&
              ((Kt = Ct(_r, Kt, yr)),
              cr === null ? (Xn = _r) : (cr.sibling = _r),
              (cr = _r))
        return br && Vs(rn, yr), Xn
      }
      for (sr = mt(rn, sr); !_r.done; yr++, _r = ln.next())
        (_r = Mr(sr, rn, yr, _r.value, kn)),
          _r !== null &&
            (nt &&
              _r.alternate !== null &&
              sr.delete(_r.key === null ? yr : _r.key),
            (Kt = Ct(_r, Kt, yr)),
            cr === null ? (Xn = _r) : (cr.sibling = _r),
            (cr = _r))
      return (
        nt &&
          sr.forEach(function (a0) {
            return rt(rn, a0)
          }),
        br && Vs(rn, yr),
        Xn
      )
    }
    function us(rn, Kt, ln, kn) {
      if (
        (typeof ln == "object" &&
          ln !== null &&
          ln.type === $ &&
          ln.key === null &&
          (ln = ln.props.children),
        typeof ln == "object" && ln !== null)
      ) {
        switch (ln.$$typeof) {
          case b:
            e: {
              for (var Xn = ln.key, cr = Kt; cr !== null; ) {
                if (cr.key === Xn) {
                  if (((Xn = ln.type), Xn === $)) {
                    if (cr.tag === 7) {
                      ft(rn, cr.sibling),
                        (Kt = xt(cr, ln.props.children)),
                        (Kt.return = rn),
                        (rn = Kt)
                      break e
                    }
                  } else if (
                    cr.elementType === Xn ||
                    (typeof Xn == "object" &&
                      Xn !== null &&
                      Xn.$$typeof === lt &&
                      tp(Xn) === cr.type)
                  ) {
                    ft(rn, cr.sibling),
                      (Kt = xt(cr, ln.props)),
                      (Kt.ref = co(rn, cr, ln)),
                      (Kt.return = rn),
                      (rn = Kt)
                    break e
                  }
                  ft(rn, cr)
                  break
                } else rt(rn, cr)
                cr = cr.sibling
              }
              ln.type === $
                ? ((Kt = Xs(ln.props.children, rn.mode, kn, ln.key)),
                  (Kt.return = rn),
                  (rn = Kt))
                : ((kn = Dl(ln.type, ln.key, ln.props, null, rn.mode, kn)),
                  (kn.ref = co(rn, Kt, ln)),
                  (kn.return = rn),
                  (rn = kn))
            }
            return Gt(rn)
          case j:
            e: {
              for (cr = ln.key; Kt !== null; ) {
                if (Kt.key === cr)
                  if (
                    Kt.tag === 4 &&
                    Kt.stateNode.containerInfo === ln.containerInfo &&
                    Kt.stateNode.implementation === ln.implementation
                  ) {
                    ft(rn, Kt.sibling),
                      (Kt = xt(Kt, ln.children || [])),
                      (Kt.return = rn),
                      (rn = Kt)
                    break e
                  } else {
                    ft(rn, Kt)
                    break
                  }
                else rt(rn, Kt)
                Kt = Kt.sibling
              }
              ;(Kt = Gu(ln, rn.mode, kn)), (Kt.return = rn), (rn = Kt)
            }
            return Gt(rn)
          case lt:
            return (cr = ln._init), us(rn, Kt, cr(ln._payload), kn)
        }
        if (Dt(ln)) return Kn(rn, Kt, ln, kn)
        if (pt(ln)) return $r(rn, Kt, ln, kn)
        Oo(rn, ln)
      }
      return (typeof ln == "string" && ln !== "") || typeof ln == "number"
        ? ((ln = "" + ln),
          Kt !== null && Kt.tag === 6
            ? (ft(rn, Kt.sibling),
              (Kt = xt(Kt, ln)),
              (Kt.return = rn),
              (rn = Kt))
            : (ft(rn, Kt),
              (Kt = Vu(ln, rn.mode, kn)),
              (Kt.return = rn),
              (rn = Kt)),
          Gt(rn))
        : ft(rn, Kt)
    }
    return us
  }
  var xa = np(!0),
    rp = np(!1),
    uo = {},
    as = Dn(uo),
    ho = Dn(uo),
    ba = Dn(uo)
  function xs(nt) {
    if (nt === uo) throw Error(g(174))
    return nt
  }
  function iu(nt, rt) {
    Wn(ba, rt), Wn(ho, nt), Wn(as, uo), (nt = wt(rt)), er(as), Wn(as, nt)
  }
  function $a() {
    er(as), er(ho), er(ba)
  }
  function sp(nt) {
    var rt = xs(ba.current),
      ft = xs(as.current)
    ;(rt = gt(ft, nt.type, rt)), ft !== rt && (Wn(ho, nt), Wn(as, rt))
  }
  function su(nt) {
    ho.current === nt && (er(as), er(ho))
  }
  var Pr = Dn(0)
  function Uo(nt) {
    for (var rt = nt; rt !== null; ) {
      if (rt.tag === 13) {
        var ft = rt.memoizedState
        if (
          ft !== null &&
          ((ft = ft.dehydrated), ft === null || Es(ft) || ds(ft))
        )
          return rt
      } else if (rt.tag === 19 && rt.memoizedProps.revealOrder !== void 0) {
        if (rt.flags & 128) return rt
      } else if (rt.child !== null) {
        ;(rt.child.return = rt), (rt = rt.child)
        continue
      }
      if (rt === nt) break
      for (; rt.sibling === null; ) {
        if (rt.return === null || rt.return === nt) return null
        rt = rt.return
      }
      ;(rt.sibling.return = rt.return), (rt = rt.sibling)
    }
    return null
  }
  var au = []
  function ou() {
    for (var nt = 0; nt < au.length; nt++) {
      var rt = au[nt]
      Vn
        ? (rt._workInProgressVersionPrimary = null)
        : (rt._workInProgressVersionSecondary = null)
    }
    au.length = 0
  }
  var Vo = _.ReactCurrentDispatcher,
    os = _.ReactCurrentBatchConfig,
    eo = 0,
    Rr = null,
    Hr = null,
    Ur = null,
    Go = !1,
    fo = !1,
    po = 0,
    Im = 0
  function Wr() {
    throw Error(g(321))
  }
  function lu(nt, rt) {
    if (rt === null) return !1
    for (var ft = 0; ft < rt.length && ft < nt.length; ft++)
      if (!vs(nt[ft], rt[ft])) return !1
    return !0
  }
  function cu(nt, rt, ft, mt, xt, Ct) {
    if (
      ((eo = Ct),
      (Rr = rt),
      (rt.memoizedState = null),
      (rt.updateQueue = null),
      (rt.lanes = 0),
      (Vo.current = nt === null || nt.memoizedState === null ? km : Nm),
      (nt = ft(mt, xt)),
      fo)
    ) {
      Ct = 0
      do {
        if (((fo = !1), (po = 0), 25 <= Ct)) throw Error(g(301))
        ;(Ct += 1),
          (Ur = Hr = null),
          (rt.updateQueue = null),
          (Vo.current = Om),
          (nt = ft(mt, xt))
      } while (fo)
    }
    if (
      ((Vo.current = $o),
      (rt = Hr !== null && Hr.next !== null),
      (eo = 0),
      (Ur = Hr = Rr = null),
      (Go = !1),
      rt)
    )
      throw Error(g(300))
    return nt
  }
  function uu() {
    var nt = po !== 0
    return (po = 0), nt
  }
  function Ps() {
    var nt = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    }
    return Ur === null ? (Rr.memoizedState = Ur = nt) : (Ur = Ur.next = nt), Ur
  }
  function As() {
    if (Hr === null) {
      var nt = Rr.alternate
      nt = nt !== null ? nt.memoizedState : null
    } else nt = Hr.next
    var rt = Ur === null ? Rr.memoizedState : Ur.next
    if (rt !== null) (Ur = rt), (Hr = nt)
    else {
      if (nt === null) throw Error(g(310))
      ;(Hr = nt),
        (nt = {
          memoizedState: Hr.memoizedState,
          baseState: Hr.baseState,
          baseQueue: Hr.baseQueue,
          queue: Hr.queue,
          next: null,
        }),
        Ur === null ? (Rr.memoizedState = Ur = nt) : (Ur = Ur.next = nt)
    }
    return Ur
  }
  function Gs(nt, rt) {
    return typeof rt == "function" ? rt(nt) : rt
  }
  function zo(nt) {
    var rt = As(),
      ft = rt.queue
    if (ft === null) throw Error(g(311))
    ft.lastRenderedReducer = nt
    var mt = Hr,
      xt = mt.baseQueue,
      Ct = ft.pending
    if (Ct !== null) {
      if (xt !== null) {
        var Gt = xt.next
        ;(xt.next = Ct.next), (Ct.next = Gt)
      }
      ;(mt.baseQueue = xt = Ct), (ft.pending = null)
    }
    if (xt !== null) {
      ;(Ct = xt.next), (mt = mt.baseState)
      var Jt = (Gt = null),
        fn = null,
        Cn = Ct
      do {
        var zn = Cn.lane
        if ((eo & zn) === zn)
          fn !== null &&
            (fn = fn.next =
              {
                lane: 0,
                action: Cn.action,
                hasEagerState: Cn.hasEagerState,
                eagerState: Cn.eagerState,
                next: null,
              }),
            (mt = Cn.hasEagerState ? Cn.eagerState : nt(mt, Cn.action))
        else {
          var ir = {
            lane: zn,
            action: Cn.action,
            hasEagerState: Cn.hasEagerState,
            eagerState: Cn.eagerState,
            next: null,
          }
          fn === null ? ((Jt = fn = ir), (Gt = mt)) : (fn = fn.next = ir),
            (Rr.lanes |= zn),
            (no |= zn)
        }
        Cn = Cn.next
      } while (Cn !== null && Cn !== Ct)
      fn === null ? (Gt = mt) : (fn.next = Jt),
        vs(mt, rt.memoizedState) || (es = !0),
        (rt.memoizedState = mt),
        (rt.baseState = Gt),
        (rt.baseQueue = fn),
        (ft.lastRenderedState = mt)
    }
    if (((nt = ft.interleaved), nt !== null)) {
      xt = nt
      do (Ct = xt.lane), (Rr.lanes |= Ct), (no |= Ct), (xt = xt.next)
      while (xt !== nt)
    } else xt === null && (ft.lanes = 0)
    return [rt.memoizedState, ft.dispatch]
  }
  function Ho(nt) {
    var rt = As(),
      ft = rt.queue
    if (ft === null) throw Error(g(311))
    ft.lastRenderedReducer = nt
    var mt = ft.dispatch,
      xt = ft.pending,
      Ct = rt.memoizedState
    if (xt !== null) {
      ft.pending = null
      var Gt = (xt = xt.next)
      do (Ct = nt(Ct, Gt.action)), (Gt = Gt.next)
      while (Gt !== xt)
      vs(Ct, rt.memoizedState) || (es = !0),
        (rt.memoizedState = Ct),
        rt.baseQueue === null && (rt.baseState = Ct),
        (ft.lastRenderedState = Ct)
    }
    return [Ct, mt]
  }
  function ap() {}
  function lp(nt, rt) {
    var ft = Rr,
      mt = As(),
      xt = rt(),
      Ct = !vs(mt.memoizedState, xt)
    if (
      (Ct && ((mt.memoizedState = xt), (es = !0)),
      (mt = mt.queue),
      go(hp.bind(null, ft, mt, nt), [nt]),
      mt.getSnapshot !== rt || Ct || (Ur !== null && Ur.memoizedState.tag & 1))
    ) {
      if (
        ((ft.flags |= 2048),
        mo(9, up.bind(null, ft, mt, xt, rt), void 0, null),
        Fr === null)
      )
        throw Error(g(349))
      eo & 30 || cp(ft, rt, xt)
    }
    return xt
  }
  function cp(nt, rt, ft) {
    ;(nt.flags |= 16384),
      (nt = { getSnapshot: rt, value: ft }),
      (rt = Rr.updateQueue),
      rt === null
        ? ((rt = { lastEffect: null, stores: null }),
          (Rr.updateQueue = rt),
          (rt.stores = [nt]))
        : ((ft = rt.stores), ft === null ? (rt.stores = [nt]) : ft.push(nt))
  }
  function up(nt, rt, ft, mt) {
    ;(rt.value = ft), (rt.getSnapshot = mt), fp(rt) && ls(nt, 1, -1)
  }
  function hp(nt, rt, ft) {
    return ft(function () {
      fp(rt) && ls(nt, 1, -1)
    })
  }
  function fp(nt) {
    var rt = nt.getSnapshot
    nt = nt.value
    try {
      var ft = rt()
      return !vs(nt, ft)
    } catch {
      return !0
    }
  }
  function hu(nt) {
    var rt = Ps()
    return (
      typeof nt == "function" && (nt = nt()),
      (rt.memoizedState = rt.baseState = nt),
      (nt = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Gs,
        lastRenderedState: nt,
      }),
      (rt.queue = nt),
      (nt = nt.dispatch = Dm.bind(null, Rr, nt)),
      [rt.memoizedState, nt]
    )
  }
  function mo(nt, rt, ft, mt) {
    return (
      (nt = { tag: nt, create: rt, destroy: ft, deps: mt, next: null }),
      (rt = Rr.updateQueue),
      rt === null
        ? ((rt = { lastEffect: null, stores: null }),
          (Rr.updateQueue = rt),
          (rt.lastEffect = nt.next = nt))
        : ((ft = rt.lastEffect),
          ft === null
            ? (rt.lastEffect = nt.next = nt)
            : ((mt = ft.next),
              (ft.next = nt),
              (nt.next = mt),
              (rt.lastEffect = nt))),
      nt
    )
  }
  function dp() {
    return As().memoizedState
  }
  function Wo(nt, rt, ft, mt) {
    var xt = Ps()
    ;(Rr.flags |= nt),
      (xt.memoizedState = mo(1 | rt, ft, void 0, mt === void 0 ? null : mt))
  }
  function jo(nt, rt, ft, mt) {
    var xt = As()
    mt = mt === void 0 ? null : mt
    var Ct = void 0
    if (Hr !== null) {
      var Gt = Hr.memoizedState
      if (((Ct = Gt.destroy), mt !== null && lu(mt, Gt.deps))) {
        xt.memoizedState = mo(rt, ft, Ct, mt)
        return
      }
    }
    ;(Rr.flags |= nt), (xt.memoizedState = mo(1 | rt, ft, Ct, mt))
  }
  function fu(nt, rt) {
    return Wo(8390656, 8, nt, rt)
  }
  function go(nt, rt) {
    return jo(2048, 8, nt, rt)
  }
  function pp(nt, rt) {
    return jo(4, 2, nt, rt)
  }
  function mp(nt, rt) {
    return jo(4, 4, nt, rt)
  }
  function gp(nt, rt) {
    if (typeof rt == "function")
      return (
        (nt = nt()),
        rt(nt),
        function () {
          rt(null)
        }
      )
    if (rt != null)
      return (
        (nt = nt()),
        (rt.current = nt),
        function () {
          rt.current = null
        }
      )
  }
  function vp(nt, rt, ft) {
    return (
      (ft = ft != null ? ft.concat([nt]) : null),
      jo(4, 4, gp.bind(null, rt, nt), ft)
    )
  }
  function du() {}
  function yp(nt, rt) {
    var ft = As()
    rt = rt === void 0 ? null : rt
    var mt = ft.memoizedState
    return mt !== null && rt !== null && lu(rt, mt[1])
      ? mt[0]
      : ((ft.memoizedState = [nt, rt]), nt)
  }
  function _p(nt, rt) {
    var ft = As()
    rt = rt === void 0 ? null : rt
    var mt = ft.memoizedState
    return mt !== null && rt !== null && lu(rt, mt[1])
      ? mt[0]
      : ((nt = nt()), (ft.memoizedState = [nt, rt]), nt)
  }
  function Lm(nt, rt) {
    var ft = vr
    ;(vr = ft !== 0 && 4 > ft ? ft : 4), nt(!0)
    var mt = os.transition
    os.transition = {}
    try {
      nt(!1), rt()
    } finally {
      ;(vr = ft), (os.transition = mt)
    }
  }
  function xp() {
    return As().memoizedState
  }
  function Fm(nt, rt, ft) {
    var mt = Ds(nt)
    ;(ft = {
      lane: mt,
      action: ft,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      Ap(nt)
        ? Sp(rt, ft)
        : (Ep(nt, rt, ft),
          (ft = Yr()),
          (nt = ls(nt, mt, ft)),
          nt !== null && Mp(nt, rt, mt))
  }
  function Dm(nt, rt, ft) {
    var mt = Ds(nt),
      xt = {
        lane: mt,
        action: ft,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }
    if (Ap(nt)) Sp(rt, xt)
    else {
      Ep(nt, rt, xt)
      var Ct = nt.alternate
      if (
        nt.lanes === 0 &&
        (Ct === null || Ct.lanes === 0) &&
        ((Ct = rt.lastRenderedReducer), Ct !== null)
      )
        try {
          var Gt = rt.lastRenderedState,
            Jt = Ct(Gt, ft)
          if (((xt.hasEagerState = !0), (xt.eagerState = Jt), vs(Jt, Gt)))
            return
        } catch {
        } finally {
        }
      ;(ft = Yr()), (nt = ls(nt, mt, ft)), nt !== null && Mp(nt, rt, mt)
    }
  }
  function Ap(nt) {
    var rt = nt.alternate
    return nt === Rr || (rt !== null && rt === Rr)
  }
  function Sp(nt, rt) {
    fo = Go = !0
    var ft = nt.pending
    ft === null ? (rt.next = rt) : ((rt.next = ft.next), (ft.next = rt)),
      (nt.pending = rt)
  }
  function Ep(nt, rt, ft) {
    Fr !== null && nt.mode & 1 && !(ur & 2)
      ? ((nt = rt.interleaved),
        nt === null
          ? ((ft.next = ft), _s === null ? (_s = [rt]) : _s.push(rt))
          : ((ft.next = nt.next), (nt.next = ft)),
        (rt.interleaved = ft))
      : ((nt = rt.pending),
        nt === null ? (ft.next = ft) : ((ft.next = nt.next), (nt.next = ft)),
        (rt.pending = ft))
  }
  function Mp(nt, rt, ft) {
    if (ft & 4194240) {
      var mt = rt.lanes
      ;(mt &= nt.pendingLanes), (ft |= mt), (rt.lanes = ft), Vl(nt, ft)
    }
  }
  var $o = {
      readContext: ns,
      useCallback: Wr,
      useContext: Wr,
      useEffect: Wr,
      useImperativeHandle: Wr,
      useInsertionEffect: Wr,
      useLayoutEffect: Wr,
      useMemo: Wr,
      useReducer: Wr,
      useRef: Wr,
      useState: Wr,
      useDebugValue: Wr,
      useDeferredValue: Wr,
      useTransition: Wr,
      useMutableSource: Wr,
      useSyncExternalStore: Wr,
      useId: Wr,
      unstable_isNewReconciler: !1,
    },
    km = {
      readContext: ns,
      useCallback: function (nt, rt) {
        return (Ps().memoizedState = [nt, rt === void 0 ? null : rt]), nt
      },
      useContext: ns,
      useEffect: fu,
      useImperativeHandle: function (nt, rt, ft) {
        return (
          (ft = ft != null ? ft.concat([nt]) : null),
          Wo(4194308, 4, gp.bind(null, rt, nt), ft)
        )
      },
      useLayoutEffect: function (nt, rt) {
        return Wo(4194308, 4, nt, rt)
      },
      useInsertionEffect: function (nt, rt) {
        return Wo(4, 2, nt, rt)
      },
      useMemo: function (nt, rt) {
        var ft = Ps()
        return (
          (rt = rt === void 0 ? null : rt),
          (nt = nt()),
          (ft.memoizedState = [nt, rt]),
          nt
        )
      },
      useReducer: function (nt, rt, ft) {
        var mt = Ps()
        return (
          (rt = ft !== void 0 ? ft(rt) : rt),
          (mt.memoizedState = mt.baseState = rt),
          (nt = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: nt,
            lastRenderedState: rt,
          }),
          (mt.queue = nt),
          (nt = nt.dispatch = Fm.bind(null, Rr, nt)),
          [mt.memoizedState, nt]
        )
      },
      useRef: function (nt) {
        var rt = Ps()
        return (nt = { current: nt }), (rt.memoizedState = nt)
      },
      useState: hu,
      useDebugValue: du,
      useDeferredValue: function (nt) {
        var rt = hu(nt),
          ft = rt[0],
          mt = rt[1]
        return (
          fu(
            function () {
              var xt = os.transition
              os.transition = {}
              try {
                mt(nt)
              } finally {
                os.transition = xt
              }
            },
            [nt]
          ),
          ft
        )
      },
      useTransition: function () {
        var nt = hu(!1),
          rt = nt[0]
        return (nt = Lm.bind(null, nt[1])), (Ps().memoizedState = nt), [rt, nt]
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (nt, rt, ft) {
        var mt = Rr,
          xt = Ps()
        if (br) {
          if (ft === void 0) throw Error(g(407))
          ft = ft()
        } else {
          if (((ft = rt()), Fr === null)) throw Error(g(349))
          eo & 30 || cp(mt, rt, ft)
        }
        xt.memoizedState = ft
        var Ct = { value: ft, getSnapshot: rt }
        return (
          (xt.queue = Ct),
          fu(hp.bind(null, mt, Ct, nt), [nt]),
          (mt.flags |= 2048),
          mo(9, up.bind(null, mt, Ct, ft, rt), void 0, null),
          ft
        )
      },
      useId: function () {
        var nt = Ps(),
          rt = Fr.identifierPrefix
        if (br) {
          var ft = ws,
            mt = bs
          ;(ft = (mt & ~(1 << (32 - Cr(mt) - 1))).toString(32) + ft),
            (rt = ":" + rt + "R" + ft),
            (ft = po++),
            0 < ft && (rt += "H" + ft.toString(32)),
            (rt += ":")
        } else (ft = Im++), (rt = ":" + rt + "r" + ft.toString(32) + ":")
        return (nt.memoizedState = rt)
      },
      unstable_isNewReconciler: !1,
    },
    Nm = {
      readContext: ns,
      useCallback: yp,
      useContext: ns,
      useEffect: go,
      useImperativeHandle: vp,
      useInsertionEffect: pp,
      useLayoutEffect: mp,
      useMemo: _p,
      useReducer: zo,
      useRef: dp,
      useState: function () {
        return zo(Gs)
      },
      useDebugValue: du,
      useDeferredValue: function (nt) {
        var rt = zo(Gs),
          ft = rt[0],
          mt = rt[1]
        return (
          go(
            function () {
              var xt = os.transition
              os.transition = {}
              try {
                mt(nt)
              } finally {
                os.transition = xt
              }
            },
            [nt]
          ),
          ft
        )
      },
      useTransition: function () {
        var nt = zo(Gs)[0],
          rt = As().memoizedState
        return [nt, rt]
      },
      useMutableSource: ap,
      useSyncExternalStore: lp,
      useId: xp,
      unstable_isNewReconciler: !1,
    },
    Om = {
      readContext: ns,
      useCallback: yp,
      useContext: ns,
      useEffect: go,
      useImperativeHandle: vp,
      useInsertionEffect: pp,
      useLayoutEffect: mp,
      useMemo: _p,
      useReducer: Ho,
      useRef: dp,
      useState: function () {
        return Ho(Gs)
      },
      useDebugValue: du,
      useDeferredValue: function (nt) {
        var rt = Ho(Gs),
          ft = rt[0],
          mt = rt[1]
        return (
          go(
            function () {
              var xt = os.transition
              os.transition = {}
              try {
                mt(nt)
              } finally {
                os.transition = xt
              }
            },
            [nt]
          ),
          ft
        )
      },
      useTransition: function () {
        var nt = Ho(Gs)[0],
          rt = As().memoizedState
        return [nt, rt]
      },
      useMutableSource: ap,
      useSyncExternalStore: lp,
      useId: xp,
      unstable_isNewReconciler: !1,
    }
  function pu(nt, rt) {
    try {
      var ft = "",
        mt = rt
      do (ft += Bm(mt)), (mt = mt.return)
      while (mt)
      var xt = ft
    } catch (Ct) {
      xt =
        `
Error generating stack: ` +
        Ct.message +
        `
` +
        Ct.stack
    }
    return { value: nt, source: rt, stack: xt }
  }
  function mu(nt, rt) {
    try {
      console.error(rt.value)
    } catch (ft) {
      setTimeout(function () {
        throw ft
      })
    }
  }
  var Um = typeof WeakMap == "function" ? WeakMap : Map
  function Tp(nt, rt, ft) {
    ;(ft = Cs(-1, ft)), (ft.tag = 3), (ft.payload = { element: null })
    var mt = rt.value
    return (
      (ft.callback = function () {
        Cl || ((Cl = !0), (Lu = mt)), mu(nt, rt)
      }),
      ft
    )
  }
  function Cp(nt, rt, ft) {
    ;(ft = Cs(-1, ft)), (ft.tag = 3)
    var mt = nt.type.getDerivedStateFromError
    if (typeof mt == "function") {
      var xt = rt.value
      ;(ft.payload = function () {
        return mt(xt)
      }),
        (ft.callback = function () {
          mu(nt, rt)
        })
    }
    var Ct = nt.stateNode
    return (
      Ct !== null &&
        typeof Ct.componentDidCatch == "function" &&
        (ft.callback = function () {
          mu(nt, rt),
            typeof mt != "function" &&
              (Ls === null ? (Ls = new Set([this])) : Ls.add(this))
          var Gt = rt.stack
          this.componentDidCatch(rt.value, {
            componentStack: Gt !== null ? Gt : "",
          })
        }),
      ft
    )
  }
  function bp(nt, rt, ft) {
    var mt = nt.pingCache
    if (mt === null) {
      mt = nt.pingCache = new Um()
      var xt = new Set()
      mt.set(rt, xt)
    } else
      (xt = mt.get(rt)), xt === void 0 && ((xt = new Set()), mt.set(rt, xt))
    xt.has(ft) ||
      (xt.add(ft), (nt = Qm.bind(null, nt, rt, ft)), rt.then(nt, nt))
  }
  function wp(nt) {
    do {
      var rt
      if (
        ((rt = nt.tag === 13) &&
          ((rt = nt.memoizedState),
          (rt = rt !== null ? rt.dehydrated !== null : !0)),
        rt)
      )
        return nt
      nt = nt.return
    } while (nt !== null)
    return null
  }
  function Pp(nt, rt, ft, mt, xt) {
    return nt.mode & 1
      ? ((nt.flags |= 65536), (nt.lanes = xt), nt)
      : (nt === rt
          ? (nt.flags |= 65536)
          : ((nt.flags |= 128),
            (ft.flags |= 131072),
            (ft.flags &= -52805),
            ft.tag === 1 &&
              (ft.alternate === null
                ? (ft.tag = 17)
                : ((rt = Cs(-1, 1)), (rt.tag = 2), Is(ft, rt))),
            (ft.lanes |= 1)),
        nt)
  }
  function Ss(nt) {
    nt.flags |= 4
  }
  function Rp(nt, rt) {
    if (nt !== null && nt.child === rt.child) return !0
    if (rt.flags & 16) return !1
    for (nt = rt.child; nt !== null; ) {
      if (nt.flags & 12854 || nt.subtreeFlags & 12854) return !1
      nt = nt.sibling
    }
    return !0
  }
  var vo, yo, Xo, Jo
  if (gn)
    (vo = function (nt, rt) {
      for (var ft = rt.child; ft !== null; ) {
        if (ft.tag === 5 || ft.tag === 6) It(nt, ft.stateNode)
        else if (ft.tag !== 4 && ft.child !== null) {
          ;(ft.child.return = ft), (ft = ft.child)
          continue
        }
        if (ft === rt) break
        for (; ft.sibling === null; ) {
          if (ft.return === null || ft.return === rt) return
          ft = ft.return
        }
        ;(ft.sibling.return = ft.return), (ft = ft.sibling)
      }
    }),
      (yo = function () {}),
      (Xo = function (nt, rt, ft, mt, xt) {
        if (((nt = nt.memoizedProps), nt !== mt)) {
          var Ct = rt.stateNode,
            Gt = xs(as.current)
          ;(ft = Xt(Ct, ft, nt, mt, xt, Gt)), (rt.updateQueue = ft) && Ss(rt)
        }
      }),
      (Jo = function (nt, rt, ft, mt) {
        ft !== mt && Ss(rt)
      })
  else if (Ht) {
    vo = function (nt, rt, ft, mt) {
      for (var xt = rt.child; xt !== null; ) {
        if (xt.tag === 5) {
          var Ct = xt.stateNode
          ft && mt && (Ct = dr(Ct, xt.type, xt.memoizedProps, xt)), It(nt, Ct)
        } else if (xt.tag === 6)
          (Ct = xt.stateNode),
            ft && mt && (Ct = Br(Ct, xt.memoizedProps, xt)),
            It(nt, Ct)
        else if (xt.tag !== 4) {
          if (xt.tag === 22 && xt.memoizedState !== null)
            (Ct = xt.child), Ct !== null && (Ct.return = xt), vo(nt, xt, !0, !0)
          else if (xt.child !== null) {
            ;(xt.child.return = xt), (xt = xt.child)
            continue
          }
        }
        if (xt === rt) break
        for (; xt.sibling === null; ) {
          if (xt.return === null || xt.return === rt) return
          xt = xt.return
        }
        ;(xt.sibling.return = xt.return), (xt = xt.sibling)
      }
    }
    var Bp = function (nt, rt, ft, mt) {
      for (var xt = rt.child; xt !== null; ) {
        if (xt.tag === 5) {
          var Ct = xt.stateNode
          ft && mt && (Ct = dr(Ct, xt.type, xt.memoizedProps, xt)), hr(nt, Ct)
        } else if (xt.tag === 6)
          (Ct = xt.stateNode),
            ft && mt && (Ct = Br(Ct, xt.memoizedProps, xt)),
            hr(nt, Ct)
        else if (xt.tag !== 4) {
          if (xt.tag === 22 && xt.memoizedState !== null)
            (Ct = xt.child), Ct !== null && (Ct.return = xt), Bp(nt, xt, !0, !0)
          else if (xt.child !== null) {
            ;(xt.child.return = xt), (xt = xt.child)
            continue
          }
        }
        if (xt === rt) break
        for (; xt.sibling === null; ) {
          if (xt.return === null || xt.return === rt) return
          xt = xt.return
        }
        ;(xt.sibling.return = xt.return), (xt = xt.sibling)
      }
    }
    ;(yo = function (nt, rt) {
      var ft = rt.stateNode
      if (!Rp(nt, rt)) {
        nt = ft.containerInfo
        var mt = or(nt)
        Bp(mt, rt, !1, !1), (ft.pendingChildren = mt), Ss(rt), mr(nt, mt)
      }
    }),
      (Xo = function (nt, rt, ft, mt, xt) {
        var Ct = nt.stateNode,
          Gt = nt.memoizedProps
        if ((nt = Rp(nt, rt)) && Gt === mt) rt.stateNode = Ct
        else {
          var Jt = rt.stateNode,
            fn = xs(as.current),
            Cn = null
          Gt !== mt && (Cn = Xt(Jt, ft, Gt, mt, xt, fn)),
            nt && Cn === null
              ? (rt.stateNode = Ct)
              : ((Ct = In(Ct, Cn, ft, Gt, mt, rt, nt, Jt)),
                $t(Ct, ft, mt, xt, fn) && Ss(rt),
                (rt.stateNode = Ct),
                nt ? Ss(rt) : vo(Ct, rt, !1, !1))
        }
      }),
      (Jo = function (nt, rt, ft, mt) {
        ft !== mt
          ? ((nt = xs(ba.current)),
            (ft = xs(as.current)),
            (rt.stateNode = en(mt, nt, ft, rt)),
            Ss(rt))
          : (rt.stateNode = nt.stateNode)
      })
  } else (yo = function () {}), (Xo = function () {}), (Jo = function () {})
  function _o(nt, rt) {
    if (!br)
      switch (nt.tailMode) {
        case "hidden":
          rt = nt.tail
          for (var ft = null; rt !== null; )
            rt.alternate !== null && (ft = rt), (rt = rt.sibling)
          ft === null ? (nt.tail = null) : (ft.sibling = null)
          break
        case "collapsed":
          ft = nt.tail
          for (var mt = null; ft !== null; )
            ft.alternate !== null && (mt = ft), (ft = ft.sibling)
          mt === null
            ? rt || nt.tail === null
              ? (nt.tail = null)
              : (nt.tail.sibling = null)
            : (mt.sibling = null)
      }
  }
  function jr(nt) {
    var rt = nt.alternate !== null && nt.alternate.child === nt.child,
      ft = 0,
      mt = 0
    if (rt)
      for (var xt = nt.child; xt !== null; )
        (ft |= xt.lanes | xt.childLanes),
          (mt |= xt.subtreeFlags & 14680064),
          (mt |= xt.flags & 14680064),
          (xt.return = nt),
          (xt = xt.sibling)
    else
      for (xt = nt.child; xt !== null; )
        (ft |= xt.lanes | xt.childLanes),
          (mt |= xt.subtreeFlags),
          (mt |= xt.flags),
          (xt.return = nt),
          (xt = xt.sibling)
    return (nt.subtreeFlags |= mt), (nt.childLanes = ft), rt
  }
  function Vm(nt, rt, ft) {
    var mt = rt.pendingProps
    switch ((eu(rt), rt.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return jr(rt), null
      case 1:
        return Er(rt.type) && Ir(), jr(rt), null
      case 3:
        return (
          (mt = rt.stateNode),
          $a(),
          er(tr),
          er(Ar),
          ou(),
          mt.pendingContext &&
            ((mt.context = mt.pendingContext), (mt.pendingContext = null)),
          (nt === null || nt.child === null) &&
            (lo(rt)
              ? Ss(rt)
              : nt === null ||
                (nt.memoizedState.isDehydrated && !(rt.flags & 256)) ||
                ((rt.flags |= 1024), fs !== null && (ku(fs), (fs = null)))),
          yo(nt, rt),
          jr(rt),
          null
        )
      case 5:
        su(rt), (ft = xs(ba.current))
        var xt = rt.type
        if (nt !== null && rt.stateNode != null)
          Xo(nt, rt, xt, mt, ft),
            nt.ref !== rt.ref && ((rt.flags |= 512), (rt.flags |= 2097152))
        else {
          if (!mt) {
            if (rt.stateNode === null) throw Error(g(166))
            return jr(rt), null
          }
          if (((nt = xs(as.current)), lo(rt))) {
            if (!on) throw Error(g(175))
            ;(nt = Pt(
              rt.stateNode,
              rt.type,
              rt.memoizedProps,
              ft,
              nt,
              rt,
              !oo
            )),
              (rt.updateQueue = nt),
              nt !== null && Ss(rt)
          } else {
            var Ct = Tt(xt, mt, ft, nt, rt)
            vo(Ct, rt, !1, !1),
              (rt.stateNode = Ct),
              $t(Ct, xt, mt, ft, nt) && Ss(rt)
          }
          rt.ref !== null && ((rt.flags |= 512), (rt.flags |= 2097152))
        }
        return jr(rt), null
      case 6:
        if (nt && rt.stateNode != null) Jo(nt, rt, nt.memoizedProps, mt)
        else {
          if (typeof mt != "string" && rt.stateNode === null)
            throw Error(g(166))
          if (((nt = xs(ba.current)), (ft = xs(as.current)), lo(rt))) {
            if (!on) throw Error(g(176))
            if (
              ((nt = rt.stateNode),
              (mt = rt.memoizedProps),
              (ft = St(nt, mt, rt, !oo)) && ((xt = Qr), xt !== null))
            )
              switch (((Ct = (xt.mode & 1) !== 0), xt.tag)) {
                case 3:
                  hn(xt.stateNode.containerInfo, nt, mt, Ct)
                  break
                case 5:
                  mn(xt.type, xt.memoizedProps, xt.stateNode, nt, mt, Ct)
              }
            ft && Ss(rt)
          } else rt.stateNode = en(mt, nt, ft, rt)
        }
        return jr(rt), null
      case 13:
        if (
          (er(Pr),
          (mt = rt.memoizedState),
          br && _i !== null && rt.mode & 1 && !(rt.flags & 128))
        ) {
          for (nt = _i; nt; ) nt = zr(nt)
          return ga(), (rt.flags |= 98560), rt
        }
        if (mt !== null && mt.dehydrated !== null) {
          if (((mt = lo(rt)), nt === null)) {
            if (!mt) throw Error(g(318))
            if (!on) throw Error(g(344))
            if (
              ((nt = rt.memoizedState),
              (nt = nt !== null ? nt.dehydrated : null),
              !nt)
            )
              throw Error(g(317))
            Bt(nt, rt)
          } else
            ga(),
              !(rt.flags & 128) && (rt.memoizedState = null),
              (rt.flags |= 4)
          return jr(rt), null
        }
        return (
          fs !== null && (ku(fs), (fs = null)),
          rt.flags & 128
            ? ((rt.lanes = ft), rt)
            : ((mt = mt !== null),
              (ft = !1),
              nt === null ? lo(rt) : (ft = nt.memoizedState !== null),
              mt &&
                !ft &&
                ((rt.child.flags |= 8192),
                rt.mode & 1 &&
                  (nt === null || Pr.current & 1
                    ? Nr === 0 && (Nr = 3)
                    : Ou())),
              rt.updateQueue !== null && (rt.flags |= 4),
              jr(rt),
              null)
        )
      case 4:
        return (
          $a(),
          yo(nt, rt),
          nt === null && _n(rt.stateNode.containerInfo),
          jr(rt),
          null
        )
      case 10:
        return Jl(rt.type._context), jr(rt), null
      case 17:
        return Er(rt.type) && Ir(), jr(rt), null
      case 19:
        if ((er(Pr), (xt = rt.memoizedState), xt === null)) return jr(rt), null
        if (((mt = (rt.flags & 128) !== 0), (Ct = xt.rendering), Ct === null))
          if (mt) _o(xt, !1)
          else {
            if (Nr !== 0 || (nt !== null && nt.flags & 128))
              for (nt = rt.child; nt !== null; ) {
                if (((Ct = Uo(nt)), Ct !== null)) {
                  for (
                    rt.flags |= 128,
                      _o(xt, !1),
                      nt = Ct.updateQueue,
                      nt !== null && ((rt.updateQueue = nt), (rt.flags |= 4)),
                      rt.subtreeFlags = 0,
                      nt = ft,
                      mt = rt.child;
                    mt !== null;

                  )
                    (ft = mt),
                      (xt = nt),
                      (ft.flags &= 14680066),
                      (Ct = ft.alternate),
                      Ct === null
                        ? ((ft.childLanes = 0),
                          (ft.lanes = xt),
                          (ft.child = null),
                          (ft.subtreeFlags = 0),
                          (ft.memoizedProps = null),
                          (ft.memoizedState = null),
                          (ft.updateQueue = null),
                          (ft.dependencies = null),
                          (ft.stateNode = null))
                        : ((ft.childLanes = Ct.childLanes),
                          (ft.lanes = Ct.lanes),
                          (ft.child = Ct.child),
                          (ft.subtreeFlags = 0),
                          (ft.deletions = null),
                          (ft.memoizedProps = Ct.memoizedProps),
                          (ft.memoizedState = Ct.memoizedState),
                          (ft.updateQueue = Ct.updateQueue),
                          (ft.type = Ct.type),
                          (xt = Ct.dependencies),
                          (ft.dependencies =
                            xt === null
                              ? null
                              : {
                                  lanes: xt.lanes,
                                  firstContext: xt.firstContext,
                                })),
                      (mt = mt.sibling)
                  return Wn(Pr, (Pr.current & 1) | 2), rt.child
                }
                nt = nt.sibling
              }
            xt.tail !== null &&
              Or() > Iu &&
              ((rt.flags |= 128), (mt = !0), _o(xt, !1), (rt.lanes = 4194304))
          }
        else {
          if (!mt)
            if (((nt = Uo(Ct)), nt !== null)) {
              if (
                ((rt.flags |= 128),
                (mt = !0),
                (nt = nt.updateQueue),
                nt !== null && ((rt.updateQueue = nt), (rt.flags |= 4)),
                _o(xt, !0),
                xt.tail === null &&
                  xt.tailMode === "hidden" &&
                  !Ct.alternate &&
                  !br)
              )
                return jr(rt), null
            } else
              2 * Or() - xt.renderingStartTime > Iu &&
                ft !== 1073741824 &&
                ((rt.flags |= 128), (mt = !0), _o(xt, !1), (rt.lanes = 4194304))
          xt.isBackwards
            ? ((Ct.sibling = rt.child), (rt.child = Ct))
            : ((nt = xt.last),
              nt !== null ? (nt.sibling = Ct) : (rt.child = Ct),
              (xt.last = Ct))
        }
        return xt.tail !== null
          ? ((rt = xt.tail),
            (xt.rendering = rt),
            (xt.tail = rt.sibling),
            (xt.renderingStartTime = Or()),
            (rt.sibling = null),
            (nt = Pr.current),
            Wn(Pr, mt ? (nt & 1) | 2 : nt & 1),
            rt)
          : (jr(rt), null)
      case 22:
      case 23:
        return (
          Nu(),
          (mt = rt.memoizedState !== null),
          nt !== null &&
            (nt.memoizedState !== null) !== mt &&
            (rt.flags |= 8192),
          mt && rt.mode & 1
            ? ts & 1073741824 &&
              (jr(rt), gn && rt.subtreeFlags & 6 && (rt.flags |= 8192))
            : jr(rt),
          null
        )
      case 24:
        return null
      case 25:
        return null
    }
    throw Error(g(156, rt.tag))
  }
  var Gm = _.ReactCurrentOwner,
    es = !1
  function Jr(nt, rt, ft, mt) {
    rt.child = nt === null ? rp(rt, null, ft, mt) : xa(rt, nt.child, ft, mt)
  }
  function Ip(nt, rt, ft, mt, xt) {
    ft = ft.render
    var Ct = rt.ref
    return (
      Zs(rt, xt),
      (mt = cu(nt, rt, ft, mt, Ct, xt)),
      (ft = uu()),
      nt !== null && !es
        ? ((rt.updateQueue = nt.updateQueue),
          (rt.flags &= -2053),
          (nt.lanes &= ~xt),
          Rs(nt, rt, xt))
        : (br && ft && _c(rt), (rt.flags |= 1), Jr(nt, rt, mt, xt), rt.child)
    )
  }
  function Lp(nt, rt, ft, mt, xt) {
    if (nt === null) {
      var Ct = ft.type
      return typeof Ct == "function" &&
        !Uu(Ct) &&
        Ct.defaultProps === void 0 &&
        ft.compare === null &&
        ft.defaultProps === void 0
        ? ((rt.tag = 15), (rt.type = Ct), Fp(nt, rt, Ct, mt, xt))
        : ((nt = Dl(ft.type, null, mt, rt, rt.mode, xt)),
          (nt.ref = rt.ref),
          (nt.return = rt),
          (rt.child = nt))
    }
    if (((Ct = nt.child), !(nt.lanes & xt))) {
      var Gt = Ct.memoizedProps
      if (
        ((ft = ft.compare),
        (ft = ft !== null ? ft : Ro),
        ft(Gt, mt) && nt.ref === rt.ref)
      )
        return Rs(nt, rt, xt)
    }
    return (
      (rt.flags |= 1),
      (nt = Ns(Ct, mt)),
      (nt.ref = rt.ref),
      (nt.return = rt),
      (rt.child = nt)
    )
  }
  function Fp(nt, rt, ft, mt, xt) {
    if (nt !== null && Ro(nt.memoizedProps, mt) && nt.ref === rt.ref)
      if (((es = !1), (nt.lanes & xt) !== 0)) nt.flags & 131072 && (es = !0)
      else return (rt.lanes = nt.lanes), Rs(nt, rt, xt)
    return gu(nt, rt, ft, mt, xt)
  }
  function Dp(nt, rt, ft) {
    var mt = rt.pendingProps,
      xt = mt.children,
      Ct = nt !== null ? nt.memoizedState : null
    if (mt.mode === "hidden")
      if (!(rt.mode & 1))
        (rt.memoizedState = { baseLanes: 0, cachePool: null }),
          Wn(to, ts),
          (ts |= ft)
      else if (ft & 1073741824)
        (rt.memoizedState = { baseLanes: 0, cachePool: null }),
          (mt = Ct !== null ? Ct.baseLanes : ft),
          Wn(to, ts),
          (ts |= mt)
      else
        return (
          (nt = Ct !== null ? Ct.baseLanes | ft : ft),
          (rt.lanes = rt.childLanes = 1073741824),
          (rt.memoizedState = { baseLanes: nt, cachePool: null }),
          (rt.updateQueue = null),
          Wn(to, ts),
          (ts |= nt),
          null
        )
    else
      Ct !== null
        ? ((mt = Ct.baseLanes | ft), (rt.memoizedState = null))
        : (mt = ft),
        Wn(to, ts),
        (ts |= mt)
    return Jr(nt, rt, xt, ft), rt.child
  }
  function kp(nt, rt) {
    var ft = rt.ref
    ;((nt === null && ft !== null) || (nt !== null && nt.ref !== ft)) &&
      ((rt.flags |= 512), (rt.flags |= 2097152))
  }
  function gu(nt, rt, ft, mt, xt) {
    var Ct = Er(ft) ? Sr : Ar.current
    return (
      (Ct = gr(rt, Ct)),
      Zs(rt, xt),
      (ft = cu(nt, rt, ft, mt, Ct, xt)),
      (mt = uu()),
      nt !== null && !es
        ? ((rt.updateQueue = nt.updateQueue),
          (rt.flags &= -2053),
          (nt.lanes &= ~xt),
          Rs(nt, rt, xt))
        : (br && mt && _c(rt), (rt.flags |= 1), Jr(nt, rt, ft, xt), rt.child)
    )
  }
  function Np(nt, rt, ft, mt, xt) {
    if (Er(ft)) {
      var Ct = !0
      xr(rt)
    } else Ct = !1
    if ((Zs(rt, xt), rt.stateNode === null))
      nt !== null &&
        ((nt.alternate = null), (rt.alternate = null), (rt.flags |= 2)),
        Zu(rt, ft, mt),
        Ql(rt, ft, mt, xt),
        (mt = !0)
    else if (nt === null) {
      var Gt = rt.stateNode,
        Jt = rt.memoizedProps
      Gt.props = Jt
      var fn = Gt.context,
        Cn = ft.contextType
      typeof Cn == "object" && Cn !== null
        ? (Cn = ns(Cn))
        : ((Cn = Er(ft) ? Sr : Ar.current), (Cn = gr(rt, Cn)))
      var zn = ft.getDerivedStateFromProps,
        ir =
          typeof zn == "function" ||
          typeof Gt.getSnapshotBeforeUpdate == "function"
      ir ||
        (typeof Gt.UNSAFE_componentWillReceiveProps != "function" &&
          typeof Gt.componentWillReceiveProps != "function") ||
        ((Jt !== mt || fn !== Cn) && Qu(rt, Gt, mt, Cn)),
        (Bs = !1)
      var Qn = rt.memoizedState
      ;(Gt.state = Qn),
        Fo(rt, mt, Gt, xt),
        (fn = rt.memoizedState),
        Jt !== mt || Qn !== fn || tr.current || Bs
          ? (typeof zn == "function" &&
              (Zl(rt, ft, zn, mt), (fn = rt.memoizedState)),
            (Jt = Bs || qu(rt, ft, Jt, mt, Qn, fn, Cn))
              ? (ir ||
                  (typeof Gt.UNSAFE_componentWillMount != "function" &&
                    typeof Gt.componentWillMount != "function") ||
                  (typeof Gt.componentWillMount == "function" &&
                    Gt.componentWillMount(),
                  typeof Gt.UNSAFE_componentWillMount == "function" &&
                    Gt.UNSAFE_componentWillMount()),
                typeof Gt.componentDidMount == "function" &&
                  (rt.flags |= 4194308))
              : (typeof Gt.componentDidMount == "function" &&
                  (rt.flags |= 4194308),
                (rt.memoizedProps = mt),
                (rt.memoizedState = fn)),
            (Gt.props = mt),
            (Gt.state = fn),
            (Gt.context = Cn),
            (mt = Jt))
          : (typeof Gt.componentDidMount == "function" && (rt.flags |= 4194308),
            (mt = !1))
    } else {
      ;(Gt = rt.stateNode),
        Xu(nt, rt),
        (Jt = rt.memoizedProps),
        (Cn = rt.type === rt.elementType ? Jt : hs(rt.type, Jt)),
        (Gt.props = Cn),
        (ir = rt.pendingProps),
        (Qn = Gt.context),
        (fn = ft.contextType),
        typeof fn == "object" && fn !== null
          ? (fn = ns(fn))
          : ((fn = Er(ft) ? Sr : Ar.current), (fn = gr(rt, fn)))
      var Mr = ft.getDerivedStateFromProps
      ;(zn =
        typeof Mr == "function" ||
        typeof Gt.getSnapshotBeforeUpdate == "function") ||
        (typeof Gt.UNSAFE_componentWillReceiveProps != "function" &&
          typeof Gt.componentWillReceiveProps != "function") ||
        ((Jt !== ir || Qn !== fn) && Qu(rt, Gt, mt, fn)),
        (Bs = !1),
        (Qn = rt.memoizedState),
        (Gt.state = Qn),
        Fo(rt, mt, Gt, xt)
      var Kn = rt.memoizedState
      Jt !== ir || Qn !== Kn || tr.current || Bs
        ? (typeof Mr == "function" &&
            (Zl(rt, ft, Mr, mt), (Kn = rt.memoizedState)),
          (Cn = Bs || qu(rt, ft, Cn, mt, Qn, Kn, fn) || !1)
            ? (zn ||
                (typeof Gt.UNSAFE_componentWillUpdate != "function" &&
                  typeof Gt.componentWillUpdate != "function") ||
                (typeof Gt.componentWillUpdate == "function" &&
                  Gt.componentWillUpdate(mt, Kn, fn),
                typeof Gt.UNSAFE_componentWillUpdate == "function" &&
                  Gt.UNSAFE_componentWillUpdate(mt, Kn, fn)),
              typeof Gt.componentDidUpdate == "function" && (rt.flags |= 4),
              typeof Gt.getSnapshotBeforeUpdate == "function" &&
                (rt.flags |= 1024))
            : (typeof Gt.componentDidUpdate != "function" ||
                (Jt === nt.memoizedProps && Qn === nt.memoizedState) ||
                (rt.flags |= 4),
              typeof Gt.getSnapshotBeforeUpdate != "function" ||
                (Jt === nt.memoizedProps && Qn === nt.memoizedState) ||
                (rt.flags |= 1024),
              (rt.memoizedProps = mt),
              (rt.memoizedState = Kn)),
          (Gt.props = mt),
          (Gt.state = Kn),
          (Gt.context = fn),
          (mt = Cn))
        : (typeof Gt.componentDidUpdate != "function" ||
            (Jt === nt.memoizedProps && Qn === nt.memoizedState) ||
            (rt.flags |= 4),
          typeof Gt.getSnapshotBeforeUpdate != "function" ||
            (Jt === nt.memoizedProps && Qn === nt.memoizedState) ||
            (rt.flags |= 1024),
          (mt = !1))
    }
    return vu(nt, rt, ft, mt, Ct, xt)
  }
  function vu(nt, rt, ft, mt, xt, Ct) {
    kp(nt, rt)
    var Gt = (rt.flags & 128) !== 0
    if (!mt && !Gt) return xt && pr(rt, ft, !1), Rs(nt, rt, Ct)
    ;(mt = rt.stateNode), (Gm.current = rt)
    var Jt =
      Gt && typeof ft.getDerivedStateFromError != "function"
        ? null
        : mt.render()
    return (
      (rt.flags |= 1),
      nt !== null && Gt
        ? ((rt.child = xa(rt, nt.child, null, Ct)),
          (rt.child = xa(rt, null, Jt, Ct)))
        : Jr(nt, rt, Jt, Ct),
      (rt.memoizedState = mt.state),
      xt && pr(rt, ft, !0),
      rt.child
    )
  }
  function Op(nt) {
    var rt = nt.stateNode
    rt.pendingContext
      ? nr(nt, rt.pendingContext, rt.pendingContext !== rt.context)
      : rt.context && nr(nt, rt.context, !1),
      iu(nt, rt.containerInfo)
  }
  function Up(nt, rt, ft, mt, xt) {
    return ga(), ru(xt), (rt.flags |= 256), Jr(nt, rt, ft, mt), rt.child
  }
  var Yo = { dehydrated: null, treeContext: null, retryLane: 0 }
  function Ko(nt) {
    return { baseLanes: nt, cachePool: null }
  }
  function Vp(nt, rt, ft) {
    var mt = rt.pendingProps,
      xt = Pr.current,
      Ct = !1,
      Gt = (rt.flags & 128) !== 0,
      Jt
    if (
      ((Jt = Gt) ||
        (Jt = nt !== null && nt.memoizedState === null ? !1 : (xt & 2) !== 0),
      Jt
        ? ((Ct = !0), (rt.flags &= -129))
        : (nt === null || nt.memoizedState !== null) && (xt |= 1),
      Wn(Pr, xt & 1),
      nt === null)
    )
      return (
        nu(rt),
        (nt = rt.memoizedState),
        nt !== null && ((nt = nt.dehydrated), nt !== null)
          ? (rt.mode & 1
              ? ds(nt)
                ? (rt.lanes = 8)
                : (rt.lanes = 1073741824)
              : (rt.lanes = 1),
            null)
          : ((xt = mt.children),
            (nt = mt.fallback),
            Ct
              ? ((mt = rt.mode),
                (Ct = rt.child),
                (xt = { mode: "hidden", children: xt }),
                !(mt & 1) && Ct !== null
                  ? ((Ct.childLanes = 0), (Ct.pendingProps = xt))
                  : (Ct = Nl(xt, mt, 0, null)),
                (nt = Xs(nt, mt, ft, null)),
                (Ct.return = rt),
                (nt.return = rt),
                (Ct.sibling = nt),
                (rt.child = Ct),
                (rt.child.memoizedState = Ko(ft)),
                (rt.memoizedState = Yo),
                nt)
              : yu(rt, xt))
      )
    if (((xt = nt.memoizedState), xt !== null)) {
      if (((Jt = xt.dehydrated), Jt !== null)) {
        if (Gt)
          return rt.flags & 256
            ? ((rt.flags &= -257), qo(nt, rt, ft, Error(g(422))))
            : rt.memoizedState !== null
            ? ((rt.child = nt.child), (rt.flags |= 128), null)
            : ((Ct = mt.fallback),
              (xt = rt.mode),
              (mt = Nl(
                { mode: "visible", children: mt.children },
                xt,
                0,
                null
              )),
              (Ct = Xs(Ct, xt, ft, null)),
              (Ct.flags |= 2),
              (mt.return = rt),
              (Ct.return = rt),
              (mt.sibling = Ct),
              (rt.child = mt),
              rt.mode & 1 && xa(rt, nt.child, null, ft),
              (rt.child.memoizedState = Ko(ft)),
              (rt.memoizedState = Yo),
              Ct)
        if (!(rt.mode & 1)) rt = qo(nt, rt, ft, null)
        else if (ds(Jt)) rt = qo(nt, rt, ft, Error(g(419)))
        else if (((mt = (ft & nt.childLanes) !== 0), es || mt)) {
          if (((mt = Fr), mt !== null)) {
            switch (ft & -ft) {
              case 4:
                Ct = 2
                break
              case 16:
                Ct = 8
                break
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                Ct = 32
                break
              case 536870912:
                Ct = 268435456
                break
              default:
                Ct = 0
            }
            ;(mt = Ct & (mt.suspendedLanes | ft) ? 0 : Ct),
              mt !== 0 &&
                mt !== xt.retryLane &&
                ((xt.retryLane = mt), ls(nt, mt, -1))
          }
          Ou(), (rt = qo(nt, rt, ft, Error(g(421))))
        } else
          Es(Jt)
            ? ((rt.flags |= 128),
              (rt.child = nt.child),
              (rt = _g.bind(null, nt)),
              ps(Jt, rt),
              (rt = null))
            : ((ft = xt.treeContext),
              on &&
                ((_i = io(Jt)),
                (Qr = rt),
                (br = !0),
                (fs = null),
                (oo = !1),
                ft !== null &&
                  ((rs[ss++] = bs),
                  (rs[ss++] = ws),
                  (rs[ss++] = Us),
                  (bs = ft.id),
                  (ws = ft.overflow),
                  (Us = rt))),
              (rt = yu(rt, rt.pendingProps.children)),
              (rt.flags |= 4096))
        return rt
      }
      return Ct
        ? ((mt = zp(nt, rt, mt.children, mt.fallback, ft)),
          (Ct = rt.child),
          (xt = nt.child.memoizedState),
          (Ct.memoizedState =
            xt === null
              ? Ko(ft)
              : { baseLanes: xt.baseLanes | ft, cachePool: null }),
          (Ct.childLanes = nt.childLanes & ~ft),
          (rt.memoizedState = Yo),
          mt)
        : ((ft = Gp(nt, rt, mt.children, ft)), (rt.memoizedState = null), ft)
    }
    return Ct
      ? ((mt = zp(nt, rt, mt.children, mt.fallback, ft)),
        (Ct = rt.child),
        (xt = nt.child.memoizedState),
        (Ct.memoizedState =
          xt === null
            ? Ko(ft)
            : { baseLanes: xt.baseLanes | ft, cachePool: null }),
        (Ct.childLanes = nt.childLanes & ~ft),
        (rt.memoizedState = Yo),
        mt)
      : ((ft = Gp(nt, rt, mt.children, ft)), (rt.memoizedState = null), ft)
  }
  function yu(nt, rt) {
    return (
      (rt = Nl({ mode: "visible", children: rt }, nt.mode, 0, null)),
      (rt.return = nt),
      (nt.child = rt)
    )
  }
  function Gp(nt, rt, ft, mt) {
    var xt = nt.child
    return (
      (nt = xt.sibling),
      (ft = Ns(xt, { mode: "visible", children: ft })),
      !(rt.mode & 1) && (ft.lanes = mt),
      (ft.return = rt),
      (ft.sibling = null),
      nt !== null &&
        ((mt = rt.deletions),
        mt === null ? ((rt.deletions = [nt]), (rt.flags |= 16)) : mt.push(nt)),
      (rt.child = ft)
    )
  }
  function zp(nt, rt, ft, mt, xt) {
    var Ct = rt.mode
    nt = nt.child
    var Gt = nt.sibling,
      Jt = { mode: "hidden", children: ft }
    return (
      !(Ct & 1) && rt.child !== nt
        ? ((ft = rt.child),
          (ft.childLanes = 0),
          (ft.pendingProps = Jt),
          (rt.deletions = null))
        : ((ft = Ns(nt, Jt)), (ft.subtreeFlags = nt.subtreeFlags & 14680064)),
      Gt !== null
        ? (mt = Ns(Gt, mt))
        : ((mt = Xs(mt, Ct, xt, null)), (mt.flags |= 2)),
      (mt.return = rt),
      (ft.return = rt),
      (ft.sibling = mt),
      (rt.child = ft),
      mt
    )
  }
  function qo(nt, rt, ft, mt) {
    return (
      mt !== null && ru(mt),
      xa(rt, nt.child, null, ft),
      (nt = yu(rt, rt.pendingProps.children)),
      (nt.flags |= 2),
      (rt.memoizedState = null),
      nt
    )
  }
  function Hp(nt, rt, ft) {
    nt.lanes |= rt
    var mt = nt.alternate
    mt !== null && (mt.lanes |= rt), Yl(nt.return, rt, ft)
  }
  function _u(nt, rt, ft, mt, xt) {
    var Ct = nt.memoizedState
    Ct === null
      ? (nt.memoizedState = {
          isBackwards: rt,
          rendering: null,
          renderingStartTime: 0,
          last: mt,
          tail: ft,
          tailMode: xt,
        })
      : ((Ct.isBackwards = rt),
        (Ct.rendering = null),
        (Ct.renderingStartTime = 0),
        (Ct.last = mt),
        (Ct.tail = ft),
        (Ct.tailMode = xt))
  }
  function Wp(nt, rt, ft) {
    var mt = rt.pendingProps,
      xt = mt.revealOrder,
      Ct = mt.tail
    if ((Jr(nt, rt, mt.children, ft), (mt = Pr.current), mt & 2))
      (mt = (mt & 1) | 2), (rt.flags |= 128)
    else {
      if (nt !== null && nt.flags & 128)
        e: for (nt = rt.child; nt !== null; ) {
          if (nt.tag === 13) nt.memoizedState !== null && Hp(nt, ft, rt)
          else if (nt.tag === 19) Hp(nt, ft, rt)
          else if (nt.child !== null) {
            ;(nt.child.return = nt), (nt = nt.child)
            continue
          }
          if (nt === rt) break e
          for (; nt.sibling === null; ) {
            if (nt.return === null || nt.return === rt) break e
            nt = nt.return
          }
          ;(nt.sibling.return = nt.return), (nt = nt.sibling)
        }
      mt &= 1
    }
    if ((Wn(Pr, mt), !(rt.mode & 1))) rt.memoizedState = null
    else
      switch (xt) {
        case "forwards":
          for (ft = rt.child, xt = null; ft !== null; )
            (nt = ft.alternate),
              nt !== null && Uo(nt) === null && (xt = ft),
              (ft = ft.sibling)
          ;(ft = xt),
            ft === null
              ? ((xt = rt.child), (rt.child = null))
              : ((xt = ft.sibling), (ft.sibling = null)),
            _u(rt, !1, xt, ft, Ct)
          break
        case "backwards":
          for (ft = null, xt = rt.child, rt.child = null; xt !== null; ) {
            if (((nt = xt.alternate), nt !== null && Uo(nt) === null)) {
              rt.child = xt
              break
            }
            ;(nt = xt.sibling), (xt.sibling = ft), (ft = xt), (xt = nt)
          }
          _u(rt, !0, ft, null, Ct)
          break
        case "together":
          _u(rt, !1, null, null, void 0)
          break
        default:
          rt.memoizedState = null
      }
    return rt.child
  }
  function Rs(nt, rt, ft) {
    if (
      (nt !== null && (rt.dependencies = nt.dependencies),
      (no |= rt.lanes),
      !(ft & rt.childLanes))
    )
      return null
    if (nt !== null && rt.child !== nt.child) throw Error(g(153))
    if (rt.child !== null) {
      for (
        nt = rt.child,
          ft = Ns(nt, nt.pendingProps),
          rt.child = ft,
          ft.return = rt;
        nt.sibling !== null;

      )
        (nt = nt.sibling),
          (ft = ft.sibling = Ns(nt, nt.pendingProps)),
          (ft.return = rt)
      ft.sibling = null
    }
    return rt.child
  }
  function zm(nt, rt, ft) {
    switch (rt.tag) {
      case 3:
        Op(rt), ga()
        break
      case 5:
        sp(rt)
        break
      case 1:
        Er(rt.type) && xr(rt)
        break
      case 4:
        iu(rt, rt.stateNode.containerInfo)
        break
      case 10:
        $u(rt, rt.type._context, rt.memoizedProps.value)
        break
      case 13:
        var mt = rt.memoizedState
        if (mt !== null)
          return mt.dehydrated !== null
            ? (Wn(Pr, Pr.current & 1), (rt.flags |= 128), null)
            : ft & rt.child.childLanes
            ? Vp(nt, rt, ft)
            : (Wn(Pr, Pr.current & 1),
              (nt = Rs(nt, rt, ft)),
              nt !== null ? nt.sibling : null)
        Wn(Pr, Pr.current & 1)
        break
      case 19:
        if (((mt = (ft & rt.childLanes) !== 0), nt.flags & 128)) {
          if (mt) return Wp(nt, rt, ft)
          rt.flags |= 128
        }
        var xt = rt.memoizedState
        if (
          (xt !== null &&
            ((xt.rendering = null), (xt.tail = null), (xt.lastEffect = null)),
          Wn(Pr, Pr.current),
          mt)
        )
          break
        return null
      case 22:
      case 23:
        return (rt.lanes = 0), Dp(nt, rt, ft)
    }
    return Rs(nt, rt, ft)
  }
  function Hm(nt, rt) {
    switch ((eu(rt), rt.tag)) {
      case 1:
        return (
          Er(rt.type) && Ir(),
          (nt = rt.flags),
          nt & 65536 ? ((rt.flags = (nt & -65537) | 128), rt) : null
        )
      case 3:
        return (
          $a(),
          er(tr),
          er(Ar),
          ou(),
          (nt = rt.flags),
          nt & 65536 && !(nt & 128)
            ? ((rt.flags = (nt & -65537) | 128), rt)
            : null
        )
      case 5:
        return su(rt), null
      case 13:
        if (
          (er(Pr),
          (nt = rt.memoizedState),
          nt !== null && nt.dehydrated !== null)
        ) {
          if (rt.alternate === null) throw Error(g(340))
          ga()
        }
        return (
          (nt = rt.flags),
          nt & 65536 ? ((rt.flags = (nt & -65537) | 128), rt) : null
        )
      case 19:
        return er(Pr), null
      case 4:
        return $a(), null
      case 10:
        return Jl(rt.type._context), null
      case 22:
      case 23:
        return Nu(), null
      case 24:
        return null
      default:
        return null
    }
  }
  var Zo = !1,
    zs = !1,
    Wm = typeof WeakSet == "function" ? WeakSet : Set,
    Ln = null
  function Qo(nt, rt) {
    var ft = nt.ref
    if (ft !== null)
      if (typeof ft == "function")
        try {
          ft(null)
        } catch (mt) {
          Zr(nt, rt, mt)
        }
      else ft.current = null
  }
  function xu(nt, rt, ft) {
    try {
      ft()
    } catch (mt) {
      Zr(nt, rt, mt)
    }
  }
  var jp = !1
  function jm(nt, rt) {
    for (At(nt.containerInfo), Ln = rt; Ln !== null; )
      if (
        ((nt = Ln),
        (rt = nt.child),
        (nt.subtreeFlags & 1028) !== 0 && rt !== null)
      )
        (rt.return = nt), (Ln = rt)
      else
        for (; Ln !== null; ) {
          nt = Ln
          try {
            var ft = nt.alternate
            if (nt.flags & 1024)
              switch (nt.tag) {
                case 0:
                case 11:
                case 15:
                  break
                case 1:
                  if (ft !== null) {
                    var mt = ft.memoizedProps,
                      xt = ft.memoizedState,
                      Ct = nt.stateNode,
                      Gt = Ct.getSnapshotBeforeUpdate(
                        nt.elementType === nt.type ? mt : hs(nt.type, mt),
                        xt
                      )
                    Ct.__reactInternalSnapshotBeforeUpdate = Gt
                  }
                  break
                case 3:
                  gn && En(nt.stateNode.containerInfo)
                  break
                case 5:
                case 6:
                case 4:
                case 17:
                  break
                default:
                  throw Error(g(163))
              }
          } catch (Jt) {
            Zr(nt, nt.return, Jt)
          }
          if (((rt = nt.sibling), rt !== null)) {
            ;(rt.return = nt.return), (Ln = rt)
            break
          }
          Ln = nt.return
        }
    return (ft = jp), (jp = !1), ft
  }
  function Hs(nt, rt, ft) {
    var mt = rt.updateQueue
    if (((mt = mt !== null ? mt.lastEffect : null), mt !== null)) {
      var xt = (mt = mt.next)
      do {
        if ((xt.tag & nt) === nt) {
          var Ct = xt.destroy
          ;(xt.destroy = void 0), Ct !== void 0 && xu(rt, ft, Ct)
        }
        xt = xt.next
      } while (xt !== mt)
    }
  }
  function xo(nt, rt) {
    if (
      ((rt = rt.updateQueue),
      (rt = rt !== null ? rt.lastEffect : null),
      rt !== null)
    ) {
      var ft = (rt = rt.next)
      do {
        if ((ft.tag & nt) === nt) {
          var mt = ft.create
          ft.destroy = mt()
        }
        ft = ft.next
      } while (ft !== rt)
    }
  }
  function Au(nt) {
    var rt = nt.ref
    if (rt !== null) {
      var ft = nt.stateNode
      switch (nt.tag) {
        case 5:
          nt = Mt(ft)
          break
        default:
          nt = ft
      }
      typeof rt == "function" ? rt(nt) : (rt.current = nt)
    }
  }
  function $p(nt, rt, ft) {
    if (gs && typeof gs.onCommitFiberUnmount == "function")
      try {
        gs.onCommitFiberUnmount(wo, rt)
      } catch {}
    switch (rt.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((nt = rt.updateQueue),
          nt !== null && ((nt = nt.lastEffect), nt !== null))
        ) {
          var mt = (nt = nt.next)
          do {
            var xt = mt,
              Ct = xt.destroy
            ;(xt = xt.tag),
              Ct !== void 0 && (xt & 2 || xt & 4) && xu(rt, ft, Ct),
              (mt = mt.next)
          } while (mt !== nt)
        }
        break
      case 1:
        if (
          (Qo(rt, ft),
          (nt = rt.stateNode),
          typeof nt.componentWillUnmount == "function")
        )
          try {
            ;(nt.props = rt.memoizedProps),
              (nt.state = rt.memoizedState),
              nt.componentWillUnmount()
          } catch (Gt) {
            Zr(rt, ft, Gt)
          }
        break
      case 5:
        Qo(rt, ft)
        break
      case 4:
        gn
          ? Zp(nt, rt, ft)
          : Ht &&
            Ht &&
            ((rt = rt.stateNode.containerInfo), (ft = or(rt)), kr(rt, ft))
    }
  }
  function Xp(nt, rt, ft) {
    for (var mt = rt; ; )
      if (($p(nt, mt, ft), mt.child === null || (gn && mt.tag === 4))) {
        if (mt === rt) break
        for (; mt.sibling === null; ) {
          if (mt.return === null || mt.return === rt) return
          mt = mt.return
        }
        ;(mt.sibling.return = mt.return), (mt = mt.sibling)
      } else (mt.child.return = mt), (mt = mt.child)
  }
  function Jp(nt) {
    var rt = nt.alternate
    rt !== null && ((nt.alternate = null), Jp(rt)),
      (nt.child = null),
      (nt.deletions = null),
      (nt.sibling = null),
      nt.tag === 5 && ((rt = nt.stateNode), rt !== null && Rn(rt)),
      (nt.stateNode = null),
      (nt.return = null),
      (nt.dependencies = null),
      (nt.memoizedProps = null),
      (nt.memoizedState = null),
      (nt.pendingProps = null),
      (nt.stateNode = null),
      (nt.updateQueue = null)
  }
  function Yp(nt) {
    return nt.tag === 5 || nt.tag === 3 || nt.tag === 4
  }
  function Kp(nt) {
    e: for (;;) {
      for (; nt.sibling === null; ) {
        if (nt.return === null || Yp(nt.return)) return null
        nt = nt.return
      }
      for (
        nt.sibling.return = nt.return, nt = nt.sibling;
        nt.tag !== 5 && nt.tag !== 6 && nt.tag !== 18;

      ) {
        if (nt.flags & 2 || nt.child === null || nt.tag === 4) continue e
        ;(nt.child.return = nt), (nt = nt.child)
      }
      if (!(nt.flags & 2)) return nt.stateNode
    }
  }
  function qp(nt) {
    if (gn) {
      e: {
        for (var rt = nt.return; rt !== null; ) {
          if (Yp(rt)) break e
          rt = rt.return
        }
        throw Error(g(160))
      }
      var ft = rt
      switch (ft.tag) {
        case 5:
          ;(rt = ft.stateNode),
            ft.flags & 32 && (un(rt), (ft.flags &= -33)),
            (ft = Kp(nt)),
            Eu(nt, ft, rt)
          break
        case 3:
        case 4:
          ;(rt = ft.stateNode.containerInfo), (ft = Kp(nt)), Su(nt, ft, rt)
          break
        default:
          throw Error(g(161))
      }
    }
  }
  function Su(nt, rt, ft) {
    var mt = nt.tag
    if (mt === 5 || mt === 6)
      (nt = nt.stateNode), rt ? Fn(ft, nt, rt) : Nn(ft, nt)
    else if (mt !== 4 && ((nt = nt.child), nt !== null))
      for (Su(nt, rt, ft), nt = nt.sibling; nt !== null; )
        Su(nt, rt, ft), (nt = nt.sibling)
  }
  function Eu(nt, rt, ft) {
    var mt = nt.tag
    if (mt === 5 || mt === 6)
      (nt = nt.stateNode), rt ? Hn(ft, nt, rt) : An(ft, nt)
    else if (mt !== 4 && ((nt = nt.child), nt !== null))
      for (Eu(nt, rt, ft), nt = nt.sibling; nt !== null; )
        Eu(nt, rt, ft), (nt = nt.sibling)
  }
  function Zp(nt, rt, ft) {
    for (var mt = rt, xt = !1, Ct, Gt; ; ) {
      if (!xt) {
        xt = mt.return
        e: for (;;) {
          if (xt === null) throw Error(g(160))
          switch (((Ct = xt.stateNode), xt.tag)) {
            case 5:
              Gt = !1
              break e
            case 3:
              ;(Ct = Ct.containerInfo), (Gt = !0)
              break e
            case 4:
              ;(Ct = Ct.containerInfo), (Gt = !0)
              break e
          }
          xt = xt.return
        }
        xt = !0
      }
      if (mt.tag === 5 || mt.tag === 6)
        Xp(nt, mt, ft), Gt ? Wt(Ct, mt.stateNode) : Un(Ct, mt.stateNode)
      else if (mt.tag === 18) Gt ? sn(Ct, mt.stateNode) : tn(Ct, mt.stateNode)
      else if (mt.tag === 4) {
        if (mt.child !== null) {
          ;(Ct = mt.stateNode.containerInfo),
            (Gt = !0),
            (mt.child.return = mt),
            (mt = mt.child)
          continue
        }
      } else if (($p(nt, mt, ft), mt.child !== null)) {
        ;(mt.child.return = mt), (mt = mt.child)
        continue
      }
      if (mt === rt) break
      for (; mt.sibling === null; ) {
        if (mt.return === null || mt.return === rt) return
        ;(mt = mt.return), mt.tag === 4 && (xt = !1)
      }
      ;(mt.sibling.return = mt.return), (mt = mt.sibling)
    }
  }
  function Mu(nt, rt) {
    if (gn) {
      switch (rt.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Hs(3, rt, rt.return), xo(3, rt), Hs(5, rt, rt.return)
          return
        case 1:
          return
        case 5:
          var ft = rt.stateNode
          if (ft != null) {
            var mt = rt.memoizedProps
            nt = nt !== null ? nt.memoizedProps : mt
            var xt = rt.type,
              Ct = rt.updateQueue
            ;(rt.updateQueue = null), Ct !== null && Jn(ft, Ct, xt, nt, mt, rt)
          }
          return
        case 6:
          if (rt.stateNode === null) throw Error(g(162))
          ;(ft = rt.memoizedProps),
            Sn(rt.stateNode, nt !== null ? nt.memoizedProps : ft, ft)
          return
        case 3:
          on &&
            nt !== null &&
            nt.memoizedState.isDehydrated &&
            Ot(rt.stateNode.containerInfo)
          return
        case 12:
          return
        case 13:
          yl(rt)
          return
        case 19:
          yl(rt)
          return
        case 17:
          return
      }
      throw Error(g(163))
    }
    switch (rt.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Hs(3, rt, rt.return), xo(3, rt), Hs(5, rt, rt.return)
        return
      case 12:
        return
      case 13:
        yl(rt)
        return
      case 19:
        yl(rt)
        return
      case 3:
        on &&
          nt !== null &&
          nt.memoizedState.isDehydrated &&
          Ot(rt.stateNode.containerInfo)
        break
      case 22:
      case 23:
        return
    }
    e: if (Ht) {
      switch (rt.tag) {
        case 1:
        case 5:
        case 6:
          break e
        case 3:
        case 4:
          ;(rt = rt.stateNode), kr(rt.containerInfo, rt.pendingChildren)
          break e
      }
      throw Error(g(163))
    }
  }
  function yl(nt) {
    var rt = nt.updateQueue
    if (rt !== null) {
      nt.updateQueue = null
      var ft = nt.stateNode
      ft === null && (ft = nt.stateNode = new Wm()),
        rt.forEach(function (mt) {
          var xt = e0.bind(null, nt, mt)
          ft.has(mt) || (ft.add(mt), mt.then(xt, xt))
        })
    }
  }
  function $m(nt, rt) {
    for (Ln = rt; Ln !== null; ) {
      rt = Ln
      var ft = rt.deletions
      if (ft !== null)
        for (var mt = 0; mt < ft.length; mt++) {
          var xt = ft[mt]
          try {
            var Ct = nt
            gn ? Zp(Ct, xt, rt) : Xp(Ct, xt, rt)
            var Gt = xt.alternate
            Gt !== null && (Gt.return = null), (xt.return = null)
          } catch (Xn) {
            Zr(xt, rt, Xn)
          }
        }
      if (((ft = rt.child), rt.subtreeFlags & 12854 && ft !== null))
        (ft.return = rt), (Ln = ft)
      else
        for (; Ln !== null; ) {
          rt = Ln
          try {
            var Jt = rt.flags
            if ((Jt & 32 && gn && un(rt.stateNode), Jt & 512)) {
              var fn = rt.alternate
              if (fn !== null) {
                var Cn = fn.ref
                Cn !== null &&
                  (typeof Cn == "function" ? Cn(null) : (Cn.current = null))
              }
            }
            if (Jt & 8192)
              switch (rt.tag) {
                case 13:
                  if (rt.memoizedState !== null) {
                    var zn = rt.alternate
                    ;(zn === null || zn.memoizedState === null) && (Bu = Or())
                  }
                  break
                case 22:
                  var ir = rt.memoizedState !== null,
                    Qn = rt.alternate,
                    Mr = Qn !== null && Qn.memoizedState !== null
                  if (((ft = rt), gn)) {
                    e: if (((mt = ft), (xt = ir), (Ct = null), gn))
                      for (var Kn = mt; ; ) {
                        if (Kn.tag === 5) {
                          if (Ct === null) {
                            Ct = Kn
                            var $r = Kn.stateNode
                            xt ? Mn($r) : Qt(Kn.stateNode, Kn.memoizedProps)
                          }
                        } else if (Kn.tag === 6) {
                          if (Ct === null) {
                            var us = Kn.stateNode
                            xt ? jt(us) : nn(us, Kn.memoizedProps)
                          }
                        } else if (
                          ((Kn.tag !== 22 && Kn.tag !== 23) ||
                            Kn.memoizedState === null ||
                            Kn === mt) &&
                          Kn.child !== null
                        ) {
                          ;(Kn.child.return = Kn), (Kn = Kn.child)
                          continue
                        }
                        if (Kn === mt) break
                        for (; Kn.sibling === null; ) {
                          if (Kn.return === null || Kn.return === mt) break e
                          Ct === Kn && (Ct = null), (Kn = Kn.return)
                        }
                        Ct === Kn && (Ct = null),
                          (Kn.sibling.return = Kn.return),
                          (Kn = Kn.sibling)
                      }
                  }
                  if (ir && !Mr && ft.mode & 1) {
                    Ln = ft
                    for (var rn = ft.child; rn !== null; ) {
                      for (ft = Ln = rn; Ln !== null; ) {
                        mt = Ln
                        var Kt = mt.child
                        switch (mt.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            Hs(4, mt, mt.return)
                            break
                          case 1:
                            Qo(mt, mt.return)
                            var ln = mt.stateNode
                            if (typeof ln.componentWillUnmount == "function") {
                              var kn = mt.return
                              try {
                                ;(ln.props = mt.memoizedProps),
                                  (ln.state = mt.memoizedState),
                                  ln.componentWillUnmount()
                              } catch (Xn) {
                                Zr(mt, kn, Xn)
                              }
                            }
                            break
                          case 5:
                            Qo(mt, mt.return)
                            break
                          case 22:
                            if (mt.memoizedState !== null) {
                              tm(ft)
                              continue
                            }
                        }
                        Kt !== null ? ((Kt.return = mt), (Ln = Kt)) : tm(ft)
                      }
                      rn = rn.sibling
                    }
                  }
              }
            switch (Jt & 4102) {
              case 2:
                qp(rt), (rt.flags &= -3)
                break
              case 6:
                qp(rt), (rt.flags &= -3), Mu(rt.alternate, rt)
                break
              case 4096:
                rt.flags &= -4097
                break
              case 4100:
                ;(rt.flags &= -4097), Mu(rt.alternate, rt)
                break
              case 4:
                Mu(rt.alternate, rt)
            }
          } catch (Xn) {
            Zr(rt, rt.return, Xn)
          }
          if (((ft = rt.sibling), ft !== null)) {
            ;(ft.return = rt.return), (Ln = ft)
            break
          }
          Ln = rt.return
        }
    }
  }
  function Xm(nt, rt, ft) {
    ;(Ln = nt), Qp(nt)
  }
  function Qp(nt, rt, ft) {
    for (var mt = (nt.mode & 1) !== 0; Ln !== null; ) {
      var xt = Ln,
        Ct = xt.child
      if (xt.tag === 22 && mt) {
        var Gt = xt.memoizedState !== null || Zo
        if (!Gt) {
          var Jt = xt.alternate,
            fn = (Jt !== null && Jt.memoizedState !== null) || zs
          Jt = Zo
          var Cn = zs
          if (((Zo = Gt), (zs = fn) && !Cn))
            for (Ln = xt; Ln !== null; )
              (Gt = Ln),
                (fn = Gt.child),
                Gt.tag === 22 && Gt.memoizedState !== null
                  ? rm(xt)
                  : fn !== null
                  ? ((fn.return = Gt), (Ln = fn))
                  : rm(xt)
          for (; Ct !== null; ) (Ln = Ct), Qp(Ct), (Ct = Ct.sibling)
          ;(Ln = xt), (Zo = Jt), (zs = Cn)
        }
        em(nt)
      } else
        xt.subtreeFlags & 8772 && Ct !== null
          ? ((Ct.return = xt), (Ln = Ct))
          : em(nt)
    }
  }
  function em(nt) {
    for (; Ln !== null; ) {
      var rt = Ln
      if (rt.flags & 8772) {
        var ft = rt.alternate
        try {
          if (rt.flags & 8772)
            switch (rt.tag) {
              case 0:
              case 11:
              case 15:
                zs || xo(5, rt)
                break
              case 1:
                var mt = rt.stateNode
                if (rt.flags & 4 && !zs)
                  if (ft === null) mt.componentDidMount()
                  else {
                    var xt =
                      rt.elementType === rt.type
                        ? ft.memoizedProps
                        : hs(rt.type, ft.memoizedProps)
                    mt.componentDidUpdate(
                      xt,
                      ft.memoizedState,
                      mt.__reactInternalSnapshotBeforeUpdate
                    )
                  }
                var Ct = rt.updateQueue
                Ct !== null && Yu(rt, Ct, mt)
                break
              case 3:
                var Gt = rt.updateQueue
                if (Gt !== null) {
                  if (((ft = null), rt.child !== null))
                    switch (rt.child.tag) {
                      case 5:
                        ft = Mt(rt.child.stateNode)
                        break
                      case 1:
                        ft = rt.child.stateNode
                    }
                  Yu(rt, Gt, ft)
                }
                break
              case 5:
                var Jt = rt.stateNode
                ft === null &&
                  rt.flags & 4 &&
                  an(Jt, rt.type, rt.memoizedProps, rt)
                break
              case 6:
                break
              case 4:
                break
              case 12:
                break
              case 13:
                if (on && rt.memoizedState === null) {
                  var fn = rt.alternate
                  if (fn !== null) {
                    var Cn = fn.memoizedState
                    if (Cn !== null) {
                      var zn = Cn.dehydrated
                      zn !== null && zt(zn)
                    }
                  }
                }
                break
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break
              default:
                throw Error(g(163))
            }
          zs || (rt.flags & 512 && Au(rt))
        } catch (ir) {
          Zr(rt, rt.return, ir)
        }
      }
      if (rt === nt) {
        Ln = null
        break
      }
      if (((ft = rt.sibling), ft !== null)) {
        ;(ft.return = rt.return), (Ln = ft)
        break
      }
      Ln = rt.return
    }
  }
  function tm(nt) {
    for (; Ln !== null; ) {
      var rt = Ln
      if (rt === nt) {
        Ln = null
        break
      }
      var ft = rt.sibling
      if (ft !== null) {
        ;(ft.return = rt.return), (Ln = ft)
        break
      }
      Ln = rt.return
    }
  }
  function rm(nt) {
    for (; Ln !== null; ) {
      var rt = Ln
      try {
        switch (rt.tag) {
          case 0:
          case 11:
          case 15:
            var ft = rt.return
            try {
              xo(4, rt)
            } catch (fn) {
              Zr(rt, ft, fn)
            }
            break
          case 1:
            var mt = rt.stateNode
            if (typeof mt.componentDidMount == "function") {
              var xt = rt.return
              try {
                mt.componentDidMount()
              } catch (fn) {
                Zr(rt, xt, fn)
              }
            }
            var Ct = rt.return
            try {
              Au(rt)
            } catch (fn) {
              Zr(rt, Ct, fn)
            }
            break
          case 5:
            var Gt = rt.return
            try {
              Au(rt)
            } catch (fn) {
              Zr(rt, Gt, fn)
            }
        }
      } catch (fn) {
        Zr(rt, rt.return, fn)
      }
      if (rt === nt) {
        Ln = null
        break
      }
      var Jt = rt.sibling
      if (Jt !== null) {
        ;(Jt.return = rt.return), (Ln = Jt)
        break
      }
      Ln = rt.return
    }
  }
  var _l = 0,
    xl = 1,
    Al = 2,
    Sl = 3,
    El = 4
  if (typeof Symbol == "function" && Symbol.for) {
    var Ao = Symbol.for
    ;(_l = Ao("selector.component")),
      (xl = Ao("selector.has_pseudo_class")),
      (Al = Ao("selector.role")),
      (Sl = Ao("selector.test_id")),
      (El = Ao("selector.text"))
  }
  function Tu(nt) {
    var rt = Yt(nt)
    if (rt != null) {
      if (typeof rt.memoizedProps["data-testname"] != "string")
        throw Error(g(364))
      return rt
    }
    if (((nt = jn(nt)), nt === null)) throw Error(g(362))
    return nt.stateNode.current
  }
  function Cu(nt, rt) {
    switch (rt.$$typeof) {
      case _l:
        if (nt.type === rt.value) return !0
        break
      case xl:
        e: {
          ;(rt = rt.value), (nt = [nt, 0])
          for (var ft = 0; ft < nt.length; ) {
            var mt = nt[ft++],
              xt = nt[ft++],
              Ct = rt[xt]
            if (mt.tag !== 5 || !Lt(mt)) {
              for (; Ct != null && Cu(mt, Ct); ) xt++, (Ct = rt[xt])
              if (xt === rt.length) {
                rt = !0
                break e
              } else
                for (mt = mt.child; mt !== null; )
                  nt.push(mt, xt), (mt = mt.sibling)
            }
          }
          rt = !1
        }
        return rt
      case Al:
        if (nt.tag === 5 && Zt(nt.stateNode, rt.value)) return !0
        break
      case El:
        if (
          (nt.tag === 5 || nt.tag === 6) &&
          ((nt = Vt(nt)), nt !== null && 0 <= nt.indexOf(rt.value))
        )
          return !0
        break
      case Sl:
        if (
          nt.tag === 5 &&
          ((nt = nt.memoizedProps["data-testname"]),
          typeof nt == "string" && nt.toLowerCase() === rt.value.toLowerCase())
        )
          return !0
        break
      default:
        throw Error(g(365))
    }
    return !1
  }
  function bu(nt) {
    switch (nt.$$typeof) {
      case _l:
        return "<" + (vt(nt.value) || "Unknown") + ">"
      case xl:
        return ":has(" + (bu(nt) || "") + ")"
      case Al:
        return '[role="' + nt.value + '"]'
      case El:
        return '"' + nt.value + '"'
      case Sl:
        return '[data-testname="' + nt.value + '"]'
      default:
        throw Error(g(365))
    }
  }
  function im(nt, rt) {
    var ft = []
    nt = [nt, 0]
    for (var mt = 0; mt < nt.length; ) {
      var xt = nt[mt++],
        Ct = nt[mt++],
        Gt = rt[Ct]
      if (xt.tag !== 5 || !Lt(xt)) {
        for (; Gt != null && Cu(xt, Gt); ) Ct++, (Gt = rt[Ct])
        if (Ct === rt.length) ft.push(xt)
        else
          for (xt = xt.child; xt !== null; ) nt.push(xt, Ct), (xt = xt.sibling)
      }
    }
    return ft
  }
  function wu(nt, rt) {
    if (!Gn) throw Error(g(363))
    ;(nt = Tu(nt)), (nt = im(nt, rt)), (rt = []), (nt = Array.from(nt))
    for (var ft = 0; ft < nt.length; ) {
      var mt = nt[ft++]
      if (mt.tag === 5) Lt(mt) || rt.push(mt.stateNode)
      else for (mt = mt.child; mt !== null; ) nt.push(mt), (mt = mt.sibling)
    }
    return rt
  }
  var Jm = Math.ceil,
    Ml = _.ReactCurrentDispatcher,
    Pu = _.ReactCurrentOwner,
    Lr = _.ReactCurrentBatchConfig,
    ur = 0,
    Fr = null,
    Dr = null,
    Gr = 0,
    ts = 0,
    to = Dn(0),
    Nr = 0,
    So = null,
    no = 0,
    Tl = 0,
    Ru = 0,
    Eo = null,
    Kr = null,
    Bu = 0,
    Iu = 1 / 0
  function ro() {
    Iu = Or() + 500
  }
  var Cl = !1,
    Lu = null,
    Ls = null,
    Pl = !1,
    Fs = null,
    Rl = 0,
    Mo = 0,
    Fu = null,
    Bl = -1,
    Il = 0
  function Yr() {
    return ur & 6 ? Or() : Bl !== -1 ? Bl : (Bl = Or())
  }
  function Ds(nt) {
    return nt.mode & 1
      ? ur & 2 && Gr !== 0
        ? Gr & -Gr
        : Rm.transition !== null
        ? (Il === 0 &&
            ((nt = To), (To <<= 1), !(To & 4194240) && (To = 64), (Il = nt)),
          Il)
        : ((nt = vr), nt !== 0 ? nt : pn())
      : 1
  }
  function ls(nt, rt, ft) {
    if (50 < Mo) throw ((Mo = 0), (Fu = null), Error(g(185)))
    var mt = Ll(nt, rt)
    return mt === null
      ? null
      : (ao(mt, rt, ft),
        (!(ur & 2) || mt !== Fr) &&
          (mt === Fr && (!(ur & 2) && (Tl |= rt), Nr === 4 && ks(mt, Gr)),
          qr(mt, ft),
          rt === 1 && ur === 0 && !(nt.mode & 1) && (ro(), Po && ys())),
        mt)
  }
  function Ll(nt, rt) {
    nt.lanes |= rt
    var ft = nt.alternate
    for (
      ft !== null && (ft.lanes |= rt), ft = nt, nt = nt.return;
      nt !== null;

    )
      (nt.childLanes |= rt),
        (ft = nt.alternate),
        ft !== null && (ft.childLanes |= rt),
        (ft = nt),
        (nt = nt.return)
    return ft.tag === 3 ? ft.stateNode : null
  }
  function qr(nt, rt) {
    var ft = nt.callbackNode
    Am(nt, rt)
    var mt = bo(nt, nt === Fr ? Gr : 0)
    if (mt === 0)
      ft !== null && Wu(ft), (nt.callbackNode = null), (nt.callbackPriority = 0)
    else if (((rt = mt & -mt), nt.callbackPriority !== rt)) {
      if ((ft != null && Wu(ft), rt === 1))
        nt.tag === 0 ? Pm(am.bind(null, nt)) : ju(am.bind(null, nt)),
          bn
            ? Pn(function () {
                ur === 0 && ys()
              })
            : Gl(zl, ys),
          (ft = null)
      else {
        switch (Hu(mt)) {
          case 1:
            ft = zl
            break
          case 4:
            ft = Tm
            break
          case 16:
            ft = Hl
            break
          case 536870912:
            ft = Cm
            break
          default:
            ft = Hl
        }
        ft = mm(ft, sm.bind(null, nt))
      }
      ;(nt.callbackPriority = rt), (nt.callbackNode = ft)
    }
  }
  function sm(nt, rt) {
    if (((Bl = -1), (Il = 0), ur & 6)) throw Error(g(327))
    var ft = nt.callbackNode
    if ($s() && nt.callbackNode !== ft) return null
    var mt = bo(nt, nt === Fr ? Gr : 0)
    if (mt === 0) return null
    if (mt & 30 || mt & nt.expiredLanes || rt) rt = Fl(nt, mt)
    else {
      rt = mt
      var xt = ur
      ur |= 2
      var Ct = cm()
      ;(Fr !== nt || Gr !== rt) && (ro(), Ws(nt, rt))
      do
        try {
          qm()
          break
        } catch (Jt) {
          lm(nt, Jt)
        }
      while (1)
      Xl(),
        (Ml.current = Ct),
        (ur = xt),
        Dr !== null ? (rt = 0) : ((Fr = null), (Gr = 0), (rt = Nr))
    }
    if (rt !== 0) {
      if (
        (rt === 2 &&
          ((xt = Ol(nt)), xt !== 0 && ((mt = xt), (rt = Du(nt, xt)))),
        rt === 1)
      )
        throw ((ft = So), Ws(nt, 0), ks(nt, mt), qr(nt, Or()), ft)
      if (rt === 6) ks(nt, mt)
      else {
        if (
          ((xt = nt.current.alternate),
          !(mt & 30) &&
            !Ym(xt) &&
            ((rt = Fl(nt, mt)),
            rt === 2 &&
              ((Ct = Ol(nt)), Ct !== 0 && ((mt = Ct), (rt = Du(nt, Ct)))),
            rt === 1))
        )
          throw ((ft = So), Ws(nt, 0), ks(nt, mt), qr(nt, Or()), ft)
        switch (((nt.finishedWork = xt), (nt.finishedLanes = mt), rt)) {
          case 0:
          case 1:
            throw Error(g(345))
          case 2:
            js(nt, Kr)
            break
          case 3:
            if (
              (ks(nt, mt),
              (mt & 130023424) === mt && ((rt = Bu + 500 - Or()), 10 < rt))
            ) {
              if (bo(nt, 0) !== 0) break
              if (((xt = nt.suspendedLanes), (xt & mt) !== mt)) {
                Yr(), (nt.pingedLanes |= nt.suspendedLanes & xt)
                break
              }
              nt.timeoutHandle = yn(js.bind(null, nt, Kr), rt)
              break
            }
            js(nt, Kr)
            break
          case 4:
            if ((ks(nt, mt), (mt & 4194240) === mt)) break
            for (rt = nt.eventTimes, xt = -1; 0 < mt; ) {
              var Gt = 31 - Cr(mt)
              ;(Ct = 1 << Gt), (Gt = rt[Gt]), Gt > xt && (xt = Gt), (mt &= ~Ct)
            }
            if (
              ((mt = xt),
              (mt = Or() - mt),
              (mt =
                (120 > mt
                  ? 120
                  : 480 > mt
                  ? 480
                  : 1080 > mt
                  ? 1080
                  : 1920 > mt
                  ? 1920
                  : 3e3 > mt
                  ? 3e3
                  : 4320 > mt
                  ? 4320
                  : 1960 * Jm(mt / 1960)) - mt),
              10 < mt)
            ) {
              nt.timeoutHandle = yn(js.bind(null, nt, Kr), mt)
              break
            }
            js(nt, Kr)
            break
          case 5:
            js(nt, Kr)
            break
          default:
            throw Error(g(329))
        }
      }
    }
    return qr(nt, Or()), nt.callbackNode === ft ? sm.bind(null, nt) : null
  }
  function Du(nt, rt) {
    var ft = Eo
    return (
      nt.current.memoizedState.isDehydrated && (Ws(nt, rt).flags |= 256),
      (nt = Fl(nt, rt)),
      nt !== 2 && ((rt = Kr), (Kr = ft), rt !== null && ku(rt)),
      nt
    )
  }
  function ku(nt) {
    Kr === null ? (Kr = nt) : Kr.push.apply(Kr, nt)
  }
  function Ym(nt) {
    for (var rt = nt; ; ) {
      if (rt.flags & 16384) {
        var ft = rt.updateQueue
        if (ft !== null && ((ft = ft.stores), ft !== null))
          for (var mt = 0; mt < ft.length; mt++) {
            var xt = ft[mt],
              Ct = xt.getSnapshot
            xt = xt.value
            try {
              if (!vs(Ct(), xt)) return !1
            } catch {
              return !1
            }
          }
      }
      if (((ft = rt.child), rt.subtreeFlags & 16384 && ft !== null))
        (ft.return = rt), (rt = ft)
      else {
        if (rt === nt) break
        for (; rt.sibling === null; ) {
          if (rt.return === null || rt.return === nt) return !0
          rt = rt.return
        }
        ;(rt.sibling.return = rt.return), (rt = rt.sibling)
      }
    }
    return !0
  }
  function ks(nt, rt) {
    for (
      rt &= ~Ru,
        rt &= ~Tl,
        nt.suspendedLanes |= rt,
        nt.pingedLanes &= ~rt,
        nt = nt.expirationTimes;
      0 < rt;

    ) {
      var ft = 31 - Cr(rt),
        mt = 1 << ft
      ;(nt[ft] = -1), (rt &= ~mt)
    }
  }
  function am(nt) {
    if (ur & 6) throw Error(g(327))
    $s()
    var rt = bo(nt, 0)
    if (!(rt & 1)) return qr(nt, Or()), null
    var ft = Fl(nt, rt)
    if (nt.tag !== 0 && ft === 2) {
      var mt = Ol(nt)
      mt !== 0 && ((rt = mt), (ft = Du(nt, mt)))
    }
    if (ft === 1) throw ((ft = So), Ws(nt, 0), ks(nt, rt), qr(nt, Or()), ft)
    if (ft === 6) throw Error(g(345))
    return (
      (nt.finishedWork = nt.current.alternate),
      (nt.finishedLanes = rt),
      js(nt, Kr),
      qr(nt, Or()),
      null
    )
  }
  function om(nt) {
    Fs !== null && Fs.tag === 0 && !(ur & 6) && $s()
    var rt = ur
    ur |= 1
    var ft = Lr.transition,
      mt = vr
    try {
      if (((Lr.transition = null), (vr = 1), nt)) return nt()
    } finally {
      ;(vr = mt), (Lr.transition = ft), (ur = rt), !(ur & 6) && ys()
    }
  }
  function Nu() {
    ;(ts = to.current), er(to)
  }
  function Ws(nt, rt) {
    ;(nt.finishedWork = null), (nt.finishedLanes = 0)
    var ft = nt.timeoutHandle
    if ((ft !== $n && ((nt.timeoutHandle = $n), Tn(ft)), Dr !== null))
      for (ft = Dr.return; ft !== null; ) {
        var mt = ft
        switch ((eu(mt), mt.tag)) {
          case 1:
            ;(mt = mt.type.childContextTypes), mt != null && Ir()
            break
          case 3:
            $a(), er(tr), er(Ar), ou()
            break
          case 5:
            su(mt)
            break
          case 4:
            $a()
            break
          case 13:
            er(Pr)
            break
          case 19:
            er(Pr)
            break
          case 10:
            Jl(mt.type._context)
            break
          case 22:
          case 23:
            Nu()
        }
        ft = ft.return
      }
    if (
      ((Fr = nt),
      (Dr = nt = Ns(nt.current, null)),
      (Gr = ts = rt),
      (Nr = 0),
      (So = null),
      (Ru = Tl = no = 0),
      (Kr = Eo = null),
      _s !== null)
    ) {
      for (rt = 0; rt < _s.length; rt++)
        if (((ft = _s[rt]), (mt = ft.interleaved), mt !== null)) {
          ft.interleaved = null
          var xt = mt.next,
            Ct = ft.pending
          if (Ct !== null) {
            var Gt = Ct.next
            ;(Ct.next = xt), (mt.next = Gt)
          }
          ft.pending = mt
        }
      _s = null
    }
    return nt
  }
  function lm(nt, rt) {
    do {
      var ft = Dr
      try {
        if ((Xl(), (Vo.current = $o), Go)) {
          for (var mt = Rr.memoizedState; mt !== null; ) {
            var xt = mt.queue
            xt !== null && (xt.pending = null), (mt = mt.next)
          }
          Go = !1
        }
        if (
          ((eo = 0),
          (Ur = Hr = Rr = null),
          (fo = !1),
          (po = 0),
          (Pu.current = null),
          ft === null || ft.return === null)
        ) {
          ;(Nr = 1), (So = rt), (Dr = null)
          break
        }
        e: {
          var Ct = nt,
            Gt = ft.return,
            Jt = ft,
            fn = rt
          if (
            ((rt = Gr),
            (Jt.flags |= 32768),
            fn !== null &&
              typeof fn == "object" &&
              typeof fn.then == "function")
          ) {
            var Cn = fn,
              zn = Jt,
              ir = zn.tag
            if (!(zn.mode & 1) && (ir === 0 || ir === 11 || ir === 15)) {
              var Qn = zn.alternate
              Qn
                ? ((zn.updateQueue = Qn.updateQueue),
                  (zn.memoizedState = Qn.memoizedState),
                  (zn.lanes = Qn.lanes))
                : ((zn.updateQueue = null), (zn.memoizedState = null))
            }
            var Mr = wp(Gt)
            if (Mr !== null) {
              ;(Mr.flags &= -257),
                Pp(Mr, Gt, Jt, Ct, rt),
                Mr.mode & 1 && bp(Ct, Cn, rt),
                (rt = Mr),
                (fn = Cn)
              var Kn = rt.updateQueue
              if (Kn === null) {
                var $r = new Set()
                $r.add(fn), (rt.updateQueue = $r)
              } else Kn.add(fn)
              break e
            } else {
              if (!(rt & 1)) {
                bp(Ct, Cn, rt), Ou()
                break e
              }
              fn = Error(g(426))
            }
          } else if (br && Jt.mode & 1) {
            var us = wp(Gt)
            if (us !== null) {
              !(us.flags & 65536) && (us.flags |= 256),
                Pp(us, Gt, Jt, Ct, rt),
                ru(fn)
              break e
            }
          }
          ;(Ct = fn),
            Nr !== 4 && (Nr = 2),
            Eo === null ? (Eo = [Ct]) : Eo.push(Ct),
            (fn = pu(fn, Jt)),
            (Jt = Gt)
          do {
            switch (Jt.tag) {
              case 3:
                ;(Jt.flags |= 65536), (rt &= -rt), (Jt.lanes |= rt)
                var rn = Tp(Jt, fn, rt)
                Ju(Jt, rn)
                break e
              case 1:
                Ct = fn
                var Kt = Jt.type,
                  ln = Jt.stateNode
                if (
                  !(Jt.flags & 128) &&
                  (typeof Kt.getDerivedStateFromError == "function" ||
                    (ln !== null &&
                      typeof ln.componentDidCatch == "function" &&
                      (Ls === null || !Ls.has(ln))))
                ) {
                  ;(Jt.flags |= 65536), (rt &= -rt), (Jt.lanes |= rt)
                  var kn = Cp(Jt, Ct, rt)
                  Ju(Jt, kn)
                  break e
                }
            }
            Jt = Jt.return
          } while (Jt !== null)
        }
        hm(ft)
      } catch (Xn) {
        ;(rt = Xn), Dr === ft && ft !== null && (Dr = ft = ft.return)
        continue
      }
      break
    } while (1)
  }
  function cm() {
    var nt = Ml.current
    return (Ml.current = $o), nt === null ? $o : nt
  }
  function Ou() {
    ;(Nr === 0 || Nr === 3 || Nr === 2) && (Nr = 4),
      Fr === null || (!(no & 268435455) && !(Tl & 268435455)) || ks(Fr, Gr)
  }
  function Fl(nt, rt) {
    var ft = ur
    ur |= 2
    var mt = cm()
    ;(Fr === nt && Gr === rt) || Ws(nt, rt)
    do
      try {
        Km()
        break
      } catch (xt) {
        lm(nt, xt)
      }
    while (1)
    if ((Xl(), (ur = ft), (Ml.current = mt), Dr !== null)) throw Error(g(261))
    return (Fr = null), (Gr = 0), Nr
  }
  function Km() {
    for (; Dr !== null; ) um(Dr)
  }
  function qm() {
    for (; Dr !== null && !Em(); ) um(Dr)
  }
  function um(nt) {
    var rt = pm(nt.alternate, nt, ts)
    ;(nt.memoizedProps = nt.pendingProps),
      rt === null ? hm(nt) : (Dr = rt),
      (Pu.current = null)
  }
  function hm(nt) {
    var rt = nt
    do {
      var ft = rt.alternate
      if (((nt = rt.return), rt.flags & 32768)) {
        if (((ft = Hm(ft, rt)), ft !== null)) {
          ;(ft.flags &= 32767), (Dr = ft)
          return
        }
        if (nt !== null)
          (nt.flags |= 32768), (nt.subtreeFlags = 0), (nt.deletions = null)
        else {
          ;(Nr = 6), (Dr = null)
          return
        }
      } else if (((ft = Vm(ft, rt, ts)), ft !== null)) {
        Dr = ft
        return
      }
      if (((rt = rt.sibling), rt !== null)) {
        Dr = rt
        return
      }
      Dr = rt = nt
    } while (rt !== null)
    Nr === 0 && (Nr = 5)
  }
  function js(nt, rt) {
    var ft = vr,
      mt = Lr.transition
    try {
      ;(Lr.transition = null), (vr = 1), Zm(nt, rt, ft)
    } finally {
      ;(Lr.transition = mt), (vr = ft)
    }
    return null
  }
  function Zm(nt, rt, ft) {
    do $s()
    while (Fs !== null)
    if (ur & 6) throw Error(g(327))
    var mt = nt.finishedWork,
      xt = nt.finishedLanes
    if (mt === null) return null
    if (((nt.finishedWork = null), (nt.finishedLanes = 0), mt === nt.current))
      throw Error(g(177))
    ;(nt.callbackNode = null), (nt.callbackPriority = 0)
    var Ct = mt.lanes | mt.childLanes
    if (
      (Sm(nt, Ct),
      nt === Fr && ((Dr = Fr = null), (Gr = 0)),
      (!(mt.subtreeFlags & 2064) && !(mt.flags & 2064)) ||
        Pl ||
        ((Pl = !0),
        mm(Hl, function () {
          return $s(), null
        })),
      (Ct = (mt.flags & 15990) !== 0),
      mt.subtreeFlags & 15990 || Ct)
    ) {
      ;(Ct = Lr.transition), (Lr.transition = null)
      var Gt = vr
      vr = 1
      var Jt = ur
      ;(ur |= 4),
        (Pu.current = null),
        jm(nt, mt),
        $m(nt, mt),
        bt(nt.containerInfo),
        (nt.current = mt),
        Xm(mt),
        Mm(),
        (ur = Jt),
        (vr = Gt),
        (Lr.transition = Ct)
    } else nt.current = mt
    if (
      (Pl && ((Pl = !1), (Fs = nt), (Rl = xt)),
      (Ct = nt.pendingLanes),
      Ct === 0 && (Ls = null),
      bm(mt.stateNode),
      qr(nt, Or()),
      rt !== null)
    )
      for (ft = nt.onRecoverableError, mt = 0; mt < rt.length; mt++) ft(rt[mt])
    if (Cl) throw ((Cl = !1), (nt = Lu), (Lu = null), nt)
    return (
      Rl & 1 && nt.tag !== 0 && $s(),
      (Ct = nt.pendingLanes),
      Ct & 1 ? (nt === Fu ? Mo++ : ((Mo = 0), (Fu = nt))) : (Mo = 0),
      ys(),
      null
    )
  }
  function $s() {
    if (Fs !== null) {
      var nt = Hu(Rl),
        rt = Lr.transition,
        ft = vr
      try {
        if (((Lr.transition = null), (vr = 16 > nt ? 16 : nt), Fs === null))
          var mt = !1
        else {
          if (((nt = Fs), (Fs = null), (Rl = 0), ur & 6)) throw Error(g(331))
          var xt = ur
          for (ur |= 4, Ln = nt.current; Ln !== null; ) {
            var Ct = Ln,
              Gt = Ct.child
            if (Ln.flags & 16) {
              var Jt = Ct.deletions
              if (Jt !== null) {
                for (var fn = 0; fn < Jt.length; fn++) {
                  var Cn = Jt[fn]
                  for (Ln = Cn; Ln !== null; ) {
                    var zn = Ln
                    switch (zn.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Hs(8, zn, Ct)
                    }
                    var ir = zn.child
                    if (ir !== null) (ir.return = zn), (Ln = ir)
                    else
                      for (; Ln !== null; ) {
                        zn = Ln
                        var Qn = zn.sibling,
                          Mr = zn.return
                        if ((Jp(zn), zn === Cn)) {
                          Ln = null
                          break
                        }
                        if (Qn !== null) {
                          ;(Qn.return = Mr), (Ln = Qn)
                          break
                        }
                        Ln = Mr
                      }
                  }
                }
                var Kn = Ct.alternate
                if (Kn !== null) {
                  var $r = Kn.child
                  if ($r !== null) {
                    Kn.child = null
                    do {
                      var us = $r.sibling
                      ;($r.sibling = null), ($r = us)
                    } while ($r !== null)
                  }
                }
                Ln = Ct
              }
            }
            if (Ct.subtreeFlags & 2064 && Gt !== null)
              (Gt.return = Ct), (Ln = Gt)
            else
              e: for (; Ln !== null; ) {
                if (((Ct = Ln), Ct.flags & 2048))
                  switch (Ct.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Hs(9, Ct, Ct.return)
                  }
                var rn = Ct.sibling
                if (rn !== null) {
                  ;(rn.return = Ct.return), (Ln = rn)
                  break e
                }
                Ln = Ct.return
              }
          }
          var Kt = nt.current
          for (Ln = Kt; Ln !== null; ) {
            Gt = Ln
            var ln = Gt.child
            if (Gt.subtreeFlags & 2064 && ln !== null)
              (ln.return = Gt), (Ln = ln)
            else
              e: for (Gt = Kt; Ln !== null; ) {
                if (((Jt = Ln), Jt.flags & 2048))
                  try {
                    switch (Jt.tag) {
                      case 0:
                      case 11:
                      case 15:
                        xo(9, Jt)
                    }
                  } catch (Xn) {
                    Zr(Jt, Jt.return, Xn)
                  }
                if (Jt === Gt) {
                  Ln = null
                  break e
                }
                var kn = Jt.sibling
                if (kn !== null) {
                  ;(kn.return = Jt.return), (Ln = kn)
                  break e
                }
                Ln = Jt.return
              }
          }
          if (
            ((ur = xt),
            ys(),
            gs && typeof gs.onPostCommitFiberRoot == "function")
          )
            try {
              gs.onPostCommitFiberRoot(wo, nt)
            } catch {}
          mt = !0
        }
        return mt
      } finally {
        ;(vr = ft), (Lr.transition = rt)
      }
    }
    return !1
  }
  function fm(nt, rt, ft) {
    ;(rt = pu(ft, rt)),
      (rt = Tp(nt, rt, 1)),
      Is(nt, rt),
      (rt = Yr()),
      (nt = Ll(nt, 1)),
      nt !== null && (ao(nt, 1, rt), qr(nt, rt))
  }
  function Zr(nt, rt, ft) {
    if (nt.tag === 3) fm(nt, nt, ft)
    else
      for (; rt !== null; ) {
        if (rt.tag === 3) {
          fm(rt, nt, ft)
          break
        } else if (rt.tag === 1) {
          var mt = rt.stateNode
          if (
            typeof rt.type.getDerivedStateFromError == "function" ||
            (typeof mt.componentDidCatch == "function" &&
              (Ls === null || !Ls.has(mt)))
          ) {
            ;(nt = pu(ft, nt)),
              (nt = Cp(rt, nt, 1)),
              Is(rt, nt),
              (nt = Yr()),
              (rt = Ll(rt, 1)),
              rt !== null && (ao(rt, 1, nt), qr(rt, nt))
            break
          }
        }
        rt = rt.return
      }
  }
  function Qm(nt, rt, ft) {
    var mt = nt.pingCache
    mt !== null && mt.delete(rt),
      (rt = Yr()),
      (nt.pingedLanes |= nt.suspendedLanes & ft),
      Fr === nt &&
        (Gr & ft) === ft &&
        (Nr === 4 || (Nr === 3 && (Gr & 130023424) === Gr && 500 > Or() - Bu)
          ? Ws(nt, 0)
          : (Ru |= ft)),
      qr(nt, rt)
  }
  function dm(nt, rt) {
    rt === 0 &&
      (nt.mode & 1
        ? ((rt = Co), (Co <<= 1), !(Co & 130023424) && (Co = 4194304))
        : (rt = 1))
    var ft = Yr()
    ;(nt = Ll(nt, rt)), nt !== null && (ao(nt, rt, ft), qr(nt, ft))
  }
  function _g(nt) {
    var rt = nt.memoizedState,
      ft = 0
    rt !== null && (ft = rt.retryLane), dm(nt, ft)
  }
  function e0(nt, rt) {
    var ft = 0
    switch (nt.tag) {
      case 13:
        var mt = nt.stateNode,
          xt = nt.memoizedState
        xt !== null && (ft = xt.retryLane)
        break
      case 19:
        mt = nt.stateNode
        break
      default:
        throw Error(g(314))
    }
    mt !== null && mt.delete(rt), dm(nt, ft)
  }
  var pm
  pm = function (nt, rt, ft) {
    if (nt !== null)
      if (nt.memoizedProps !== rt.pendingProps || tr.current) es = !0
      else {
        if (!(nt.lanes & ft) && !(rt.flags & 128))
          return (es = !1), zm(nt, rt, ft)
        es = !!(nt.flags & 131072)
      }
    else (es = !1), br && rt.flags & 1048576 && _h(rt, No, rt.index)
    switch (((rt.lanes = 0), rt.tag)) {
      case 2:
        var mt = rt.type
        nt !== null &&
          ((nt.alternate = null), (rt.alternate = null), (rt.flags |= 2)),
          (nt = rt.pendingProps)
        var xt = gr(rt, Ar.current)
        Zs(rt, ft), (xt = cu(null, rt, mt, nt, xt, ft))
        var Ct = uu()
        return (
          (rt.flags |= 1),
          typeof xt == "object" &&
          xt !== null &&
          typeof xt.render == "function" &&
          xt.$$typeof === void 0
            ? ((rt.tag = 1),
              (rt.memoizedState = null),
              (rt.updateQueue = null),
              Er(mt) ? ((Ct = !0), xr(rt)) : (Ct = !1),
              (rt.memoizedState =
                xt.state !== null && xt.state !== void 0 ? xt.state : null),
              Kl(rt),
              (xt.updater = Do),
              (rt.stateNode = xt),
              (xt._reactInternals = rt),
              Ql(rt, mt, nt, ft),
              (rt = vu(null, rt, mt, !0, Ct, ft)))
            : ((rt.tag = 0),
              br && Ct && _c(rt),
              Jr(null, rt, xt, ft),
              (rt = rt.child)),
          rt
        )
      case 16:
        mt = rt.elementType
        e: {
          switch (
            (nt !== null &&
              ((nt.alternate = null), (rt.alternate = null), (rt.flags |= 2)),
            (nt = rt.pendingProps),
            (xt = mt._init),
            (mt = xt(mt._payload)),
            (rt.type = mt),
            (xt = rt.tag = n0(mt)),
            (nt = hs(mt, nt)),
            xt)
          ) {
            case 0:
              rt = gu(null, rt, mt, nt, ft)
              break e
            case 1:
              rt = Np(null, rt, mt, nt, ft)
              break e
            case 11:
              rt = Ip(null, rt, mt, nt, ft)
              break e
            case 14:
              rt = Lp(null, rt, mt, hs(mt.type, nt), ft)
              break e
          }
          throw Error(g(306, mt, ""))
        }
        return rt
      case 0:
        return (
          (mt = rt.type),
          (xt = rt.pendingProps),
          (xt = rt.elementType === mt ? xt : hs(mt, xt)),
          gu(nt, rt, mt, xt, ft)
        )
      case 1:
        return (
          (mt = rt.type),
          (xt = rt.pendingProps),
          (xt = rt.elementType === mt ? xt : hs(mt, xt)),
          Np(nt, rt, mt, xt, ft)
        )
      case 3:
        e: {
          if ((Op(rt), nt === null)) throw Error(g(387))
          ;(mt = rt.pendingProps),
            (Ct = rt.memoizedState),
            (xt = Ct.element),
            Xu(nt, rt),
            Fo(rt, mt, null, ft)
          var Gt = rt.memoizedState
          if (((mt = Gt.element), on && Ct.isDehydrated))
            if (
              ((Ct = {
                element: mt,
                isDehydrated: !1,
                cache: Gt.cache,
                transitions: Gt.transitions,
              }),
              (rt.updateQueue.baseState = Ct),
              (rt.memoizedState = Ct),
              rt.flags & 256)
            ) {
              ;(xt = Error(g(423))), (rt = Up(nt, rt, mt, ft, xt))
              break e
            } else if (mt !== xt) {
              ;(xt = Error(g(424))), (rt = Up(nt, rt, mt, ft, xt))
              break e
            } else
              for (
                on &&
                  ((_i = Ks(rt.stateNode.containerInfo)),
                  (Qr = rt),
                  (br = !0),
                  (fs = null),
                  (oo = !1)),
                  ft = rp(rt, null, mt, ft),
                  rt.child = ft;
                ft;

              )
                (ft.flags = (ft.flags & -3) | 4096), (ft = ft.sibling)
          else {
            if ((ga(), mt === xt)) {
              rt = Rs(nt, rt, ft)
              break e
            }
            Jr(nt, rt, mt, ft)
          }
          rt = rt.child
        }
        return rt
      case 5:
        return (
          sp(rt),
          nt === null && nu(rt),
          (mt = rt.type),
          (xt = rt.pendingProps),
          (Ct = nt !== null ? nt.memoizedProps : null),
          (Gt = xt.children),
          qt(mt, xt)
            ? (Gt = null)
            : Ct !== null && qt(mt, Ct) && (rt.flags |= 32),
          kp(nt, rt),
          Jr(nt, rt, Gt, ft),
          rt.child
        )
      case 6:
        return nt === null && nu(rt), null
      case 13:
        return Vp(nt, rt, ft)
      case 4:
        return (
          iu(rt, rt.stateNode.containerInfo),
          (mt = rt.pendingProps),
          nt === null ? (rt.child = xa(rt, null, mt, ft)) : Jr(nt, rt, mt, ft),
          rt.child
        )
      case 11:
        return (
          (mt = rt.type),
          (xt = rt.pendingProps),
          (xt = rt.elementType === mt ? xt : hs(mt, xt)),
          Ip(nt, rt, mt, xt, ft)
        )
      case 7:
        return Jr(nt, rt, rt.pendingProps, ft), rt.child
      case 8:
        return Jr(nt, rt, rt.pendingProps.children, ft), rt.child
      case 12:
        return Jr(nt, rt, rt.pendingProps.children, ft), rt.child
      case 10:
        e: {
          if (
            ((mt = rt.type._context),
            (xt = rt.pendingProps),
            (Ct = rt.memoizedProps),
            (Gt = xt.value),
            $u(rt, mt, Gt),
            Ct !== null)
          )
            if (vs(Ct.value, Gt)) {
              if (Ct.children === xt.children && !tr.current) {
                rt = Rs(nt, rt, ft)
                break e
              }
            } else
              for (
                Ct = rt.child, Ct !== null && (Ct.return = rt);
                Ct !== null;

              ) {
                var Jt = Ct.dependencies
                if (Jt !== null) {
                  Gt = Ct.child
                  for (var fn = Jt.firstContext; fn !== null; ) {
                    if (fn.context === mt) {
                      if (Ct.tag === 1) {
                        ;(fn = Cs(-1, ft & -ft)), (fn.tag = 2)
                        var Cn = Ct.updateQueue
                        if (Cn !== null) {
                          Cn = Cn.shared
                          var zn = Cn.pending
                          zn === null
                            ? (fn.next = fn)
                            : ((fn.next = zn.next), (zn.next = fn)),
                            (Cn.pending = fn)
                        }
                      }
                      ;(Ct.lanes |= ft),
                        (fn = Ct.alternate),
                        fn !== null && (fn.lanes |= ft),
                        Yl(Ct.return, ft, rt),
                        (Jt.lanes |= ft)
                      break
                    }
                    fn = fn.next
                  }
                } else if (Ct.tag === 10)
                  Gt = Ct.type === rt.type ? null : Ct.child
                else if (Ct.tag === 18) {
                  if (((Gt = Ct.return), Gt === null)) throw Error(g(341))
                  ;(Gt.lanes |= ft),
                    (Jt = Gt.alternate),
                    Jt !== null && (Jt.lanes |= ft),
                    Yl(Gt, ft, rt),
                    (Gt = Ct.sibling)
                } else Gt = Ct.child
                if (Gt !== null) Gt.return = Ct
                else
                  for (Gt = Ct; Gt !== null; ) {
                    if (Gt === rt) {
                      Gt = null
                      break
                    }
                    if (((Ct = Gt.sibling), Ct !== null)) {
                      ;(Ct.return = Gt.return), (Gt = Ct)
                      break
                    }
                    Gt = Gt.return
                  }
                Ct = Gt
              }
          Jr(nt, rt, xt.children, ft), (rt = rt.child)
        }
        return rt
      case 9:
        return (
          (xt = rt.type),
          (mt = rt.pendingProps.children),
          Zs(rt, ft),
          (xt = ns(xt)),
          (mt = mt(xt)),
          (rt.flags |= 1),
          Jr(nt, rt, mt, ft),
          rt.child
        )
      case 14:
        return (
          (mt = rt.type),
          (xt = hs(mt, rt.pendingProps)),
          (xt = hs(mt.type, xt)),
          Lp(nt, rt, mt, xt, ft)
        )
      case 15:
        return Fp(nt, rt, rt.type, rt.pendingProps, ft)
      case 17:
        return (
          (mt = rt.type),
          (xt = rt.pendingProps),
          (xt = rt.elementType === mt ? xt : hs(mt, xt)),
          nt !== null &&
            ((nt.alternate = null), (rt.alternate = null), (rt.flags |= 2)),
          (rt.tag = 1),
          Er(mt) ? ((nt = !0), xr(rt)) : (nt = !1),
          Zs(rt, ft),
          Zu(rt, mt, xt),
          Ql(rt, mt, xt, ft),
          vu(null, rt, mt, !0, nt, ft)
        )
      case 19:
        return Wp(nt, rt, ft)
      case 22:
        return Dp(nt, rt, ft)
    }
    throw Error(g(156, rt.tag))
  }
  function mm(nt, rt) {
    return Gl(nt, rt)
  }
  function t0(nt, rt, ft, mt) {
    ;(this.tag = nt),
      (this.key = ft),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = rt),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = mt),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null)
  }
  function cs(nt, rt, ft, mt) {
    return new t0(nt, rt, ft, mt)
  }
  function Uu(nt) {
    return (nt = nt.prototype), !(!nt || !nt.isReactComponent)
  }
  function n0(nt) {
    if (typeof nt == "function") return Uu(nt) ? 1 : 0
    if (nt != null) {
      if (((nt = nt.$$typeof), nt === ot)) return 11
      if (nt === ct) return 14
    }
    return 2
  }
  function Ns(nt, rt) {
    var ft = nt.alternate
    return (
      ft === null
        ? ((ft = cs(nt.tag, rt, nt.key, nt.mode)),
          (ft.elementType = nt.elementType),
          (ft.type = nt.type),
          (ft.stateNode = nt.stateNode),
          (ft.alternate = nt),
          (nt.alternate = ft))
        : ((ft.pendingProps = rt),
          (ft.type = nt.type),
          (ft.flags = 0),
          (ft.subtreeFlags = 0),
          (ft.deletions = null)),
      (ft.flags = nt.flags & 14680064),
      (ft.childLanes = nt.childLanes),
      (ft.lanes = nt.lanes),
      (ft.child = nt.child),
      (ft.memoizedProps = nt.memoizedProps),
      (ft.memoizedState = nt.memoizedState),
      (ft.updateQueue = nt.updateQueue),
      (rt = nt.dependencies),
      (ft.dependencies =
        rt === null
          ? null
          : { lanes: rt.lanes, firstContext: rt.firstContext }),
      (ft.sibling = nt.sibling),
      (ft.index = nt.index),
      (ft.ref = nt.ref),
      ft
    )
  }
  function Dl(nt, rt, ft, mt, xt, Ct) {
    var Gt = 2
    if (((mt = nt), typeof nt == "function")) Uu(nt) && (Gt = 1)
    else if (typeof nt == "string") Gt = 5
    else
      e: switch (nt) {
        case $:
          return Xs(ft.children, xt, Ct, rt)
        case _e:
          ;(Gt = 8), (xt |= 8)
          break
        case tt:
          return (
            (nt = cs(12, ft, rt, xt | 2)),
            (nt.elementType = tt),
            (nt.lanes = Ct),
            nt
          )
        case ut:
          return (
            (nt = cs(13, ft, rt, xt)),
            (nt.elementType = ut),
            (nt.lanes = Ct),
            nt
          )
        case it:
          return (
            (nt = cs(19, ft, rt, xt)),
            (nt.elementType = it),
            (nt.lanes = Ct),
            nt
          )
        case ht:
          return Nl(ft, xt, Ct, rt)
        default:
          if (typeof nt == "object" && nt !== null)
            switch (nt.$$typeof) {
              case st:
                Gt = 10
                break e
              case at:
                Gt = 9
                break e
              case ot:
                Gt = 11
                break e
              case ct:
                Gt = 14
                break e
              case lt:
                ;(Gt = 16), (mt = null)
                break e
            }
          throw Error(g(130, nt == null ? nt : typeof nt, ""))
      }
    return (
      (rt = cs(Gt, ft, rt, xt)),
      (rt.elementType = nt),
      (rt.type = mt),
      (rt.lanes = Ct),
      rt
    )
  }
  function Xs(nt, rt, ft, mt) {
    return (nt = cs(7, nt, mt, rt)), (nt.lanes = ft), nt
  }
  function Nl(nt, rt, ft, mt) {
    return (
      (nt = cs(22, nt, mt, rt)),
      (nt.elementType = ht),
      (nt.lanes = ft),
      (nt.stateNode = {}),
      nt
    )
  }
  function Vu(nt, rt, ft) {
    return (nt = cs(6, nt, null, rt)), (nt.lanes = ft), nt
  }
  function Gu(nt, rt, ft) {
    return (
      (rt = cs(4, nt.children !== null ? nt.children : [], nt.key, rt)),
      (rt.lanes = ft),
      (rt.stateNode = {
        containerInfo: nt.containerInfo,
        pendingChildren: null,
        implementation: nt.implementation,
      }),
      rt
    )
  }
  function r0(nt, rt, ft, mt, xt) {
    ;(this.tag = rt),
      (this.containerInfo = nt),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = $n),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Ul(0)),
      (this.expirationTimes = Ul(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Ul(0)),
      (this.identifierPrefix = mt),
      (this.onRecoverableError = xt),
      on && (this.mutableSourceEagerHydrationData = null)
  }
  function gm(nt, rt, ft, mt, xt, Ct, Gt, Jt, fn) {
    return (
      (nt = new r0(nt, rt, ft, Jt, fn)),
      rt === 1 ? ((rt = 1), Ct === !0 && (rt |= 8)) : (rt = 0),
      (Ct = cs(3, null, null, rt)),
      (nt.current = Ct),
      (Ct.stateNode = nt),
      (Ct.memoizedState = {
        element: mt,
        isDehydrated: ft,
        cache: null,
        transitions: null,
      }),
      Kl(Ct),
      nt
    )
  }
  function vm(nt) {
    if (!nt) return rr
    nt = nt._reactInternals
    e: {
      if (yt(nt) !== nt || nt.tag !== 1) throw Error(g(170))
      var rt = nt
      do {
        switch (rt.tag) {
          case 3:
            rt = rt.stateNode.context
            break e
          case 1:
            if (Er(rt.type)) {
              rt = rt.stateNode.__reactInternalMemoizedMergedChildContext
              break e
            }
        }
        rt = rt.return
      } while (rt !== null)
      throw Error(g(171))
    }
    if (nt.tag === 1) {
      var ft = nt.type
      if (Er(ft)) return wr(nt, ft, rt)
    }
    return rt
  }
  function ym(nt) {
    var rt = nt._reactInternals
    if (rt === void 0)
      throw typeof nt.render == "function"
        ? Error(g(188))
        : ((nt = Object.keys(nt).join(",")), Error(g(268, nt)))
    return (nt = Ft(rt)), nt === null ? null : nt.stateNode
  }
  function _m(nt, rt) {
    if (((nt = nt.memoizedState), nt !== null && nt.dehydrated !== null)) {
      var ft = nt.retryLane
      nt.retryLane = ft !== 0 && ft < rt ? ft : rt
    }
  }
  function zu(nt, rt) {
    _m(nt, rt), (nt = nt.alternate) && _m(nt, rt)
  }
  function i0(nt) {
    return (nt = Ft(nt)), nt === null ? null : nt.stateNode
  }
  function s0() {
    return null
  }
  return (
    (a.attemptContinuousHydration = function (nt) {
      if (nt.tag === 13) {
        var rt = Yr()
        ls(nt, 134217728, rt), zu(nt, 134217728)
      }
    }),
    (a.attemptHydrationAtCurrentPriority = function (nt) {
      if (nt.tag === 13) {
        var rt = Yr(),
          ft = Ds(nt)
        ls(nt, ft, rt), zu(nt, ft)
      }
    }),
    (a.attemptSynchronousHydration = function (nt) {
      switch (nt.tag) {
        case 3:
          var rt = nt.stateNode
          if (rt.current.memoizedState.isDehydrated) {
            var ft = so(rt.pendingLanes)
            ft !== 0 &&
              (Vl(rt, ft | 1), qr(rt, Or()), !(ur & 6) && (ro(), ys()))
          }
          break
        case 13:
          var mt = Yr()
          om(function () {
            return ls(nt, 1, mt)
          }),
            zu(nt, 1)
      }
    }),
    (a.batchedUpdates = function (nt, rt) {
      var ft = ur
      ur |= 1
      try {
        return nt(rt)
      } finally {
        ;(ur = ft), ur === 0 && (ro(), Po && ys())
      }
    }),
    (a.createComponentSelector = function (nt) {
      return { $$typeof: _l, value: nt }
    }),
    (a.createContainer = function (nt, rt, ft, mt, xt, Ct, Gt) {
      return gm(nt, rt, !1, null, ft, mt, xt, Ct, Gt)
    }),
    (a.createHasPseudoClassSelector = function (nt) {
      return { $$typeof: xl, value: nt }
    }),
    (a.createHydrationContainer = function (
      nt,
      rt,
      ft,
      mt,
      xt,
      Ct,
      Gt,
      Jt,
      fn
    ) {
      return (
        (nt = gm(ft, mt, !0, nt, xt, Ct, Gt, Jt, fn)),
        (nt.context = vm(null)),
        (ft = nt.current),
        (mt = Yr()),
        (xt = Ds(ft)),
        (Ct = Cs(mt, xt)),
        (Ct.callback = rt ?? null),
        Is(ft, Ct),
        (nt.current.lanes = xt),
        ao(nt, xt, mt),
        qr(nt, mt),
        nt
      )
    }),
    (a.createPortal = function (nt, rt, ft) {
      var mt =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
      return {
        $$typeof: j,
        key: mt == null ? null : "" + mt,
        children: nt,
        containerInfo: rt,
        implementation: ft,
      }
    }),
    (a.createRoleSelector = function (nt) {
      return { $$typeof: Al, value: nt }
    }),
    (a.createTestNameSelector = function (nt) {
      return { $$typeof: Sl, value: nt }
    }),
    (a.createTextSelector = function (nt) {
      return { $$typeof: El, value: nt }
    }),
    (a.deferredUpdates = function (nt) {
      var rt = vr,
        ft = Lr.transition
      try {
        return (Lr.transition = null), (vr = 16), nt()
      } finally {
        ;(vr = rt), (Lr.transition = ft)
      }
    }),
    (a.discreteUpdates = function (nt, rt, ft, mt, xt) {
      var Ct = vr,
        Gt = Lr.transition
      try {
        return (Lr.transition = null), (vr = 1), nt(rt, ft, mt, xt)
      } finally {
        ;(vr = Ct), (Lr.transition = Gt), ur === 0 && ro()
      }
    }),
    (a.findAllNodes = wu),
    (a.findBoundingRects = function (nt, rt) {
      if (!Gn) throw Error(g(363))
      ;(rt = wu(nt, rt)), (nt = [])
      for (var ft = 0; ft < rt.length; ft++) nt.push(ar(rt[ft]))
      for (rt = nt.length - 1; 0 < rt; rt--) {
        ft = nt[rt]
        for (
          var mt = ft.x,
            xt = mt + ft.width,
            Ct = ft.y,
            Gt = Ct + ft.height,
            Jt = rt - 1;
          0 <= Jt;
          Jt--
        )
          if (rt !== Jt) {
            var fn = nt[Jt],
              Cn = fn.x,
              zn = Cn + fn.width,
              ir = fn.y,
              Qn = ir + fn.height
            if (mt >= Cn && Ct >= ir && xt <= zn && Gt <= Qn) {
              nt.splice(rt, 1)
              break
            } else if (
              mt !== Cn ||
              ft.width !== fn.width ||
              Qn < Ct ||
              ir > Gt
            ) {
              if (
                !(Ct !== ir || ft.height !== fn.height || zn < mt || Cn > xt)
              ) {
                Cn > mt && ((fn.width += Cn - mt), (fn.x = mt)),
                  zn < xt && (fn.width = xt - Cn),
                  nt.splice(rt, 1)
                break
              }
            } else {
              ir > Ct && ((fn.height += ir - Ct), (fn.y = Ct)),
                Qn < Gt && (fn.height = Gt - ir),
                nt.splice(rt, 1)
              break
            }
          }
      }
      return nt
    }),
    (a.findHostInstance = ym),
    (a.findHostInstanceWithNoPortals = function (nt) {
      return (
        (nt = Rt(nt)),
        (nt = nt !== null ? Nt(nt) : null),
        nt === null ? null : nt.stateNode
      )
    }),
    (a.findHostInstanceWithWarning = function (nt) {
      return ym(nt)
    }),
    (a.flushControlled = function (nt) {
      var rt = ur
      ur |= 1
      var ft = Lr.transition,
        mt = vr
      try {
        ;(Lr.transition = null), (vr = 1), nt()
      } finally {
        ;(vr = mt), (Lr.transition = ft), (ur = rt), ur === 0 && (ro(), ys())
      }
    }),
    (a.flushPassiveEffects = $s),
    (a.flushSync = om),
    (a.focusWithin = function (nt, rt) {
      if (!Gn) throw Error(g(363))
      for (
        nt = Tu(nt), rt = im(nt, rt), rt = Array.from(rt), nt = 0;
        nt < rt.length;

      ) {
        var ft = rt[nt++]
        if (!Lt(ft)) {
          if (ft.tag === 5 && xn(ft.stateNode)) return !0
          for (ft = ft.child; ft !== null; ) rt.push(ft), (ft = ft.sibling)
        }
      }
      return !1
    }),
    (a.getCurrentUpdatePriority = function () {
      return vr
    }),
    (a.getFindAllNodesFailureDescription = function (nt, rt) {
      if (!Gn) throw Error(g(363))
      var ft = 0,
        mt = []
      nt = [Tu(nt), 0]
      for (var xt = 0; xt < nt.length; ) {
        var Ct = nt[xt++],
          Gt = nt[xt++],
          Jt = rt[Gt]
        if (
          (Ct.tag !== 5 || !Lt(Ct)) &&
          (Cu(Ct, Jt) && (mt.push(bu(Jt)), Gt++, Gt > ft && (ft = Gt)),
          Gt < rt.length)
        )
          for (Ct = Ct.child; Ct !== null; ) nt.push(Ct, Gt), (Ct = Ct.sibling)
      }
      if (ft < rt.length) {
        for (nt = []; ft < rt.length; ft++) nt.push(bu(rt[ft]))
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (mt.join(" > ") +
            `

No matching component was found for:
  `) +
          nt.join(" > ")
        )
      }
      return null
    }),
    (a.getPublicRootInstance = function (nt) {
      if (((nt = nt.current), !nt.child)) return null
      switch (nt.child.tag) {
        case 5:
          return Mt(nt.child.stateNode)
        default:
          return nt.child.stateNode
      }
    }),
    (a.injectIntoDevTools = function (nt) {
      if (
        ((nt = {
          bundleType: nt.bundleType,
          version: nt.version,
          rendererPackageName: nt.rendererPackageName,
          rendererConfig: nt.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: _.ReactCurrentDispatcher,
          findHostInstanceByFiber: i0,
          findFiberByHostInstance: nt.findFiberByHostInstance || s0,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        nt = !1
      else {
        var rt = __REACT_DEVTOOLS_GLOBAL_HOOK__
        if (rt.isDisabled || !rt.supportsFiber) nt = !0
        else {
          try {
            ;(wo = rt.inject(nt)), (gs = rt)
          } catch {}
          nt = !!rt.checkDCE
        }
      }
      return nt
    }),
    (a.isAlreadyRendering = function () {
      return !1
    }),
    (a.observeVisibleRects = function (nt, rt, ft, mt) {
      if (!Gn) throw Error(g(363))
      nt = wu(nt, rt)
      var xt = vn(nt, ft, mt).disconnect
      return {
        disconnect: function () {
          xt()
        },
      }
    }),
    (a.registerMutableSourceForHydration = function (nt, rt) {
      var ft = rt._getVersion
      ;(ft = ft(rt._source)),
        nt.mutableSourceEagerHydrationData == null
          ? (nt.mutableSourceEagerHydrationData = [rt, ft])
          : nt.mutableSourceEagerHydrationData.push(rt, ft)
    }),
    (a.runWithPriority = function (nt, rt) {
      var ft = vr
      try {
        return (vr = nt), rt()
      } finally {
        vr = ft
      }
    }),
    (a.shouldError = function () {
      return null
    }),
    (a.shouldSuspend = function () {
      return !1
    }),
    (a.updateContainer = function (nt, rt, ft, mt) {
      var xt = rt.current,
        Ct = Yr(),
        Gt = Ds(xt)
      return (
        (ft = vm(ft)),
        rt.context === null ? (rt.context = ft) : (rt.pendingContext = ft),
        (rt = Cs(Ct, Gt)),
        (rt.payload = { element: nt }),
        (mt = mt === void 0 ? null : mt),
        mt !== null && (rt.callback = mt),
        Is(xt, rt),
        (nt = ls(xt, Gt, Ct)),
        nt !== null && Lo(nt, xt, Gt),
        Gt
      )
    }),
    a
  )
}
reactReconciler.exports = reactReconciler_production_min
var reactReconcilerExports = reactReconciler.exports
const Reconciler = getDefaultExportFromCjs(reactReconcilerExports)
var scheduler = { exports: {} },
  scheduler_production_min = {}
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function (s) {
  function e(gt, At) {
    var bt = gt.length
    gt.push(At)
    e: for (; 0 < bt; ) {
      var Tt = (bt - 1) >>> 1,
        It = gt[Tt]
      if (0 < c(It, At)) (gt[Tt] = At), (gt[bt] = It), (bt = Tt)
      else break e
    }
  }
  function a(gt) {
    return gt.length === 0 ? null : gt[0]
  }
  function o(gt) {
    if (gt.length === 0) return null
    var At = gt[0],
      bt = gt.pop()
    if (bt !== At) {
      gt[0] = bt
      e: for (var Tt = 0, It = gt.length, $t = It >>> 1; Tt < $t; ) {
        var Xt = 2 * (Tt + 1) - 1,
          qt = gt[Xt],
          en = Xt + 1,
          yn = gt[en]
        if (0 > c(qt, bt))
          en < It && 0 > c(yn, qt)
            ? ((gt[Tt] = yn), (gt[en] = bt), (Tt = en))
            : ((gt[Tt] = qt), (gt[Xt] = bt), (Tt = Xt))
        else if (en < It && 0 > c(yn, bt))
          (gt[Tt] = yn), (gt[en] = bt), (Tt = en)
        else break e
      }
    }
    return At
  }
  function c(gt, At) {
    var bt = gt.sortIndex - At.sortIndex
    return bt !== 0 ? bt : gt.id - At.id
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var d = performance
    s.unstable_now = function () {
      return d.now()
    }
  } else {
    var g = Date,
      _ = g.now()
    s.unstable_now = function () {
      return g.now() - _
    }
  }
  var b = [],
    j = [],
    $ = 1,
    _e = null,
    tt = 3,
    st = !1,
    at = !1,
    ot = !1,
    ut = typeof setTimeout == "function" ? setTimeout : null,
    it = typeof clearTimeout == "function" ? clearTimeout : null,
    ct = typeof setImmediate < "u" ? setImmediate : null
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling)
  function lt(gt) {
    for (var At = a(j); At !== null; ) {
      if (At.callback === null) o(j)
      else if (At.startTime <= gt)
        o(j), (At.sortIndex = At.expirationTime), e(b, At)
      else break
      At = a(j)
    }
  }
  function ht(gt) {
    if (((ot = !1), lt(gt), !at))
      if (a(b) !== null) (at = !0), Mt(dt)
      else {
        var At = a(j)
        At !== null && wt(ht, At.startTime - gt)
      }
  }
  function dt(gt, At) {
    ;(at = !1), ot && ((ot = !1), it(_t), (_t = -1)), (st = !0)
    var bt = tt
    try {
      for (
        lt(At), _e = a(b);
        _e !== null && (!(_e.expirationTime > At) || (gt && !Rt()));

      ) {
        var Tt = _e.callback
        if (typeof Tt == "function") {
          ;(_e.callback = null), (tt = _e.priorityLevel)
          var It = Tt(_e.expirationTime <= At)
          ;(At = s.unstable_now()),
            typeof It == "function" ? (_e.callback = It) : _e === a(b) && o(b),
            lt(At)
        } else o(b)
        _e = a(b)
      }
      if (_e !== null) var $t = !0
      else {
        var Xt = a(j)
        Xt !== null && wt(ht, Xt.startTime - At), ($t = !1)
      }
      return $t
    } finally {
      ;(_e = null), (tt = bt), (st = !1)
    }
  }
  var pt = !1,
    vt = null,
    _t = -1,
    yt = 5,
    Et = -1
  function Rt() {
    return !(s.unstable_now() - Et < yt)
  }
  function Ft() {
    if (vt !== null) {
      var gt = s.unstable_now()
      Et = gt
      var At = !0
      try {
        At = vt(!0, gt)
      } finally {
        At ? kt() : ((pt = !1), (vt = null))
      }
    } else pt = !1
  }
  var kt
  if (typeof ct == "function")
    kt = function () {
      ct(Ft)
    }
  else if (typeof MessageChannel < "u") {
    var Nt = new MessageChannel(),
      Dt = Nt.port2
    ;(Nt.port1.onmessage = Ft),
      (kt = function () {
        Dt.postMessage(null)
      })
  } else
    kt = function () {
      ut(Ft, 0)
    }
  function Mt(gt) {
    ;(vt = gt), pt || ((pt = !0), kt())
  }
  function wt(gt, At) {
    _t = ut(function () {
      gt(s.unstable_now())
    }, At)
  }
  ;(s.unstable_IdlePriority = 5),
    (s.unstable_ImmediatePriority = 1),
    (s.unstable_LowPriority = 4),
    (s.unstable_NormalPriority = 3),
    (s.unstable_Profiling = null),
    (s.unstable_UserBlockingPriority = 2),
    (s.unstable_cancelCallback = function (gt) {
      gt.callback = null
    }),
    (s.unstable_continueExecution = function () {
      at || st || ((at = !0), Mt(dt))
    }),
    (s.unstable_forceFrameRate = function (gt) {
      0 > gt || 125 < gt
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (yt = 0 < gt ? Math.floor(1e3 / gt) : 5)
    }),
    (s.unstable_getCurrentPriorityLevel = function () {
      return tt
    }),
    (s.unstable_getFirstCallbackNode = function () {
      return a(b)
    }),
    (s.unstable_next = function (gt) {
      switch (tt) {
        case 1:
        case 2:
        case 3:
          var At = 3
          break
        default:
          At = tt
      }
      var bt = tt
      tt = At
      try {
        return gt()
      } finally {
        tt = bt
      }
    }),
    (s.unstable_pauseExecution = function () {}),
    (s.unstable_requestPaint = function () {}),
    (s.unstable_runWithPriority = function (gt, At) {
      switch (gt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break
        default:
          gt = 3
      }
      var bt = tt
      tt = gt
      try {
        return At()
      } finally {
        tt = bt
      }
    }),
    (s.unstable_scheduleCallback = function (gt, At, bt) {
      var Tt = s.unstable_now()
      switch (
        (typeof bt == "object" && bt !== null
          ? ((bt = bt.delay),
            (bt = typeof bt == "number" && 0 < bt ? Tt + bt : Tt))
          : (bt = Tt),
        gt)
      ) {
        case 1:
          var It = -1
          break
        case 2:
          It = 250
          break
        case 5:
          It = 1073741823
          break
        case 4:
          It = 1e4
          break
        default:
          It = 5e3
      }
      return (
        (It = bt + It),
        (gt = {
          id: $++,
          callback: At,
          priorityLevel: gt,
          startTime: bt,
          expirationTime: It,
          sortIndex: -1,
        }),
        bt > Tt
          ? ((gt.sortIndex = bt),
            e(j, gt),
            a(b) === null &&
              gt === a(j) &&
              (ot ? (it(_t), (_t = -1)) : (ot = !0), wt(ht, bt - Tt)))
          : ((gt.sortIndex = It), e(b, gt), at || st || ((at = !0), Mt(dt))),
        gt
      )
    }),
    (s.unstable_shouldYield = Rt),
    (s.unstable_wrapCallback = function (gt) {
      var At = tt
      return function () {
        var bt = tt
        tt = At
        try {
          return gt.apply(this, arguments)
        } finally {
          tt = bt
        }
      }
    })
})(scheduler_production_min)
scheduler.exports = scheduler_production_min
var schedulerExports = scheduler.exports
const isPromise = (s) => typeof s == "object" && typeof s.then == "function",
  globalCache = []
function shallowEqualArrays(s, e, a = (o, c) => o === c) {
  if (s === e) return !0
  if (!s || !e) return !1
  const o = s.length
  if (e.length !== o) return !1
  for (let c = 0; c < o; c++) if (!a(s[c], e[c])) return !1
  return !0
}
function query(s, e = null, a = !1, o = {}) {
  e === null && (e = [s])
  for (const d of globalCache)
    if (shallowEqualArrays(e, d.keys, d.equal)) {
      if (a) return
      if (Object.prototype.hasOwnProperty.call(d, "error")) throw d.error
      if (Object.prototype.hasOwnProperty.call(d, "response"))
        return (
          o.lifespan &&
            o.lifespan > 0 &&
            (d.timeout && clearTimeout(d.timeout),
            (d.timeout = setTimeout(d.remove, o.lifespan))),
          d.response
        )
      if (!a) throw d.promise
    }
  const c = {
    keys: e,
    equal: o.equal,
    remove: () => {
      const d = globalCache.indexOf(c)
      d !== -1 && globalCache.splice(d, 1)
    },
    promise: (isPromise(s) ? s : s(...e))
      .then((d) => {
        ;(c.response = d),
          o.lifespan &&
            o.lifespan > 0 &&
            (c.timeout = setTimeout(c.remove, o.lifespan))
      })
      .catch((d) => (c.error = d)),
  }
  if ((globalCache.push(c), !a)) throw c.promise
}
const suspend = (s, e, a) => query(s, e, !1, a),
  preload = (s, e, a) => void query(s, e, !0, a),
  clear = (s) => {
    if (s === void 0 || s.length === 0)
      globalCache.splice(0, globalCache.length)
    else {
      const e = globalCache.find((a) => shallowEqualArrays(s, a.keys, a.equal))
      e && e.remove()
    }
  },
  catalogue = {},
  extend = (s) => void Object.assign(catalogue, s)
function createRenderer(s, e) {
  function a($, { args: _e = [], attach: tt, ...st }, at) {
    let ot = `${$[0].toUpperCase()}${$.slice(1)}`,
      ut
    if ($ === "primitive") {
      if (st.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!")
      const it = st.object
      ut = prepare(it, { type: $, root: at, attach: tt, primitive: !0 })
    } else {
      const it = catalogue[ot]
      if (!it)
        throw new Error(
          `R3F: ${ot} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        )
      if (!Array.isArray(_e))
        throw new Error("R3F: The args prop must be an array!")
      ut = prepare(new it(..._e), {
        type: $,
        root: at,
        attach: tt,
        memoizedProps: { args: _e },
      })
    }
    return (
      ut.__r3f.attach === void 0 &&
        (ut instanceof BufferGeometry
          ? (ut.__r3f.attach = "geometry")
          : ut instanceof Material && (ut.__r3f.attach = "material")),
      ot !== "inject" && applyProps$1(ut, st),
      ut
    )
  }
  function o($, _e) {
    let tt = !1
    if (_e) {
      var st, at
      ;(st = _e.__r3f) != null && st.attach
        ? attach($, _e, _e.__r3f.attach)
        : _e.isObject3D && $.isObject3D && ($.add(_e), (tt = !0)),
        tt || (at = $.__r3f) == null || at.objects.push(_e),
        _e.__r3f || prepare(_e, {}),
        (_e.__r3f.parent = $),
        updateInstance(_e),
        invalidateInstance(_e)
    }
  }
  function c($, _e, tt) {
    let st = !1
    if (_e) {
      var at, ot
      if ((at = _e.__r3f) != null && at.attach) attach($, _e, _e.__r3f.attach)
      else if (_e.isObject3D && $.isObject3D) {
        ;(_e.parent = $), _e.dispatchEvent({ type: "added" })
        const ut = $.children.filter((ct) => ct !== _e),
          it = ut.indexOf(tt)
        ;($.children = [...ut.slice(0, it), _e, ...ut.slice(it)]), (st = !0)
      }
      st || (ot = $.__r3f) == null || ot.objects.push(_e),
        _e.__r3f || prepare(_e, {}),
        (_e.__r3f.parent = $),
        updateInstance(_e),
        invalidateInstance(_e)
    }
  }
  function d($, _e, tt = !1) {
    $ && [...$].forEach((st) => g(_e, st, tt))
  }
  function g($, _e, tt) {
    if (_e) {
      var st, at, ot
      if (
        (_e.__r3f && (_e.__r3f.parent = null),
        (st = $.__r3f) != null &&
          st.objects &&
          ($.__r3f.objects = $.__r3f.objects.filter((ht) => ht !== _e)),
        (at = _e.__r3f) != null && at.attach)
      )
        detach($, _e, _e.__r3f.attach)
      else if (_e.isObject3D && $.isObject3D) {
        var ut
        $.remove(_e),
          (ut = _e.__r3f) != null &&
            ut.root &&
            removeInteractivity(_e.__r3f.root, _e)
      }
      const ct = (ot = _e.__r3f) == null ? void 0 : ot.primitive,
        lt = tt === void 0 ? _e.dispose !== null && !ct : tt
      if (!ct) {
        var it
        d((it = _e.__r3f) == null ? void 0 : it.objects, _e, lt),
          d(_e.children, _e, lt)
      }
      delete _e.__r3f,
        lt &&
          _e.dispose &&
          _e.type !== "Scene" &&
          schedulerExports.unstable_scheduleCallback(
            schedulerExports.unstable_IdlePriority,
            () => {
              try {
                _e.dispose()
              } catch {}
            }
          ),
        invalidateInstance($)
    }
  }
  function _($, _e, tt, st) {
    var at
    const ot = (at = $.__r3f) == null ? void 0 : at.parent
    if (!ot) return
    const ut = a(_e, tt, $.__r3f.root)
    if ($.children) {
      for (const it of $.children) it.__r3f && o(ut, it)
      $.children = $.children.filter((it) => !it.__r3f)
    }
    $.__r3f.objects.forEach((it) => o(ut, it)),
      ($.__r3f.objects = []),
      $.__r3f.autoRemovedBeforeAppend || g(ot, $),
      ut.parent && (ut.__r3f.autoRemovedBeforeAppend = !0),
      o(ot, ut),
      ut.raycast &&
        ut.__r3f.eventCount &&
        ut.__r3f.root.getState().internal.interaction.push(ut),
      [st, st.alternate].forEach((it) => {
        it !== null &&
          ((it.stateNode = ut),
          it.ref &&
            (typeof it.ref == "function" ? it.ref(ut) : (it.ref.current = ut)))
      })
  }
  const b = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    )
  return {
    reconciler: Reconciler({
      createInstance: a,
      removeChild: g,
      appendChild: o,
      appendInitialChild: o,
      insertBefore: c,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: ($, _e) => {
        if (!_e) return
        const tt = $.getState().scene
        tt.__r3f && ((tt.__r3f.root = $), o(tt, _e))
      },
      removeChildFromContainer: ($, _e) => {
        _e && g($.getState().scene, _e)
      },
      insertInContainerBefore: ($, _e, tt) => {
        if (!_e || !tt) return
        const st = $.getState().scene
        st.__r3f && c(st, _e, tt)
      },
      getRootHostContext: () => null,
      getChildHostContext: ($) => $,
      finalizeInitialChildren($) {
        var _e
        return !!((_e = $ == null ? void 0 : $.__r3f) != null ? _e : {})
          .handlers
      },
      prepareUpdate($, _e, tt, st) {
        var at
        if (
          ((at = $ == null ? void 0 : $.__r3f) != null ? at : {}).primitive &&
          st.object &&
          st.object !== $
        )
          return [!0]
        {
          const { args: ut = [], children: it, ...ct } = st,
            { args: lt = [], children: ht, ...dt } = tt
          if (!Array.isArray(ut))
            throw new Error("R3F: the args prop must be an array!")
          if (ut.some((vt, _t) => vt !== lt[_t])) return [!0]
          const pt = diffProps($, ct, dt, !0)
          return pt.changes.length ? [!1, pt] : null
        }
      },
      commitUpdate($, [_e, tt], st, at, ot, ut) {
        _e ? _($, st, ot, ut) : applyProps$1($, tt)
      },
      commitMount($, _e, tt, st) {
        var at
        const ot = (at = $.__r3f) != null ? at : {}
        $.raycast &&
          ot.handlers &&
          ot.eventCount &&
          $.__r3f.root.getState().internal.interaction.push($)
      },
      getPublicInstance: ($) => $,
      prepareForCommit: () => null,
      preparePortalMount: ($) => prepare($.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance($) {
        var _e
        const { attach: tt, parent: st } = (_e = $.__r3f) != null ? _e : {}
        tt && st && detach(st, $, tt),
          $.isObject3D && ($.visible = !1),
          invalidateInstance($)
      },
      unhideInstance($, _e) {
        var tt
        const { attach: st, parent: at } = (tt = $.__r3f) != null ? tt : {}
        st && at && attach(at, $, st),
          (($.isObject3D && _e.visible == null) || _e.visible) &&
            ($.visible = !0),
          invalidateInstance($)
      },
      createTextInstance: b,
      hideTextInstance: b,
      unhideTextInstance: b,
      getCurrentEventPriority: () =>
        e ? e() : constantsExports.DefaultEventPriority,
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && is.fun(performance.now)
          ? performance.now
          : is.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: is.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: is.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: applyProps$1,
  }
}
var _window$document, _window$navigator
const hasColorSpace$1 = (s) => "colorSpace" in s || "outputColorSpace" in s,
  getColorManagement = () => {
    var s
    return (s = catalogue.ColorManagement) != null ? s : null
  },
  isOrthographicCamera = (s) => s && s.isOrthographicCamera,
  isRef$1 = (s) => s && s.hasOwnProperty("current"),
  useIsomorphicLayoutEffect$1 =
    typeof window < "u" &&
    (((_window$document = window.document) != null &&
      _window$document.createElement) ||
      ((_window$navigator = window.navigator) == null
        ? void 0
        : _window$navigator.product) === "ReactNative")
      ? reactExports.useLayoutEffect
      : reactExports.useEffect
function useMutableCallback(s) {
  const e = reactExports.useRef(s)
  return useIsomorphicLayoutEffect$1(() => void (e.current = s), [s]), e
}
function Block({ set: s }) {
  return (
    useIsomorphicLayoutEffect$1(
      () => (s(new Promise(() => null)), () => s(!1)),
      [s]
    ),
    null
  )
}
class ErrorBoundary extends reactExports.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 })
  }
  componentDidCatch(e) {
    this.props.set(e)
  }
  render() {
    return this.state.error ? null : this.props.children
  }
}
ErrorBoundary.getDerivedStateFromError = () => ({ error: !0 })
const DEFAULT = "__default",
  DEFAULTS = new Map(),
  isDiffSet = (s) => s && !!s.memoized && !!s.changes
function calculateDpr(s) {
  var e
  const a =
    typeof window < "u" ? ((e = window.devicePixelRatio) != null ? e : 2) : 1
  return Array.isArray(s) ? Math.min(Math.max(s[0], a), s[1]) : s
}
const getRootState = (s) => {
    var e
    return (e = s.__r3f) == null ? void 0 : e.root.getState()
  },
  is = {
    obj: (s) => s === Object(s) && !is.arr(s) && typeof s != "function",
    fun: (s) => typeof s == "function",
    str: (s) => typeof s == "string",
    num: (s) => typeof s == "number",
    boo: (s) => typeof s == "boolean",
    und: (s) => s === void 0,
    arr: (s) => Array.isArray(s),
    equ(
      s,
      e,
      { arrays: a = "shallow", objects: o = "reference", strict: c = !0 } = {}
    ) {
      if (typeof s != typeof e || !!s != !!e) return !1
      if (is.str(s) || is.num(s)) return s === e
      const d = is.obj(s)
      if (d && o === "reference") return s === e
      const g = is.arr(s)
      if (g && a === "reference") return s === e
      if ((g || d) && s === e) return !0
      let _
      for (_ in s) if (!(_ in e)) return !1
      if (d && a === "shallow" && o === "shallow") {
        for (_ in c ? e : s)
          if (!is.equ(s[_], e[_], { strict: c, objects: "reference" }))
            return !1
      } else for (_ in c ? e : s) if (s[_] !== e[_]) return !1
      if (is.und(_)) {
        if (
          (g && s.length === 0 && e.length === 0) ||
          (d && Object.keys(s).length === 0 && Object.keys(e).length === 0)
        )
          return !0
        if (s !== e) return !1
      }
      return !0
    },
  }
function buildGraph(s) {
  const e = { nodes: {}, materials: {} }
  return (
    s &&
      s.traverse((a) => {
        a.name && (e.nodes[a.name] = a),
          a.material &&
            !e.materials[a.material.name] &&
            (e.materials[a.material.name] = a.material)
      }),
    e
  )
}
function dispose(s) {
  s.dispose && s.type !== "Scene" && s.dispose()
  for (const e in s) e.dispose == null || e.dispose(), delete s[e]
}
function prepare(s, e) {
  const a = s
  return (
    (a.__r3f = {
      type: "",
      root: null,
      previousAttach: null,
      memoizedProps: {},
      eventCount: 0,
      handlers: {},
      objects: [],
      parent: null,
      ...e,
    }),
    s
  )
}
function resolve(s, e) {
  let a = s
  if (e.includes("-")) {
    const o = e.split("-"),
      c = o.pop()
    return (a = o.reduce((d, g) => d[g], s)), { target: a, key: c }
  } else return { target: a, key: e }
}
const INDEX_REGEX = /-\d+$/
function attach(s, e, a) {
  if (is.str(a)) {
    if (INDEX_REGEX.test(a)) {
      const d = a.replace(INDEX_REGEX, ""),
        { target: g, key: _ } = resolve(s, d)
      Array.isArray(g[_]) || (g[_] = [])
    }
    const { target: o, key: c } = resolve(s, a)
    ;(e.__r3f.previousAttach = o[c]), (o[c] = e)
  } else e.__r3f.previousAttach = a(s, e)
}
function detach(s, e, a) {
  var o, c
  if (is.str(a)) {
    const { target: d, key: g } = resolve(s, a),
      _ = e.__r3f.previousAttach
    _ === void 0 ? delete d[g] : (d[g] = _)
  } else
    (o = e.__r3f) == null || o.previousAttach == null || o.previousAttach(s, e)
  ;(c = e.__r3f) == null || delete c.previousAttach
}
function diffProps(
  s,
  { children: e, key: a, ref: o, ...c },
  { children: d, key: g, ref: _, ...b } = {},
  j = !1
) {
  var $
  const _e = ($ = s == null ? void 0 : s.__r3f) != null ? $ : {},
    tt = Object.entries(c),
    st = []
  if (j) {
    const ot = Object.keys(b)
    for (let ut = 0; ut < ot.length; ut++)
      c.hasOwnProperty(ot[ut]) || tt.unshift([ot[ut], DEFAULT + "remove"])
  }
  tt.forEach(([ot, ut]) => {
    var it
    if (
      ((it = s.__r3f) != null && it.primitive && ot === "object") ||
      is.equ(ut, b[ot])
    )
      return
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(ot))
      return st.push([ot, ut, !0, []])
    let ct = []
    ot.includes("-") && (ct = ot.split("-")), st.push([ot, ut, !1, ct])
    for (const lt in c) {
      const ht = c[lt]
      lt.startsWith(`${ot}-`) && st.push([lt, ht, !1, lt.split("-")])
    }
  })
  const at = { ...c }
  return (
    _e.memoizedProps &&
      _e.memoizedProps.args &&
      (at.args = _e.memoizedProps.args),
    _e.memoizedProps &&
      _e.memoizedProps.attach &&
      (at.attach = _e.memoizedProps.attach),
    { memoized: at, changes: st }
  )
}
function applyProps$1(s, e) {
  var a, o, c
  const d = (a = s.__r3f) != null ? a : {},
    g = d.root,
    _ =
      (o = g == null || g.getState == null ? void 0 : g.getState()) != null
        ? o
        : {},
    { memoized: b, changes: j } = isDiffSet(e) ? e : diffProps(s, e),
    $ = d.eventCount
  s.__r3f && (s.__r3f.memoizedProps = b)
  for (let tt = 0; tt < j.length; tt++) {
    let [st, at, ot, ut] = j[tt]
    if (hasColorSpace$1(s)) {
      const ht = "srgb",
        dt = "srgb-linear"
      st === "encoding"
        ? ((st = "colorSpace"), (at = at === 3001 ? ht : dt))
        : st === "outputEncoding" &&
          ((st = "outputColorSpace"), (at = at === 3001 ? ht : dt))
    }
    let it = s,
      ct = it[st]
    if (
      ut.length &&
      ((ct = ut.reduce((lt, ht) => lt[ht], s)), !(ct && ct.set))
    ) {
      const [lt, ...ht] = ut.reverse()
      ;(it = ht.reverse().reduce((dt, pt) => dt[pt], s)), (st = lt)
    }
    if (at === DEFAULT + "remove")
      if (it.constructor) {
        let lt = DEFAULTS.get(it.constructor)
        lt || ((lt = new it.constructor()), DEFAULTS.set(it.constructor, lt)),
          (at = lt[st])
      } else at = 0
    if (ot)
      at ? (d.handlers[st] = at) : delete d.handlers[st],
        (d.eventCount = Object.keys(d.handlers).length)
    else if (ct && ct.set && (ct.copy || ct instanceof Layers)) {
      if (Array.isArray(at)) ct.fromArray ? ct.fromArray(at) : ct.set(...at)
      else if (
        ct.copy &&
        at &&
        at.constructor &&
        ct.constructor === at.constructor
      )
        ct.copy(at)
      else if (at !== void 0) {
        const lt = ct instanceof Color
        !lt && ct.setScalar
          ? ct.setScalar(at)
          : ct instanceof Layers && at instanceof Layers
          ? (ct.mask = at.mask)
          : ct.set(at),
          !getColorManagement() && !_.linear && lt && ct.convertSRGBToLinear()
      }
    } else if (
      ((it[st] = at),
      it[st] instanceof Texture &&
        it[st].format === RGBAFormat &&
        it[st].type === UnsignedByteType)
    ) {
      const lt = it[st]
      hasColorSpace$1(lt) && hasColorSpace$1(_.gl)
        ? (lt.colorSpace = _.gl.outputColorSpace)
        : (lt.encoding = _.gl.outputEncoding)
    }
    invalidateInstance(s)
  }
  if (d.parent && _.internal && s.raycast && $ !== d.eventCount) {
    const tt = _.internal.interaction.indexOf(s)
    tt > -1 && _.internal.interaction.splice(tt, 1),
      d.eventCount && _.internal.interaction.push(s)
  }
  return (
    !(j.length === 1 && j[0][0] === "onUpdate") &&
      j.length &&
      (c = s.__r3f) != null &&
      c.parent &&
      updateInstance(s),
    s
  )
}
function invalidateInstance(s) {
  var e, a
  const o =
    (e = s.__r3f) == null || (a = e.root) == null || a.getState == null
      ? void 0
      : a.getState()
  o && o.internal.frames === 0 && o.invalidate()
}
function updateInstance(s) {
  s.onUpdate == null || s.onUpdate(s)
}
function updateCamera(s, e) {
  s.manual ||
    (isOrthographicCamera(s)
      ? ((s.left = e.width / -2),
        (s.right = e.width / 2),
        (s.top = e.height / 2),
        (s.bottom = e.height / -2))
      : (s.aspect = e.width / e.height),
    s.updateProjectionMatrix(),
    s.updateMatrixWorld())
}
function makeId(s) {
  return (s.eventObject || s.object).uuid + "/" + s.index + s.instanceId
}
function getEventPriority() {
  var s
  const e = (typeof self < "u" && self) || (typeof window < "u" && window)
  if (!e) return constantsExports.DefaultEventPriority
  switch ((s = e.event) == null ? void 0 : s.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return constantsExports.DiscreteEventPriority
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return constantsExports.ContinuousEventPriority
    default:
      return constantsExports.DefaultEventPriority
  }
}
function releaseInternalPointerCapture(s, e, a, o) {
  const c = a.get(e)
  c &&
    (a.delete(e),
    a.size === 0 && (s.delete(o), c.target.releasePointerCapture(o)))
}
function removeInteractivity(s, e) {
  const { internal: a } = s.getState()
  ;(a.interaction = a.interaction.filter((o) => o !== e)),
    (a.initialHits = a.initialHits.filter((o) => o !== e)),
    a.hovered.forEach((o, c) => {
      ;(o.eventObject === e || o.object === e) && a.hovered.delete(c)
    }),
    a.capturedMap.forEach((o, c) => {
      releaseInternalPointerCapture(a.capturedMap, e, o, c)
    })
}
function createEvents(s) {
  function e(b) {
    const { internal: j } = s.getState(),
      $ = b.offsetX - j.initialClick[0],
      _e = b.offsetY - j.initialClick[1]
    return Math.round(Math.sqrt($ * $ + _e * _e))
  }
  function a(b) {
    return b.filter((j) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some(($) => {
        var _e
        return (_e = j.__r3f) == null ? void 0 : _e.handlers["onPointer" + $]
      })
    )
  }
  function o(b, j) {
    const $ = s.getState(),
      _e = new Set(),
      tt = [],
      st = j ? j($.internal.interaction) : $.internal.interaction
    for (let it = 0; it < st.length; it++) {
      const ct = getRootState(st[it])
      ct && (ct.raycaster.camera = void 0)
    }
    $.previousRoot || $.events.compute == null || $.events.compute(b, $)
    function at(it) {
      const ct = getRootState(it)
      if (!ct || !ct.events.enabled || ct.raycaster.camera === null) return []
      if (ct.raycaster.camera === void 0) {
        var lt
        ct.events.compute == null ||
          ct.events.compute(
            b,
            ct,
            (lt = ct.previousRoot) == null ? void 0 : lt.getState()
          ),
          ct.raycaster.camera === void 0 && (ct.raycaster.camera = null)
      }
      return ct.raycaster.camera ? ct.raycaster.intersectObject(it, !0) : []
    }
    let ot = st
      .flatMap(at)
      .sort((it, ct) => {
        const lt = getRootState(it.object),
          ht = getRootState(ct.object)
        return !lt || !ht
          ? it.distance - ct.distance
          : ht.events.priority - lt.events.priority || it.distance - ct.distance
      })
      .filter((it) => {
        const ct = makeId(it)
        return _e.has(ct) ? !1 : (_e.add(ct), !0)
      })
    $.events.filter && (ot = $.events.filter(ot, $))
    for (const it of ot) {
      let ct = it.object
      for (; ct; ) {
        var ut
        ;(ut = ct.__r3f) != null &&
          ut.eventCount &&
          tt.push({ ...it, eventObject: ct }),
          (ct = ct.parent)
      }
    }
    if ("pointerId" in b && $.internal.capturedMap.has(b.pointerId))
      for (let it of $.internal.capturedMap.get(b.pointerId).values())
        _e.has(makeId(it.intersection)) || tt.push(it.intersection)
    return tt
  }
  function c(b, j, $, _e) {
    const tt = s.getState()
    if (b.length) {
      const st = { stopped: !1 }
      for (const at of b) {
        const ot = getRootState(at.object) || tt,
          { raycaster: ut, pointer: it, camera: ct, internal: lt } = ot,
          ht = new Vector3(it.x, it.y, 0).unproject(ct),
          dt = (Et) => {
            var Rt, Ft
            return (Rt =
              (Ft = lt.capturedMap.get(Et)) == null
                ? void 0
                : Ft.has(at.eventObject)) != null
              ? Rt
              : !1
          },
          pt = (Et) => {
            const Rt = { intersection: at, target: j.target }
            lt.capturedMap.has(Et)
              ? lt.capturedMap.get(Et).set(at.eventObject, Rt)
              : lt.capturedMap.set(Et, new Map([[at.eventObject, Rt]])),
              j.target.setPointerCapture(Et)
          },
          vt = (Et) => {
            const Rt = lt.capturedMap.get(Et)
            Rt &&
              releaseInternalPointerCapture(
                lt.capturedMap,
                at.eventObject,
                Rt,
                Et
              )
          }
        let _t = {}
        for (let Et in j) {
          let Rt = j[Et]
          typeof Rt != "function" && (_t[Et] = Rt)
        }
        let yt = {
          ...at,
          ..._t,
          pointer: it,
          intersections: b,
          stopped: st.stopped,
          delta: $,
          unprojectedPoint: ht,
          ray: ut.ray,
          camera: ct,
          stopPropagation() {
            const Et = "pointerId" in j && lt.capturedMap.get(j.pointerId)
            if (
              (!Et || Et.has(at.eventObject)) &&
              ((yt.stopped = st.stopped = !0),
              lt.hovered.size &&
                Array.from(lt.hovered.values()).find(
                  (Rt) => Rt.eventObject === at.eventObject
                ))
            ) {
              const Rt = b.slice(0, b.indexOf(at))
              d([...Rt, at])
            }
          },
          target: {
            hasPointerCapture: dt,
            setPointerCapture: pt,
            releasePointerCapture: vt,
          },
          currentTarget: {
            hasPointerCapture: dt,
            setPointerCapture: pt,
            releasePointerCapture: vt,
          },
          nativeEvent: j,
        }
        if ((_e(yt), st.stopped === !0)) break
      }
    }
    return b
  }
  function d(b) {
    const { internal: j } = s.getState()
    for (const $ of j.hovered.values())
      if (
        !b.length ||
        !b.find(
          (_e) =>
            _e.object === $.object &&
            _e.index === $.index &&
            _e.instanceId === $.instanceId
        )
      ) {
        const tt = $.eventObject.__r3f,
          st = tt == null ? void 0 : tt.handlers
        if ((j.hovered.delete(makeId($)), tt != null && tt.eventCount)) {
          const at = { ...$, intersections: b }
          st.onPointerOut == null || st.onPointerOut(at),
            st.onPointerLeave == null || st.onPointerLeave(at)
        }
      }
  }
  function g(b, j) {
    for (let $ = 0; $ < j.length; $++) {
      const _e = j[$].__r3f
      _e == null ||
        _e.handlers.onPointerMissed == null ||
        _e.handlers.onPointerMissed(b)
    }
  }
  function _(b) {
    switch (b) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => d([])
      case "onLostPointerCapture":
        return (j) => {
          const { internal: $ } = s.getState()
          "pointerId" in j &&
            $.capturedMap.has(j.pointerId) &&
            requestAnimationFrame(() => {
              $.capturedMap.has(j.pointerId) &&
                ($.capturedMap.delete(j.pointerId), d([]))
            })
        }
    }
    return function ($) {
      const { onPointerMissed: _e, internal: tt } = s.getState()
      tt.lastEvent.current = $
      const st = b === "onPointerMove",
        at = b === "onClick" || b === "onContextMenu" || b === "onDoubleClick",
        ut = o($, st ? a : void 0),
        it = at ? e($) : 0
      b === "onPointerDown" &&
        ((tt.initialClick = [$.offsetX, $.offsetY]),
        (tt.initialHits = ut.map((lt) => lt.eventObject))),
        at && !ut.length && it <= 2 && (g($, tt.interaction), _e && _e($)),
        st && d(ut)
      function ct(lt) {
        const ht = lt.eventObject,
          dt = ht.__r3f,
          pt = dt == null ? void 0 : dt.handlers
        if (dt != null && dt.eventCount)
          if (st) {
            if (
              pt.onPointerOver ||
              pt.onPointerEnter ||
              pt.onPointerOut ||
              pt.onPointerLeave
            ) {
              const vt = makeId(lt),
                _t = tt.hovered.get(vt)
              _t
                ? _t.stopped && lt.stopPropagation()
                : (tt.hovered.set(vt, lt),
                  pt.onPointerOver == null || pt.onPointerOver(lt),
                  pt.onPointerEnter == null || pt.onPointerEnter(lt))
            }
            pt.onPointerMove == null || pt.onPointerMove(lt)
          } else {
            const vt = pt[b]
            vt
              ? (!at || tt.initialHits.includes(ht)) &&
                (g(
                  $,
                  tt.interaction.filter((_t) => !tt.initialHits.includes(_t))
                ),
                vt(lt))
              : at &&
                tt.initialHits.includes(ht) &&
                g(
                  $,
                  tt.interaction.filter((_t) => !tt.initialHits.includes(_t))
                )
          }
      }
      c(ut, $, it, ct)
    }
  }
  return { handlePointer: _ }
}
const privateKeys = [
    "set",
    "get",
    "setSize",
    "setFrameloop",
    "setDpr",
    "events",
    "invalidate",
    "advance",
    "size",
    "viewport",
  ],
  isRenderer = (s) => !!(s != null && s.render),
  context$1 = reactExports.createContext(null),
  createStore = (s, e) => {
    const a = create((_, b) => {
        const j = new Vector3(),
          $ = new Vector3(),
          _e = new Vector3()
        function tt(it = b().camera, ct = $, lt = b().size) {
          const { width: ht, height: dt, top: pt, left: vt } = lt,
            _t = ht / dt
          ct instanceof Vector3 ? _e.copy(ct) : _e.set(...ct)
          const yt = it.getWorldPosition(j).distanceTo(_e)
          if (isOrthographicCamera(it))
            return {
              width: ht / it.zoom,
              height: dt / it.zoom,
              top: pt,
              left: vt,
              factor: 1,
              distance: yt,
              aspect: _t,
            }
          {
            const Et = (it.fov * Math.PI) / 180,
              Rt = 2 * Math.tan(Et / 2) * yt,
              Ft = Rt * (ht / dt)
            return {
              width: Ft,
              height: Rt,
              top: pt,
              left: vt,
              factor: ht / Ft,
              distance: yt,
              aspect: _t,
            }
          }
        }
        let st
        const at = (it) =>
            _((ct) => ({ performance: { ...ct.performance, current: it } })),
          ot = new Vector2()
        return {
          set: _,
          get: b,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (it = 1) => s(b(), it),
          advance: (it, ct) => e(it, ct, b()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new Clock(),
          pointer: ot,
          mouse: ot,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const it = b()
              st && clearTimeout(st),
                it.performance.current !== it.performance.min &&
                  at(it.performance.min),
                (st = setTimeout(
                  () => at(b().performance.max),
                  it.performance.debounce
                ))
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: tt,
          },
          setEvents: (it) =>
            _((ct) => ({ ...ct, events: { ...ct.events, ...it } })),
          setSize: (it, ct, lt, ht, dt) => {
            const pt = b().camera,
              vt = {
                width: it,
                height: ct,
                top: ht || 0,
                left: dt || 0,
                updateStyle: lt,
              }
            _((_t) => ({
              size: vt,
              viewport: { ..._t.viewport, ...tt(pt, $, vt) },
            }))
          },
          setDpr: (it) =>
            _((ct) => {
              const lt = calculateDpr(it)
              return {
                viewport: {
                  ...ct.viewport,
                  dpr: lt,
                  initialDpr: ct.viewport.initialDpr || lt,
                },
              }
            }),
          setFrameloop: (it = "always") => {
            const ct = b().clock
            ct.stop(),
              (ct.elapsedTime = 0),
              it !== "never" && (ct.start(), (ct.elapsedTime = 0)),
              _(() => ({ frameloop: it }))
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: reactExports.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (it, ct, lt) => {
              const ht = b().internal
              return (
                (ht.priority = ht.priority + (ct > 0 ? 1 : 0)),
                ht.subscribers.push({ ref: it, priority: ct, store: lt }),
                (ht.subscribers = ht.subscribers.sort(
                  (dt, pt) => dt.priority - pt.priority
                )),
                () => {
                  const dt = b().internal
                  dt != null &&
                    dt.subscribers &&
                    ((dt.priority = dt.priority - (ct > 0 ? 1 : 0)),
                    (dt.subscribers = dt.subscribers.filter(
                      (pt) => pt.ref !== it
                    )))
                }
              )
            },
          },
        }
      }),
      o = a.getState()
    let c = o.size,
      d = o.viewport.dpr,
      g = o.camera
    return (
      a.subscribe(() => {
        const { camera: _, size: b, viewport: j, gl: $, set: _e } = a.getState()
        if (b !== c || j.dpr !== d) {
          var tt
          ;(c = b), (d = j.dpr), updateCamera(_, b), $.setPixelRatio(j.dpr)
          const st =
            (tt = b.updateStyle) != null
              ? tt
              : typeof HTMLCanvasElement < "u" &&
                $.domElement instanceof HTMLCanvasElement
          $.setSize(b.width, b.height, st)
        }
        _ !== g &&
          ((g = _),
          _e((st) => ({
            viewport: { ...st.viewport, ...st.viewport.getCurrentViewport(_) },
          })))
      }),
      a.subscribe((_) => s(_)),
      a
    )
  }
let i$2,
  globalEffects = new Set(),
  globalAfterEffects = new Set(),
  globalTailEffects = new Set()
function run(s, e) {
  if (s.size) for (const { callback: a } of s.values()) a(e)
}
function flushGlobalEffects(s, e) {
  switch (s) {
    case "before":
      return run(globalEffects, e)
    case "after":
      return run(globalAfterEffects, e)
    case "tail":
      return run(globalTailEffects, e)
  }
}
let subscribers, subscription
function render$1(s, e, a) {
  let o = e.clock.getDelta()
  for (
    e.frameloop === "never" &&
      typeof s == "number" &&
      ((o = s - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = s)),
      subscribers = e.internal.subscribers,
      i$2 = 0;
    i$2 < subscribers.length;
    i$2++
  )
    (subscription = subscribers[i$2]),
      subscription.ref.current(subscription.store.getState(), o, a)
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  )
}
function createLoop(s) {
  let e = !1,
    a,
    o,
    c
  function d(b) {
    ;(o = requestAnimationFrame(d)),
      (e = !0),
      (a = 0),
      flushGlobalEffects("before", b)
    for (const $ of s.values()) {
      var j
      ;(c = $.store.getState()),
        c.internal.active &&
          (c.frameloop === "always" || c.internal.frames > 0) &&
          !((j = c.gl.xr) != null && j.isPresenting) &&
          (a += render$1(b, c))
    }
    if ((flushGlobalEffects("after", b), a === 0))
      return flushGlobalEffects("tail", b), (e = !1), cancelAnimationFrame(o)
  }
  function g(b, j = 1) {
    var $
    if (!b) return s.forEach((_e) => g(_e.store.getState()), j)
    ;(($ = b.gl.xr) != null && $.isPresenting) ||
      !b.internal.active ||
      b.frameloop === "never" ||
      ((b.internal.frames = Math.min(60, b.internal.frames + j)),
      e || ((e = !0), requestAnimationFrame(d)))
  }
  function _(b, j = !0, $, _e) {
    if ((j && flushGlobalEffects("before", b), $)) render$1(b, $, _e)
    else for (const tt of s.values()) render$1(b, tt.store.getState())
    j && flushGlobalEffects("after", b)
  }
  return { loop: d, invalidate: g, advance: _ }
}
function useStore() {
  const s = reactExports.useContext(context$1)
  if (!s)
    throw new Error("R3F: Hooks can only be used within the Canvas component!")
  return s
}
function useThree(s = (a) => a, e) {
  return useStore()(s, e)
}
function useFrame(s, e = 0) {
  const a = useStore(),
    o = a.getState().internal.subscribe,
    c = useMutableCallback(s)
  return useIsomorphicLayoutEffect$1(() => o(c, e, a), [e, o, a]), null
}
const memoizedLoaders = new WeakMap()
function loadingFn(s, e) {
  return function (a, ...o) {
    let c = memoizedLoaders.get(a)
    return (
      c || ((c = new a()), memoizedLoaders.set(a, c)),
      s && s(c),
      Promise.all(
        o.map(
          (d) =>
            new Promise((g, _) =>
              c.load(
                d,
                (b) => {
                  b.scene && Object.assign(b, buildGraph(b.scene)), g(b)
                },
                e,
                (b) =>
                  _(
                    new Error(
                      `Could not load ${d}: ${b == null ? void 0 : b.message}`
                    )
                  )
              )
            )
        )
      ).finally(() => (c.dispose == null ? void 0 : c.dispose()))
    )
  }
}
function useLoader(s, e, a, o) {
  const c = Array.isArray(e) ? e : [e],
    d = suspend(loadingFn(a, o), [s, ...c], { equal: is.equ })
  return Array.isArray(e) ? d : d[0]
}
useLoader.preload = function (s, e, a) {
  const o = Array.isArray(e) ? e : [e]
  return preload(loadingFn(a), [s, ...o])
}
useLoader.clear = function (s, e) {
  const a = Array.isArray(e) ? e : [e]
  return clear([s, ...a])
}
const roots = new Map(),
  { invalidate, advance } = createLoop(roots),
  { reconciler, applyProps } = createRenderer(roots, getEventPriority),
  shallowLoose = { objects: "shallow", strict: !1 },
  createRendererInstance = (s, e) => {
    const a = typeof s == "function" ? s(e) : s
    return isRenderer(a)
      ? a
      : new WebGLRenderer({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...s,
        })
  }
function computeInitialSize(s, e) {
  if (e) return e
  if (
    typeof HTMLCanvasElement < "u" &&
    s instanceof HTMLCanvasElement &&
    s.parentElement
  ) {
    const {
      width: a,
      height: o,
      top: c,
      left: d,
    } = s.parentElement.getBoundingClientRect()
    return { width: a, height: o, top: c, left: d }
  } else if (typeof OffscreenCanvas < "u" && s instanceof OffscreenCanvas)
    return { width: s.width, height: s.height, top: 0, left: 0 }
  return { width: 0, height: 0, top: 0, left: 0 }
}
function createRoot(s) {
  const e = roots.get(s),
    a = e == null ? void 0 : e.fiber,
    o = e == null ? void 0 : e.store
  e && console.warn("R3F.createRoot should only be called once!")
  const c = typeof reportError == "function" ? reportError : console.error,
    d = o || createStore(invalidate, advance),
    g =
      a ||
      reconciler.createContainer(
        d,
        constantsExports.ConcurrentRoot,
        null,
        !1,
        null,
        "",
        c,
        null
      )
  e || roots.set(s, { fiber: g, store: d })
  let _,
    b = !1,
    j
  return {
    configure($ = {}) {
      let {
          gl: _e,
          size: tt,
          scene: st,
          events: at,
          onCreated: ot,
          shadows: ut = !1,
          linear: it = !1,
          flat: ct = !1,
          legacy: lt = !1,
          orthographic: ht = !1,
          frameloop: dt = "always",
          dpr: pt = [1, 2],
          performance: vt,
          raycaster: _t,
          camera: yt,
          onPointerMissed: Et,
        } = $,
        Rt = d.getState(),
        Ft = Rt.gl
      Rt.gl || Rt.set({ gl: (Ft = createRendererInstance(_e, s)) })
      let kt = Rt.raycaster
      kt || Rt.set({ raycaster: (kt = new Raycaster()) })
      const { params: Nt, ...Dt } = _t || {}
      if (
        (is.equ(Dt, kt, shallowLoose) || applyProps(kt, { ...Dt }),
        is.equ(Nt, kt.params, shallowLoose) ||
          applyProps(kt, { params: { ...kt.params, ...Nt } }),
        !Rt.camera || (Rt.camera === j && !is.equ(j, yt, shallowLoose)))
      ) {
        j = yt
        const It = yt instanceof Camera,
          $t = It
            ? yt
            : ht
            ? new OrthographicCamera(0, 0, 0, 0, 0.1, 1e3)
            : new PerspectiveCamera(75, 0, 0.1, 1e3)
        It ||
          (($t.position.z = 5),
          yt && applyProps($t, yt),
          !Rt.camera && !(yt != null && yt.rotation) && $t.lookAt(0, 0, 0)),
          Rt.set({ camera: $t })
      }
      if (!Rt.scene) {
        let It
        st instanceof Scene
          ? (It = st)
          : ((It = new Scene()), st && applyProps(It, st)),
          Rt.set({ scene: prepare(It) })
      }
      if (!Rt.xr) {
        var Mt
        const It = (qt, en) => {
            const yn = d.getState()
            yn.frameloop !== "never" && advance(qt, !0, yn, en)
          },
          $t = () => {
            const qt = d.getState()
            ;(qt.gl.xr.enabled = qt.gl.xr.isPresenting),
              qt.gl.xr.setAnimationLoop(qt.gl.xr.isPresenting ? It : null),
              qt.gl.xr.isPresenting || invalidate(qt)
          },
          Xt = {
            connect() {
              const qt = d.getState().gl
              qt.xr.addEventListener("sessionstart", $t),
                qt.xr.addEventListener("sessionend", $t)
            },
            disconnect() {
              const qt = d.getState().gl
              qt.xr.removeEventListener("sessionstart", $t),
                qt.xr.removeEventListener("sessionend", $t)
            },
          }
        typeof ((Mt = Ft.xr) == null ? void 0 : Mt.addEventListener) ==
          "function" && Xt.connect(),
          Rt.set({ xr: Xt })
      }
      if (Ft.shadowMap) {
        const It = Ft.shadowMap.enabled,
          $t = Ft.shadowMap.type
        if (((Ft.shadowMap.enabled = !!ut), is.boo(ut)))
          Ft.shadowMap.type = PCFSoftShadowMap
        else if (is.str(ut)) {
          var wt
          const Xt = {
            basic: BasicShadowMap,
            percentage: PCFShadowMap,
            soft: PCFSoftShadowMap,
            variance: VSMShadowMap,
          }
          Ft.shadowMap.type = (wt = Xt[ut]) != null ? wt : PCFSoftShadowMap
        } else is.obj(ut) && Object.assign(Ft.shadowMap, ut)
        ;(It !== Ft.shadowMap.enabled || $t !== Ft.shadowMap.type) &&
          (Ft.shadowMap.needsUpdate = !0)
      }
      const gt = getColorManagement()
      gt &&
        ("enabled" in gt
          ? (gt.enabled = !lt)
          : "legacyMode" in gt && (gt.legacyMode = lt)),
        applyProps(Ft, {
          outputEncoding: it ? 3e3 : 3001,
          toneMapping: ct ? NoToneMapping : ACESFilmicToneMapping,
        }),
        Rt.legacy !== lt && Rt.set(() => ({ legacy: lt })),
        Rt.linear !== it && Rt.set(() => ({ linear: it })),
        Rt.flat !== ct && Rt.set(() => ({ flat: ct })),
        _e &&
          !is.fun(_e) &&
          !isRenderer(_e) &&
          !is.equ(_e, Ft, shallowLoose) &&
          applyProps(Ft, _e),
        at && !Rt.events.handlers && Rt.set({ events: at(d) })
      const Tt = computeInitialSize(s, tt)
      return (
        is.equ(Tt, Rt.size, shallowLoose) ||
          Rt.setSize(Tt.width, Tt.height, Tt.updateStyle, Tt.top, Tt.left),
        pt && Rt.viewport.dpr !== calculateDpr(pt) && Rt.setDpr(pt),
        Rt.frameloop !== dt && Rt.setFrameloop(dt),
        Rt.onPointerMissed || Rt.set({ onPointerMissed: Et }),
        vt &&
          !is.equ(vt, Rt.performance, shallowLoose) &&
          Rt.set((It) => ({ performance: { ...It.performance, ...vt } })),
        (_ = ot),
        (b = !0),
        this
      )
    },
    render($) {
      return (
        b || this.configure(),
        reconciler.updateContainer(
          reactExports.createElement(Provider, {
            store: d,
            children: $,
            onCreated: _,
            rootElement: s,
          }),
          g,
          null,
          () => {}
        ),
        d
      )
    },
    unmount() {
      unmountComponentAtNode(s)
    },
  }
}
function Provider({ store: s, children: e, onCreated: a, rootElement: o }) {
  return (
    useIsomorphicLayoutEffect$1(() => {
      const c = s.getState()
      c.set((d) => ({ internal: { ...d.internal, active: !0 } })),
        a && a(c),
        s.getState().events.connected ||
          c.events.connect == null ||
          c.events.connect(o)
    }, []),
    reactExports.createElement(context$1.Provider, { value: s }, e)
  )
}
function unmountComponentAtNode(s, e) {
  const a = roots.get(s),
    o = a == null ? void 0 : a.fiber
  if (o) {
    const c = a == null ? void 0 : a.store.getState()
    c && (c.internal.active = !1),
      reconciler.updateContainer(null, o, null, () => {
        c &&
          setTimeout(() => {
            try {
              var d, g, _, b
              c.events.disconnect == null || c.events.disconnect(),
                (d = c.gl) == null ||
                  (g = d.renderLists) == null ||
                  g.dispose == null ||
                  g.dispose(),
                (_ = c.gl) == null ||
                  _.forceContextLoss == null ||
                  _.forceContextLoss(),
                (b = c.gl) != null && b.xr && c.xr.disconnect(),
                dispose(c),
                roots.delete(s),
                e && e(s)
            } catch {}
          }, 500)
      })
  }
}
function createPortal(s, e, a) {
  return reactExports.createElement(Portal, {
    key: e.uuid,
    children: s,
    container: e,
    state: a,
  })
}
function Portal({ state: s = {}, children: e, container: a }) {
  const { events: o, size: c, ...d } = s,
    g = useStore(),
    [_] = reactExports.useState(() => new Raycaster()),
    [b] = reactExports.useState(() => new Vector2()),
    j = reactExports.useCallback(
      (_e, tt) => {
        const st = { ..._e }
        Object.keys(_e).forEach((ot) => {
          ;(privateKeys.includes(ot) || (_e[ot] !== tt[ot] && tt[ot])) &&
            delete st[ot]
        })
        let at
        if (tt && c) {
          const ot = tt.camera
          ;(at = _e.viewport.getCurrentViewport(ot, new Vector3(), c)),
            ot !== _e.camera && updateCamera(ot, c)
        }
        return {
          ...st,
          scene: a,
          raycaster: _,
          pointer: b,
          mouse: b,
          previousRoot: g,
          events: { ..._e.events, ...(tt == null ? void 0 : tt.events), ...o },
          size: { ..._e.size, ...c },
          viewport: { ..._e.viewport, ...at },
          ...d,
        }
      },
      [s]
    ),
    [$] = reactExports.useState(() => {
      const _e = g.getState()
      return create((st, at) => ({
        ..._e,
        scene: a,
        raycaster: _,
        pointer: b,
        mouse: b,
        previousRoot: g,
        events: { ..._e.events, ...o },
        size: { ..._e.size, ...c },
        ...d,
        set: st,
        get: at,
        setEvents: (ot) =>
          st((ut) => ({ ...ut, events: { ...ut.events, ...ot } })),
      }))
    })
  return (
    reactExports.useEffect(() => {
      const _e = g.subscribe((tt) => $.setState((st) => j(tt, st)))
      return () => {
        _e(), $.destroy()
      }
    }, []),
    reactExports.useEffect(() => {
      $.setState((_e) => j(g.getState(), _e))
    }, [j]),
    reactExports.createElement(
      reactExports.Fragment,
      null,
      reconciler.createPortal(
        reactExports.createElement(context$1.Provider, { value: $ }, e),
        $,
        null
      )
    )
  )
}
reconciler.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: reactExports.version,
})
function _extends$1() {
  return (
    (_extends$1 = Object.assign
      ? Object.assign.bind()
      : function (s) {
          for (var e = 1; e < arguments.length; e++) {
            var a = arguments[e]
            for (var o in a)
              Object.prototype.hasOwnProperty.call(a, o) && (s[o] = a[o])
          }
          return s
        }),
    _extends$1.apply(this, arguments)
  )
}
function debounce(s, e, a) {
  var o, c, d, g, _
  e == null && (e = 100)
  function b() {
    var $ = Date.now() - g
    $ < e && $ >= 0
      ? (o = setTimeout(b, e - $))
      : ((o = null), a || ((_ = s.apply(d, c)), (d = c = null)))
  }
  var j = function () {
    ;(d = this), (c = arguments), (g = Date.now())
    var $ = a && !o
    return (
      o || (o = setTimeout(b, e)), $ && ((_ = s.apply(d, c)), (d = c = null)), _
    )
  }
  return (
    (j.clear = function () {
      o && (clearTimeout(o), (o = null))
    }),
    (j.flush = function () {
      o && ((_ = s.apply(d, c)), (d = c = null), clearTimeout(o), (o = null))
    }),
    j
  )
}
debounce.debounce = debounce
var debounce_1 = debounce
const createDebounce = getDefaultExportFromCjs(debounce_1)
function useMeasure(s) {
  let {
    debounce: e,
    scroll: a,
    polyfill: o,
    offsetSize: c,
  } = s === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : s
  const d = o || (typeof window > "u" ? class {} : window.ResizeObserver)
  if (!d)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    )
  const [g, _] = reactExports.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    b = reactExports.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: g,
    }),
    j = e ? (typeof e == "number" ? e : e.scroll) : null,
    $ = e ? (typeof e == "number" ? e : e.resize) : null,
    _e = reactExports.useRef(!1)
  reactExports.useEffect(
    () => ((_e.current = !0), () => void (_e.current = !1))
  )
  const [tt, st, at] = reactExports.useMemo(() => {
    const ct = () => {
      if (!b.current.element) return
      const {
          left: lt,
          top: ht,
          width: dt,
          height: pt,
          bottom: vt,
          right: _t,
          x: yt,
          y: Et,
        } = b.current.element.getBoundingClientRect(),
        Rt = {
          left: lt,
          top: ht,
          width: dt,
          height: pt,
          bottom: vt,
          right: _t,
          x: yt,
          y: Et,
        }
      b.current.element instanceof HTMLElement &&
        c &&
        ((Rt.height = b.current.element.offsetHeight),
        (Rt.width = b.current.element.offsetWidth)),
        Object.freeze(Rt),
        _e.current &&
          !areBoundsEqual(b.current.lastBounds, Rt) &&
          _((b.current.lastBounds = Rt))
    }
    return [ct, $ ? createDebounce(ct, $) : ct, j ? createDebounce(ct, j) : ct]
  }, [_, c, j, $])
  function ot() {
    b.current.scrollContainers &&
      (b.current.scrollContainers.forEach((ct) =>
        ct.removeEventListener("scroll", at, !0)
      ),
      (b.current.scrollContainers = null)),
      b.current.resizeObserver &&
        (b.current.resizeObserver.disconnect(),
        (b.current.resizeObserver = null))
  }
  function ut() {
    b.current.element &&
      ((b.current.resizeObserver = new d(at)),
      b.current.resizeObserver.observe(b.current.element),
      a &&
        b.current.scrollContainers &&
        b.current.scrollContainers.forEach((ct) =>
          ct.addEventListener("scroll", at, { capture: !0, passive: !0 })
        ))
  }
  const it = (ct) => {
    !ct ||
      ct === b.current.element ||
      (ot(),
      (b.current.element = ct),
      (b.current.scrollContainers = findScrollContainers(ct)),
      ut())
  }
  return (
    useOnWindowScroll(at, !!a),
    useOnWindowResize(st),
    reactExports.useEffect(() => {
      ot(), ut()
    }, [a, at, st]),
    reactExports.useEffect(() => ot, []),
    [it, g, tt]
  )
}
function useOnWindowResize(s) {
  reactExports.useEffect(() => {
    const e = s
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    )
  }, [s])
}
function useOnWindowScroll(s, e) {
  reactExports.useEffect(() => {
    if (e) {
      const a = s
      return (
        window.addEventListener("scroll", a, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", a, !0)
      )
    }
  }, [s, e])
}
function findScrollContainers(s) {
  const e = []
  if (!s || s === document.body) return e
  const { overflow: a, overflowX: o, overflowY: c } = window.getComputedStyle(s)
  return (
    [a, o, c].some((d) => d === "auto" || d === "scroll") && e.push(s),
    [...e, ...findScrollContainers(s.parentElement)]
  )
}
const keys = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  areBoundsEqual = (s, e) => keys.every((a) => s[a] === e[a])
var __defProp$2 = Object.defineProperty,
  __defProps$1 = Object.defineProperties,
  __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors,
  __getOwnPropSymbols$1 = Object.getOwnPropertySymbols,
  __hasOwnProp$1 = Object.prototype.hasOwnProperty,
  __propIsEnum$1 = Object.prototype.propertyIsEnumerable,
  __defNormalProp$2 = (s, e, a) =>
    e in s
      ? __defProp$2(s, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: a,
        })
      : (s[e] = a),
  __spreadValues$1 = (s, e) => {
    for (var a in e || (e = {}))
      __hasOwnProp$1.call(e, a) && __defNormalProp$2(s, a, e[a])
    if (__getOwnPropSymbols$1)
      for (var a of __getOwnPropSymbols$1(e))
        __propIsEnum$1.call(e, a) && __defNormalProp$2(s, a, e[a])
    return s
  },
  __spreadProps$1 = (s, e) => __defProps$1(s, __getOwnPropDescs$1(e))
function traverseFiber(s, e, a) {
  if (!s) return
  if (a(s) === !0) return s
  let o = e ? s.return : s.child
  for (; o; ) {
    const c = traverseFiber(o, e, a)
    if (c) return c
    o = e ? null : o.sibling
  }
}
function wrapContext(s) {
  try {
    return Object.defineProperties(s, {
      _currentRenderer: {
        get() {
          return null
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null
        },
        set() {},
      },
    })
  } catch {
    return s
  }
}
const FiberContext = wrapContext(reactExports.createContext(null))
class FiberProvider extends reactExports.Component {
  render() {
    return reactExports.createElement(
      FiberContext.Provider,
      { value: this._reactInternals },
      this.props.children
    )
  }
}
const { ReactCurrentOwner, ReactCurrentDispatcher } =
  reactExports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
function useFiber() {
  const s = reactExports.useContext(FiberContext)
  if (s === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    )
  const e = reactExports.useId()
  return reactExports.useMemo(() => {
    for (const o of [
      ReactCurrentOwner == null ? void 0 : ReactCurrentOwner.current,
      s,
      s == null ? void 0 : s.alternate,
    ]) {
      if (!o) continue
      const c = traverseFiber(o, !1, (d) => {
        let g = d.memoizedState
        for (; g; ) {
          if (g.memoizedState === e) return !0
          g = g.next
        }
      })
      if (c) return c
    }
  }, [s, e])
}
function useContextMap() {
  var s, e
  const a = useFiber(),
    [o] = reactExports.useState(() => new Map())
  o.clear()
  let c = a
  for (; c; ) {
    const d = (s = c.type) == null ? void 0 : s._context
    d &&
      d !== FiberContext &&
      !o.has(d) &&
      o.set(
        d,
        (e =
          ReactCurrentDispatcher == null
            ? void 0
            : ReactCurrentDispatcher.current) == null
          ? void 0
          : e.readContext(wrapContext(d))
      ),
      (c = c.return)
  }
  return o
}
function useContextBridge() {
  const s = useContextMap()
  return reactExports.useMemo(
    () =>
      Array.from(s.keys()).reduce(
        (e, a) => (o) =>
          reactExports.createElement(
            e,
            null,
            reactExports.createElement(
              a.Provider,
              __spreadProps$1(__spreadValues$1({}, o), { value: s.get(a) })
            )
          ),
        (e) =>
          reactExports.createElement(FiberProvider, __spreadValues$1({}, e))
      ),
    [s]
  )
}
const DOM_EVENTS = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
}
function createPointerEvents(s) {
  const { handlePointer: e } = createEvents(s)
  return {
    priority: 1,
    enabled: !0,
    compute(a, o, c) {
      o.pointer.set(
        (a.offsetX / o.size.width) * 2 - 1,
        -(a.offsetY / o.size.height) * 2 + 1
      ),
        o.raycaster.setFromCamera(o.pointer, o.camera)
    },
    connected: void 0,
    handlers: Object.keys(DOM_EVENTS).reduce(
      (a, o) => ({ ...a, [o]: e(o) }),
      {}
    ),
    update: () => {
      var a
      const { events: o, internal: c } = s.getState()
      ;(a = c.lastEvent) != null &&
        a.current &&
        o.handlers &&
        o.handlers.onPointerMove(c.lastEvent.current)
    },
    connect: (a) => {
      var o
      const { set: c, events: d } = s.getState()
      d.disconnect == null || d.disconnect(),
        c((g) => ({ events: { ...g.events, connected: a } })),
        Object.entries((o = d.handlers) != null ? o : []).forEach(([g, _]) => {
          const [b, j] = DOM_EVENTS[g]
          a.addEventListener(b, _, { passive: j })
        })
    },
    disconnect: () => {
      const { set: a, events: o } = s.getState()
      if (o.connected) {
        var c
        Object.entries((c = o.handlers) != null ? c : []).forEach(([d, g]) => {
          if (o && o.connected instanceof HTMLElement) {
            const [_] = DOM_EVENTS[d]
            o.connected.removeEventListener(_, g)
          }
        }),
          a((d) => ({ events: { ...d.events, connected: void 0 } }))
      }
    },
  }
}
const CanvasImpl = reactExports.forwardRef(function (
    {
      children: e,
      fallback: a,
      resize: o,
      style: c,
      gl: d,
      events: g = createPointerEvents,
      eventSource: _,
      eventPrefix: b,
      shadows: j,
      linear: $,
      flat: _e,
      legacy: tt,
      orthographic: st,
      frameloop: at,
      dpr: ot,
      performance: ut,
      raycaster: it,
      camera: ct,
      scene: lt,
      onPointerMissed: ht,
      onCreated: dt,
      ...pt
    },
    vt
  ) {
    reactExports.useMemo(() => extend(THREE), [])
    const _t = useContextBridge(),
      [yt, Et] = useMeasure({
        scroll: !0,
        debounce: { scroll: 50, resize: 0 },
        ...o,
      }),
      Rt = reactExports.useRef(null),
      Ft = reactExports.useRef(null)
    reactExports.useImperativeHandle(vt, () => Rt.current)
    const kt = useMutableCallback(ht),
      [Nt, Dt] = reactExports.useState(!1),
      [Mt, wt] = reactExports.useState(!1)
    if (Nt) throw Nt
    if (Mt) throw Mt
    const gt = reactExports.useRef(null)
    useIsomorphicLayoutEffect$1(() => {
      const bt = Rt.current
      Et.width > 0 &&
        Et.height > 0 &&
        bt &&
        (gt.current || (gt.current = createRoot(bt)),
        gt.current.configure({
          gl: d,
          events: g,
          shadows: j,
          linear: $,
          flat: _e,
          legacy: tt,
          orthographic: st,
          frameloop: at,
          dpr: ot,
          performance: ut,
          raycaster: it,
          camera: ct,
          scene: lt,
          size: Et,
          onPointerMissed: (...Tt) =>
            kt.current == null ? void 0 : kt.current(...Tt),
          onCreated: (Tt) => {
            Tt.events.connect == null ||
              Tt.events.connect(_ ? (isRef$1(_) ? _.current : _) : Ft.current),
              b &&
                Tt.setEvents({
                  compute: (It, $t) => {
                    const Xt = It[b + "X"],
                      qt = It[b + "Y"]
                    $t.pointer.set(
                      (Xt / $t.size.width) * 2 - 1,
                      -(qt / $t.size.height) * 2 + 1
                    ),
                      $t.raycaster.setFromCamera($t.pointer, $t.camera)
                  },
                }),
              dt == null || dt(Tt)
          },
        }),
        gt.current.render(
          reactExports.createElement(
            _t,
            null,
            reactExports.createElement(
              ErrorBoundary,
              { set: wt },
              reactExports.createElement(
                reactExports.Suspense,
                { fallback: reactExports.createElement(Block, { set: Dt }) },
                e
              )
            )
          )
        ))
    }),
      reactExports.useEffect(() => {
        const bt = Rt.current
        if (bt) return () => unmountComponentAtNode(bt)
      }, [])
    const At = _ ? "none" : "auto"
    return reactExports.createElement(
      "div",
      _extends$1(
        {
          ref: Ft,
          style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: At,
            ...c,
          },
        },
        pt
      ),
      reactExports.createElement(
        "div",
        { ref: yt, style: { width: "100%", height: "100%" } },
        reactExports.createElement(
          "canvas",
          { ref: Rt, style: { display: "block" } },
          a
        )
      )
    )
  }),
  Canvas = reactExports.forwardRef(function (e, a) {
    return reactExports.createElement(
      FiberProvider,
      null,
      reactExports.createElement(CanvasImpl, _extends$1({}, e, { ref: a }))
    )
  }),
  v1 = new Vector3(),
  v2 = new Vector3(),
  v3 = new Vector3()
function defaultCalculatePosition(s, e, a) {
  const o = v1.setFromMatrixPosition(s.matrixWorld)
  o.project(e)
  const c = a.width / 2,
    d = a.height / 2
  return [o.x * c + c, -(o.y * d) + d]
}
function isObjectBehindCamera(s, e) {
  const a = v1.setFromMatrixPosition(s.matrixWorld),
    o = v2.setFromMatrixPosition(e.matrixWorld),
    c = a.sub(o),
    d = e.getWorldDirection(v3)
  return c.angleTo(d) > Math.PI / 2
}
function isObjectVisible(s, e, a, o) {
  const c = v1.setFromMatrixPosition(s.matrixWorld),
    d = c.clone()
  d.project(e), a.setFromCamera(d, e)
  const g = a.intersectObjects(o, !0)
  if (g.length) {
    const _ = g[0].distance
    return c.distanceTo(a.ray.origin) < _
  }
  return !0
}
function objectScale(s, e) {
  if (e instanceof OrthographicCamera) return e.zoom
  if (e instanceof PerspectiveCamera) {
    const a = v1.setFromMatrixPosition(s.matrixWorld),
      o = v2.setFromMatrixPosition(e.matrixWorld),
      c = (e.fov * Math.PI) / 180,
      d = a.distanceTo(o)
    return 1 / (2 * Math.tan(c / 2) * d)
  } else return 1
}
function objectZIndex(s, e, a) {
  if (e instanceof PerspectiveCamera || e instanceof OrthographicCamera) {
    const o = v1.setFromMatrixPosition(s.matrixWorld),
      c = v2.setFromMatrixPosition(e.matrixWorld),
      d = o.distanceTo(c),
      g = (a[1] - a[0]) / (e.far - e.near),
      _ = a[1] - g * e.far
    return Math.round(g * d + _)
  }
}
const epsilon = (s) => (Math.abs(s) < 1e-10 ? 0 : s)
function getCSSMatrix(s, e, a = "") {
  let o = "matrix3d("
  for (let c = 0; c !== 16; c++)
    o += epsilon(e[c] * s.elements[c]) + (c !== 15 ? "," : ")")
  return a + o
}
const getCameraCSSMatrix = (
    (s) => (e) =>
      getCSSMatrix(e, s)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  getObjectCSSMatrix = (
    (s) => (e, a) =>
      getCSSMatrix(e, s(a), "translate(-50%,-50%)")
  )((s) => [
    1 / s,
    1 / s,
    1 / s,
    1,
    -1 / s,
    -1 / s,
    -1 / s,
    -1,
    1 / s,
    1 / s,
    1 / s,
    1,
    1,
    1,
    1,
    1,
  ])
function isRefObject$1(s) {
  return s && typeof s == "object" && "current" in s
}
const Html = reactExports.forwardRef(
  (
    {
      children: s,
      eps: e = 0.001,
      style: a,
      className: o,
      prepend: c,
      center: d,
      fullscreen: g,
      portal: _,
      distanceFactor: b,
      sprite: j = !1,
      transform: $ = !1,
      occlude: _e,
      onOcclude: tt,
      castShadow: st,
      receiveShadow: at,
      material: ot,
      geometry: ut,
      zIndexRange: it = [16777271, 0],
      calculatePosition: ct = defaultCalculatePosition,
      as: lt = "div",
      wrapperClass: ht,
      pointerEvents: dt = "auto",
      ...pt
    },
    vt
  ) => {
    const {
        gl: _t,
        camera: yt,
        scene: Et,
        size: Rt,
        raycaster: Ft,
        events: kt,
        viewport: Nt,
      } = useThree(),
      [Dt] = reactExports.useState(() => document.createElement(lt)),
      Mt = reactExports.useRef(),
      wt = reactExports.useRef(null),
      gt = reactExports.useRef(0),
      At = reactExports.useRef([0, 0]),
      bt = reactExports.useRef(null),
      Tt = reactExports.useRef(null),
      It =
        (_ == null ? void 0 : _.current) ||
        kt.connected ||
        _t.domElement.parentNode,
      $t = reactExports.useRef(null),
      Xt = reactExports.useRef(!1),
      qt = reactExports.useMemo(
        () =>
          (_e && _e !== "blending") ||
          (Array.isArray(_e) && _e.length && isRefObject$1(_e[0])),
        [_e]
      )
    reactExports.useLayoutEffect(() => {
      const Vn = _t.domElement
      _e && _e === "blending"
        ? ((Vn.style.zIndex = `${Math.floor(it[0] / 2)}`),
          (Vn.style.position = "absolute"),
          (Vn.style.pointerEvents = "none"))
        : ((Vn.style.zIndex = null),
          (Vn.style.position = null),
          (Vn.style.pointerEvents = null))
    }, [_e]),
      reactExports.useLayoutEffect(() => {
        if (wt.current) {
          const Vn = (Mt.current = createRoot$1(Dt))
          if ((Et.updateMatrixWorld(), $))
            Dt.style.cssText =
              "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;"
          else {
            const gn = ct(wt.current, yt, Rt)
            Dt.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${gn[0]}px,${gn[1]}px,0);transform-origin:0 0;`
          }
          return (
            It && (c ? It.prepend(Dt) : It.appendChild(Dt)),
            () => {
              It && It.removeChild(Dt), Vn.unmount()
            }
          )
        }
      }, [It, $]),
      reactExports.useLayoutEffect(() => {
        ht && (Dt.className = ht)
      }, [ht])
    const en = reactExports.useMemo(
        () =>
          $
            ? {
                position: "absolute",
                top: 0,
                left: 0,
                width: Rt.width,
                height: Rt.height,
                transformStyle: "preserve-3d",
                pointerEvents: "none",
              }
            : {
                position: "absolute",
                transform: d ? "translate3d(-50%,-50%,0)" : "none",
                ...(g && {
                  top: -Rt.height / 2,
                  left: -Rt.width / 2,
                  width: Rt.width,
                  height: Rt.height,
                }),
                ...a,
              },
        [a, d, g, Rt, $]
      ),
      yn = reactExports.useMemo(
        () => ({ position: "absolute", pointerEvents: dt }),
        [dt]
      )
    reactExports.useLayoutEffect(() => {
      if (((Xt.current = !1), $)) {
        var Vn
        ;(Vn = Mt.current) == null ||
          Vn.render(
            reactExports.createElement(
              "div",
              { ref: bt, style: en },
              reactExports.createElement(
                "div",
                { ref: Tt, style: yn },
                reactExports.createElement("div", {
                  ref: vt,
                  className: o,
                  style: a,
                  children: s,
                })
              )
            )
          )
      } else {
        var gn
        ;(gn = Mt.current) == null ||
          gn.render(
            reactExports.createElement("div", {
              ref: vt,
              style: en,
              className: o,
              children: s,
            })
          )
      }
    })
    const Tn = reactExports.useRef(!0)
    useFrame((Vn) => {
      if (wt.current) {
        yt.updateMatrixWorld(), wt.current.updateWorldMatrix(!0, !1)
        const gn = $ ? At.current : ct(wt.current, yt, Rt)
        if (
          $ ||
          Math.abs(gt.current - yt.zoom) > e ||
          Math.abs(At.current[0] - gn[0]) > e ||
          Math.abs(At.current[1] - gn[1]) > e
        ) {
          const Ht = isObjectBehindCamera(wt.current, yt)
          let on = !1
          qt &&
            (Array.isArray(_e)
              ? (on = _e.map((Rn) => Rn.current))
              : _e !== "blending" && (on = [Et]))
          const Yt = Tn.current
          if (on) {
            const Rn = isObjectVisible(wt.current, yt, Ft, on)
            Tn.current = Rn && !Ht
          } else Tn.current = !Ht
          Yt !== Tn.current &&
            (tt
              ? tt(!Tn.current)
              : (Dt.style.display = Tn.current ? "block" : "none"))
          const _n = Math.floor(it[0] / 2),
            pn = _e ? (qt ? [it[0], _n] : [_n - 1, 0]) : it
          if (((Dt.style.zIndex = `${objectZIndex(wt.current, yt, pn)}`), $)) {
            const [Rn, bn] = [Rt.width / 2, Rt.height / 2],
              Pn = yt.projectionMatrix.elements[5] * bn,
              {
                isOrthographicCamera: Gn,
                top: jn,
                left: ar,
                bottom: Vt,
                right: Lt,
              } = yt,
              Zt = getCameraCSSMatrix(yt.matrixWorldInverse),
              xn = Gn
                ? `scale(${Pn})translate(${epsilon(-(Lt + ar) / 2)}px,${epsilon(
                    (jn + Vt) / 2
                  )}px)`
                : `translateZ(${Pn}px)`
            let vn = wt.current.matrixWorld
            j &&
              ((vn = yt.matrixWorldInverse
                .clone()
                .transpose()
                .copyPosition(vn)
                .scale(wt.current.scale)),
              (vn.elements[3] = vn.elements[7] = vn.elements[11] = 0),
              (vn.elements[15] = 1)),
              (Dt.style.width = Rt.width + "px"),
              (Dt.style.height = Rt.height + "px"),
              (Dt.style.perspective = Gn ? "" : `${Pn}px`),
              bt.current &&
                Tt.current &&
                ((bt.current.style.transform = `${xn}${Zt}translate(${Rn}px,${bn}px)`),
                (Tt.current.style.transform = getObjectCSSMatrix(
                  vn,
                  1 / ((b || 10) / 400)
                )))
          } else {
            const Rn = b === void 0 ? 1 : objectScale(wt.current, yt) * b
            Dt.style.transform = `translate3d(${gn[0]}px,${gn[1]}px,0) scale(${Rn})`
          }
          ;(At.current = gn), (gt.current = yt.zoom)
        }
      }
      if (!qt && $t.current && !Xt.current)
        if ($) {
          if (bt.current) {
            const gn = bt.current.children[0]
            if (gn != null && gn.clientWidth && gn != null && gn.clientHeight) {
              const { isOrthographicCamera: Ht } = yt
              if (Ht || ut)
                pt.scale &&
                  (Array.isArray(pt.scale)
                    ? pt.scale instanceof Vector3
                      ? $t.current.scale.copy(pt.scale.clone().divideScalar(1))
                      : $t.current.scale.set(
                          1 / pt.scale[0],
                          1 / pt.scale[1],
                          1 / pt.scale[2]
                        )
                    : $t.current.scale.setScalar(1 / pt.scale))
              else {
                const on = (b || 10) / 400,
                  Yt = gn.clientWidth * on,
                  _n = gn.clientHeight * on
                $t.current.scale.set(Yt, _n, 1)
              }
              Xt.current = !0
            }
          }
        } else {
          const gn = Dt.children[0]
          if (gn != null && gn.clientWidth && gn != null && gn.clientHeight) {
            const Ht = 1 / Nt.factor,
              on = gn.clientWidth * Ht,
              Yt = gn.clientHeight * Ht
            $t.current.scale.set(on, Yt, 1), (Xt.current = !0)
          }
          $t.current.lookAt(Vn.camera.position)
        }
    })
    const $n = reactExports.useMemo(
      () => ({
        vertexShader: $
          ? void 0
          : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
      }),
      [$]
    )
    return reactExports.createElement(
      "group",
      _extends$1({}, pt, { ref: wt }),
      _e &&
        !qt &&
        reactExports.createElement(
          "mesh",
          { castShadow: st, receiveShadow: at, ref: $t },
          ut || reactExports.createElement("planeGeometry", null),
          ot ||
            reactExports.createElement("shaderMaterial", {
              side: DoubleSide,
              vertexShader: $n.vertexShader,
              fragmentShader: $n.fragmentShader,
            })
        )
    )
  }
)
let saveLastTotalLoaded = 0
const useProgress = create(
  (s) => (
    (DefaultLoadingManager.onStart = (e, a, o) => {
      s({
        active: !0,
        item: e,
        loaded: a,
        total: o,
        progress: ((a - saveLastTotalLoaded) / (o - saveLastTotalLoaded)) * 100,
      })
    }),
    (DefaultLoadingManager.onLoad = () => {
      s({ active: !1 })
    }),
    (DefaultLoadingManager.onError = (e) =>
      s((a) => ({ errors: [...a.errors, e] }))),
    (DefaultLoadingManager.onProgress = (e, a, o) => {
      a === o && (saveLastTotalLoaded = o),
        s({
          active: !0,
          item: e,
          loaded: a,
          total: o,
          progress:
            ((a - saveLastTotalLoaded) / (o - saveLastTotalLoaded)) * 100 ||
            100,
        })
    }),
    { errors: [], active: !1, progress: 0, item: "", loaded: 0, total: 0 }
  )
)
function mergeRefs(s) {
  return function (e) {
    s.forEach(function (a) {
      typeof a == "function" ? a(e) : a != null && (a.current = e)
    })
  }
}
function _defineProperty$1(s, e, a) {
  return (
    e in s
      ? Object.defineProperty(s, e, {
          value: a,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (s[e] = a),
    s
  )
}
function ownKeys$1(s, e) {
  var a = Object.keys(s)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(s)
    e &&
      (o = o.filter(function (c) {
        return Object.getOwnPropertyDescriptor(s, c).enumerable
      })),
      a.push.apply(a, o)
  }
  return a
}
function _objectSpread2$1(s) {
  for (var e = 1; e < arguments.length; e++) {
    var a = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? ownKeys$1(Object(a), !0).forEach(function (o) {
          _defineProperty$1(s, o, a[o])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(a))
      : ownKeys$1(Object(a)).forEach(function (o) {
          Object.defineProperty(s, o, Object.getOwnPropertyDescriptor(a, o))
        })
  }
  return s
}
new Vector2()
new Vector2()
function _classCallCheck(s, e) {
  if (!(s instanceof e))
    throw new TypeError("Cannot call a class as a function")
}
var Grad = function s(e, a, o) {
    var c = this
    _classCallCheck(this, s),
      _defineProperty$1(this, "dot2", function (d, g) {
        return c.x * d + c.y * g
      }),
      _defineProperty$1(this, "dot3", function (d, g, _) {
        return c.x * d + c.y * g + c.z * _
      }),
      (this.x = e),
      (this.y = a),
      (this.z = o)
  },
  grad3 = [
    new Grad(1, 1, 0),
    new Grad(-1, 1, 0),
    new Grad(1, -1, 0),
    new Grad(-1, -1, 0),
    new Grad(1, 0, 1),
    new Grad(-1, 0, 1),
    new Grad(1, 0, -1),
    new Grad(-1, 0, -1),
    new Grad(0, 1, 1),
    new Grad(0, -1, 1),
    new Grad(0, 1, -1),
    new Grad(0, -1, -1),
  ],
  p = [
    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140,
    36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
    234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
    134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
    230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
    1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130,
    116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250,
    124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227,
    47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
    154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,
    108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
    242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
    239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
    50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243,
    141, 128, 195, 78, 66, 215, 61, 156, 180,
  ],
  perm = new Array(512),
  gradP = new Array(512),
  seed = function (e) {
    e > 0 && e < 1 && (e *= 65536),
      (e = Math.floor(e)),
      e < 256 && (e |= e << 8)
    for (var a = 0; a < 256; a++) {
      var o
      a & 1 ? (o = p[a] ^ (e & 255)) : (o = p[a] ^ ((e >> 8) & 255)),
        (perm[a] = perm[a + 256] = o),
        (gradP[a] = gradP[a + 256] = grad3[o % 12])
    }
  }
seed(0)
function normalizeSeed(s) {
  if (typeof s == "number") s = Math.abs(s)
  else if (typeof s == "string") {
    var e = s
    s = 0
    for (var a = 0; a < e.length; a++)
      s = (s + (a + 1) * (e.charCodeAt(a) % 96)) % 2147483647
  }
  return s === 0 && (s = 311), s
}
function lcgRandom(s) {
  var e = normalizeSeed(s)
  return function () {
    var a = (e * 48271) % 2147483647
    return (e = a), a / 2147483647
  }
}
var Generator = function s(e) {
    var a = this
    _classCallCheck(this, s),
      _defineProperty$1(this, "seed", 0),
      _defineProperty$1(this, "init", function (o) {
        ;(a.seed = o), (a.value = lcgRandom(o))
      }),
      _defineProperty$1(this, "value", lcgRandom(this.seed)),
      this.init(e)
  },
  defaultGen = new Generator(Math.random()),
  defaultSphere = { radius: 1, center: [0, 0, 0] }
function inSphere(s, e) {
  for (
    var a =
        arguments.length > 2 && arguments[2] !== void 0
          ? arguments[2]
          : defaultGen,
      o = _objectSpread2$1(_objectSpread2$1({}, defaultSphere), e),
      c = o.radius,
      d = o.center,
      g = 0;
    g < s.length;
    g += 3
  ) {
    var _ = Math.pow(a.value(), 0.3333333333333333),
      b = a.value() * 2 - 1,
      j = a.value() * 2 - 1,
      $ = a.value() * 2 - 1,
      _e = Math.sqrt(b * b + j * j + $ * $)
    ;(b = (_ * b) / _e),
      (j = (_ * j) / _e),
      ($ = (_ * $) / _e),
      (s[g] = b * c + d[0]),
      (s[g + 1] = j * c + d[1]),
      (s[g + 2] = $ * c + d[2])
  }
  return s
}
function toTrianglesDrawMode(s, e) {
  if (e === TrianglesDrawMode)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      s
    )
  if (e === TriangleFanDrawMode || e === TriangleStripDrawMode) {
    let a = s.getIndex()
    if (a === null) {
      const g = [],
        _ = s.getAttribute("position")
      if (_ !== void 0) {
        for (let b = 0; b < _.count; b++) g.push(b)
        s.setIndex(g), (a = s.getIndex())
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          s
        )
    }
    const o = a.count - 2,
      c = []
    if (a)
      if (e === TriangleFanDrawMode)
        for (let g = 1; g <= o; g++)
          c.push(a.getX(0)), c.push(a.getX(g)), c.push(a.getX(g + 1))
      else
        for (let g = 0; g < o; g++)
          g % 2 === 0
            ? (c.push(a.getX(g)), c.push(a.getX(g + 1)), c.push(a.getX(g + 2)))
            : (c.push(a.getX(g + 2)), c.push(a.getX(g + 1)), c.push(a.getX(g)))
    c.length / 3 !== o &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      )
    const d = s.clone()
    return d.setIndex(c), d.clearGroups(), d
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      s
    )
}
const version$1 = parseInt(REVISION.replace(/\D+/g, ""))
var u8 = Uint8Array,
  u16 = Uint16Array,
  u32 = Uint32Array,
  fleb = new u8([
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,
    5, 5, 5, 0, 0, 0, 0,
  ]),
  fdeb = new u8([
    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,
    11, 11, 12, 12, 13, 13, 0, 0,
  ]),
  clim = new u8([
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
  ]),
  freb = function (s, e) {
    for (var a = new u16(31), o = 0; o < 31; ++o) a[o] = e += 1 << s[o - 1]
    for (var c = new u32(a[30]), o = 1; o < 30; ++o)
      for (var d = a[o]; d < a[o + 1]; ++d) c[d] = ((d - a[o]) << 5) | o
    return [a, c]
  },
  _a = freb(fleb, 2),
  fl = _a[0],
  revfl = _a[1]
;(fl[28] = 258), (revfl[258] = 28)
var _b = freb(fdeb, 0),
  fd = _b[0],
  rev = new u16(32768)
for (var i$1 = 0; i$1 < 32768; ++i$1) {
  var x = ((i$1 & 43690) >>> 1) | ((i$1 & 21845) << 1)
  ;(x = ((x & 52428) >>> 2) | ((x & 13107) << 2)),
    (x = ((x & 61680) >>> 4) | ((x & 3855) << 4)),
    (rev[i$1] = (((x & 65280) >>> 8) | ((x & 255) << 8)) >>> 1)
}
var hMap = function (s, e, a) {
    for (var o = s.length, c = 0, d = new u16(e); c < o; ++c) ++d[s[c] - 1]
    var g = new u16(e)
    for (c = 0; c < e; ++c) g[c] = (g[c - 1] + d[c - 1]) << 1
    var _
    if (a) {
      _ = new u16(1 << e)
      var b = 15 - e
      for (c = 0; c < o; ++c)
        if (s[c])
          for (
            var j = (c << 4) | s[c],
              $ = e - s[c],
              _e = g[s[c] - 1]++ << $,
              tt = _e | ((1 << $) - 1);
            _e <= tt;
            ++_e
          )
            _[rev[_e] >>> b] = j
    } else
      for (_ = new u16(o), c = 0; c < o; ++c)
        s[c] && (_[c] = rev[g[s[c] - 1]++] >>> (15 - s[c]))
    return _
  },
  flt = new u8(288)
for (var i$1 = 0; i$1 < 144; ++i$1) flt[i$1] = 8
for (var i$1 = 144; i$1 < 256; ++i$1) flt[i$1] = 9
for (var i$1 = 256; i$1 < 280; ++i$1) flt[i$1] = 7
for (var i$1 = 280; i$1 < 288; ++i$1) flt[i$1] = 8
var fdt = new u8(32)
for (var i$1 = 0; i$1 < 32; ++i$1) fdt[i$1] = 5
var flrm = hMap(flt, 9, 1),
  fdrm = hMap(fdt, 5, 1),
  max = function (s) {
    for (var e = s[0], a = 1; a < s.length; ++a) s[a] > e && (e = s[a])
    return e
  },
  bits = function (s, e, a) {
    var o = (e / 8) | 0
    return ((s[o] | (s[o + 1] << 8)) >> (e & 7)) & a
  },
  bits16 = function (s, e) {
    var a = (e / 8) | 0
    return (s[a] | (s[a + 1] << 8) | (s[a + 2] << 16)) >> (e & 7)
  },
  shft = function (s) {
    return ((s / 8) | 0) + (s & 7 && 1)
  },
  slc = function (s, e, a) {
    ;(e == null || e < 0) && (e = 0),
      (a == null || a > s.length) && (a = s.length)
    var o = new (s instanceof u16 ? u16 : s instanceof u32 ? u32 : u8)(a - e)
    return o.set(s.subarray(e, a)), o
  },
  inflt = function (s, e, a) {
    var o = s.length
    if (!o || (a && !a.l && o < 5)) return e || new u8(0)
    var c = !e || a,
      d = !a || a.i
    a || (a = {}), e || (e = new u8(o * 3))
    var g = function (en) {
        var yn = e.length
        if (en > yn) {
          var Tn = new u8(Math.max(yn * 2, en))
          Tn.set(e), (e = Tn)
        }
      },
      _ = a.f || 0,
      b = a.p || 0,
      j = a.b || 0,
      $ = a.l,
      _e = a.d,
      tt = a.m,
      st = a.n,
      at = o * 8
    do {
      if (!$) {
        a.f = _ = bits(s, b, 1)
        var ot = bits(s, b + 1, 3)
        if (((b += 3), ot))
          if (ot == 1) ($ = flrm), (_e = fdrm), (tt = 9), (st = 5)
          else if (ot == 2) {
            var lt = bits(s, b, 31) + 257,
              ht = bits(s, b + 10, 15) + 4,
              dt = lt + bits(s, b + 5, 31) + 1
            b += 14
            for (var pt = new u8(dt), vt = new u8(19), _t = 0; _t < ht; ++_t)
              vt[clim[_t]] = bits(s, b + _t * 3, 7)
            b += ht * 3
            for (
              var yt = max(vt),
                Et = (1 << yt) - 1,
                Rt = hMap(vt, yt, 1),
                _t = 0;
              _t < dt;

            ) {
              var Ft = Rt[bits(s, b, Et)]
              b += Ft & 15
              var ut = Ft >>> 4
              if (ut < 16) pt[_t++] = ut
              else {
                var kt = 0,
                  Nt = 0
                for (
                  ut == 16
                    ? ((Nt = 3 + bits(s, b, 3)), (b += 2), (kt = pt[_t - 1]))
                    : ut == 17
                    ? ((Nt = 3 + bits(s, b, 7)), (b += 3))
                    : ut == 18 && ((Nt = 11 + bits(s, b, 127)), (b += 7));
                  Nt--;

                )
                  pt[_t++] = kt
              }
            }
            var Dt = pt.subarray(0, lt),
              Mt = pt.subarray(lt)
            ;(tt = max(Dt)),
              (st = max(Mt)),
              ($ = hMap(Dt, tt, 1)),
              (_e = hMap(Mt, st, 1))
          } else throw "invalid block type"
        else {
          var ut = shft(b) + 4,
            it = s[ut - 4] | (s[ut - 3] << 8),
            ct = ut + it
          if (ct > o) {
            if (d) throw "unexpected EOF"
            break
          }
          c && g(j + it),
            e.set(s.subarray(ut, ct), j),
            (a.b = j += it),
            (a.p = b = ct * 8)
          continue
        }
        if (b > at) {
          if (d) throw "unexpected EOF"
          break
        }
      }
      c && g(j + 131072)
      for (var wt = (1 << tt) - 1, gt = (1 << st) - 1, At = b; ; At = b) {
        var kt = $[bits16(s, b) & wt],
          bt = kt >>> 4
        if (((b += kt & 15), b > at)) {
          if (d) throw "unexpected EOF"
          break
        }
        if (!kt) throw "invalid length/literal"
        if (bt < 256) e[j++] = bt
        else if (bt == 256) {
          ;(At = b), ($ = null)
          break
        } else {
          var Tt = bt - 254
          if (bt > 264) {
            var _t = bt - 257,
              It = fleb[_t]
            ;(Tt = bits(s, b, (1 << It) - 1) + fl[_t]), (b += It)
          }
          var $t = _e[bits16(s, b) & gt],
            Xt = $t >>> 4
          if (!$t) throw "invalid distance"
          b += $t & 15
          var Mt = fd[Xt]
          if (Xt > 3) {
            var It = fdeb[Xt]
            ;(Mt += bits16(s, b) & ((1 << It) - 1)), (b += It)
          }
          if (b > at) {
            if (d) throw "unexpected EOF"
            break
          }
          c && g(j + 131072)
          for (var qt = j + Tt; j < qt; j += 4)
            (e[j] = e[j - Mt]),
              (e[j + 1] = e[j + 1 - Mt]),
              (e[j + 2] = e[j + 2 - Mt]),
              (e[j + 3] = e[j + 3 - Mt])
          j = qt
        }
      }
      ;(a.l = $),
        (a.p = At),
        (a.b = j),
        $ && ((_ = 1), (a.m = tt), (a.d = _e), (a.n = st))
    } while (!_)
    return j == e.length ? e : slc(e, 0, j)
  },
  et = new u8(0),
  zlv = function (s) {
    if ((s[0] & 15) != 8 || s[0] >>> 4 > 7 || ((s[0] << 8) | s[1]) % 31)
      throw "invalid zlib data"
    if (s[1] & 32) throw "invalid zlib data: preset dictionaries not supported"
  }
function unzlibSync(s, e) {
  return inflt((zlv(s), s.subarray(2, -4)), e)
}
var td = typeof TextDecoder < "u" && new TextDecoder(),
  tds = 0
try {
  td.decode(et, { stream: !0 }), (tds = 1)
} catch {}
const isCubeTexture = (s) => s && s.isCubeTexture
class GroundProjectedEnv extends Mesh {
  constructor(e, a) {
    var o, c
    const d = isCubeTexture(e),
      _ =
        ((c = d
          ? (o = e.image[0]) == null
            ? void 0
            : o.width
          : e.image.width) != null
          ? c
          : 1024) / 4,
      b = Math.floor(Math.log2(_)),
      j = Math.pow(2, b),
      $ = 3 * Math.max(j, 16 * 7),
      _e = 4 * j,
      tt = [
        d ? "#define ENVMAP_TYPE_CUBE" : "",
        `#define CUBEUV_TEXEL_WIDTH ${1 / $}`,
        `#define CUBEUV_TEXEL_HEIGHT ${1 / _e}`,
        `#define CUBEUV_MAX_MIP ${b}.0`,
      ],
      st = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,
      at =
        tt.join(`
`) +
        `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${
              parseInt(REVISION.replace(/\D+/g, "")) >= 154
                ? "colorspace_fragment"
                : "encodings_fragment"
            }>
        }
        `,
      ot = {
        map: { value: e },
        height: { value: (a == null ? void 0 : a.height) || 15 },
        radius: { value: (a == null ? void 0 : a.radius) || 100 },
      },
      ut = new IcosahedronGeometry(1, 16),
      it = new ShaderMaterial({
        uniforms: ot,
        fragmentShader: at,
        vertexShader: st,
        side: DoubleSide,
      })
    super(ut, it)
  }
  set radius(e) {
    this.material.uniforms.radius.value = e
  }
  get radius() {
    return this.material.uniforms.radius.value
  }
  set height(e) {
    this.material.uniforms.height.value = e
  }
  get height() {
    return this.material.uniforms.height.value
  }
}
var __defProp$1 = Object.defineProperty,
  __defNormalProp$1 = (s, e, a) =>
    e in s
      ? __defProp$1(s, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: a,
        })
      : (s[e] = a),
  __publicField = (s, e, a) => (
    __defNormalProp$1(s, typeof e != "symbol" ? e + "" : e, a), a
  )
const _ray = new Ray(),
  _plane = new Plane(),
  TILT_LIMIT = Math.cos(70 * (Math.PI / 180)),
  moduloWrapAround = (s, e) => ((s % e) + e) % e
let OrbitControls$1 = class extends EventDispatcher {
  constructor(e, a) {
    super(),
      __publicField(this, "object"),
      __publicField(this, "domElement"),
      __publicField(this, "enabled", !0),
      __publicField(this, "target", new Vector3()),
      __publicField(this, "minDistance", 0),
      __publicField(this, "maxDistance", 1 / 0),
      __publicField(this, "minZoom", 0),
      __publicField(this, "maxZoom", 1 / 0),
      __publicField(this, "minPolarAngle", 0),
      __publicField(this, "maxPolarAngle", Math.PI),
      __publicField(this, "minAzimuthAngle", -1 / 0),
      __publicField(this, "maxAzimuthAngle", 1 / 0),
      __publicField(this, "enableDamping", !1),
      __publicField(this, "dampingFactor", 0.05),
      __publicField(this, "enableZoom", !0),
      __publicField(this, "zoomSpeed", 1),
      __publicField(this, "enableRotate", !0),
      __publicField(this, "rotateSpeed", 1),
      __publicField(this, "enablePan", !0),
      __publicField(this, "panSpeed", 1),
      __publicField(this, "screenSpacePanning", !0),
      __publicField(this, "keyPanSpeed", 7),
      __publicField(this, "zoomToCursor", !1),
      __publicField(this, "autoRotate", !1),
      __publicField(this, "autoRotateSpeed", 2),
      __publicField(this, "reverseOrbit", !1),
      __publicField(this, "reverseHorizontalOrbit", !1),
      __publicField(this, "reverseVerticalOrbit", !1),
      __publicField(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      __publicField(this, "mouseButtons", {
        LEFT: MOUSE.ROTATE,
        MIDDLE: MOUSE.DOLLY,
        RIGHT: MOUSE.PAN,
      }),
      __publicField(this, "touches", {
        ONE: TOUCH.ROTATE,
        TWO: TOUCH.DOLLY_PAN,
      }),
      __publicField(this, "target0"),
      __publicField(this, "position0"),
      __publicField(this, "zoom0"),
      __publicField(this, "_domElementKeyEvents", null),
      __publicField(this, "getPolarAngle"),
      __publicField(this, "getAzimuthalAngle"),
      __publicField(this, "setPolarAngle"),
      __publicField(this, "setAzimuthalAngle"),
      __publicField(this, "getDistance"),
      __publicField(this, "listenToKeyEvents"),
      __publicField(this, "stopListenToKeyEvents"),
      __publicField(this, "saveState"),
      __publicField(this, "reset"),
      __publicField(this, "update"),
      __publicField(this, "connect"),
      __publicField(this, "dispose"),
      (this.object = e),
      (this.domElement = a),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this.getPolarAngle = () => $.phi),
      (this.getAzimuthalAngle = () => $.theta),
      (this.setPolarAngle = (Wt) => {
        let un = moduloWrapAround(Wt, 2 * Math.PI),
          Mn = $.phi
        Mn < 0 && (Mn += 2 * Math.PI), un < 0 && (un += 2 * Math.PI)
        let jt = Math.abs(un - Mn)
        2 * Math.PI - jt < jt &&
          (un < Mn ? (un += 2 * Math.PI) : (Mn += 2 * Math.PI)),
          (_e.phi = un - Mn),
          o.update()
      }),
      (this.setAzimuthalAngle = (Wt) => {
        let un = moduloWrapAround(Wt, 2 * Math.PI),
          Mn = $.theta
        Mn < 0 && (Mn += 2 * Math.PI), un < 0 && (un += 2 * Math.PI)
        let jt = Math.abs(un - Mn)
        2 * Math.PI - jt < jt &&
          (un < Mn ? (un += 2 * Math.PI) : (Mn += 2 * Math.PI)),
          (_e.theta = un - Mn),
          o.update()
      }),
      (this.getDistance = () => o.object.position.distanceTo(o.target)),
      (this.listenToKeyEvents = (Wt) => {
        Wt.addEventListener("keydown", An), (this._domElementKeyEvents = Wt)
      }),
      (this.stopListenToKeyEvents = () => {
        this._domElementKeyEvents.removeEventListener("keydown", An),
          (this._domElementKeyEvents = null)
      }),
      (this.saveState = () => {
        o.target0.copy(o.target),
          o.position0.copy(o.object.position),
          (o.zoom0 = o.object.zoom)
      }),
      (this.reset = () => {
        o.target.copy(o.target0),
          o.object.position.copy(o.position0),
          (o.object.zoom = o.zoom0),
          o.object.updateProjectionMatrix(),
          o.dispatchEvent(c),
          o.update(),
          (b = _.NONE)
      }),
      (this.update = (() => {
        const Wt = new Vector3(),
          un = new Vector3(0, 1, 0),
          Mn = new Quaternion().setFromUnitVectors(e.up, un),
          jt = Mn.clone().invert(),
          Qt = new Vector3(),
          nn = new Quaternion(),
          En = 2 * Math.PI
        return function () {
          const or = o.object.position
          Mn.setFromUnitVectors(e.up, un),
            jt.copy(Mn).invert(),
            Wt.copy(or).sub(o.target),
            Wt.applyQuaternion(Mn),
            $.setFromVector3(Wt),
            o.autoRotate && b === _.NONE && Nt(Ft()),
            o.enableDamping
              ? (($.theta += _e.theta * o.dampingFactor),
                ($.phi += _e.phi * o.dampingFactor))
              : (($.theta += _e.theta), ($.phi += _e.phi))
          let hr = o.minAzimuthAngle,
            mr = o.maxAzimuthAngle
          isFinite(hr) &&
            isFinite(mr) &&
            (hr < -Math.PI ? (hr += En) : hr > Math.PI && (hr -= En),
            mr < -Math.PI ? (mr += En) : mr > Math.PI && (mr -= En),
            hr <= mr
              ? ($.theta = Math.max(hr, Math.min(mr, $.theta)))
              : ($.theta =
                  $.theta > (hr + mr) / 2
                    ? Math.max(hr, $.theta)
                    : Math.min(mr, $.theta))),
            ($.phi = Math.max(
              o.minPolarAngle,
              Math.min(o.maxPolarAngle, $.phi)
            )),
            $.makeSafe(),
            o.enableDamping === !0
              ? o.target.addScaledVector(st, o.dampingFactor)
              : o.target.add(st),
            (o.zoomToCursor && yt) || o.object.isOrthographicCamera
              ? ($.radius = It($.radius))
              : ($.radius = It($.radius * tt)),
            Wt.setFromSpherical($),
            Wt.applyQuaternion(jt),
            or.copy(o.target).add(Wt),
            o.object.matrixAutoUpdate || o.object.updateMatrix(),
            o.object.lookAt(o.target),
            o.enableDamping === !0
              ? ((_e.theta *= 1 - o.dampingFactor),
                (_e.phi *= 1 - o.dampingFactor),
                st.multiplyScalar(1 - o.dampingFactor))
              : (_e.set(0, 0, 0), st.set(0, 0, 0))
          let kr = !1
          if (o.zoomToCursor && yt) {
            let dr = null
            if (
              o.object instanceof PerspectiveCamera &&
              o.object.isPerspectiveCamera
            ) {
              const Br = Wt.length()
              dr = It(Br * tt)
              const Tr = Br - dr
              o.object.position.addScaledVector(vt, Tr),
                o.object.updateMatrixWorld()
            } else if (o.object.isOrthographicCamera) {
              const Br = new Vector3(_t.x, _t.y, 0)
              Br.unproject(o.object),
                (o.object.zoom = Math.max(
                  o.minZoom,
                  Math.min(o.maxZoom, o.object.zoom / tt)
                )),
                o.object.updateProjectionMatrix(),
                (kr = !0)
              const Tr = new Vector3(_t.x, _t.y, 0)
              Tr.unproject(o.object),
                o.object.position.sub(Tr).add(Br),
                o.object.updateMatrixWorld(),
                (dr = Wt.length())
            } else
              console.warn(
                "WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."
              ),
                (o.zoomToCursor = !1)
            dr !== null &&
              (o.screenSpacePanning
                ? o.target
                    .set(0, 0, -1)
                    .transformDirection(o.object.matrix)
                    .multiplyScalar(dr)
                    .add(o.object.position)
                : (_ray.origin.copy(o.object.position),
                  _ray.direction
                    .set(0, 0, -1)
                    .transformDirection(o.object.matrix),
                  Math.abs(o.object.up.dot(_ray.direction)) < TILT_LIMIT
                    ? e.lookAt(o.target)
                    : (_plane.setFromNormalAndCoplanarPoint(
                        o.object.up,
                        o.target
                      ),
                      _ray.intersectPlane(_plane, o.target))))
          } else
            o.object instanceof OrthographicCamera &&
              o.object.isOrthographicCamera &&
              ((kr = tt !== 1),
              kr &&
                ((o.object.zoom = Math.max(
                  o.minZoom,
                  Math.min(o.maxZoom, o.object.zoom / tt)
                )),
                o.object.updateProjectionMatrix()))
          return (
            (tt = 1),
            (yt = !1),
            kr ||
            Qt.distanceToSquared(o.object.position) > j ||
            8 * (1 - nn.dot(o.object.quaternion)) > j
              ? (o.dispatchEvent(c),
                Qt.copy(o.object.position),
                nn.copy(o.object.quaternion),
                (kr = !1),
                !0)
              : !1
          )
        }
      })()),
      (this.connect = (Wt) => {
        Wt === document &&
          console.error(
            'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
          ),
          (o.domElement = Wt),
          (o.domElement.style.touchAction = "none"),
          o.domElement.addEventListener("contextmenu", an),
          o.domElement.addEventListener("pointerdown", jn),
          o.domElement.addEventListener("pointercancel", Lt),
          o.domElement.addEventListener("wheel", vn)
      }),
      (this.dispose = () => {
        var Wt, un, Mn, jt, Qt, nn
        ;(Wt = o.domElement) == null ||
          Wt.removeEventListener("contextmenu", an),
          (un = o.domElement) == null ||
            un.removeEventListener("pointerdown", jn),
          (Mn = o.domElement) == null ||
            Mn.removeEventListener("pointercancel", Lt),
          (jt = o.domElement) == null || jt.removeEventListener("wheel", vn),
          (Qt = o.domElement) == null ||
            Qt.ownerDocument.removeEventListener("pointermove", ar),
          (nn = o.domElement) == null ||
            nn.ownerDocument.removeEventListener("pointerup", Vt),
          o._domElementKeyEvents !== null &&
            o._domElementKeyEvents.removeEventListener("keydown", An)
      })
    const o = this,
      c = { type: "change" },
      d = { type: "start" },
      g = { type: "end" },
      _ = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      }
    let b = _.NONE
    const j = 1e-6,
      $ = new Spherical(),
      _e = new Spherical()
    let tt = 1
    const st = new Vector3(),
      at = new Vector2(),
      ot = new Vector2(),
      ut = new Vector2(),
      it = new Vector2(),
      ct = new Vector2(),
      lt = new Vector2(),
      ht = new Vector2(),
      dt = new Vector2(),
      pt = new Vector2(),
      vt = new Vector3(),
      _t = new Vector2()
    let yt = !1
    const Et = [],
      Rt = {}
    function Ft() {
      return ((2 * Math.PI) / 60 / 60) * o.autoRotateSpeed
    }
    function kt() {
      return Math.pow(0.95, o.zoomSpeed)
    }
    function Nt(Wt) {
      o.reverseOrbit || o.reverseHorizontalOrbit
        ? (_e.theta += Wt)
        : (_e.theta -= Wt)
    }
    function Dt(Wt) {
      o.reverseOrbit || o.reverseVerticalOrbit ? (_e.phi += Wt) : (_e.phi -= Wt)
    }
    const Mt = (() => {
        const Wt = new Vector3()
        return function (Mn, jt) {
          Wt.setFromMatrixColumn(jt, 0), Wt.multiplyScalar(-Mn), st.add(Wt)
        }
      })(),
      wt = (() => {
        const Wt = new Vector3()
        return function (Mn, jt) {
          o.screenSpacePanning === !0
            ? Wt.setFromMatrixColumn(jt, 1)
            : (Wt.setFromMatrixColumn(jt, 0), Wt.crossVectors(o.object.up, Wt)),
            Wt.multiplyScalar(Mn),
            st.add(Wt)
        }
      })(),
      gt = (() => {
        const Wt = new Vector3()
        return function (Mn, jt) {
          const Qt = o.domElement
          if (
            Qt &&
            o.object instanceof PerspectiveCamera &&
            o.object.isPerspectiveCamera
          ) {
            const nn = o.object.position
            Wt.copy(nn).sub(o.target)
            let En = Wt.length()
            ;(En *= Math.tan(((o.object.fov / 2) * Math.PI) / 180)),
              Mt((2 * Mn * En) / Qt.clientHeight, o.object.matrix),
              wt((2 * jt * En) / Qt.clientHeight, o.object.matrix)
          } else
            Qt &&
            o.object instanceof OrthographicCamera &&
            o.object.isOrthographicCamera
              ? (Mt(
                  (Mn * (o.object.right - o.object.left)) /
                    o.object.zoom /
                    Qt.clientWidth,
                  o.object.matrix
                ),
                wt(
                  (jt * (o.object.top - o.object.bottom)) /
                    o.object.zoom /
                    Qt.clientHeight,
                  o.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (o.enablePan = !1))
        }
      })()
    function At(Wt) {
      ;(o.object instanceof PerspectiveCamera &&
        o.object.isPerspectiveCamera) ||
      (o.object instanceof OrthographicCamera && o.object.isOrthographicCamera)
        ? (tt /= Wt)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (o.enableZoom = !1))
    }
    function bt(Wt) {
      ;(o.object instanceof PerspectiveCamera &&
        o.object.isPerspectiveCamera) ||
      (o.object instanceof OrthographicCamera && o.object.isOrthographicCamera)
        ? (tt *= Wt)
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (o.enableZoom = !1))
    }
    function Tt(Wt) {
      if (!o.zoomToCursor || !o.domElement) return
      yt = !0
      const un = o.domElement.getBoundingClientRect(),
        Mn = Wt.clientX - un.left,
        jt = Wt.clientY - un.top,
        Qt = un.width,
        nn = un.height
      ;(_t.x = (Mn / Qt) * 2 - 1),
        (_t.y = -(jt / nn) * 2 + 1),
        vt
          .set(_t.x, _t.y, 1)
          .unproject(o.object)
          .sub(o.object.position)
          .normalize()
    }
    function It(Wt) {
      return Math.max(o.minDistance, Math.min(o.maxDistance, Wt))
    }
    function $t(Wt) {
      at.set(Wt.clientX, Wt.clientY)
    }
    function Xt(Wt) {
      Tt(Wt), ht.set(Wt.clientX, Wt.clientY)
    }
    function qt(Wt) {
      it.set(Wt.clientX, Wt.clientY)
    }
    function en(Wt) {
      ot.set(Wt.clientX, Wt.clientY),
        ut.subVectors(ot, at).multiplyScalar(o.rotateSpeed)
      const un = o.domElement
      un &&
        (Nt((2 * Math.PI * ut.x) / un.clientHeight),
        Dt((2 * Math.PI * ut.y) / un.clientHeight)),
        at.copy(ot),
        o.update()
    }
    function yn(Wt) {
      dt.set(Wt.clientX, Wt.clientY),
        pt.subVectors(dt, ht),
        pt.y > 0 ? At(kt()) : pt.y < 0 && bt(kt()),
        ht.copy(dt),
        o.update()
    }
    function Tn(Wt) {
      ct.set(Wt.clientX, Wt.clientY),
        lt.subVectors(ct, it).multiplyScalar(o.panSpeed),
        gt(lt.x, lt.y),
        it.copy(ct),
        o.update()
    }
    function $n(Wt) {
      Tt(Wt), Wt.deltaY < 0 ? bt(kt()) : Wt.deltaY > 0 && At(kt()), o.update()
    }
    function Vn(Wt) {
      let un = !1
      switch (Wt.code) {
        case o.keys.UP:
          gt(0, o.keyPanSpeed), (un = !0)
          break
        case o.keys.BOTTOM:
          gt(0, -o.keyPanSpeed), (un = !0)
          break
        case o.keys.LEFT:
          gt(o.keyPanSpeed, 0), (un = !0)
          break
        case o.keys.RIGHT:
          gt(-o.keyPanSpeed, 0), (un = !0)
          break
      }
      un && (Wt.preventDefault(), o.update())
    }
    function gn() {
      if (Et.length == 1) at.set(Et[0].pageX, Et[0].pageY)
      else {
        const Wt = 0.5 * (Et[0].pageX + Et[1].pageX),
          un = 0.5 * (Et[0].pageY + Et[1].pageY)
        at.set(Wt, un)
      }
    }
    function Ht() {
      if (Et.length == 1) it.set(Et[0].pageX, Et[0].pageY)
      else {
        const Wt = 0.5 * (Et[0].pageX + Et[1].pageX),
          un = 0.5 * (Et[0].pageY + Et[1].pageY)
        it.set(Wt, un)
      }
    }
    function on() {
      const Wt = Et[0].pageX - Et[1].pageX,
        un = Et[0].pageY - Et[1].pageY,
        Mn = Math.sqrt(Wt * Wt + un * un)
      ht.set(0, Mn)
    }
    function Yt() {
      o.enableZoom && on(), o.enablePan && Ht()
    }
    function _n() {
      o.enableZoom && on(), o.enableRotate && gn()
    }
    function pn(Wt) {
      if (Et.length == 1) ot.set(Wt.pageX, Wt.pageY)
      else {
        const Mn = Un(Wt),
          jt = 0.5 * (Wt.pageX + Mn.x),
          Qt = 0.5 * (Wt.pageY + Mn.y)
        ot.set(jt, Qt)
      }
      ut.subVectors(ot, at).multiplyScalar(o.rotateSpeed)
      const un = o.domElement
      un &&
        (Nt((2 * Math.PI * ut.x) / un.clientHeight),
        Dt((2 * Math.PI * ut.y) / un.clientHeight)),
        at.copy(ot)
    }
    function Rn(Wt) {
      if (Et.length == 1) ct.set(Wt.pageX, Wt.pageY)
      else {
        const un = Un(Wt),
          Mn = 0.5 * (Wt.pageX + un.x),
          jt = 0.5 * (Wt.pageY + un.y)
        ct.set(Mn, jt)
      }
      lt.subVectors(ct, it).multiplyScalar(o.panSpeed),
        gt(lt.x, lt.y),
        it.copy(ct)
    }
    function bn(Wt) {
      const un = Un(Wt),
        Mn = Wt.pageX - un.x,
        jt = Wt.pageY - un.y,
        Qt = Math.sqrt(Mn * Mn + jt * jt)
      dt.set(0, Qt),
        pt.set(0, Math.pow(dt.y / ht.y, o.zoomSpeed)),
        At(pt.y),
        ht.copy(dt)
    }
    function Pn(Wt) {
      o.enableZoom && bn(Wt), o.enablePan && Rn(Wt)
    }
    function Gn(Wt) {
      o.enableZoom && bn(Wt), o.enableRotate && pn(Wt)
    }
    function jn(Wt) {
      var un, Mn
      o.enabled !== !1 &&
        (Et.length === 0 &&
          ((un = o.domElement) == null ||
            un.ownerDocument.addEventListener("pointermove", ar),
          (Mn = o.domElement) == null ||
            Mn.ownerDocument.addEventListener("pointerup", Vt)),
        Jn(Wt),
        Wt.pointerType === "touch" ? Nn(Wt) : Zt(Wt))
    }
    function ar(Wt) {
      o.enabled !== !1 && (Wt.pointerType === "touch" ? Sn(Wt) : xn(Wt))
    }
    function Vt(Wt) {
      var un, Mn, jt
      Hn(Wt),
        Et.length === 0 &&
          ((un = o.domElement) == null ||
            un.releasePointerCapture(Wt.pointerId),
          (Mn = o.domElement) == null ||
            Mn.ownerDocument.removeEventListener("pointermove", ar),
          (jt = o.domElement) == null ||
            jt.ownerDocument.removeEventListener("pointerup", Vt)),
        o.dispatchEvent(g),
        (b = _.NONE)
    }
    function Lt(Wt) {
      Hn(Wt)
    }
    function Zt(Wt) {
      let un
      switch (Wt.button) {
        case 0:
          un = o.mouseButtons.LEFT
          break
        case 1:
          un = o.mouseButtons.MIDDLE
          break
        case 2:
          un = o.mouseButtons.RIGHT
          break
        default:
          un = -1
      }
      switch (un) {
        case MOUSE.DOLLY:
          if (o.enableZoom === !1) return
          Xt(Wt), (b = _.DOLLY)
          break
        case MOUSE.ROTATE:
          if (Wt.ctrlKey || Wt.metaKey || Wt.shiftKey) {
            if (o.enablePan === !1) return
            qt(Wt), (b = _.PAN)
          } else {
            if (o.enableRotate === !1) return
            $t(Wt), (b = _.ROTATE)
          }
          break
        case MOUSE.PAN:
          if (Wt.ctrlKey || Wt.metaKey || Wt.shiftKey) {
            if (o.enableRotate === !1) return
            $t(Wt), (b = _.ROTATE)
          } else {
            if (o.enablePan === !1) return
            qt(Wt), (b = _.PAN)
          }
          break
        default:
          b = _.NONE
      }
      b !== _.NONE && o.dispatchEvent(d)
    }
    function xn(Wt) {
      if (o.enabled !== !1)
        switch (b) {
          case _.ROTATE:
            if (o.enableRotate === !1) return
            en(Wt)
            break
          case _.DOLLY:
            if (o.enableZoom === !1) return
            yn(Wt)
            break
          case _.PAN:
            if (o.enablePan === !1) return
            Tn(Wt)
            break
        }
    }
    function vn(Wt) {
      o.enabled === !1 ||
        o.enableZoom === !1 ||
        (b !== _.NONE && b !== _.ROTATE) ||
        (Wt.preventDefault(), o.dispatchEvent(d), $n(Wt), o.dispatchEvent(g))
    }
    function An(Wt) {
      o.enabled === !1 || o.enablePan === !1 || Vn(Wt)
    }
    function Nn(Wt) {
      switch ((Fn(Wt), Et.length)) {
        case 1:
          switch (o.touches.ONE) {
            case TOUCH.ROTATE:
              if (o.enableRotate === !1) return
              gn(), (b = _.TOUCH_ROTATE)
              break
            case TOUCH.PAN:
              if (o.enablePan === !1) return
              Ht(), (b = _.TOUCH_PAN)
              break
            default:
              b = _.NONE
          }
          break
        case 2:
          switch (o.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (o.enableZoom === !1 && o.enablePan === !1) return
              Yt(), (b = _.TOUCH_DOLLY_PAN)
              break
            case TOUCH.DOLLY_ROTATE:
              if (o.enableZoom === !1 && o.enableRotate === !1) return
              _n(), (b = _.TOUCH_DOLLY_ROTATE)
              break
            default:
              b = _.NONE
          }
          break
        default:
          b = _.NONE
      }
      b !== _.NONE && o.dispatchEvent(d)
    }
    function Sn(Wt) {
      switch ((Fn(Wt), b)) {
        case _.TOUCH_ROTATE:
          if (o.enableRotate === !1) return
          pn(Wt), o.update()
          break
        case _.TOUCH_PAN:
          if (o.enablePan === !1) return
          Rn(Wt), o.update()
          break
        case _.TOUCH_DOLLY_PAN:
          if (o.enableZoom === !1 && o.enablePan === !1) return
          Pn(Wt), o.update()
          break
        case _.TOUCH_DOLLY_ROTATE:
          if (o.enableZoom === !1 && o.enableRotate === !1) return
          Gn(Wt), o.update()
          break
        default:
          b = _.NONE
      }
    }
    function an(Wt) {
      o.enabled !== !1 && Wt.preventDefault()
    }
    function Jn(Wt) {
      Et.push(Wt)
    }
    function Hn(Wt) {
      delete Rt[Wt.pointerId]
      for (let un = 0; un < Et.length; un++)
        if (Et[un].pointerId == Wt.pointerId) {
          Et.splice(un, 1)
          return
        }
    }
    function Fn(Wt) {
      let un = Rt[Wt.pointerId]
      un === void 0 && ((un = new Vector2()), (Rt[Wt.pointerId] = un)),
        un.set(Wt.pageX, Wt.pageY)
    }
    function Un(Wt) {
      const un = Wt.pointerId === Et[0].pointerId ? Et[1] : Et[0]
      return Rt[un.pointerId]
    }
    a !== void 0 && this.connect(a), this.update()
  }
}
class GLTFLoader extends Loader$1 {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (a) {
        return new GLTFMaterialsClearcoatExtension(a)
      }),
      this.register(function (a) {
        return new GLTFTextureBasisUExtension(a)
      }),
      this.register(function (a) {
        return new GLTFTextureWebPExtension(a)
      }),
      this.register(function (a) {
        return new GLTFTextureAVIFExtension(a)
      }),
      this.register(function (a) {
        return new GLTFMaterialsSheenExtension(a)
      }),
      this.register(function (a) {
        return new GLTFMaterialsTransmissionExtension(a)
      }),
      this.register(function (a) {
        return new GLTFMaterialsVolumeExtension(a)
      }),
      this.register(function (a) {
        return new GLTFMaterialsIorExtension(a)
      }),
      this.register(function (a) {
        return new GLTFMaterialsEmissiveStrengthExtension(a)
      }),
      this.register(function (a) {
        return new GLTFMaterialsSpecularExtension(a)
      }),
      this.register(function (a) {
        return new GLTFMaterialsIridescenceExtension(a)
      }),
      this.register(function (a) {
        return new GLTFMaterialsAnisotropyExtension(a)
      }),
      this.register(function (a) {
        return new GLTFLightsExtension(a)
      }),
      this.register(function (a) {
        return new GLTFMeshoptCompression(a)
      }),
      this.register(function (a) {
        return new GLTFMeshGpuInstancing(a)
      })
  }
  load(e, a, o, c) {
    const d = this
    let g
    this.resourcePath !== ""
      ? (g = this.resourcePath)
      : this.path !== ""
      ? (g = this.path)
      : (g = LoaderUtils.extractUrlBase(e)),
      this.manager.itemStart(e)
    const _ = function (j) {
        c ? c(j) : console.error(j),
          d.manager.itemError(e),
          d.manager.itemEnd(e)
      },
      b = new FileLoader(this.manager)
    b.setPath(this.path),
      b.setResponseType("arraybuffer"),
      b.setRequestHeader(this.requestHeader),
      b.setWithCredentials(this.withCredentials),
      b.load(
        e,
        function (j) {
          try {
            d.parse(
              j,
              g,
              function ($) {
                a($), d.manager.itemEnd(e)
              },
              _
            )
          } catch ($) {
            _($)
          }
        },
        o,
        _
      )
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    )
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    )
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    )
  }
  parse(e, a, o, c) {
    let d
    const g = {},
      _ = {}
    if (typeof e == "string") d = JSON.parse(e)
    else if (e instanceof ArrayBuffer)
      if (
        LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))) ===
        BINARY_EXTENSION_HEADER_MAGIC
      ) {
        try {
          g[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(e)
        } catch ($) {
          c && c($)
          return
        }
        d = JSON.parse(g[EXTENSIONS.KHR_BINARY_GLTF].content)
      } else d = JSON.parse(LoaderUtils.decodeText(new Uint8Array(e)))
    else d = e
    if (d.asset === void 0 || d.asset.version[0] < 2) {
      c &&
        c(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        )
      return
    }
    const b = new GLTFParser(d, {
      path: a || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    })
    b.fileLoader.setRequestHeader(this.requestHeader)
    for (let j = 0; j < this.pluginCallbacks.length; j++) {
      const $ = this.pluginCallbacks[j](b)
      ;(_[$.name] = $), (g[$.name] = !0)
    }
    if (d.extensionsUsed)
      for (let j = 0; j < d.extensionsUsed.length; ++j) {
        const $ = d.extensionsUsed[j],
          _e = d.extensionsRequired || []
        switch ($) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            g[$] = new GLTFMaterialsUnlitExtension()
            break
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            g[$] = new GLTFDracoMeshCompressionExtension(d, this.dracoLoader)
            break
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            g[$] = new GLTFTextureTransformExtension()
            break
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            g[$] = new GLTFMeshQuantizationExtension()
            break
          default:
            _e.indexOf($) >= 0 &&
              _[$] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + $ + '".')
        }
      }
    b.setExtensions(g), b.setPlugins(_), b.parse(o, c)
  }
  parseAsync(e, a) {
    const o = this
    return new Promise(function (c, d) {
      o.parse(e, a, c, d)
    })
  }
}
function GLTFRegistry() {
  let s = {}
  return {
    get: function (e) {
      return s[e]
    },
    add: function (e, a) {
      s[e] = a
    },
    remove: function (e) {
      delete s[e]
    },
    removeAll: function () {
      s = {}
    },
  }
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
}
class GLTFLightsExtension {
  constructor(e) {
    ;(this.parser = e),
      (this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} })
  }
  _markDefs() {
    const e = this.parser,
      a = this.parser.json.nodes || []
    for (let o = 0, c = a.length; o < c; o++) {
      const d = a[o]
      d.extensions &&
        d.extensions[this.name] &&
        d.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, d.extensions[this.name].light)
    }
  }
  _loadLight(e) {
    const a = this.parser,
      o = "light:" + e
    let c = a.cache.get(o)
    if (c) return c
    const d = a.json,
      b = (((d.extensions && d.extensions[this.name]) || {}).lights || [])[e]
    let j
    const $ = new Color(16777215)
    b.color !== void 0 && $.fromArray(b.color)
    const _e = b.range !== void 0 ? b.range : 0
    switch (b.type) {
      case "directional":
        ;(j = new DirectionalLight($)),
          j.target.position.set(0, 0, -1),
          j.add(j.target)
        break
      case "point":
        ;(j = new PointLight($)), (j.distance = _e)
        break
      case "spot":
        ;(j = new SpotLight($)),
          (j.distance = _e),
          (b.spot = b.spot || {}),
          (b.spot.innerConeAngle =
            b.spot.innerConeAngle !== void 0 ? b.spot.innerConeAngle : 0),
          (b.spot.outerConeAngle =
            b.spot.outerConeAngle !== void 0
              ? b.spot.outerConeAngle
              : Math.PI / 4),
          (j.angle = b.spot.outerConeAngle),
          (j.penumbra = 1 - b.spot.innerConeAngle / b.spot.outerConeAngle),
          j.target.position.set(0, 0, -1),
          j.add(j.target)
        break
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + b.type)
    }
    return (
      j.position.set(0, 0, 0),
      (j.decay = 2),
      assignExtrasToUserData(j, b),
      b.intensity !== void 0 && (j.intensity = b.intensity),
      (j.name = a.createUniqueName(b.name || "light_" + e)),
      (c = Promise.resolve(j)),
      a.cache.add(o, c),
      c
    )
  }
  getDependency(e, a) {
    if (e === "light") return this._loadLight(a)
  }
  createNodeAttachment(e) {
    const a = this,
      o = this.parser,
      d = o.json.nodes[e],
      _ = ((d.extensions && d.extensions[this.name]) || {}).light
    return _ === void 0
      ? null
      : this._loadLight(_).then(function (b) {
          return o._getNodeRef(a.cache, _, b)
        })
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT
  }
  getMaterialType() {
    return MeshBasicMaterial
  }
  extendParams(e, a, o) {
    const c = []
    ;(e.color = new Color(1, 1, 1)), (e.opacity = 1)
    const d = a.pbrMetallicRoughness
    if (d) {
      if (Array.isArray(d.baseColorFactor)) {
        const g = d.baseColorFactor
        e.color.fromArray(g), (e.opacity = g[3])
      }
      d.baseColorTexture !== void 0 &&
        c.push(o.assignTexture(e, "map", d.baseColorTexture, 3001))
    }
    return Promise.all(c)
  }
}
class GLTFMaterialsEmissiveStrengthExtension {
  constructor(e) {
    ;(this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH)
  }
  extendMaterialParams(e, a) {
    const c = this.parser.json.materials[e]
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve()
    const d = c.extensions[this.name].emissiveStrength
    return d !== void 0 && (a.emissiveIntensity = d), Promise.resolve()
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(e) {
    ;(this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT)
  }
  getMaterialType(e) {
    const o = this.parser.json.materials[e]
    return !o.extensions || !o.extensions[this.name]
      ? null
      : MeshPhysicalMaterial
  }
  extendMaterialParams(e, a) {
    const o = this.parser,
      c = o.json.materials[e]
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve()
    const d = [],
      g = c.extensions[this.name]
    if (
      (g.clearcoatFactor !== void 0 && (a.clearcoat = g.clearcoatFactor),
      g.clearcoatTexture !== void 0 &&
        d.push(o.assignTexture(a, "clearcoatMap", g.clearcoatTexture)),
      g.clearcoatRoughnessFactor !== void 0 &&
        (a.clearcoatRoughness = g.clearcoatRoughnessFactor),
      g.clearcoatRoughnessTexture !== void 0 &&
        d.push(
          o.assignTexture(
            a,
            "clearcoatRoughnessMap",
            g.clearcoatRoughnessTexture
          )
        ),
      g.clearcoatNormalTexture !== void 0 &&
        (d.push(
          o.assignTexture(a, "clearcoatNormalMap", g.clearcoatNormalTexture)
        ),
        g.clearcoatNormalTexture.scale !== void 0))
    ) {
      const _ = g.clearcoatNormalTexture.scale
      a.clearcoatNormalScale = new Vector2(_, _)
    }
    return Promise.all(d)
  }
}
class GLTFMaterialsIridescenceExtension {
  constructor(e) {
    ;(this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE)
  }
  getMaterialType(e) {
    const o = this.parser.json.materials[e]
    return !o.extensions || !o.extensions[this.name]
      ? null
      : MeshPhysicalMaterial
  }
  extendMaterialParams(e, a) {
    const o = this.parser,
      c = o.json.materials[e]
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve()
    const d = [],
      g = c.extensions[this.name]
    return (
      g.iridescenceFactor !== void 0 && (a.iridescence = g.iridescenceFactor),
      g.iridescenceTexture !== void 0 &&
        d.push(o.assignTexture(a, "iridescenceMap", g.iridescenceTexture)),
      g.iridescenceIor !== void 0 && (a.iridescenceIOR = g.iridescenceIor),
      a.iridescenceThicknessRange === void 0 &&
        (a.iridescenceThicknessRange = [100, 400]),
      g.iridescenceThicknessMinimum !== void 0 &&
        (a.iridescenceThicknessRange[0] = g.iridescenceThicknessMinimum),
      g.iridescenceThicknessMaximum !== void 0 &&
        (a.iridescenceThicknessRange[1] = g.iridescenceThicknessMaximum),
      g.iridescenceThicknessTexture !== void 0 &&
        d.push(
          o.assignTexture(
            a,
            "iridescenceThicknessMap",
            g.iridescenceThicknessTexture
          )
        ),
      Promise.all(d)
    )
  }
}
class GLTFMaterialsSheenExtension {
  constructor(e) {
    ;(this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_SHEEN)
  }
  getMaterialType(e) {
    const o = this.parser.json.materials[e]
    return !o.extensions || !o.extensions[this.name]
      ? null
      : MeshPhysicalMaterial
  }
  extendMaterialParams(e, a) {
    const o = this.parser,
      c = o.json.materials[e]
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve()
    const d = []
    ;(a.sheenColor = new Color(0, 0, 0)), (a.sheenRoughness = 0), (a.sheen = 1)
    const g = c.extensions[this.name]
    return (
      g.sheenColorFactor !== void 0 &&
        a.sheenColor.fromArray(g.sheenColorFactor),
      g.sheenRoughnessFactor !== void 0 &&
        (a.sheenRoughness = g.sheenRoughnessFactor),
      g.sheenColorTexture !== void 0 &&
        d.push(o.assignTexture(a, "sheenColorMap", g.sheenColorTexture, 3001)),
      g.sheenRoughnessTexture !== void 0 &&
        d.push(
          o.assignTexture(a, "sheenRoughnessMap", g.sheenRoughnessTexture)
        ),
      Promise.all(d)
    )
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(e) {
    ;(this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION)
  }
  getMaterialType(e) {
    const o = this.parser.json.materials[e]
    return !o.extensions || !o.extensions[this.name]
      ? null
      : MeshPhysicalMaterial
  }
  extendMaterialParams(e, a) {
    const o = this.parser,
      c = o.json.materials[e]
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve()
    const d = [],
      g = c.extensions[this.name]
    return (
      g.transmissionFactor !== void 0 &&
        (a.transmission = g.transmissionFactor),
      g.transmissionTexture !== void 0 &&
        d.push(o.assignTexture(a, "transmissionMap", g.transmissionTexture)),
      Promise.all(d)
    )
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(e) {
    ;(this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_VOLUME)
  }
  getMaterialType(e) {
    const o = this.parser.json.materials[e]
    return !o.extensions || !o.extensions[this.name]
      ? null
      : MeshPhysicalMaterial
  }
  extendMaterialParams(e, a) {
    const o = this.parser,
      c = o.json.materials[e]
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve()
    const d = [],
      g = c.extensions[this.name]
    ;(a.thickness = g.thicknessFactor !== void 0 ? g.thicknessFactor : 0),
      g.thicknessTexture !== void 0 &&
        d.push(o.assignTexture(a, "thicknessMap", g.thicknessTexture)),
      (a.attenuationDistance = g.attenuationDistance || 1 / 0)
    const _ = g.attenuationColor || [1, 1, 1]
    return (a.attenuationColor = new Color(_[0], _[1], _[2])), Promise.all(d)
  }
}
class GLTFMaterialsIorExtension {
  constructor(e) {
    ;(this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_IOR)
  }
  getMaterialType(e) {
    const o = this.parser.json.materials[e]
    return !o.extensions || !o.extensions[this.name]
      ? null
      : MeshPhysicalMaterial
  }
  extendMaterialParams(e, a) {
    const c = this.parser.json.materials[e]
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve()
    const d = c.extensions[this.name]
    return (a.ior = d.ior !== void 0 ? d.ior : 1.5), Promise.resolve()
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(e) {
    ;(this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR)
  }
  getMaterialType(e) {
    const o = this.parser.json.materials[e]
    return !o.extensions || !o.extensions[this.name]
      ? null
      : MeshPhysicalMaterial
  }
  extendMaterialParams(e, a) {
    const o = this.parser,
      c = o.json.materials[e]
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve()
    const d = [],
      g = c.extensions[this.name]
    ;(a.specularIntensity = g.specularFactor !== void 0 ? g.specularFactor : 1),
      g.specularTexture !== void 0 &&
        d.push(o.assignTexture(a, "specularIntensityMap", g.specularTexture))
    const _ = g.specularColorFactor || [1, 1, 1]
    return (
      (a.specularColor = new Color(_[0], _[1], _[2])),
      g.specularColorTexture !== void 0 &&
        d.push(
          o.assignTexture(a, "specularColorMap", g.specularColorTexture, 3001)
        ),
      Promise.all(d)
    )
  }
}
class GLTFMaterialsAnisotropyExtension {
  constructor(e) {
    ;(this.parser = e), (this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY)
  }
  getMaterialType(e) {
    const o = this.parser.json.materials[e]
    return !o.extensions || !o.extensions[this.name]
      ? null
      : MeshPhysicalMaterial
  }
  extendMaterialParams(e, a) {
    const o = this.parser,
      c = o.json.materials[e]
    if (!c.extensions || !c.extensions[this.name]) return Promise.resolve()
    const d = [],
      g = c.extensions[this.name]
    return (
      g.anisotropyStrength !== void 0 && (a.anisotropy = g.anisotropyStrength),
      g.anisotropyRotation !== void 0 &&
        (a.anisotropyRotation = g.anisotropyRotation),
      g.anisotropyTexture !== void 0 &&
        d.push(o.assignTexture(a, "anisotropyMap", g.anisotropyTexture)),
      Promise.all(d)
    )
  }
}
class GLTFTextureBasisUExtension {
  constructor(e) {
    ;(this.parser = e), (this.name = EXTENSIONS.KHR_TEXTURE_BASISU)
  }
  loadTexture(e) {
    const a = this.parser,
      o = a.json,
      c = o.textures[e]
    if (!c.extensions || !c.extensions[this.name]) return null
    const d = c.extensions[this.name],
      g = a.options.ktx2Loader
    if (!g) {
      if (o.extensionsRequired && o.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        )
      return null
    }
    return a.loadTextureImage(e, d.source, g)
  }
}
class GLTFTextureWebPExtension {
  constructor(e) {
    ;(this.parser = e),
      (this.name = EXTENSIONS.EXT_TEXTURE_WEBP),
      (this.isSupported = null)
  }
  loadTexture(e) {
    const a = this.name,
      o = this.parser,
      c = o.json,
      d = c.textures[e]
    if (!d.extensions || !d.extensions[a]) return null
    const g = d.extensions[a],
      _ = c.images[g.source]
    let b = o.textureLoader
    if (_.uri) {
      const j = o.options.manager.getHandler(_.uri)
      j !== null && (b = j)
    }
    return this.detectSupport().then(function (j) {
      if (j) return o.loadTextureImage(e, g.source, b)
      if (c.extensionsRequired && c.extensionsRequired.indexOf(a) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        )
      return o.loadTexture(e)
    })
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const a = new Image()
          ;(a.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (a.onload = a.onerror =
              function () {
                e(a.height === 1)
              })
        })),
      this.isSupported
    )
  }
}
class GLTFTextureAVIFExtension {
  constructor(e) {
    ;(this.parser = e),
      (this.name = EXTENSIONS.EXT_TEXTURE_AVIF),
      (this.isSupported = null)
  }
  loadTexture(e) {
    const a = this.name,
      o = this.parser,
      c = o.json,
      d = c.textures[e]
    if (!d.extensions || !d.extensions[a]) return null
    const g = d.extensions[a],
      _ = c.images[g.source]
    let b = o.textureLoader
    if (_.uri) {
      const j = o.options.manager.getHandler(_.uri)
      j !== null && (b = j)
    }
    return this.detectSupport().then(function (j) {
      if (j) return o.loadTextureImage(e, g.source, b)
      if (c.extensionsRequired && c.extensionsRequired.indexOf(a) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        )
      return o.loadTexture(e)
    })
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const a = new Image()
          ;(a.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (a.onload = a.onerror =
              function () {
                e(a.height === 1)
              })
        })),
      this.isSupported
    )
  }
}
class GLTFMeshoptCompression {
  constructor(e) {
    ;(this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION), (this.parser = e)
  }
  loadBufferView(e) {
    const a = this.parser.json,
      o = a.bufferViews[e]
    if (o.extensions && o.extensions[this.name]) {
      const c = o.extensions[this.name],
        d = this.parser.getDependency("buffer", c.buffer),
        g = this.parser.options.meshoptDecoder
      if (!g || !g.supported) {
        if (
          a.extensionsRequired &&
          a.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          )
        return null
      }
      return d.then(function (_) {
        const b = c.byteOffset || 0,
          j = c.byteLength || 0,
          $ = c.count,
          _e = c.byteStride,
          tt = new Uint8Array(_, b, j)
        return g.decodeGltfBufferAsync
          ? g
              .decodeGltfBufferAsync($, _e, tt, c.mode, c.filter)
              .then(function (st) {
                return st.buffer
              })
          : g.ready.then(function () {
              const st = new ArrayBuffer($ * _e)
              return (
                g.decodeGltfBuffer(
                  new Uint8Array(st),
                  $,
                  _e,
                  tt,
                  c.mode,
                  c.filter
                ),
                st
              )
            })
      })
    } else return null
  }
}
class GLTFMeshGpuInstancing {
  constructor(e) {
    ;(this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING), (this.parser = e)
  }
  createNodeMesh(e) {
    const a = this.parser.json,
      o = a.nodes[e]
    if (!o.extensions || !o.extensions[this.name] || o.mesh === void 0)
      return null
    const c = a.meshes[o.mesh]
    for (const j of c.primitives)
      if (
        j.mode !== WEBGL_CONSTANTS.TRIANGLES &&
        j.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP &&
        j.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN &&
        j.mode !== void 0
      )
        return null
    const g = o.extensions[this.name].attributes,
      _ = [],
      b = {}
    for (const j in g)
      _.push(
        this.parser
          .getDependency("accessor", g[j])
          .then(($) => ((b[j] = $), b[j]))
      )
    return _.length < 1
      ? null
      : (_.push(this.parser.createNodeMesh(e)),
        Promise.all(_).then((j) => {
          const $ = j.pop(),
            _e = $.isGroup ? $.children : [$],
            tt = j[0].count,
            st = []
          for (const at of _e) {
            const ot = new Matrix4(),
              ut = new Vector3(),
              it = new Quaternion(),
              ct = new Vector3(1, 1, 1),
              lt = new InstancedMesh(at.geometry, at.material, tt)
            for (let ht = 0; ht < tt; ht++)
              b.TRANSLATION && ut.fromBufferAttribute(b.TRANSLATION, ht),
                b.ROTATION && it.fromBufferAttribute(b.ROTATION, ht),
                b.SCALE && ct.fromBufferAttribute(b.SCALE, ht),
                lt.setMatrixAt(ht, ot.compose(ut, it, ct))
            for (const ht in b)
              ht !== "TRANSLATION" &&
                ht !== "ROTATION" &&
                ht !== "SCALE" &&
                at.geometry.setAttribute(ht, b[ht])
            Object3D.prototype.copy.call(lt, at),
              this.parser.assignFinalMaterial(lt),
              st.push(lt)
          }
          return $.isGroup ? ($.clear(), $.add(...st), $) : st[0]
        }))
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = "glTF",
  BINARY_EXTENSION_HEADER_LENGTH = 12,
  BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 }
class GLTFBinaryExtension {
  constructor(e) {
    ;(this.name = EXTENSIONS.KHR_BINARY_GLTF),
      (this.content = null),
      (this.body = null)
    const a = new DataView(e, 0, BINARY_EXTENSION_HEADER_LENGTH)
    if (
      ((this.header = {
        magic: LoaderUtils.decodeText(new Uint8Array(e.slice(0, 4))),
        version: a.getUint32(4, !0),
        length: a.getUint32(8, !0),
      }),
      this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.")
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.")
    const o = this.header.length - BINARY_EXTENSION_HEADER_LENGTH,
      c = new DataView(e, BINARY_EXTENSION_HEADER_LENGTH)
    let d = 0
    for (; d < o; ) {
      const g = c.getUint32(d, !0)
      d += 4
      const _ = c.getUint32(d, !0)
      if (((d += 4), _ === BINARY_EXTENSION_CHUNK_TYPES.JSON)) {
        const b = new Uint8Array(e, BINARY_EXTENSION_HEADER_LENGTH + d, g)
        this.content = LoaderUtils.decodeText(b)
      } else if (_ === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const b = BINARY_EXTENSION_HEADER_LENGTH + d
        this.body = e.slice(b, b + g)
      }
      d += g
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.")
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(e, a) {
    if (!a)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.")
    ;(this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = a),
      this.dracoLoader.preload()
  }
  decodePrimitive(e, a) {
    const o = this.json,
      c = this.dracoLoader,
      d = e.extensions[this.name].bufferView,
      g = e.extensions[this.name].attributes,
      _ = {},
      b = {},
      j = {}
    for (const $ in g) {
      const _e = ATTRIBUTES[$] || $.toLowerCase()
      _[_e] = g[$]
    }
    for (const $ in e.attributes) {
      const _e = ATTRIBUTES[$] || $.toLowerCase()
      if (g[$] !== void 0) {
        const tt = o.accessors[e.attributes[$]],
          st = WEBGL_COMPONENT_TYPES[tt.componentType]
        ;(j[_e] = st.name), (b[_e] = tt.normalized === !0)
      }
    }
    return a.getDependency("bufferView", d).then(function ($) {
      return new Promise(function (_e) {
        c.decodeDracoFile(
          $,
          function (tt) {
            for (const st in tt.attributes) {
              const at = tt.attributes[st],
                ot = b[st]
              ot !== void 0 && (at.normalized = ot)
            }
            _e(tt)
          },
          _,
          j
        )
      })
    })
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM
  }
  extendTexture(e, a) {
    return (
      ((a.texCoord === void 0 || a.texCoord === e.channel) &&
        a.offset === void 0 &&
        a.rotation === void 0 &&
        a.scale === void 0) ||
        ((e = e.clone()),
        a.texCoord !== void 0 && (e.channel = a.texCoord),
        a.offset !== void 0 && e.offset.fromArray(a.offset),
        a.rotation !== void 0 && (e.rotation = a.rotation),
        a.scale !== void 0 && e.repeat.fromArray(a.scale),
        (e.needsUpdate = !0)),
      e
    )
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(e, a, o, c) {
    super(e, a, o, c)
  }
  copySampleValue_(e) {
    const a = this.resultBuffer,
      o = this.sampleValues,
      c = this.valueSize,
      d = e * c * 3 + c
    for (let g = 0; g !== c; g++) a[g] = o[d + g]
    return a
  }
  interpolate_(e, a, o, c) {
    const d = this.resultBuffer,
      g = this.sampleValues,
      _ = this.valueSize,
      b = _ * 2,
      j = _ * 3,
      $ = c - a,
      _e = (o - a) / $,
      tt = _e * _e,
      st = tt * _e,
      at = e * j,
      ot = at - j,
      ut = -2 * st + 3 * tt,
      it = st - tt,
      ct = 1 - ut,
      lt = it - tt + _e
    for (let ht = 0; ht !== _; ht++) {
      const dt = g[ot + ht + _],
        pt = g[ot + ht + b] * $,
        vt = g[at + ht + _],
        _t = g[at + ht] * $
      d[ht] = ct * dt + lt * pt + ut * vt + it * _t
    }
    return d
  }
}
const _q = new Quaternion()
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(e, a, o, c) {
    const d = super.interpolate_(e, a, o, c)
    return _q.fromArray(d).normalize().toArray(d), d
  }
}
const WEBGL_CONSTANTS = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter,
  },
  WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping,
  },
  WEBGL_TYPE_SIZES = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16,
  },
  ATTRIBUTES = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    ...(version$1 >= 152
      ? {
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
        }
      : { TEXCOORD_0: "uv", TEXCOORD_1: "uv2" }),
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  PATH_PROPERTIES = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  INTERPOLATION = {
    CUBICSPLINE: void 0,
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete,
  },
  ALPHA_MODES = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" }
function createDefaultMaterial(s) {
  return (
    s.DefaultMaterial === void 0 &&
      (s.DefaultMaterial = new MeshStandardMaterial({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: FrontSide,
      })),
    s.DefaultMaterial
  )
}
function addUnknownExtensionsToUserData(s, e, a) {
  for (const o in a.extensions)
    s[o] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[o] = a.extensions[o]))
}
function assignExtrasToUserData(s, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(s.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ))
}
function addMorphTargets(s, e, a) {
  let o = !1,
    c = !1,
    d = !1
  for (let j = 0, $ = e.length; j < $; j++) {
    const _e = e[j]
    if (
      (_e.POSITION !== void 0 && (o = !0),
      _e.NORMAL !== void 0 && (c = !0),
      _e.COLOR_0 !== void 0 && (d = !0),
      o && c && d)
    )
      break
  }
  if (!o && !c && !d) return Promise.resolve(s)
  const g = [],
    _ = [],
    b = []
  for (let j = 0, $ = e.length; j < $; j++) {
    const _e = e[j]
    if (o) {
      const tt =
        _e.POSITION !== void 0
          ? a.getDependency("accessor", _e.POSITION)
          : s.attributes.position
      g.push(tt)
    }
    if (c) {
      const tt =
        _e.NORMAL !== void 0
          ? a.getDependency("accessor", _e.NORMAL)
          : s.attributes.normal
      _.push(tt)
    }
    if (d) {
      const tt =
        _e.COLOR_0 !== void 0
          ? a.getDependency("accessor", _e.COLOR_0)
          : s.attributes.color
      b.push(tt)
    }
  }
  return Promise.all([Promise.all(g), Promise.all(_), Promise.all(b)]).then(
    function (j) {
      const $ = j[0],
        _e = j[1],
        tt = j[2]
      return (
        o && (s.morphAttributes.position = $),
        c && (s.morphAttributes.normal = _e),
        d && (s.morphAttributes.color = tt),
        (s.morphTargetsRelative = !0),
        s
      )
    }
  )
}
function updateMorphTargets(s, e) {
  if ((s.updateMorphTargets(), e.weights !== void 0))
    for (let a = 0, o = e.weights.length; a < o; a++)
      s.morphTargetInfluences[a] = e.weights[a]
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const a = e.extras.targetNames
    if (s.morphTargetInfluences.length === a.length) {
      s.morphTargetDictionary = {}
      for (let o = 0, c = a.length; o < c; o++)
        s.morphTargetDictionary[a[o]] = o
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      )
  }
}
function createPrimitiveKey(s) {
  let e
  const a = s.extensions && s.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
  if (
    (a
      ? (e =
          "draco:" +
          a.bufferView +
          ":" +
          a.indices +
          ":" +
          createAttributesKey(a.attributes))
      : (e =
          s.indices + ":" + createAttributesKey(s.attributes) + ":" + s.mode),
    s.targets !== void 0)
  )
    for (let o = 0, c = s.targets.length; o < c; o++)
      e += ":" + createAttributesKey(s.targets[o])
  return e
}
function createAttributesKey(s) {
  let e = ""
  const a = Object.keys(s).sort()
  for (let o = 0, c = a.length; o < c; o++) e += a[o] + ":" + s[a[o]] + ";"
  return e
}
function getNormalizedComponentScale(s) {
  switch (s) {
    case Int8Array:
      return 1 / 127
    case Uint8Array:
      return 1 / 255
    case Int16Array:
      return 1 / 32767
    case Uint16Array:
      return 1 / 65535
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      )
  }
}
function getImageURIMimeType(s) {
  return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png"
}
const _identityMatrix = new Matrix4()
class GLTFParser {
  constructor(e = {}, a = {}) {
    ;(this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = a),
      (this.cache = new GLTFRegistry()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {})
    let o = !1,
      c = !1,
      d = -1
    typeof navigator < "u" &&
      typeof navigator.userAgent < "u" &&
      ((o = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (c = navigator.userAgent.indexOf("Firefox") > -1),
      (d = c ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || o || (c && d < 98)
        ? (this.textureLoader = new TextureLoader(this.options.manager))
        : (this.textureLoader = new ImageBitmapLoader(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new FileLoader(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0)
  }
  setExtensions(e) {
    this.extensions = e
  }
  setPlugins(e) {
    this.plugins = e
  }
  parse(e, a) {
    const o = this,
      c = this.json,
      d = this.extensions
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (g) {
        return g._markDefs && g._markDefs()
      }),
      Promise.all(
        this._invokeAll(function (g) {
          return g.beforeRoot && g.beforeRoot()
        })
      )
        .then(function () {
          return Promise.all([
            o.getDependencies("scene"),
            o.getDependencies("animation"),
            o.getDependencies("camera"),
          ])
        })
        .then(function (g) {
          const _ = {
            scene: g[0][c.scene || 0],
            scenes: g[0],
            animations: g[1],
            cameras: g[2],
            asset: c.asset,
            parser: o,
            userData: {},
          }
          addUnknownExtensionsToUserData(d, _, c),
            assignExtrasToUserData(_, c),
            Promise.all(
              o._invokeAll(function (b) {
                return b.afterRoot && b.afterRoot(_)
              })
            ).then(function () {
              e(_)
            })
        })
        .catch(a)
  }
  _markDefs() {
    const e = this.json.nodes || [],
      a = this.json.skins || [],
      o = this.json.meshes || []
    for (let c = 0, d = a.length; c < d; c++) {
      const g = a[c].joints
      for (let _ = 0, b = g.length; _ < b; _++) e[g[_]].isBone = !0
    }
    for (let c = 0, d = e.length; c < d; c++) {
      const g = e[c]
      g.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, g.mesh),
        g.skin !== void 0 && (o[g.mesh].isSkinnedMesh = !0)),
        g.camera !== void 0 && this._addNodeRef(this.cameraCache, g.camera)
    }
  }
  _addNodeRef(e, a) {
    a !== void 0 &&
      (e.refs[a] === void 0 && (e.refs[a] = e.uses[a] = 0), e.refs[a]++)
  }
  _getNodeRef(e, a, o) {
    if (e.refs[a] <= 1) return o
    const c = o.clone(),
      d = (g, _) => {
        const b = this.associations.get(g)
        b != null && this.associations.set(_, b)
        for (const [j, $] of g.children.entries()) d($, _.children[j])
      }
    return d(o, c), (c.name += "_instance_" + e.uses[a]++), c
  }
  _invokeOne(e) {
    const a = Object.values(this.plugins)
    a.push(this)
    for (let o = 0; o < a.length; o++) {
      const c = e(a[o])
      if (c) return c
    }
    return null
  }
  _invokeAll(e) {
    const a = Object.values(this.plugins)
    a.unshift(this)
    const o = []
    for (let c = 0; c < a.length; c++) {
      const d = e(a[c])
      d && o.push(d)
    }
    return o
  }
  getDependency(e, a) {
    const o = e + ":" + a
    let c = this.cache.get(o)
    if (!c) {
      switch (e) {
        case "scene":
          c = this.loadScene(a)
          break
        case "node":
          c = this._invokeOne(function (d) {
            return d.loadNode && d.loadNode(a)
          })
          break
        case "mesh":
          c = this._invokeOne(function (d) {
            return d.loadMesh && d.loadMesh(a)
          })
          break
        case "accessor":
          c = this.loadAccessor(a)
          break
        case "bufferView":
          c = this._invokeOne(function (d) {
            return d.loadBufferView && d.loadBufferView(a)
          })
          break
        case "buffer":
          c = this.loadBuffer(a)
          break
        case "material":
          c = this._invokeOne(function (d) {
            return d.loadMaterial && d.loadMaterial(a)
          })
          break
        case "texture":
          c = this._invokeOne(function (d) {
            return d.loadTexture && d.loadTexture(a)
          })
          break
        case "skin":
          c = this.loadSkin(a)
          break
        case "animation":
          c = this._invokeOne(function (d) {
            return d.loadAnimation && d.loadAnimation(a)
          })
          break
        case "camera":
          c = this.loadCamera(a)
          break
        default:
          if (
            ((c = this._invokeOne(function (d) {
              return d != this && d.getDependency && d.getDependency(e, a)
            })),
            !c)
          )
            throw new Error("Unknown type: " + e)
          break
      }
      this.cache.add(o, c)
    }
    return c
  }
  getDependencies(e) {
    let a = this.cache.get(e)
    if (!a) {
      const o = this,
        c = this.json[e + (e === "mesh" ? "es" : "s")] || []
      ;(a = Promise.all(
        c.map(function (d, g) {
          return o.getDependency(e, g)
        })
      )),
        this.cache.add(e, a)
    }
    return a
  }
  loadBuffer(e) {
    const a = this.json.buffers[e],
      o = this.fileLoader
    if (a.type && a.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + a.type + " buffer type is not supported."
      )
    if (a.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)
    const c = this.options
    return new Promise(function (d, g) {
      o.load(LoaderUtils.resolveURL(a.uri, c.path), d, void 0, function () {
        g(new Error('THREE.GLTFLoader: Failed to load buffer "' + a.uri + '".'))
      })
    })
  }
  loadBufferView(e) {
    const a = this.json.bufferViews[e]
    return this.getDependency("buffer", a.buffer).then(function (o) {
      const c = a.byteLength || 0,
        d = a.byteOffset || 0
      return o.slice(d, d + c)
    })
  }
  loadAccessor(e) {
    const a = this,
      o = this.json,
      c = this.json.accessors[e]
    if (c.bufferView === void 0 && c.sparse === void 0) {
      const g = WEBGL_TYPE_SIZES[c.type],
        _ = WEBGL_COMPONENT_TYPES[c.componentType],
        b = c.normalized === !0,
        j = new _(c.count * g)
      return Promise.resolve(new BufferAttribute(j, g, b))
    }
    const d = []
    return (
      c.bufferView !== void 0
        ? d.push(this.getDependency("bufferView", c.bufferView))
        : d.push(null),
      c.sparse !== void 0 &&
        (d.push(this.getDependency("bufferView", c.sparse.indices.bufferView)),
        d.push(this.getDependency("bufferView", c.sparse.values.bufferView))),
      Promise.all(d).then(function (g) {
        const _ = g[0],
          b = WEBGL_TYPE_SIZES[c.type],
          j = WEBGL_COMPONENT_TYPES[c.componentType],
          $ = j.BYTES_PER_ELEMENT,
          _e = $ * b,
          tt = c.byteOffset || 0,
          st =
            c.bufferView !== void 0
              ? o.bufferViews[c.bufferView].byteStride
              : void 0,
          at = c.normalized === !0
        let ot, ut
        if (st && st !== _e) {
          const it = Math.floor(tt / st),
            ct =
              "InterleavedBuffer:" +
              c.bufferView +
              ":" +
              c.componentType +
              ":" +
              it +
              ":" +
              c.count
          let lt = a.cache.get(ct)
          lt ||
            ((ot = new j(_, it * st, (c.count * st) / $)),
            (lt = new InterleavedBuffer(ot, st / $)),
            a.cache.add(ct, lt)),
            (ut = new InterleavedBufferAttribute(lt, b, (tt % st) / $, at))
        } else _ === null ? (ot = new j(c.count * b)) : (ot = new j(_, tt, c.count * b)), (ut = new BufferAttribute(ot, b, at))
        if (c.sparse !== void 0) {
          const it = WEBGL_TYPE_SIZES.SCALAR,
            ct = WEBGL_COMPONENT_TYPES[c.sparse.indices.componentType],
            lt = c.sparse.indices.byteOffset || 0,
            ht = c.sparse.values.byteOffset || 0,
            dt = new ct(g[1], lt, c.sparse.count * it),
            pt = new j(g[2], ht, c.sparse.count * b)
          _ !== null &&
            (ut = new BufferAttribute(
              ut.array.slice(),
              ut.itemSize,
              ut.normalized
            ))
          for (let vt = 0, _t = dt.length; vt < _t; vt++) {
            const yt = dt[vt]
            if (
              (ut.setX(yt, pt[vt * b]),
              b >= 2 && ut.setY(yt, pt[vt * b + 1]),
              b >= 3 && ut.setZ(yt, pt[vt * b + 2]),
              b >= 4 && ut.setW(yt, pt[vt * b + 3]),
              b >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              )
          }
        }
        return ut
      })
    )
  }
  loadTexture(e) {
    const a = this.json,
      o = this.options,
      d = a.textures[e].source,
      g = a.images[d]
    let _ = this.textureLoader
    if (g.uri) {
      const b = o.manager.getHandler(g.uri)
      b !== null && (_ = b)
    }
    return this.loadTextureImage(e, d, _)
  }
  loadTextureImage(e, a, o) {
    const c = this,
      d = this.json,
      g = d.textures[e],
      _ = d.images[a],
      b = (_.uri || _.bufferView) + ":" + g.sampler
    if (this.textureCache[b]) return this.textureCache[b]
    const j = this.loadImageSource(a, o)
      .then(function ($) {
        ;($.flipY = !1),
          ($.name = g.name || _.name || ""),
          $.name === "" &&
            typeof _.uri == "string" &&
            _.uri.startsWith("data:image/") === !1 &&
            ($.name = _.uri)
        const tt = (d.samplers || {})[g.sampler] || {}
        return (
          ($.magFilter = WEBGL_FILTERS[tt.magFilter] || LinearFilter),
          ($.minFilter =
            WEBGL_FILTERS[tt.minFilter] || LinearMipmapLinearFilter),
          ($.wrapS = WEBGL_WRAPPINGS[tt.wrapS] || RepeatWrapping),
          ($.wrapT = WEBGL_WRAPPINGS[tt.wrapT] || RepeatWrapping),
          c.associations.set($, { textures: e }),
          $
        )
      })
      .catch(function () {
        return null
      })
    return (this.textureCache[b] = j), j
  }
  loadImageSource(e, a) {
    const o = this,
      c = this.json,
      d = this.options
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((_e) => _e.clone())
    const g = c.images[e],
      _ = self.URL || self.webkitURL
    let b = g.uri || "",
      j = !1
    if (g.bufferView !== void 0)
      b = o.getDependency("bufferView", g.bufferView).then(function (_e) {
        j = !0
        const tt = new Blob([_e], { type: g.mimeType })
        return (b = _.createObjectURL(tt)), b
      })
    else if (g.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      )
    const $ = Promise.resolve(b)
      .then(function (_e) {
        return new Promise(function (tt, st) {
          let at = tt
          a.isImageBitmapLoader === !0 &&
            (at = function (ot) {
              const ut = new Texture(ot)
              ;(ut.needsUpdate = !0), tt(ut)
            }),
            a.load(LoaderUtils.resolveURL(_e, d.path), at, void 0, st)
        })
      })
      .then(function (_e) {
        return (
          j === !0 && _.revokeObjectURL(b),
          (_e.userData.mimeType = g.mimeType || getImageURIMimeType(g.uri)),
          _e
        )
      })
      .catch(function (_e) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", b), _e)
      })
    return (this.sourceCache[e] = $), $
  }
  assignTexture(e, a, o, c) {
    const d = this
    return this.getDependency("texture", o.index).then(function (g) {
      if (!g) return null
      if (
        (o.texCoord !== void 0 &&
          o.texCoord > 0 &&
          ((g = g.clone()), (g.channel = o.texCoord)),
        d.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM])
      ) {
        const _ =
          o.extensions !== void 0
            ? o.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]
            : void 0
        if (_) {
          const b = d.associations.get(g)
          ;(g = d.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(
            g,
            _
          )),
            d.associations.set(g, b)
        }
      }
      return (
        c !== void 0 &&
          ("colorSpace" in g
            ? (g.colorSpace = c === 3001 ? "srgb" : "srgb-linear")
            : (g.encoding = c)),
        (e[a] = g),
        g
      )
    })
  }
  assignFinalMaterial(e) {
    const a = e.geometry
    let o = e.material
    const c = a.attributes.tangent === void 0,
      d = a.attributes.color !== void 0,
      g = a.attributes.normal === void 0
    if (e.isPoints) {
      const _ = "PointsMaterial:" + o.uuid
      let b = this.cache.get(_)
      b ||
        ((b = new PointsMaterial()),
        Material.prototype.copy.call(b, o),
        b.color.copy(o.color),
        (b.map = o.map),
        (b.sizeAttenuation = !1),
        this.cache.add(_, b)),
        (o = b)
    } else if (e.isLine) {
      const _ = "LineBasicMaterial:" + o.uuid
      let b = this.cache.get(_)
      b ||
        ((b = new LineBasicMaterial()),
        Material.prototype.copy.call(b, o),
        b.color.copy(o.color),
        (b.map = o.map),
        this.cache.add(_, b)),
        (o = b)
    }
    if (c || d || g) {
      let _ = "ClonedMaterial:" + o.uuid + ":"
      c && (_ += "derivative-tangents:"),
        d && (_ += "vertex-colors:"),
        g && (_ += "flat-shading:")
      let b = this.cache.get(_)
      b ||
        ((b = o.clone()),
        d && (b.vertexColors = !0),
        g && (b.flatShading = !0),
        c &&
          (b.normalScale && (b.normalScale.y *= -1),
          b.clearcoatNormalScale && (b.clearcoatNormalScale.y *= -1)),
        this.cache.add(_, b),
        this.associations.set(b, this.associations.get(o))),
        (o = b)
    }
    e.material = o
  }
  getMaterialType() {
    return MeshStandardMaterial
  }
  loadMaterial(e) {
    const a = this,
      o = this.json,
      c = this.extensions,
      d = o.materials[e]
    let g
    const _ = {},
      b = d.extensions || {},
      j = []
    if (b[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const _e = c[EXTENSIONS.KHR_MATERIALS_UNLIT]
      ;(g = _e.getMaterialType()), j.push(_e.extendParams(_, d, a))
    } else {
      const _e = d.pbrMetallicRoughness || {}
      if (
        ((_.color = new Color(1, 1, 1)),
        (_.opacity = 1),
        Array.isArray(_e.baseColorFactor))
      ) {
        const tt = _e.baseColorFactor
        _.color.fromArray(tt), (_.opacity = tt[3])
      }
      _e.baseColorTexture !== void 0 &&
        j.push(a.assignTexture(_, "map", _e.baseColorTexture, 3001)),
        (_.metalness = _e.metallicFactor !== void 0 ? _e.metallicFactor : 1),
        (_.roughness = _e.roughnessFactor !== void 0 ? _e.roughnessFactor : 1),
        _e.metallicRoughnessTexture !== void 0 &&
          (j.push(
            a.assignTexture(_, "metalnessMap", _e.metallicRoughnessTexture)
          ),
          j.push(
            a.assignTexture(_, "roughnessMap", _e.metallicRoughnessTexture)
          )),
        (g = this._invokeOne(function (tt) {
          return tt.getMaterialType && tt.getMaterialType(e)
        })),
        j.push(
          Promise.all(
            this._invokeAll(function (tt) {
              return tt.extendMaterialParams && tt.extendMaterialParams(e, _)
            })
          )
        )
    }
    d.doubleSided === !0 && (_.side = DoubleSide)
    const $ = d.alphaMode || ALPHA_MODES.OPAQUE
    if (
      ($ === ALPHA_MODES.BLEND
        ? ((_.transparent = !0), (_.depthWrite = !1))
        : ((_.transparent = !1),
          $ === ALPHA_MODES.MASK &&
            (_.alphaTest = d.alphaCutoff !== void 0 ? d.alphaCutoff : 0.5)),
      d.normalTexture !== void 0 &&
        g !== MeshBasicMaterial &&
        (j.push(a.assignTexture(_, "normalMap", d.normalTexture)),
        (_.normalScale = new Vector2(1, 1)),
        d.normalTexture.scale !== void 0))
    ) {
      const _e = d.normalTexture.scale
      _.normalScale.set(_e, _e)
    }
    return (
      d.occlusionTexture !== void 0 &&
        g !== MeshBasicMaterial &&
        (j.push(a.assignTexture(_, "aoMap", d.occlusionTexture)),
        d.occlusionTexture.strength !== void 0 &&
          (_.aoMapIntensity = d.occlusionTexture.strength)),
      d.emissiveFactor !== void 0 &&
        g !== MeshBasicMaterial &&
        (_.emissive = new Color().fromArray(d.emissiveFactor)),
      d.emissiveTexture !== void 0 &&
        g !== MeshBasicMaterial &&
        j.push(a.assignTexture(_, "emissiveMap", d.emissiveTexture, 3001)),
      Promise.all(j).then(function () {
        const _e = new g(_)
        return (
          d.name && (_e.name = d.name),
          assignExtrasToUserData(_e, d),
          a.associations.set(_e, { materials: e }),
          d.extensions && addUnknownExtensionsToUserData(c, _e, d),
          _e
        )
      })
    )
  }
  createUniqueName(e) {
    const a = PropertyBinding.sanitizeNodeName(e || "")
    return a in this.nodeNamesUsed
      ? a + "_" + ++this.nodeNamesUsed[a]
      : ((this.nodeNamesUsed[a] = 0), a)
  }
  loadGeometries(e) {
    const a = this,
      o = this.extensions,
      c = this.primitiveCache
    function d(_) {
      return o[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(_, a)
        .then(function (b) {
          return addPrimitiveAttributes(b, _, a)
        })
    }
    const g = []
    for (let _ = 0, b = e.length; _ < b; _++) {
      const j = e[_],
        $ = createPrimitiveKey(j),
        _e = c[$]
      if (_e) g.push(_e.promise)
      else {
        let tt
        j.extensions && j.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
          ? (tt = d(j))
          : (tt = addPrimitiveAttributes(new BufferGeometry(), j, a)),
          (c[$] = { primitive: j, promise: tt }),
          g.push(tt)
      }
    }
    return Promise.all(g)
  }
  loadMesh(e) {
    const a = this,
      o = this.json,
      c = this.extensions,
      d = o.meshes[e],
      g = d.primitives,
      _ = []
    for (let b = 0, j = g.length; b < j; b++) {
      const $ =
        g[b].material === void 0
          ? createDefaultMaterial(this.cache)
          : this.getDependency("material", g[b].material)
      _.push($)
    }
    return (
      _.push(a.loadGeometries(g)),
      Promise.all(_).then(function (b) {
        const j = b.slice(0, b.length - 1),
          $ = b[b.length - 1],
          _e = []
        for (let st = 0, at = $.length; st < at; st++) {
          const ot = $[st],
            ut = g[st]
          let it
          const ct = j[st]
          if (
            ut.mode === WEBGL_CONSTANTS.TRIANGLES ||
            ut.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
            ut.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
            ut.mode === void 0
          )
            (it =
              d.isSkinnedMesh === !0
                ? new SkinnedMesh(ot, ct)
                : new Mesh(ot, ct)),
              it.isSkinnedMesh === !0 && it.normalizeSkinWeights(),
              ut.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP
                ? (it.geometry = toTrianglesDrawMode(
                    it.geometry,
                    TriangleStripDrawMode
                  ))
                : ut.mode === WEBGL_CONSTANTS.TRIANGLE_FAN &&
                  (it.geometry = toTrianglesDrawMode(
                    it.geometry,
                    TriangleFanDrawMode
                  ))
          else if (ut.mode === WEBGL_CONSTANTS.LINES)
            it = new LineSegments(ot, ct)
          else if (ut.mode === WEBGL_CONSTANTS.LINE_STRIP) it = new Line(ot, ct)
          else if (ut.mode === WEBGL_CONSTANTS.LINE_LOOP)
            it = new LineLoop(ot, ct)
          else if (ut.mode === WEBGL_CONSTANTS.POINTS) it = new Points$1(ot, ct)
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + ut.mode
            )
          Object.keys(it.geometry.morphAttributes).length > 0 &&
            updateMorphTargets(it, d),
            (it.name = a.createUniqueName(d.name || "mesh_" + e)),
            assignExtrasToUserData(it, d),
            ut.extensions && addUnknownExtensionsToUserData(c, it, ut),
            a.assignFinalMaterial(it),
            _e.push(it)
        }
        for (let st = 0, at = _e.length; st < at; st++)
          a.associations.set(_e[st], { meshes: e, primitives: st })
        if (_e.length === 1)
          return (
            d.extensions && addUnknownExtensionsToUserData(c, _e[0], d), _e[0]
          )
        const tt = new Group()
        d.extensions && addUnknownExtensionsToUserData(c, tt, d),
          a.associations.set(tt, { meshes: e })
        for (let st = 0, at = _e.length; st < at; st++) tt.add(_e[st])
        return tt
      })
    )
  }
  loadCamera(e) {
    let a
    const o = this.json.cameras[e],
      c = o[o.type]
    if (!c) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.")
      return
    }
    return (
      o.type === "perspective"
        ? (a = new PerspectiveCamera(
            MathUtils.radToDeg(c.yfov),
            c.aspectRatio || 1,
            c.znear || 1,
            c.zfar || 2e6
          ))
        : o.type === "orthographic" &&
          (a = new OrthographicCamera(
            -c.xmag,
            c.xmag,
            c.ymag,
            -c.ymag,
            c.znear,
            c.zfar
          )),
      o.name && (a.name = this.createUniqueName(o.name)),
      assignExtrasToUserData(a, o),
      Promise.resolve(a)
    )
  }
  loadSkin(e) {
    const a = this.json.skins[e],
      o = []
    for (let c = 0, d = a.joints.length; c < d; c++)
      o.push(this._loadNodeShallow(a.joints[c]))
    return (
      a.inverseBindMatrices !== void 0
        ? o.push(this.getDependency("accessor", a.inverseBindMatrices))
        : o.push(null),
      Promise.all(o).then(function (c) {
        const d = c.pop(),
          g = c,
          _ = [],
          b = []
        for (let j = 0, $ = g.length; j < $; j++) {
          const _e = g[j]
          if (_e) {
            _.push(_e)
            const tt = new Matrix4()
            d !== null && tt.fromArray(d.array, j * 16), b.push(tt)
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              a.joints[j]
            )
        }
        return new Skeleton(_, b)
      })
    )
  }
  loadAnimation(e) {
    const o = this.json.animations[e],
      c = o.name ? o.name : "animation_" + e,
      d = [],
      g = [],
      _ = [],
      b = [],
      j = []
    for (let $ = 0, _e = o.channels.length; $ < _e; $++) {
      const tt = o.channels[$],
        st = o.samplers[tt.sampler],
        at = tt.target,
        ot = at.node,
        ut = o.parameters !== void 0 ? o.parameters[st.input] : st.input,
        it = o.parameters !== void 0 ? o.parameters[st.output] : st.output
      at.node !== void 0 &&
        (d.push(this.getDependency("node", ot)),
        g.push(this.getDependency("accessor", ut)),
        _.push(this.getDependency("accessor", it)),
        b.push(st),
        j.push(at))
    }
    return Promise.all([
      Promise.all(d),
      Promise.all(g),
      Promise.all(_),
      Promise.all(b),
      Promise.all(j),
    ]).then(function ($) {
      const _e = $[0],
        tt = $[1],
        st = $[2],
        at = $[3],
        ot = $[4],
        ut = []
      for (let it = 0, ct = _e.length; it < ct; it++) {
        const lt = _e[it],
          ht = tt[it],
          dt = st[it],
          pt = at[it],
          vt = ot[it]
        if (lt === void 0) continue
        lt.updateMatrix()
        let _t
        switch (PATH_PROPERTIES[vt.path]) {
          case PATH_PROPERTIES.weights:
            _t = NumberKeyframeTrack
            break
          case PATH_PROPERTIES.rotation:
            _t = QuaternionKeyframeTrack
            break
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            _t = VectorKeyframeTrack
            break
        }
        const yt = lt.name ? lt.name : lt.uuid,
          Et =
            pt.interpolation !== void 0
              ? INTERPOLATION[pt.interpolation]
              : InterpolateLinear,
          Rt = []
        PATH_PROPERTIES[vt.path] === PATH_PROPERTIES.weights
          ? lt.traverse(function (kt) {
              kt.morphTargetInfluences && Rt.push(kt.name ? kt.name : kt.uuid)
            })
          : Rt.push(yt)
        let Ft = dt.array
        if (dt.normalized) {
          const kt = getNormalizedComponentScale(Ft.constructor),
            Nt = new Float32Array(Ft.length)
          for (let Dt = 0, Mt = Ft.length; Dt < Mt; Dt++) Nt[Dt] = Ft[Dt] * kt
          Ft = Nt
        }
        for (let kt = 0, Nt = Rt.length; kt < Nt; kt++) {
          const Dt = new _t(
            Rt[kt] + "." + PATH_PROPERTIES[vt.path],
            ht.array,
            Ft,
            Et
          )
          pt.interpolation === "CUBICSPLINE" &&
            ((Dt.createInterpolant = function (wt) {
              const gt =
                this instanceof QuaternionKeyframeTrack
                  ? GLTFCubicSplineQuaternionInterpolant
                  : GLTFCubicSplineInterpolant
              return new gt(
                this.times,
                this.values,
                this.getValueSize() / 3,
                wt
              )
            }),
            (Dt.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            ut.push(Dt)
        }
      }
      return new AnimationClip(c, void 0, ut)
    })
  }
  createNodeMesh(e) {
    const a = this.json,
      o = this,
      c = a.nodes[e]
    return c.mesh === void 0
      ? null
      : o.getDependency("mesh", c.mesh).then(function (d) {
          const g = o._getNodeRef(o.meshCache, c.mesh, d)
          return (
            c.weights !== void 0 &&
              g.traverse(function (_) {
                if (_.isMesh)
                  for (let b = 0, j = c.weights.length; b < j; b++)
                    _.morphTargetInfluences[b] = c.weights[b]
              }),
            g
          )
        })
  }
  loadNode(e) {
    const a = this.json,
      o = this,
      c = a.nodes[e],
      d = o._loadNodeShallow(e),
      g = [],
      _ = c.children || []
    for (let j = 0, $ = _.length; j < $; j++)
      g.push(o.getDependency("node", _[j]))
    const b =
      c.skin === void 0
        ? Promise.resolve(null)
        : o.getDependency("skin", c.skin)
    return Promise.all([d, Promise.all(g), b]).then(function (j) {
      const $ = j[0],
        _e = j[1],
        tt = j[2]
      tt !== null &&
        $.traverse(function (st) {
          st.isSkinnedMesh && st.bind(tt, _identityMatrix)
        })
      for (let st = 0, at = _e.length; st < at; st++) $.add(_e[st])
      return $
    })
  }
  _loadNodeShallow(e) {
    const a = this.json,
      o = this.extensions,
      c = this
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e]
    const d = a.nodes[e],
      g = d.name ? c.createUniqueName(d.name) : "",
      _ = [],
      b = c._invokeOne(function (j) {
        return j.createNodeMesh && j.createNodeMesh(e)
      })
    return (
      b && _.push(b),
      d.camera !== void 0 &&
        _.push(
          c.getDependency("camera", d.camera).then(function (j) {
            return c._getNodeRef(c.cameraCache, d.camera, j)
          })
        ),
      c
        ._invokeAll(function (j) {
          return j.createNodeAttachment && j.createNodeAttachment(e)
        })
        .forEach(function (j) {
          _.push(j)
        }),
      (this.nodeCache[e] = Promise.all(_).then(function (j) {
        let $
        if (
          (d.isBone === !0
            ? ($ = new Bone())
            : j.length > 1
            ? ($ = new Group())
            : j.length === 1
            ? ($ = j[0])
            : ($ = new Object3D()),
          $ !== j[0])
        )
          for (let _e = 0, tt = j.length; _e < tt; _e++) $.add(j[_e])
        if (
          (d.name && (($.userData.name = d.name), ($.name = g)),
          assignExtrasToUserData($, d),
          d.extensions && addUnknownExtensionsToUserData(o, $, d),
          d.matrix !== void 0)
        ) {
          const _e = new Matrix4()
          _e.fromArray(d.matrix), $.applyMatrix4(_e)
        } else d.translation !== void 0 && $.position.fromArray(d.translation), d.rotation !== void 0 && $.quaternion.fromArray(d.rotation), d.scale !== void 0 && $.scale.fromArray(d.scale)
        return (
          c.associations.has($) || c.associations.set($, {}),
          (c.associations.get($).nodes = e),
          $
        )
      })),
      this.nodeCache[e]
    )
  }
  loadScene(e) {
    const a = this.extensions,
      o = this.json.scenes[e],
      c = this,
      d = new Group()
    o.name && (d.name = c.createUniqueName(o.name)),
      assignExtrasToUserData(d, o),
      o.extensions && addUnknownExtensionsToUserData(a, d, o)
    const g = o.nodes || [],
      _ = []
    for (let b = 0, j = g.length; b < j; b++)
      _.push(c.getDependency("node", g[b]))
    return Promise.all(_).then(function (b) {
      for (let $ = 0, _e = b.length; $ < _e; $++) d.add(b[$])
      const j = ($) => {
        const _e = new Map()
        for (const [tt, st] of c.associations)
          (tt instanceof Material || tt instanceof Texture) && _e.set(tt, st)
        return (
          $.traverse((tt) => {
            const st = c.associations.get(tt)
            st != null && _e.set(tt, st)
          }),
          _e
        )
      }
      return (c.associations = j(d)), d
    })
  }
}
function computeBounds(s, e, a) {
  const o = e.attributes,
    c = new Box3()
  if (o.POSITION !== void 0) {
    const _ = a.json.accessors[o.POSITION],
      b = _.min,
      j = _.max
    if (b !== void 0 && j !== void 0) {
      if (
        (c.set(new Vector3(b[0], b[1], b[2]), new Vector3(j[0], j[1], j[2])),
        _.normalized)
      ) {
        const $ = getNormalizedComponentScale(
          WEBGL_COMPONENT_TYPES[_.componentType]
        )
        c.min.multiplyScalar($), c.max.multiplyScalar($)
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      )
      return
    }
  } else return
  const d = e.targets
  if (d !== void 0) {
    const _ = new Vector3(),
      b = new Vector3()
    for (let j = 0, $ = d.length; j < $; j++) {
      const _e = d[j]
      if (_e.POSITION !== void 0) {
        const tt = a.json.accessors[_e.POSITION],
          st = tt.min,
          at = tt.max
        if (st !== void 0 && at !== void 0) {
          if (
            (b.setX(Math.max(Math.abs(st[0]), Math.abs(at[0]))),
            b.setY(Math.max(Math.abs(st[1]), Math.abs(at[1]))),
            b.setZ(Math.max(Math.abs(st[2]), Math.abs(at[2]))),
            tt.normalized)
          ) {
            const ot = getNormalizedComponentScale(
              WEBGL_COMPONENT_TYPES[tt.componentType]
            )
            b.multiplyScalar(ot)
          }
          _.max(b)
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          )
      }
    }
    c.expandByVector(_)
  }
  s.boundingBox = c
  const g = new Sphere()
  c.getCenter(g.center),
    (g.radius = c.min.distanceTo(c.max) / 2),
    (s.boundingSphere = g)
}
function addPrimitiveAttributes(s, e, a) {
  const o = e.attributes,
    c = []
  function d(g, _) {
    return a.getDependency("accessor", g).then(function (b) {
      s.setAttribute(_, b)
    })
  }
  for (const g in o) {
    const _ = ATTRIBUTES[g] || g.toLowerCase()
    _ in s.attributes || c.push(d(o[g], _))
  }
  if (e.indices !== void 0 && !s.index) {
    const g = a.getDependency("accessor", e.indices).then(function (_) {
      s.setIndex(_)
    })
    c.push(g)
  }
  return (
    assignExtrasToUserData(s, e),
    computeBounds(s, e, a),
    Promise.all(c).then(function () {
      return e.targets !== void 0 ? addMorphTargets(s, e.targets, a) : s
    })
  )
}
class DecalGeometry extends BufferGeometry {
  constructor(e, a, o, c) {
    super()
    const d = [],
      g = [],
      _ = [],
      b = new Vector3(),
      j = new Matrix4()
    j.makeRotationFromEuler(o), j.setPosition(a)
    const $ = new Matrix4()
    $.copy(j).invert(),
      _e(),
      this.setAttribute("position", new Float32BufferAttribute(d, 3)),
      this.setAttribute("normal", new Float32BufferAttribute(g, 3)),
      this.setAttribute("uv", new Float32BufferAttribute(_, 2))
    function _e() {
      let ot,
        ut = []
      const it = new Vector3(),
        ct = new Vector3()
      if (e.geometry.isGeometry === !0) {
        console.error(
          "THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead."
        )
        return
      }
      const lt = e.geometry,
        ht = lt.attributes.position,
        dt = lt.attributes.normal
      if (lt.index !== null) {
        const pt = lt.index
        for (ot = 0; ot < pt.count; ot++)
          it.fromBufferAttribute(ht, pt.getX(ot)),
            ct.fromBufferAttribute(dt, pt.getX(ot)),
            tt(ut, it, ct)
      } else
        for (ot = 0; ot < ht.count; ot++)
          it.fromBufferAttribute(ht, ot),
            ct.fromBufferAttribute(dt, ot),
            tt(ut, it, ct)
      for (
        ut = st(ut, b.set(1, 0, 0)),
          ut = st(ut, b.set(-1, 0, 0)),
          ut = st(ut, b.set(0, 1, 0)),
          ut = st(ut, b.set(0, -1, 0)),
          ut = st(ut, b.set(0, 0, 1)),
          ut = st(ut, b.set(0, 0, -1)),
          ot = 0;
        ot < ut.length;
        ot++
      ) {
        const pt = ut[ot]
        _.push(0.5 + pt.position.x / c.x, 0.5 + pt.position.y / c.y),
          pt.position.applyMatrix4(j),
          d.push(pt.position.x, pt.position.y, pt.position.z),
          g.push(pt.normal.x, pt.normal.y, pt.normal.z)
      }
    }
    function tt(ot, ut, it) {
      ut.applyMatrix4(e.matrixWorld),
        ut.applyMatrix4($),
        it.transformDirection(e.matrixWorld),
        ot.push(new DecalVertex(ut.clone(), it.clone()))
    }
    function st(ot, ut) {
      const it = [],
        ct = 0.5 * Math.abs(c.dot(ut))
      for (let lt = 0; lt < ot.length; lt += 3) {
        let ht,
          dt,
          pt,
          vt = 0,
          _t,
          yt,
          Et,
          Rt
        const Ft = ot[lt + 0].position.dot(ut) - ct,
          kt = ot[lt + 1].position.dot(ut) - ct,
          Nt = ot[lt + 2].position.dot(ut) - ct
        switch (
          ((ht = Ft > 0),
          (dt = kt > 0),
          (pt = Nt > 0),
          (vt = (ht ? 1 : 0) + (dt ? 1 : 0) + (pt ? 1 : 0)),
          vt)
        ) {
          case 0: {
            it.push(ot[lt]), it.push(ot[lt + 1]), it.push(ot[lt + 2])
            break
          }
          case 1: {
            if (
              (ht &&
                ((_t = ot[lt + 1]),
                (yt = ot[lt + 2]),
                (Et = at(ot[lt], _t, ut, ct)),
                (Rt = at(ot[lt], yt, ut, ct))),
              dt)
            ) {
              ;(_t = ot[lt]),
                (yt = ot[lt + 2]),
                (Et = at(ot[lt + 1], _t, ut, ct)),
                (Rt = at(ot[lt + 1], yt, ut, ct)),
                it.push(Et),
                it.push(yt.clone()),
                it.push(_t.clone()),
                it.push(yt.clone()),
                it.push(Et.clone()),
                it.push(Rt)
              break
            }
            pt &&
              ((_t = ot[lt]),
              (yt = ot[lt + 1]),
              (Et = at(ot[lt + 2], _t, ut, ct)),
              (Rt = at(ot[lt + 2], yt, ut, ct))),
              it.push(_t.clone()),
              it.push(yt.clone()),
              it.push(Et),
              it.push(Rt),
              it.push(Et.clone()),
              it.push(yt.clone())
            break
          }
          case 2: {
            ht ||
              ((_t = ot[lt].clone()),
              (yt = at(_t, ot[lt + 1], ut, ct)),
              (Et = at(_t, ot[lt + 2], ut, ct)),
              it.push(_t),
              it.push(yt),
              it.push(Et)),
              dt ||
                ((_t = ot[lt + 1].clone()),
                (yt = at(_t, ot[lt + 2], ut, ct)),
                (Et = at(_t, ot[lt], ut, ct)),
                it.push(_t),
                it.push(yt),
                it.push(Et)),
              pt ||
                ((_t = ot[lt + 2].clone()),
                (yt = at(_t, ot[lt], ut, ct)),
                (Et = at(_t, ot[lt + 1], ut, ct)),
                it.push(_t),
                it.push(yt),
                it.push(Et))
            break
          }
        }
      }
      return it
    }
    function at(ot, ut, it, ct) {
      const lt = ot.position.dot(it) - ct,
        ht = ut.position.dot(it) - ct,
        dt = lt / (lt - ht)
      return new DecalVertex(
        new Vector3(
          ot.position.x + dt * (ut.position.x - ot.position.x),
          ot.position.y + dt * (ut.position.y - ot.position.y),
          ot.position.z + dt * (ut.position.z - ot.position.z)
        ),
        new Vector3(
          ot.normal.x + dt * (ut.normal.x - ot.normal.x),
          ot.normal.y + dt * (ut.normal.y - ot.normal.y),
          ot.normal.z + dt * (ut.normal.z - ot.normal.z)
        )
      )
    }
  }
}
class DecalVertex {
  constructor(e, a) {
    ;(this.position = e), (this.normal = a)
  }
  clone() {
    return new this.constructor(this.position.clone(), this.normal.clone())
  }
}
const HorizontalBlurShader = {
    uniforms: { tDiffuse: { value: null }, h: { value: 1 / 512 } },
    vertexShader: `
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `,
    fragmentShader: `
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `,
  },
  VerticalBlurShader = {
    uniforms: { tDiffuse: { value: null }, v: { value: 1 / 512 } },
    vertexShader: `
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `,
    fragmentShader: `

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `,
  }
class RGBELoader extends DataTextureLoader {
  constructor(e) {
    super(e), (this.type = HalfFloatType)
  }
  parse(e) {
    const _ = function (lt, ht) {
        switch (lt) {
          case 1:
            console.error("THREE.RGBELoader Read Error: " + (ht || ""))
            break
          case 2:
            console.error("THREE.RGBELoader Write Error: " + (ht || ""))
            break
          case 3:
            console.error("THREE.RGBELoader Bad File Format: " + (ht || ""))
            break
          default:
          case 4:
            console.error("THREE.RGBELoader: Error: " + (ht || ""))
        }
        return -1
      },
      _e = `
`,
      tt = function (lt, ht, dt) {
        ht = ht || 1024
        let vt = lt.pos,
          _t = -1,
          yt = 0,
          Et = "",
          Rt = String.fromCharCode.apply(
            null,
            new Uint16Array(lt.subarray(vt, vt + 128))
          )
        for (; 0 > (_t = Rt.indexOf(_e)) && yt < ht && vt < lt.byteLength; )
          (Et += Rt),
            (yt += Rt.length),
            (vt += 128),
            (Rt += String.fromCharCode.apply(
              null,
              new Uint16Array(lt.subarray(vt, vt + 128))
            ))
        return -1 < _t
          ? (dt !== !1 && (lt.pos += yt + _t + 1), Et + Rt.slice(0, _t))
          : !1
      },
      st = function (lt) {
        const ht = /^#\?(\S+)/,
          dt = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          pt = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          vt = /^\s*FORMAT=(\S+)\s*$/,
          _t = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          yt = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          }
        let Et, Rt
        if (lt.pos >= lt.byteLength || !(Et = tt(lt)))
          return _(1, "no header found")
        if (!(Rt = Et.match(ht))) return _(3, "bad initial token")
        for (
          yt.valid |= 1,
            yt.programtype = Rt[1],
            yt.string +=
              Et +
              `
`;
          (Et = tt(lt)), Et !== !1;

        ) {
          if (
            ((yt.string +=
              Et +
              `
`),
            Et.charAt(0) === "#")
          ) {
            yt.comments +=
              Et +
              `
`
            continue
          }
          if (
            ((Rt = Et.match(dt)) && (yt.gamma = parseFloat(Rt[1])),
            (Rt = Et.match(pt)) && (yt.exposure = parseFloat(Rt[1])),
            (Rt = Et.match(vt)) && ((yt.valid |= 2), (yt.format = Rt[1])),
            (Rt = Et.match(_t)) &&
              ((yt.valid |= 4),
              (yt.height = parseInt(Rt[1], 10)),
              (yt.width = parseInt(Rt[2], 10))),
            yt.valid & 2 && yt.valid & 4)
          )
            break
        }
        return yt.valid & 2
          ? yt.valid & 4
            ? yt
            : _(3, "missing image size specifier")
          : _(3, "missing format specifier")
      },
      at = function (lt, ht, dt) {
        const pt = ht
        if (pt < 8 || pt > 32767 || lt[0] !== 2 || lt[1] !== 2 || lt[2] & 128)
          return new Uint8Array(lt)
        if (pt !== ((lt[2] << 8) | lt[3])) return _(3, "wrong scanline width")
        const vt = new Uint8Array(4 * ht * dt)
        if (!vt.length) return _(4, "unable to allocate buffer space")
        let _t = 0,
          yt = 0
        const Et = 4 * pt,
          Rt = new Uint8Array(4),
          Ft = new Uint8Array(Et)
        let kt = dt
        for (; kt > 0 && yt < lt.byteLength; ) {
          if (yt + 4 > lt.byteLength) return _(1)
          if (
            ((Rt[0] = lt[yt++]),
            (Rt[1] = lt[yt++]),
            (Rt[2] = lt[yt++]),
            (Rt[3] = lt[yt++]),
            Rt[0] != 2 || Rt[1] != 2 || ((Rt[2] << 8) | Rt[3]) != pt)
          )
            return _(3, "bad rgbe scanline format")
          let Nt = 0,
            Dt
          for (; Nt < Et && yt < lt.byteLength; ) {
            Dt = lt[yt++]
            const wt = Dt > 128
            if ((wt && (Dt -= 128), Dt === 0 || Nt + Dt > Et))
              return _(3, "bad scanline data")
            if (wt) {
              const gt = lt[yt++]
              for (let At = 0; At < Dt; At++) Ft[Nt++] = gt
            } else Ft.set(lt.subarray(yt, yt + Dt), Nt), (Nt += Dt), (yt += Dt)
          }
          const Mt = pt
          for (let wt = 0; wt < Mt; wt++) {
            let gt = 0
            ;(vt[_t] = Ft[wt + gt]),
              (gt += pt),
              (vt[_t + 1] = Ft[wt + gt]),
              (gt += pt),
              (vt[_t + 2] = Ft[wt + gt]),
              (gt += pt),
              (vt[_t + 3] = Ft[wt + gt]),
              (_t += 4)
          }
          kt--
        }
        return vt
      },
      ot = function (lt, ht, dt, pt) {
        const vt = lt[ht + 3],
          _t = Math.pow(2, vt - 128) / 255
        ;(dt[pt + 0] = lt[ht + 0] * _t),
          (dt[pt + 1] = lt[ht + 1] * _t),
          (dt[pt + 2] = lt[ht + 2] * _t),
          (dt[pt + 3] = 1)
      },
      ut = function (lt, ht, dt, pt) {
        const vt = lt[ht + 3],
          _t = Math.pow(2, vt - 128) / 255
        ;(dt[pt + 0] = DataUtils.toHalfFloat(Math.min(lt[ht + 0] * _t, 65504))),
          (dt[pt + 1] = DataUtils.toHalfFloat(
            Math.min(lt[ht + 1] * _t, 65504)
          )),
          (dt[pt + 2] = DataUtils.toHalfFloat(
            Math.min(lt[ht + 2] * _t, 65504)
          )),
          (dt[pt + 3] = DataUtils.toHalfFloat(1))
      },
      it = new Uint8Array(e)
    it.pos = 0
    const ct = st(it)
    if (ct !== -1) {
      const lt = ct.width,
        ht = ct.height,
        dt = at(it.subarray(it.pos), lt, ht)
      if (dt !== -1) {
        let pt, vt, _t
        switch (this.type) {
          case FloatType:
            _t = dt.length / 4
            const yt = new Float32Array(_t * 4)
            for (let Rt = 0; Rt < _t; Rt++) ot(dt, Rt * 4, yt, Rt * 4)
            ;(pt = yt), (vt = FloatType)
            break
          case HalfFloatType:
            _t = dt.length / 4
            const Et = new Uint16Array(_t * 4)
            for (let Rt = 0; Rt < _t; Rt++) ut(dt, Rt * 4, Et, Rt * 4)
            ;(pt = Et), (vt = HalfFloatType)
            break
          default:
            console.error("THREE.RGBELoader: unsupported type: ", this.type)
            break
        }
        return {
          width: lt,
          height: ht,
          data: pt,
          header: ct.string,
          gamma: ct.gamma,
          exposure: ct.exposure,
          type: vt,
        }
      }
    }
    return null
  }
  setDataType(e) {
    return (this.type = e), this
  }
  load(e, a, o, c) {
    function d(g, _) {
      switch (g.type) {
        case FloatType:
        case HalfFloatType:
          "colorSpace" in g
            ? (g.colorSpace = "srgb-linear")
            : (g.encoding = 3e3),
            (g.minFilter = LinearFilter),
            (g.magFilter = LinearFilter),
            (g.generateMipmaps = !1),
            (g.flipY = !0)
          break
      }
      a && a(g, _)
    }
    return super.load(e, d, o, c)
  }
}
const hasColorSpace = "colorSpace" in new Texture()
class EXRLoader extends DataTextureLoader {
  constructor(e) {
    super(e), (this.type = HalfFloatType)
  }
  parse(e) {
    const yt = Math.pow(2.7182818, 2.2)
    function Et(Pt, St) {
      for (var Bt = 0, Ut = 0; Ut < 65536; ++Ut)
        (Ut == 0 || Pt[Ut >> 3] & (1 << (Ut & 7))) && (St[Bt++] = Ut)
      for (var Ot = Bt - 1; Bt < 65536; ) St[Bt++] = 0
      return Ot
    }
    function Rt(Pt) {
      for (var St = 0; St < 16384; St++)
        (Pt[St] = {}), (Pt[St].len = 0), (Pt[St].lit = 0), (Pt[St].p = null)
    }
    const Ft = { l: 0, c: 0, lc: 0 }
    function kt(Pt, St, Bt, Ut, Ot) {
      for (; Bt < Pt; ) (St = (St << 8) | Un(Ut, Ot)), (Bt += 8)
      ;(Bt -= Pt),
        (Ft.l = (St >> Bt) & ((1 << Pt) - 1)),
        (Ft.c = St),
        (Ft.lc = Bt)
    }
    const Nt = new Array(59)
    function Dt(Pt) {
      for (var St = 0; St <= 58; ++St) Nt[St] = 0
      for (var St = 0; St < 65537; ++St) Nt[Pt[St]] += 1
      for (var Bt = 0, St = 58; St > 0; --St) {
        var Ut = (Bt + Nt[St]) >> 1
        ;(Nt[St] = Bt), (Bt = Ut)
      }
      for (var St = 0; St < 65537; ++St) {
        var Ot = Pt[St]
        Ot > 0 && (Pt[St] = Ot | (Nt[Ot]++ << 6))
      }
    }
    function Mt(Pt, St, Bt, Ut, Ot, zt, tn) {
      for (var sn = Bt, dn = 0, hn = 0; Ot <= zt; Ot++) {
        if (sn.value - Bt.value > Ut) return !1
        kt(6, dn, hn, Pt, sn)
        var mn = Ft.l
        if (((dn = Ft.c), (hn = Ft.lc), (tn[Ot] = mn), mn == 63)) {
          if (sn.value - Bt.value > Ut)
            throw "Something wrong with hufUnpackEncTable"
          kt(8, dn, hn, Pt, sn)
          var cn = Ft.l + 6
          if (((dn = Ft.c), (hn = Ft.lc), Ot + cn > zt + 1))
            throw "Something wrong with hufUnpackEncTable"
          for (; cn--; ) tn[Ot++] = 0
          Ot--
        } else if (mn >= 59) {
          var cn = mn - 59 + 2
          if (Ot + cn > zt + 1) throw "Something wrong with hufUnpackEncTable"
          for (; cn--; ) tn[Ot++] = 0
          Ot--
        }
      }
      Dt(tn)
    }
    function wt(Pt) {
      return Pt & 63
    }
    function gt(Pt) {
      return Pt >> 6
    }
    function At(Pt, St, Bt, Ut) {
      for (; St <= Bt; St++) {
        var Ot = gt(Pt[St]),
          zt = wt(Pt[St])
        if (Ot >> zt) throw "Invalid table entry"
        if (zt > 14) {
          var tn = Ut[Ot >> (zt - 14)]
          if (tn.len) throw "Invalid table entry"
          if ((tn.lit++, tn.p)) {
            var sn = tn.p
            tn.p = new Array(tn.lit)
            for (var dn = 0; dn < tn.lit - 1; ++dn) tn.p[dn] = sn[dn]
          } else tn.p = new Array(1)
          tn.p[tn.lit - 1] = St
        } else if (zt)
          for (var hn = 0, dn = 1 << (14 - zt); dn > 0; dn--) {
            var tn = Ut[(Ot << (14 - zt)) + hn]
            if (tn.len || tn.p) throw "Invalid table entry"
            ;(tn.len = zt), (tn.lit = St), hn++
          }
      }
      return !0
    }
    const bt = { c: 0, lc: 0 }
    function Tt(Pt, St, Bt, Ut) {
      ;(Pt = (Pt << 8) | Un(Bt, Ut)), (St += 8), (bt.c = Pt), (bt.lc = St)
    }
    const It = { c: 0, lc: 0 }
    function $t(Pt, St, Bt, Ut, Ot, zt, tn, sn, dn, hn) {
      if (Pt == St) {
        Ut < 8 && (Tt(Bt, Ut, Ot, tn), (Bt = bt.c), (Ut = bt.lc)), (Ut -= 8)
        var mn = Bt >> Ut,
          mn = new Uint8Array([mn])[0]
        if (dn.value + mn > hn) return !1
        for (var cn = sn[dn.value - 1]; mn-- > 0; ) sn[dn.value++] = cn
      } else if (dn.value < hn) sn[dn.value++] = Pt
      else return !1
      ;(It.c = Bt), (It.lc = Ut)
    }
    function Xt(Pt) {
      return Pt & 65535
    }
    function qt(Pt) {
      var St = Xt(Pt)
      return St > 32767 ? St - 65536 : St
    }
    const en = { a: 0, b: 0 }
    function yn(Pt, St) {
      var Bt = qt(Pt),
        Ut = qt(St),
        Ot = Ut,
        zt = Bt + (Ot & 1) + (Ot >> 1),
        tn = zt,
        sn = zt - Ot
      ;(en.a = tn), (en.b = sn)
    }
    function Tn(Pt, St) {
      var Bt = Xt(Pt),
        Ut = Xt(St),
        Ot = (Bt - (Ut >> 1)) & 65535,
        zt = (Ut + Ot - 32768) & 65535
      ;(en.a = zt), (en.b = Ot)
    }
    function $n(Pt, St, Bt, Ut, Ot, zt, tn) {
      for (var sn = tn < 16384, dn = Bt > Ot ? Ot : Bt, hn = 1, mn; hn <= dn; )
        hn <<= 1
      for (hn >>= 1, mn = hn, hn >>= 1; hn >= 1; ) {
        for (
          var cn = 0,
            On = cn + zt * (Ot - mn),
            wn = zt * hn,
            Bn = zt * mn,
            Yn = Ut * hn,
            Zn = Ut * mn,
            qn,
            Dn,
            er,
            Wn;
          cn <= On;
          cn += Bn
        ) {
          for (var rr = cn, Ar = cn + Ut * (Bt - mn); rr <= Ar; rr += Zn) {
            var tr = rr + Yn,
              Sr = rr + wn,
              gr = Sr + Yn
            sn
              ? (yn(Pt[rr + St], Pt[Sr + St]),
                (qn = en.a),
                (er = en.b),
                yn(Pt[tr + St], Pt[gr + St]),
                (Dn = en.a),
                (Wn = en.b),
                yn(qn, Dn),
                (Pt[rr + St] = en.a),
                (Pt[tr + St] = en.b),
                yn(er, Wn),
                (Pt[Sr + St] = en.a),
                (Pt[gr + St] = en.b))
              : (Tn(Pt[rr + St], Pt[Sr + St]),
                (qn = en.a),
                (er = en.b),
                Tn(Pt[tr + St], Pt[gr + St]),
                (Dn = en.a),
                (Wn = en.b),
                Tn(qn, Dn),
                (Pt[rr + St] = en.a),
                (Pt[tr + St] = en.b),
                Tn(er, Wn),
                (Pt[Sr + St] = en.a),
                (Pt[gr + St] = en.b))
          }
          if (Bt & hn) {
            var Sr = rr + wn
            sn ? yn(Pt[rr + St], Pt[Sr + St]) : Tn(Pt[rr + St], Pt[Sr + St]),
              (qn = en.a),
              (Pt[Sr + St] = en.b),
              (Pt[rr + St] = qn)
          }
        }
        if (Ot & hn)
          for (var rr = cn, Ar = cn + Ut * (Bt - mn); rr <= Ar; rr += Zn) {
            var tr = rr + Yn
            sn ? yn(Pt[rr + St], Pt[tr + St]) : Tn(Pt[rr + St], Pt[tr + St]),
              (qn = en.a),
              (Pt[tr + St] = en.b),
              (Pt[rr + St] = qn)
          }
        ;(mn = hn), (hn >>= 1)
      }
      return cn
    }
    function Vn(Pt, St, Bt, Ut, Ot, zt, tn, sn, dn, hn) {
      for (
        var mn = 0, cn = 0, On = sn, wn = Math.trunc(Ot.value + (zt + 7) / 8);
        Ot.value < wn;

      )
        for (Tt(mn, cn, Bt, Ot), mn = bt.c, cn = bt.lc; cn >= 14; ) {
          var Bn = (mn >> (cn - 14)) & 16383,
            Yn = St[Bn]
          if (Yn.len)
            (cn -= Yn.len),
              $t(Yn.lit, tn, mn, cn, Bt, Ut, Ot, dn, hn, On),
              (mn = It.c),
              (cn = It.lc)
          else {
            if (!Yn.p) throw "hufDecode issues"
            var Zn
            for (Zn = 0; Zn < Yn.lit; Zn++) {
              for (var qn = wt(Pt[Yn.p[Zn]]); cn < qn && Ot.value < wn; )
                Tt(mn, cn, Bt, Ot), (mn = bt.c), (cn = bt.lc)
              if (
                cn >= qn &&
                gt(Pt[Yn.p[Zn]]) == ((mn >> (cn - qn)) & ((1 << qn) - 1))
              ) {
                ;(cn -= qn),
                  $t(Yn.p[Zn], tn, mn, cn, Bt, Ut, Ot, dn, hn, On),
                  (mn = It.c),
                  (cn = It.lc)
                break
              }
            }
            if (Zn == Yn.lit) throw "hufDecode issues"
          }
        }
      var Dn = (8 - zt) & 7
      for (mn >>= Dn, cn -= Dn; cn > 0; ) {
        var Yn = St[(mn << (14 - cn)) & 16383]
        if (Yn.len)
          (cn -= Yn.len),
            $t(Yn.lit, tn, mn, cn, Bt, Ut, Ot, dn, hn, On),
            (mn = It.c),
            (cn = It.lc)
        else throw "hufDecode issues"
      }
      return !0
    }
    function gn(Pt, St, Bt, Ut, Ot, zt) {
      var tn = { value: 0 },
        sn = Bt.value,
        dn = Fn(St, Bt),
        hn = Fn(St, Bt)
      Bt.value += 4
      var mn = Fn(St, Bt)
      if (((Bt.value += 4), dn < 0 || dn >= 65537 || hn < 0 || hn >= 65537))
        throw "Something wrong with HUF_ENCSIZE"
      var cn = new Array(65537),
        On = new Array(16384)
      Rt(On)
      var wn = Ut - (Bt.value - sn)
      if ((Mt(Pt, St, Bt, wn, dn, hn, cn), mn > 8 * (Ut - (Bt.value - sn))))
        throw "Something wrong with hufUncompress"
      At(cn, dn, hn, On), Vn(cn, On, Pt, St, Bt, mn, hn, zt, Ot, tn)
    }
    function Ht(Pt, St, Bt) {
      for (var Ut = 0; Ut < Bt; ++Ut) St[Ut] = Pt[St[Ut]]
    }
    function on(Pt) {
      for (var St = 1; St < Pt.length; St++) {
        var Bt = Pt[St - 1] + Pt[St] - 128
        Pt[St] = Bt
      }
    }
    function Yt(Pt, St) {
      for (
        var Bt = 0,
          Ut = Math.floor((Pt.length + 1) / 2),
          Ot = 0,
          zt = Pt.length - 1;
        !(Ot > zt || ((St[Ot++] = Pt[Bt++]), Ot > zt));

      )
        St[Ot++] = Pt[Ut++]
    }
    function _n(Pt) {
      for (
        var St = Pt.byteLength, Bt = new Array(), Ut = 0, Ot = new DataView(Pt);
        St > 0;

      ) {
        var zt = Ot.getInt8(Ut++)
        if (zt < 0) {
          var tn = -zt
          St -= tn + 1
          for (var sn = 0; sn < tn; sn++) Bt.push(Ot.getUint8(Ut++))
        } else {
          var tn = zt
          St -= 2
          for (var dn = Ot.getUint8(Ut++), sn = 0; sn < tn + 1; sn++)
            Bt.push(dn)
        }
      }
      return Bt
    }
    function pn(Pt, St, Bt, Ut, Ot, zt) {
      var tr = new DataView(zt.buffer),
        tn = Bt[Pt.idx[0]].width,
        sn = Bt[Pt.idx[0]].height,
        dn = 3,
        hn = Math.floor(tn / 8),
        mn = Math.ceil(tn / 8),
        cn = Math.ceil(sn / 8),
        On = tn - (mn - 1) * 8,
        wn = sn - (cn - 1) * 8,
        Bn = { value: 0 },
        Yn = new Array(dn),
        Zn = new Array(dn),
        qn = new Array(dn),
        Dn = new Array(dn),
        er = new Array(dn)
      for (let nr = 0; nr < dn; ++nr)
        (er[nr] = St[Pt.idx[nr]]),
          (Yn[nr] = nr < 1 ? 0 : Yn[nr - 1] + mn * cn),
          (Zn[nr] = new Float32Array(64)),
          (qn[nr] = new Uint16Array(64)),
          (Dn[nr] = new Uint16Array(mn * 64))
      for (let nr = 0; nr < cn; ++nr) {
        var Wn = 8
        nr == cn - 1 && (Wn = wn)
        var rr = 8
        for (let xr = 0; xr < mn; ++xr) {
          xr == mn - 1 && (rr = On)
          for (let pr = 0; pr < dn; ++pr)
            qn[pr].fill(0),
              (qn[pr][0] = Ot[Yn[pr]++]),
              Rn(Bn, Ut, qn[pr]),
              bn(qn[pr], Zn[pr]),
              Pn(Zn[pr])
          Gn(Zn)
          for (let pr = 0; pr < dn; ++pr) jn(Zn[pr], Dn[pr], xr * 64)
        }
        let wr = 0
        for (let xr = 0; xr < dn; ++xr) {
          const pr = Bt[Pt.idx[xr]].type
          for (let Cr = 8 * nr; Cr < 8 * nr + Wn; ++Cr) {
            wr = er[xr][Cr]
            for (let Ms = 0; Ms < hn; ++Ms) {
              const Xr = Ms * 64 + (Cr & 7) * 8
              tr.setUint16(wr + 0 * 2 * pr, Dn[xr][Xr + 0], !0),
                tr.setUint16(wr + 1 * 2 * pr, Dn[xr][Xr + 1], !0),
                tr.setUint16(wr + 2 * 2 * pr, Dn[xr][Xr + 2], !0),
                tr.setUint16(wr + 3 * 2 * pr, Dn[xr][Xr + 3], !0),
                tr.setUint16(wr + 4 * 2 * pr, Dn[xr][Xr + 4], !0),
                tr.setUint16(wr + 5 * 2 * pr, Dn[xr][Xr + 5], !0),
                tr.setUint16(wr + 6 * 2 * pr, Dn[xr][Xr + 6], !0),
                tr.setUint16(wr + 7 * 2 * pr, Dn[xr][Xr + 7], !0),
                (wr += 8 * 2 * pr)
            }
          }
          if (hn != mn)
            for (let Cr = 8 * nr; Cr < 8 * nr + Wn; ++Cr) {
              const Ms = er[xr][Cr] + 8 * hn * 2 * pr,
                Xr = hn * 64 + (Cr & 7) * 8
              for (let ms = 0; ms < rr; ++ms)
                tr.setUint16(Ms + ms * 2 * pr, Dn[xr][Xr + ms], !0)
            }
        }
      }
      for (
        var Ar = new Uint16Array(tn), tr = new DataView(zt.buffer), Sr = 0;
        Sr < dn;
        ++Sr
      ) {
        Bt[Pt.idx[Sr]].decoded = !0
        var gr = Bt[Pt.idx[Sr]].type
        if (Bt[Sr].type == 2)
          for (var Er = 0; Er < sn; ++Er) {
            const nr = er[Sr][Er]
            for (var Ir = 0; Ir < tn; ++Ir)
              Ar[Ir] = tr.getUint16(nr + Ir * 2 * gr, !0)
            for (var Ir = 0; Ir < tn; ++Ir)
              tr.setFloat32(nr + Ir * 2 * gr, Qt(Ar[Ir]), !0)
          }
      }
    }
    function Rn(Pt, St, Bt) {
      for (var Ut, Ot = 1; Ot < 64; )
        (Ut = St[Pt.value]),
          Ut == 65280
            ? (Ot = 64)
            : Ut >> 8 == 255
            ? (Ot += Ut & 255)
            : ((Bt[Ot] = Ut), Ot++),
          Pt.value++
    }
    function bn(Pt, St) {
      ;(St[0] = Qt(Pt[0])),
        (St[1] = Qt(Pt[1])),
        (St[2] = Qt(Pt[5])),
        (St[3] = Qt(Pt[6])),
        (St[4] = Qt(Pt[14])),
        (St[5] = Qt(Pt[15])),
        (St[6] = Qt(Pt[27])),
        (St[7] = Qt(Pt[28])),
        (St[8] = Qt(Pt[2])),
        (St[9] = Qt(Pt[4])),
        (St[10] = Qt(Pt[7])),
        (St[11] = Qt(Pt[13])),
        (St[12] = Qt(Pt[16])),
        (St[13] = Qt(Pt[26])),
        (St[14] = Qt(Pt[29])),
        (St[15] = Qt(Pt[42])),
        (St[16] = Qt(Pt[3])),
        (St[17] = Qt(Pt[8])),
        (St[18] = Qt(Pt[12])),
        (St[19] = Qt(Pt[17])),
        (St[20] = Qt(Pt[25])),
        (St[21] = Qt(Pt[30])),
        (St[22] = Qt(Pt[41])),
        (St[23] = Qt(Pt[43])),
        (St[24] = Qt(Pt[9])),
        (St[25] = Qt(Pt[11])),
        (St[26] = Qt(Pt[18])),
        (St[27] = Qt(Pt[24])),
        (St[28] = Qt(Pt[31])),
        (St[29] = Qt(Pt[40])),
        (St[30] = Qt(Pt[44])),
        (St[31] = Qt(Pt[53])),
        (St[32] = Qt(Pt[10])),
        (St[33] = Qt(Pt[19])),
        (St[34] = Qt(Pt[23])),
        (St[35] = Qt(Pt[32])),
        (St[36] = Qt(Pt[39])),
        (St[37] = Qt(Pt[45])),
        (St[38] = Qt(Pt[52])),
        (St[39] = Qt(Pt[54])),
        (St[40] = Qt(Pt[20])),
        (St[41] = Qt(Pt[22])),
        (St[42] = Qt(Pt[33])),
        (St[43] = Qt(Pt[38])),
        (St[44] = Qt(Pt[46])),
        (St[45] = Qt(Pt[51])),
        (St[46] = Qt(Pt[55])),
        (St[47] = Qt(Pt[60])),
        (St[48] = Qt(Pt[21])),
        (St[49] = Qt(Pt[34])),
        (St[50] = Qt(Pt[37])),
        (St[51] = Qt(Pt[47])),
        (St[52] = Qt(Pt[50])),
        (St[53] = Qt(Pt[56])),
        (St[54] = Qt(Pt[59])),
        (St[55] = Qt(Pt[61])),
        (St[56] = Qt(Pt[35])),
        (St[57] = Qt(Pt[36])),
        (St[58] = Qt(Pt[48])),
        (St[59] = Qt(Pt[49])),
        (St[60] = Qt(Pt[57])),
        (St[61] = Qt(Pt[58])),
        (St[62] = Qt(Pt[62])),
        (St[63] = Qt(Pt[63]))
    }
    function Pn(Pt) {
      const St = 0.5 * Math.cos(0.7853975),
        Bt = 0.5 * Math.cos(3.14159 / 16),
        Ut = 0.5 * Math.cos(3.14159 / 8),
        Ot = 0.5 * Math.cos((3 * 3.14159) / 16),
        zt = 0.5 * Math.cos((5 * 3.14159) / 16),
        tn = 0.5 * Math.cos((3 * 3.14159) / 8),
        sn = 0.5 * Math.cos((7 * 3.14159) / 16)
      for (
        var dn = new Array(4),
          hn = new Array(4),
          mn = new Array(4),
          cn = new Array(4),
          On = 0;
        On < 8;
        ++On
      ) {
        var wn = On * 8
        ;(dn[0] = Ut * Pt[wn + 2]),
          (dn[1] = tn * Pt[wn + 2]),
          (dn[2] = Ut * Pt[wn + 6]),
          (dn[3] = tn * Pt[wn + 6]),
          (hn[0] =
            Bt * Pt[wn + 1] +
            Ot * Pt[wn + 3] +
            zt * Pt[wn + 5] +
            sn * Pt[wn + 7]),
          (hn[1] =
            Ot * Pt[wn + 1] -
            sn * Pt[wn + 3] -
            Bt * Pt[wn + 5] -
            zt * Pt[wn + 7]),
          (hn[2] =
            zt * Pt[wn + 1] -
            Bt * Pt[wn + 3] +
            sn * Pt[wn + 5] +
            Ot * Pt[wn + 7]),
          (hn[3] =
            sn * Pt[wn + 1] -
            zt * Pt[wn + 3] +
            Ot * Pt[wn + 5] -
            Bt * Pt[wn + 7]),
          (mn[0] = St * (Pt[wn + 0] + Pt[wn + 4])),
          (mn[3] = St * (Pt[wn + 0] - Pt[wn + 4])),
          (mn[1] = dn[0] + dn[3]),
          (mn[2] = dn[1] - dn[2]),
          (cn[0] = mn[0] + mn[1]),
          (cn[1] = mn[3] + mn[2]),
          (cn[2] = mn[3] - mn[2]),
          (cn[3] = mn[0] - mn[1]),
          (Pt[wn + 0] = cn[0] + hn[0]),
          (Pt[wn + 1] = cn[1] + hn[1]),
          (Pt[wn + 2] = cn[2] + hn[2]),
          (Pt[wn + 3] = cn[3] + hn[3]),
          (Pt[wn + 4] = cn[3] - hn[3]),
          (Pt[wn + 5] = cn[2] - hn[2]),
          (Pt[wn + 6] = cn[1] - hn[1]),
          (Pt[wn + 7] = cn[0] - hn[0])
      }
      for (var Bn = 0; Bn < 8; ++Bn)
        (dn[0] = Ut * Pt[16 + Bn]),
          (dn[1] = tn * Pt[16 + Bn]),
          (dn[2] = Ut * Pt[48 + Bn]),
          (dn[3] = tn * Pt[48 + Bn]),
          (hn[0] =
            Bt * Pt[8 + Bn] +
            Ot * Pt[24 + Bn] +
            zt * Pt[40 + Bn] +
            sn * Pt[56 + Bn]),
          (hn[1] =
            Ot * Pt[8 + Bn] -
            sn * Pt[24 + Bn] -
            Bt * Pt[40 + Bn] -
            zt * Pt[56 + Bn]),
          (hn[2] =
            zt * Pt[8 + Bn] -
            Bt * Pt[24 + Bn] +
            sn * Pt[40 + Bn] +
            Ot * Pt[56 + Bn]),
          (hn[3] =
            sn * Pt[8 + Bn] -
            zt * Pt[24 + Bn] +
            Ot * Pt[40 + Bn] -
            Bt * Pt[56 + Bn]),
          (mn[0] = St * (Pt[Bn] + Pt[32 + Bn])),
          (mn[3] = St * (Pt[Bn] - Pt[32 + Bn])),
          (mn[1] = dn[0] + dn[3]),
          (mn[2] = dn[1] - dn[2]),
          (cn[0] = mn[0] + mn[1]),
          (cn[1] = mn[3] + mn[2]),
          (cn[2] = mn[3] - mn[2]),
          (cn[3] = mn[0] - mn[1]),
          (Pt[0 + Bn] = cn[0] + hn[0]),
          (Pt[8 + Bn] = cn[1] + hn[1]),
          (Pt[16 + Bn] = cn[2] + hn[2]),
          (Pt[24 + Bn] = cn[3] + hn[3]),
          (Pt[32 + Bn] = cn[3] - hn[3]),
          (Pt[40 + Bn] = cn[2] - hn[2]),
          (Pt[48 + Bn] = cn[1] - hn[1]),
          (Pt[56 + Bn] = cn[0] - hn[0])
    }
    function Gn(Pt) {
      for (var St = 0; St < 64; ++St) {
        var Bt = Pt[0][St],
          Ut = Pt[1][St],
          Ot = Pt[2][St]
        ;(Pt[0][St] = Bt + 1.5747 * Ot),
          (Pt[1][St] = Bt - 0.1873 * Ut - 0.4682 * Ot),
          (Pt[2][St] = Bt + 1.8556 * Ut)
      }
    }
    function jn(Pt, St, Bt) {
      for (var Ut = 0; Ut < 64; ++Ut)
        St[Bt + Ut] = DataUtils.toHalfFloat(ar(Pt[Ut]))
    }
    function ar(Pt) {
      return Pt <= 1
        ? Math.sign(Pt) * Math.pow(Math.abs(Pt), 2.2)
        : Math.sign(Pt) * Math.pow(yt, Math.abs(Pt) - 1)
    }
    function Vt(Pt) {
      return new DataView(Pt.array.buffer, Pt.offset.value, Pt.size)
    }
    function Lt(Pt) {
      var St = Pt.viewer.buffer.slice(
          Pt.offset.value,
          Pt.offset.value + Pt.size
        ),
        Bt = new Uint8Array(_n(St)),
        Ut = new Uint8Array(Bt.length)
      return on(Bt), Yt(Bt, Ut), new DataView(Ut.buffer)
    }
    function Zt(Pt) {
      var St = Pt.array.slice(Pt.offset.value, Pt.offset.value + Pt.size),
        Bt = unzlibSync(St),
        Ut = new Uint8Array(Bt.length)
      return on(Bt), Yt(Bt, Ut), new DataView(Ut.buffer)
    }
    function xn(Pt) {
      for (
        var St = Pt.viewer,
          Bt = { value: Pt.offset.value },
          Ut = new Uint16Array(
            Pt.width * Pt.scanlineBlockSize * (Pt.channels * Pt.type)
          ),
          Ot = new Uint8Array(8192),
          zt = 0,
          tn = new Array(Pt.channels),
          sn = 0;
        sn < Pt.channels;
        sn++
      )
        (tn[sn] = {}),
          (tn[sn].start = zt),
          (tn[sn].end = tn[sn].start),
          (tn[sn].nx = Pt.width),
          (tn[sn].ny = Pt.lines),
          (tn[sn].size = Pt.type),
          (zt += tn[sn].nx * tn[sn].ny * tn[sn].size)
      var dn = nn(St, Bt),
        hn = nn(St, Bt)
      if (hn >= 8192)
        throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE"
      if (dn <= hn)
        for (var sn = 0; sn < hn - dn + 1; sn++) Ot[sn + dn] = Wt(St, Bt)
      var mn = new Uint16Array(65536),
        cn = Et(Ot, mn),
        On = Fn(St, Bt)
      gn(Pt.array, St, Bt, On, Ut, zt)
      for (var sn = 0; sn < Pt.channels; ++sn)
        for (var wn = tn[sn], Bn = 0; Bn < tn[sn].size; ++Bn)
          $n(Ut, wn.start + Bn, wn.nx, wn.size, wn.ny, wn.nx * wn.size, cn)
      Ht(mn, Ut, zt)
      for (
        var Yn = 0, Zn = new Uint8Array(Ut.buffer.byteLength), qn = 0;
        qn < Pt.lines;
        qn++
      )
        for (var Dn = 0; Dn < Pt.channels; Dn++) {
          var wn = tn[Dn],
            er = wn.nx * wn.size,
            Wn = new Uint8Array(Ut.buffer, wn.end * 2, er * 2)
          Zn.set(Wn, Yn), (Yn += er * 2), (wn.end += er)
        }
      return new DataView(Zn.buffer)
    }
    function vn(Pt) {
      var St = Pt.array.slice(Pt.offset.value, Pt.offset.value + Pt.size),
        Bt = unzlibSync(St)
      const Ut = Pt.lines * Pt.channels * Pt.width,
        Ot = Pt.type == 1 ? new Uint16Array(Ut) : new Uint32Array(Ut)
      let zt = 0,
        tn = 0
      const sn = new Array(4)
      for (let dn = 0; dn < Pt.lines; dn++)
        for (let hn = 0; hn < Pt.channels; hn++) {
          let mn = 0
          switch (Pt.type) {
            case 1:
              ;(sn[0] = zt), (sn[1] = sn[0] + Pt.width), (zt = sn[1] + Pt.width)
              for (let cn = 0; cn < Pt.width; ++cn) {
                const On = (Bt[sn[0]++] << 8) | Bt[sn[1]++]
                ;(mn += On), (Ot[tn] = mn), tn++
              }
              break
            case 2:
              ;(sn[0] = zt),
                (sn[1] = sn[0] + Pt.width),
                (sn[2] = sn[1] + Pt.width),
                (zt = sn[2] + Pt.width)
              for (let cn = 0; cn < Pt.width; ++cn) {
                const On =
                  (Bt[sn[0]++] << 24) | (Bt[sn[1]++] << 16) | (Bt[sn[2]++] << 8)
                ;(mn += On), (Ot[tn] = mn), tn++
              }
              break
          }
        }
      return new DataView(Ot.buffer)
    }
    function An(Pt) {
      var St = Pt.viewer,
        Bt = { value: Pt.offset.value },
        Ut = new Uint8Array(Pt.width * Pt.lines * (Pt.channels * Pt.type * 2)),
        Ot = {
          version: un(St, Bt),
          unknownUncompressedSize: un(St, Bt),
          unknownCompressedSize: un(St, Bt),
          acCompressedSize: un(St, Bt),
          dcCompressedSize: un(St, Bt),
          rleCompressedSize: un(St, Bt),
          rleUncompressedSize: un(St, Bt),
          rleRawSize: un(St, Bt),
          totalAcUncompressedCount: un(St, Bt),
          totalDcUncompressedCount: un(St, Bt),
          acCompression: un(St, Bt),
        }
      if (Ot.version < 2)
        throw (
          "EXRLoader.parse: " +
          zr.compression +
          " version " +
          Ot.version +
          " is unsupported"
        )
      for (var zt = new Array(), tn = nn(St, Bt) - 2; tn > 0; ) {
        var sn = Nn(St.buffer, Bt),
          dn = Wt(St, Bt),
          hn = (dn >> 2) & 3,
          mn = (dn >> 4) - 1,
          cn = new Int8Array([mn])[0],
          On = Wt(St, Bt)
        zt.push({ name: sn, index: cn, type: On, compression: hn }),
          (tn -= sn.length + 3)
      }
      for (
        var wn = zr.channels, Bn = new Array(Pt.channels), Yn = 0;
        Yn < Pt.channels;
        ++Yn
      ) {
        var Zn = (Bn[Yn] = {}),
          qn = wn[Yn]
        ;(Zn.name = qn.name),
          (Zn.compression = 0),
          (Zn.decoded = !1),
          (Zn.type = qn.pixelType),
          (Zn.pLinear = qn.pLinear),
          (Zn.width = Pt.width),
          (Zn.height = Pt.lines)
      }
      for (var Dn = { idx: new Array(3) }, er = 0; er < Pt.channels; ++er)
        for (var Zn = Bn[er], Yn = 0; Yn < zt.length; ++Yn) {
          var Wn = zt[Yn]
          Zn.name == Wn.name &&
            ((Zn.compression = Wn.compression),
            Wn.index >= 0 && (Dn.idx[Wn.index] = er),
            (Zn.offset = er))
        }
      if (Ot.acCompressedSize > 0)
        switch (Ot.acCompression) {
          case 0:
            var tr = new Uint16Array(Ot.totalAcUncompressedCount)
            gn(
              Pt.array,
              St,
              Bt,
              Ot.acCompressedSize,
              tr,
              Ot.totalAcUncompressedCount
            )
            break
          case 1:
            var rr = Pt.array.slice(
                Bt.value,
                Bt.value + Ot.totalAcUncompressedCount
              ),
              Ar = unzlibSync(rr),
              tr = new Uint16Array(Ar.buffer)
            Bt.value += Ot.totalAcUncompressedCount
            break
        }
      if (Ot.dcCompressedSize > 0) {
        var Sr = { array: Pt.array, offset: Bt, size: Ot.dcCompressedSize },
          gr = new Uint16Array(Zt(Sr).buffer)
        Bt.value += Ot.dcCompressedSize
      }
      if (Ot.rleRawSize > 0) {
        var rr = Pt.array.slice(Bt.value, Bt.value + Ot.rleCompressedSize),
          Ar = unzlibSync(rr),
          Er = _n(Ar.buffer)
        Bt.value += Ot.rleCompressedSize
      }
      for (var Ir = 0, nr = new Array(Bn.length), Yn = 0; Yn < nr.length; ++Yn)
        nr[Yn] = new Array()
      for (var wr = 0; wr < Pt.lines; ++wr)
        for (var xr = 0; xr < Bn.length; ++xr)
          nr[xr].push(Ir), (Ir += Bn[xr].width * Pt.type * 2)
      pn(Dn, nr, Bn, tr, gr, Ut)
      for (var Yn = 0; Yn < Bn.length; ++Yn) {
        var Zn = Bn[Yn]
        if (!Zn.decoded)
          switch (Zn.compression) {
            case 2:
              for (var pr = 0, Cr = 0, wr = 0; wr < Pt.lines; ++wr) {
                for (var Ms = nr[Yn][pr], Xr = 0; Xr < Zn.width; ++Xr) {
                  for (var ms = 0; ms < 2 * Zn.type; ++ms)
                    Ut[Ms++] = Er[Cr + ms * Zn.width * Zn.height]
                  Cr++
                }
                pr++
              }
              break
            case 1:
            default:
              throw "EXRLoader.parse: unsupported channel compression"
          }
      }
      return new DataView(Ut.buffer)
    }
    function Nn(Pt, St) {
      for (var Bt = new Uint8Array(Pt), Ut = 0; Bt[St.value + Ut] != 0; )
        Ut += 1
      var Ot = new TextDecoder().decode(Bt.slice(St.value, St.value + Ut))
      return (St.value = St.value + Ut + 1), Ot
    }
    function Sn(Pt, St, Bt) {
      var Ut = new TextDecoder().decode(
        new Uint8Array(Pt).slice(St.value, St.value + Bt)
      )
      return (St.value = St.value + Bt), Ut
    }
    function an(Pt, St) {
      var Bt = Hn(Pt, St),
        Ut = Fn(Pt, St)
      return [Bt, Ut]
    }
    function Jn(Pt, St) {
      var Bt = Fn(Pt, St),
        Ut = Fn(Pt, St)
      return [Bt, Ut]
    }
    function Hn(Pt, St) {
      var Bt = Pt.getInt32(St.value, !0)
      return (St.value = St.value + 4), Bt
    }
    function Fn(Pt, St) {
      var Bt = Pt.getUint32(St.value, !0)
      return (St.value = St.value + 4), Bt
    }
    function Un(Pt, St) {
      var Bt = Pt[St.value]
      return (St.value = St.value + 1), Bt
    }
    function Wt(Pt, St) {
      var Bt = Pt.getUint8(St.value)
      return (St.value = St.value + 1), Bt
    }
    const un = function (Pt, St) {
      let Bt
      return (
        "getBigInt64" in DataView.prototype
          ? (Bt = Number(Pt.getBigInt64(St.value, !0)))
          : (Bt =
              Pt.getUint32(St.value + 4, !0) +
              Number(Pt.getUint32(St.value, !0) << 32)),
        (St.value += 8),
        Bt
      )
    }
    function Mn(Pt, St) {
      var Bt = Pt.getFloat32(St.value, !0)
      return (St.value += 4), Bt
    }
    function jt(Pt, St) {
      return DataUtils.toHalfFloat(Mn(Pt, St))
    }
    function Qt(Pt) {
      var St = (Pt & 31744) >> 10,
        Bt = Pt & 1023
      return (
        (Pt >> 15 ? -1 : 1) *
        (St
          ? St === 31
            ? Bt
              ? NaN
              : 1 / 0
            : Math.pow(2, St - 15) * (1 + Bt / 1024)
          : 6103515625e-14 * (Bt / 1024))
      )
    }
    function nn(Pt, St) {
      var Bt = Pt.getUint16(St.value, !0)
      return (St.value += 2), Bt
    }
    function En(Pt, St) {
      return Qt(nn(Pt, St))
    }
    function In(Pt, St, Bt, Ut) {
      for (var Ot = Bt.value, zt = []; Bt.value < Ot + Ut - 1; ) {
        var tn = Nn(St, Bt),
          sn = Hn(Pt, Bt),
          dn = Wt(Pt, Bt)
        Bt.value += 3
        var hn = Hn(Pt, Bt),
          mn = Hn(Pt, Bt)
        zt.push({
          name: tn,
          pixelType: sn,
          pLinear: dn,
          xSampling: hn,
          ySampling: mn,
        })
      }
      return (Bt.value += 1), zt
    }
    function or(Pt, St) {
      var Bt = Mn(Pt, St),
        Ut = Mn(Pt, St),
        Ot = Mn(Pt, St),
        zt = Mn(Pt, St),
        tn = Mn(Pt, St),
        sn = Mn(Pt, St),
        dn = Mn(Pt, St),
        hn = Mn(Pt, St)
      return {
        redX: Bt,
        redY: Ut,
        greenX: Ot,
        greenY: zt,
        blueX: tn,
        blueY: sn,
        whiteX: dn,
        whiteY: hn,
      }
    }
    function hr(Pt, St) {
      var Bt = [
          "NO_COMPRESSION",
          "RLE_COMPRESSION",
          "ZIPS_COMPRESSION",
          "ZIP_COMPRESSION",
          "PIZ_COMPRESSION",
          "PXR24_COMPRESSION",
          "B44_COMPRESSION",
          "B44A_COMPRESSION",
          "DWAA_COMPRESSION",
          "DWAB_COMPRESSION",
        ],
        Ut = Wt(Pt, St)
      return Bt[Ut]
    }
    function mr(Pt, St) {
      var Bt = Fn(Pt, St),
        Ut = Fn(Pt, St),
        Ot = Fn(Pt, St),
        zt = Fn(Pt, St)
      return { xMin: Bt, yMin: Ut, xMax: Ot, yMax: zt }
    }
    function kr(Pt, St) {
      var Bt = ["INCREASING_Y"],
        Ut = Wt(Pt, St)
      return Bt[Ut]
    }
    function dr(Pt, St) {
      var Bt = Mn(Pt, St),
        Ut = Mn(Pt, St)
      return [Bt, Ut]
    }
    function Br(Pt, St) {
      var Bt = Mn(Pt, St),
        Ut = Mn(Pt, St),
        Ot = Mn(Pt, St)
      return [Bt, Ut, Ot]
    }
    function Tr(Pt, St, Bt, Ut, Ot) {
      if (Ut === "string" || Ut === "stringvector" || Ut === "iccProfile")
        return Sn(St, Bt, Ot)
      if (Ut === "chlist") return In(Pt, St, Bt, Ot)
      if (Ut === "chromaticities") return or(Pt, Bt)
      if (Ut === "compression") return hr(Pt, Bt)
      if (Ut === "box2i") return mr(Pt, Bt)
      if (Ut === "lineOrder") return kr(Pt, Bt)
      if (Ut === "float") return Mn(Pt, Bt)
      if (Ut === "v2f") return dr(Pt, Bt)
      if (Ut === "v3f") return Br(Pt, Bt)
      if (Ut === "int") return Hn(Pt, Bt)
      if (Ut === "rational") return an(Pt, Bt)
      if (Ut === "timecode") return Jn(Pt, Bt)
      if (Ut === "preview") return (Bt.value += Ot), "skipped"
      Bt.value += Ot
    }
    function Js(Pt, St, Bt) {
      const Ut = {}
      if (Pt.getUint32(0, !0) != 20000630)
        throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format."
      Ut.version = Pt.getUint8(4)
      const Ot = Pt.getUint8(5)
      ;(Ut.spec = {
        singleTile: !!(Ot & 2),
        longName: !!(Ot & 4),
        deepFormat: !!(Ot & 8),
        multiPart: !!(Ot & 16),
      }),
        (Bt.value = 8)
      for (var zt = !0; zt; ) {
        var tn = Nn(St, Bt)
        if (tn == 0) zt = !1
        else {
          var sn = Nn(St, Bt),
            dn = Fn(Pt, Bt),
            hn = Tr(Pt, St, Bt, sn, dn)
          hn === void 0
            ? console.warn(
                `EXRLoader.parse: skipped unknown header attribute type '${sn}'.`
              )
            : (Ut[tn] = hn)
        }
      }
      if (Ot & -5)
        throw (
          (console.error("EXRHeader:", Ut),
          "THREE.EXRLoader: provided file is currently unsupported.")
        )
      return Ut
    }
    function Ys(Pt, St, Bt, Ut, Ot) {
      const zt = {
        size: 0,
        viewer: St,
        array: Bt,
        offset: Ut,
        width: Pt.dataWindow.xMax - Pt.dataWindow.xMin + 1,
        height: Pt.dataWindow.yMax - Pt.dataWindow.yMin + 1,
        channels: Pt.channels.length,
        bytesPerLine: null,
        lines: null,
        inputSize: null,
        type: Pt.channels[0].pixelType,
        uncompress: null,
        getter: null,
        format: null,
        [hasColorSpace ? "colorSpace" : "encoding"]: null,
      }
      switch (Pt.compression) {
        case "NO_COMPRESSION":
          ;(zt.lines = 1), (zt.uncompress = Vt)
          break
        case "RLE_COMPRESSION":
          ;(zt.lines = 1), (zt.uncompress = Lt)
          break
        case "ZIPS_COMPRESSION":
          ;(zt.lines = 1), (zt.uncompress = Zt)
          break
        case "ZIP_COMPRESSION":
          ;(zt.lines = 16), (zt.uncompress = Zt)
          break
        case "PIZ_COMPRESSION":
          ;(zt.lines = 32), (zt.uncompress = xn)
          break
        case "PXR24_COMPRESSION":
          ;(zt.lines = 16), (zt.uncompress = vn)
          break
        case "DWAA_COMPRESSION":
          ;(zt.lines = 32), (zt.uncompress = An)
          break
        case "DWAB_COMPRESSION":
          ;(zt.lines = 256), (zt.uncompress = An)
          break
        default:
          throw "EXRLoader.parse: " + Pt.compression + " is unsupported"
      }
      if (((zt.scanlineBlockSize = zt.lines), zt.type == 1))
        switch (Ot) {
          case FloatType:
            ;(zt.getter = En), (zt.inputSize = 2)
            break
          case HalfFloatType:
            ;(zt.getter = nn), (zt.inputSize = 2)
            break
        }
      else if (zt.type == 2)
        switch (Ot) {
          case FloatType:
            ;(zt.getter = Mn), (zt.inputSize = 4)
            break
          case HalfFloatType:
            ;(zt.getter = jt), (zt.inputSize = 4)
        }
      else
        throw (
          "EXRLoader.parse: unsupported pixelType " +
          zt.type +
          " for " +
          Pt.compression +
          "."
        )
      zt.blockCount = (Pt.dataWindow.yMax + 1) / zt.scanlineBlockSize
      for (var tn = 0; tn < zt.blockCount; tn++) un(St, Ut)
      zt.outputChannels = zt.channels == 3 ? 4 : zt.channels
      const sn = zt.width * zt.height * zt.outputChannels
      switch (Ot) {
        case FloatType:
          ;(zt.byteArray = new Float32Array(sn)),
            zt.channels < zt.outputChannels && zt.byteArray.fill(1, 0, sn)
          break
        case HalfFloatType:
          ;(zt.byteArray = new Uint16Array(sn)),
            zt.channels < zt.outputChannels && zt.byteArray.fill(15360, 0, sn)
          break
        default:
          console.error("THREE.EXRLoader: unsupported type: ", Ot)
          break
      }
      return (
        (zt.bytesPerLine = zt.width * zt.inputSize * zt.channels),
        zt.outputChannels == 4
          ? (zt.format = RGBAFormat)
          : (zt.format = RedFormat),
        hasColorSpace ? (zt.colorSpace = "srgb-linear") : (zt.encoding = 3e3),
        zt
      )
    }
    const Es = new DataView(e),
      ds = new Uint8Array(e),
      ps = { value: 0 },
      zr = Js(Es, e, ps),
      lr = Ys(zr, Es, ds, ps, this.type),
      Ks = { value: 0 },
      io = { R: 0, G: 1, B: 2, A: 3, Y: 0 }
    for (let Pt = 0; Pt < lr.height / lr.scanlineBlockSize; Pt++) {
      const St = Fn(Es, ps)
      ;(lr.size = Fn(Es, ps)),
        (lr.lines =
          St + lr.scanlineBlockSize > lr.height
            ? lr.height - St
            : lr.scanlineBlockSize)
      const Ut =
        lr.size < lr.lines * lr.bytesPerLine ? lr.uncompress(lr) : Vt(lr)
      ps.value += lr.size
      for (let Ot = 0; Ot < lr.scanlineBlockSize; Ot++) {
        const zt = Ot + Pt * lr.scanlineBlockSize
        if (zt >= lr.height) break
        for (let tn = 0; tn < lr.channels; tn++) {
          const sn = io[zr.channels[tn].name]
          for (let dn = 0; dn < lr.width; dn++) {
            Ks.value =
              (Ot * (lr.channels * lr.width) + tn * lr.width + dn) *
              lr.inputSize
            const hn =
              (lr.height - 1 - zt) * (lr.width * lr.outputChannels) +
              dn * lr.outputChannels +
              sn
            lr.byteArray[hn] = lr.getter(Ut, Ks)
          }
        }
      }
    }
    return {
      header: zr,
      width: lr.width,
      height: lr.height,
      data: lr.byteArray,
      format: lr.format,
      [hasColorSpace ? "colorSpace" : "encoding"]:
        lr[hasColorSpace ? "colorSpace" : "encoding"],
      type: this.type,
    }
  }
  setDataType(e) {
    return (this.type = e), this
  }
  load(e, a, o, c) {
    function d(g, _) {
      hasColorSpace ? (g.colorSpace = _.colorSpace) : (g.encoding = _.encoding),
        (g.minFilter = LinearFilter),
        (g.magFilter = LinearFilter),
        (g.generateMipmaps = !1),
        (g.flipY = !1),
        a && a(g, _)
    }
    return super.load(e, d, o, c)
  }
}
const _taskCache = new WeakMap()
class DRACOLoader extends Loader$1 {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      })
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this
  }
  load(e, a, o, c) {
    const d = new FileLoader(this.manager)
    d.setPath(this.path),
      d.setResponseType("arraybuffer"),
      d.setRequestHeader(this.requestHeader),
      d.setWithCredentials(this.withCredentials),
      d.load(
        e,
        (g) => {
          const _ = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          }
          this.decodeGeometry(g, _).then(a).catch(c)
        },
        o,
        c
      )
  }
  decodeDracoFile(e, a, o, c) {
    const d = {
      attributeIDs: o || this.defaultAttributeIDs,
      attributeTypes: c || this.defaultAttributeTypes,
      useUniqueIDs: !!o,
    }
    this.decodeGeometry(e, d).then(a)
  }
  decodeGeometry(e, a) {
    for (const b in a.attributeTypes) {
      const j = a.attributeTypes[b]
      j.BYTES_PER_ELEMENT !== void 0 && (a.attributeTypes[b] = j.name)
    }
    const o = JSON.stringify(a)
    if (_taskCache.has(e)) {
      const b = _taskCache.get(e)
      if (b.key === o) return b.promise
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        )
    }
    let c
    const d = this.workerNextTaskID++,
      g = e.byteLength,
      _ = this._getWorker(d, g)
        .then(
          (b) => (
            (c = b),
            new Promise((j, $) => {
              ;(c._callbacks[d] = { resolve: j, reject: $ }),
                c.postMessage(
                  { type: "decode", id: d, taskConfig: a, buffer: e },
                  [e]
                )
            })
          )
        )
        .then((b) => this._createGeometry(b.geometry))
    return (
      _.catch(() => !0).then(() => {
        c && d && this._releaseTask(c, d)
      }),
      _taskCache.set(e, { key: o, promise: _ }),
      _
    )
  }
  _createGeometry(e) {
    const a = new BufferGeometry()
    e.index && a.setIndex(new BufferAttribute(e.index.array, 1))
    for (let o = 0; o < e.attributes.length; o++) {
      const c = e.attributes[o],
        d = c.name,
        g = c.array,
        _ = c.itemSize
      a.setAttribute(d, new BufferAttribute(g, _))
    }
    return a
  }
  _loadLibrary(e, a) {
    const o = new FileLoader(this.manager)
    return (
      o.setPath(this.decoderPath),
      o.setResponseType(a),
      o.setWithCredentials(this.withCredentials),
      new Promise((c, d) => {
        o.load(e, c, void 0, d)
      })
    )
  }
  preload() {
    return this._initDecoder(), this
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      a = []
    return (
      e
        ? a.push(this._loadLibrary("draco_decoder.js", "text"))
        : (a.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          a.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(a).then((o) => {
        const c = o[0]
        e || (this.decoderConfig.wasmBinary = o[1])
        const d = DRACOWorker.toString(),
          g = [
            "/* draco decoder */",
            c,
            "",
            "/* worker */",
            d.substring(d.indexOf("{") + 1, d.lastIndexOf("}")),
          ].join(`
`)
        this.workerSourceURL = URL.createObjectURL(new Blob([g]))
      })),
      this.decoderPending
    )
  }
  _getWorker(e, a) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const c = new Worker(this.workerSourceURL)
        ;(c._callbacks = {}),
          (c._taskCosts = {}),
          (c._taskLoad = 0),
          c.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (c.onmessage = function (d) {
            const g = d.data
            switch (g.type) {
              case "decode":
                c._callbacks[g.id].resolve(g)
                break
              case "error":
                c._callbacks[g.id].reject(g)
                break
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + g.type + '"'
                )
            }
          }),
          this.workerPool.push(c)
      } else
        this.workerPool.sort(function (c, d) {
          return c._taskLoad > d._taskLoad ? -1 : 1
        })
      const o = this.workerPool[this.workerPool.length - 1]
      return (o._taskCosts[e] = a), (o._taskLoad += a), o
    })
  }
  _releaseTask(e, a) {
    ;(e._taskLoad -= e._taskCosts[a]),
      delete e._callbacks[a],
      delete e._taskCosts[a]
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    )
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate()
    return (this.workerPool.length = 0), this
  }
}
function DRACOWorker() {
  let s, e
  onmessage = function (g) {
    const _ = g.data
    switch (_.type) {
      case "init":
        ;(s = _.decoderConfig),
          (e = new Promise(function ($) {
            ;(s.onModuleLoaded = function (_e) {
              $({ draco: _e })
            }),
              DracoDecoderModule(s)
          }))
        break
      case "decode":
        const b = _.buffer,
          j = _.taskConfig
        e.then(($) => {
          const _e = $.draco,
            tt = new _e.Decoder(),
            st = new _e.DecoderBuffer()
          st.Init(new Int8Array(b), b.byteLength)
          try {
            const at = a(_e, tt, st, j),
              ot = at.attributes.map((ut) => ut.array.buffer)
            at.index && ot.push(at.index.array.buffer),
              self.postMessage({ type: "decode", id: _.id, geometry: at }, ot)
          } catch (at) {
            console.error(at),
              self.postMessage({ type: "error", id: _.id, error: at.message })
          } finally {
            _e.destroy(st), _e.destroy(tt)
          }
        })
        break
    }
  }
  function a(g, _, b, j) {
    const $ = j.attributeIDs,
      _e = j.attributeTypes
    let tt, st
    const at = _.GetEncodedGeometryType(b)
    if (at === g.TRIANGULAR_MESH)
      (tt = new g.Mesh()), (st = _.DecodeBufferToMesh(b, tt))
    else if (at === g.POINT_CLOUD)
      (tt = new g.PointCloud()), (st = _.DecodeBufferToPointCloud(b, tt))
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.")
    if (!st.ok() || tt.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + st.error_msg())
    const ot = { index: null, attributes: [] }
    for (const ut in $) {
      const it = self[_e[ut]]
      let ct, lt
      if (j.useUniqueIDs) (lt = $[ut]), (ct = _.GetAttributeByUniqueId(tt, lt))
      else {
        if (((lt = _.GetAttributeId(tt, g[$[ut]])), lt === -1)) continue
        ct = _.GetAttribute(tt, lt)
      }
      ot.attributes.push(c(g, _, tt, ut, it, ct))
    }
    return (
      at === g.TRIANGULAR_MESH && (ot.index = o(g, _, tt)), g.destroy(tt), ot
    )
  }
  function o(g, _, b) {
    const $ = b.num_faces() * 3,
      _e = $ * 4,
      tt = g._malloc(_e)
    _.GetTrianglesUInt32Array(b, _e, tt)
    const st = new Uint32Array(g.HEAPF32.buffer, tt, $).slice()
    return g._free(tt), { array: st, itemSize: 1 }
  }
  function c(g, _, b, j, $, _e) {
    const tt = _e.num_components(),
      at = b.num_points() * tt,
      ot = at * $.BYTES_PER_ELEMENT,
      ut = d(g, $),
      it = g._malloc(ot)
    _.GetAttributeDataArrayForAllPoints(b, _e, ut, ot, it)
    const ct = new $(g.HEAPF32.buffer, it, at).slice()
    return g._free(it), { name: j, array: ct, itemSize: tt }
  }
  function d(g, _) {
    switch (_) {
      case Float32Array:
        return g.DT_FLOAT32
      case Int8Array:
        return g.DT_INT8
      case Int16Array:
        return g.DT_INT16
      case Int32Array:
        return g.DT_INT32
      case Uint8Array:
        return g.DT_UINT8
      case Uint16Array:
        return g.DT_UINT16
      case Uint32Array:
        return g.DT_UINT32
    }
  }
}
let generated
const MeshoptDecoder = () => {
    if (generated) return generated
    const s =
        "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
      e =
        "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
      a = new Uint8Array([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1,
        0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0,
        11, 7, 0, 65, 0, 253, 15, 26, 11,
      ]),
      o = new Uint8Array([
        32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
        128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
        107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
        44, 45, 74, 156, 154, 70, 167,
      ])
    if (typeof WebAssembly != "object") return { supported: !1 }
    let c = s
    WebAssembly.validate(a) && (c = e)
    let d
    const g = WebAssembly.instantiate(_(c), {}).then((_e) => {
      ;(d = _e.instance), d.exports.__wasm_call_ctors()
    })
    function _(_e) {
      const tt = new Uint8Array(_e.length)
      for (let at = 0; at < _e.length; ++at) {
        const ot = _e.charCodeAt(at)
        tt[at] =
          ot > 96
            ? ot - 71
            : ot > 64
            ? ot - 65
            : ot > 47
            ? ot + 4
            : ot > 46
            ? 63
            : 62
      }
      let st = 0
      for (let at = 0; at < _e.length; ++at)
        tt[st++] = tt[at] < 60 ? o[tt[at]] : (tt[at] - 60) * 64 + tt[++at]
      return tt.buffer.slice(0, st)
    }
    function b(_e, tt, st, at, ot, ut) {
      const it = d.exports.sbrk,
        ct = (st + 3) & -4,
        lt = it(ct * at),
        ht = it(ot.length),
        dt = new Uint8Array(d.exports.memory.buffer)
      dt.set(ot, ht)
      const pt = _e(lt, st, at, ht, ot.length)
      if (
        (pt === 0 && ut && ut(lt, ct, at),
        tt.set(dt.subarray(lt, lt + st * at)),
        it(lt - it(0)),
        pt !== 0)
      )
        throw new Error(`Malformed buffer data: ${pt}`)
    }
    const j = {
        0: "",
        1: "meshopt_decodeFilterOct",
        2: "meshopt_decodeFilterQuat",
        3: "meshopt_decodeFilterExp",
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp",
      },
      $ = {
        0: "meshopt_decodeVertexBuffer",
        1: "meshopt_decodeIndexBuffer",
        2: "meshopt_decodeIndexSequence",
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence",
      }
    return (
      (generated = {
        ready: g,
        supported: !0,
        decodeVertexBuffer(_e, tt, st, at, ot) {
          b(
            d.exports.meshopt_decodeVertexBuffer,
            _e,
            tt,
            st,
            at,
            d.exports[j[ot]]
          )
        },
        decodeIndexBuffer(_e, tt, st, at) {
          b(d.exports.meshopt_decodeIndexBuffer, _e, tt, st, at)
        },
        decodeIndexSequence(_e, tt, st, at) {
          b(d.exports.meshopt_decodeIndexSequence, _e, tt, st, at)
        },
        decodeGltfBuffer(_e, tt, st, at, ot, ut) {
          b(d.exports[$[ot]], _e, tt, st, at, d.exports[j[ut]])
        },
      }),
      generated
    )
  },
  IsObject = (s) =>
    s === Object(s) && !Array.isArray(s) && typeof s != "function"
function useTexture(s, e) {
  const a = useThree((c) => c.gl),
    o = useLoader(TextureLoader, IsObject(s) ? Object.values(s) : s)
  if (
    (reactExports.useLayoutEffect(() => {
      e == null || e(o)
    }, [e]),
    reactExports.useEffect(() => {
      "initTexture" in a && (Array.isArray(o) ? o : [o]).forEach(a.initTexture)
    }, [a, o]),
    IsObject(s))
  ) {
    const c = {}
    let d = 0
    for (const g in s) c[g] = o[d++]
    return c
  } else return o
}
useTexture.preload = (s) => useLoader.preload(TextureLoader, s)
useTexture.clear = (s) => useLoader.clear(TextureLoader, s)
const getVersion = () => parseInt(REVISION.replace(/\D+/g, "")),
  version = getVersion()
function isArray$1(s) {
  return Array.isArray(s)
}
function vecToArray(s = [0, 0, 0]) {
  return isArray$1(s)
    ? s
    : s instanceof Vector3 || s instanceof Euler
    ? [s.x, s.y, s.z]
    : [s, s, s]
}
const Decal = reactExports.forwardRef(function (
  {
    debug: e,
    depthTest: a = !1,
    polygonOffsetFactor: o = -10,
    map: c,
    mesh: d,
    children: g,
    position: _,
    rotation: b,
    scale: j,
    ...$
  },
  _e
) {
  const tt = reactExports.useRef(null)
  reactExports.useImperativeHandle(_e, () => tt.current)
  const st = reactExports.useRef(null)
  return (
    reactExports.useLayoutEffect(() => {
      const at = (d == null ? void 0 : d.current) || tt.current.parent,
        ot = tt.current
      if (!(at instanceof Mesh))
        throw new Error(
          'Decal must have a Mesh as parent or specify its "mesh" prop'
        )
      const ut = {
        position: new Vector3(),
        rotation: new Euler(),
        scale: new Vector3(1, 1, 1),
      }
      if (at) {
        applyProps(ut, { position: _, scale: j })
        const it = at.matrixWorld.clone()
        if ((at.matrixWorld.identity(), !b || typeof b == "number")) {
          const ct = new Object3D()
          ct.position.copy(ut.position),
            ct.lookAt(at.position),
            typeof b == "number" && ct.rotateZ(b),
            applyProps(ut, { rotation: ct.rotation })
        } else applyProps(ut, { rotation: b })
        return (
          (ot.geometry = new DecalGeometry(
            at,
            ut.position,
            ut.rotation,
            ut.scale
          )),
          st.current &&
            (applyProps(st.current, ut),
            st.current.traverse((ct) => (ct.raycast = () => null))),
          (at.matrixWorld = it),
          () => {
            ot.geometry.dispose()
          }
        )
      }
    }, [d, ...vecToArray(_), ...vecToArray(j), ...vecToArray(b)]),
    reactExports.createElement(
      "mesh",
      _extends$1(
        {
          ref: tt,
          "material-transparent": !0,
          "material-polygonOffset": !0,
          "material-polygonOffsetFactor": o,
          "material-depthTest": a,
          "material-map": c,
        },
        $
      ),
      g,
      e &&
        reactExports.createElement(
          "mesh",
          { ref: st },
          reactExports.createElement("boxGeometry", null),
          reactExports.createElement("meshNormalMaterial", { wireframe: !0 }),
          reactExports.createElement("axesHelper", null)
        )
    )
  )
})
let dracoLoader = null,
  decoderPath = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"
function extensions(s, e, a) {
  return (o) => {
    a && a(o),
      s &&
        (dracoLoader || (dracoLoader = new DRACOLoader()),
        dracoLoader.setDecoderPath(typeof s == "string" ? s : decoderPath),
        o.setDRACOLoader(dracoLoader)),
      e &&
        o.setMeshoptDecoder(
          typeof MeshoptDecoder == "function"
            ? MeshoptDecoder()
            : MeshoptDecoder
        )
  }
}
function useGLTF(s, e = !0, a = !0, o) {
  return useLoader(GLTFLoader, s, extensions(e, a, o))
}
useGLTF.preload = (s, e = !0, a = !0, o) =>
  useLoader.preload(GLTFLoader, s, extensions(e, a, o))
useGLTF.clear = (s) => useLoader.clear(GLTFLoader, s)
useGLTF.setDecoderPath = (s) => {
  decoderPath = s
}
const OrbitControls = reactExports.forwardRef(
  (
    {
      makeDefault: s,
      camera: e,
      regress: a,
      domElement: o,
      enableDamping: c = !0,
      keyEvents: d = !1,
      onChange: g,
      onStart: _,
      onEnd: b,
      ...j
    },
    $
  ) => {
    const _e = useThree((pt) => pt.invalidate),
      tt = useThree((pt) => pt.camera),
      st = useThree((pt) => pt.gl),
      at = useThree((pt) => pt.events),
      ot = useThree((pt) => pt.setEvents),
      ut = useThree((pt) => pt.set),
      it = useThree((pt) => pt.get),
      ct = useThree((pt) => pt.performance),
      lt = e || tt,
      ht = o || at.connected || st.domElement,
      dt = reactExports.useMemo(() => new OrbitControls$1(lt), [lt])
    return (
      useFrame(() => {
        dt.enabled && dt.update()
      }, -1),
      reactExports.useEffect(
        () => (
          d && dt.connect(d === !0 ? ht : d),
          dt.connect(ht),
          () => void dt.dispose()
        ),
        [d, ht, a, dt, _e]
      ),
      reactExports.useEffect(() => {
        const pt = (yt) => {
            _e(), a && ct.regress(), g && g(yt)
          },
          vt = (yt) => {
            _ && _(yt)
          },
          _t = (yt) => {
            b && b(yt)
          }
        return (
          dt.addEventListener("change", pt),
          dt.addEventListener("start", vt),
          dt.addEventListener("end", _t),
          () => {
            dt.removeEventListener("start", vt),
              dt.removeEventListener("end", _t),
              dt.removeEventListener("change", pt)
          }
        )
      }, [g, _, b, dt, _e, ot]),
      reactExports.useEffect(() => {
        if (s) {
          const pt = it().controls
          return ut({ controls: dt }), () => ut({ controls: pt })
        }
      }, [s, dt]),
      reactExports.createElement(
        "primitive",
        _extends$1({ ref: $, object: dt, enableDamping: c }, j)
      )
    )
  }
)
var propTypes = { exports: {} },
  ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  ReactPropTypesSecret_1 = ReactPropTypesSecret$1,
  ReactPropTypesSecret = ReactPropTypesSecret_1
function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction
var factoryWithThrowingShims = function () {
  function s(o, c, d, g, _, b) {
    if (b !== ReactPropTypesSecret) {
      var j = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      )
      throw ((j.name = "Invariant Violation"), j)
    }
  }
  s.isRequired = s
  function e() {
    return s
  }
  var a = {
    array: s,
    bigint: s,
    bool: s,
    func: s,
    number: s,
    object: s,
    string: s,
    symbol: s,
    any: s,
    arrayOf: e,
    element: s,
    elementType: s,
    instanceOf: e,
    node: s,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction,
  }
  return (a.PropTypes = a), a
}
propTypes.exports = factoryWithThrowingShims()
var propTypesExports = propTypes.exports
const opaque_fragment = version >= 154 ? "opaque_fragment" : "output_fragment"
class PointMaterialImpl extends PointsMaterial {
  constructor(e) {
    super(e),
      (this.onBeforeCompile = (a, o) => {
        const { isWebGL2: c } = o.capabilities
        a.fragmentShader = a.fragmentShader.replace(
          `#include <${opaque_fragment}>`,
          `
        ${
          c
            ? `#include <${opaque_fragment}>`
            : `#extension GL_OES_standard_derivatives : enable
#include <${opaque_fragment}>`
        }
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <${
        version >= 154 ? "colorspace_fragment" : "encodings_fragment"
      }>
      `
        )
      })
  }
}
const PointMaterial = reactExports.forwardRef((s, e) => {
    const [a] = reactExports.useState(() => new PointMaterialImpl(null))
    return reactExports.createElement(
      "primitive",
      _extends$1({}, s, { object: a, ref: e, attach: "material" })
    )
  }),
  Float = reactExports.forwardRef(
    (
      {
        children: s,
        enabled: e = !0,
        speed: a = 1,
        rotationIntensity: o = 1,
        floatIntensity: c = 1,
        floatingRange: d = [-0.1, 0.1],
        ...g
      },
      _
    ) => {
      const b = reactExports.useRef(null),
        j = reactExports.useRef(Math.random() * 1e4)
      return (
        useFrame(($) => {
          var _e, tt
          if (!e || a === 0) return
          const st = j.current + $.clock.getElapsedTime()
          ;(b.current.rotation.x = (Math.cos((st / 4) * a) / 8) * o),
            (b.current.rotation.y = (Math.sin((st / 4) * a) / 8) * o),
            (b.current.rotation.z = (Math.sin((st / 4) * a) / 20) * o)
          let at = Math.sin((st / 4) * a) / 10
          ;(at = MathUtils.mapLinear(
            at,
            -0.1,
            0.1,
            (_e = d == null ? void 0 : d[0]) !== null && _e !== void 0
              ? _e
              : -0.1,
            (tt = d == null ? void 0 : d[1]) !== null && tt !== void 0
              ? tt
              : 0.1
          )),
            (b.current.position.y = at * c),
            b.current.updateMatrix()
        }),
        reactExports.createElement(
          "group",
          g,
          reactExports.createElement(
            "group",
            { ref: mergeRefs([b, _]), matrixAutoUpdate: !1 },
            s
          )
        )
      )
    }
  ),
  presetsObj = {
    apartment: "lebombo_1k.hdr",
    city: "potsdamer_platz_1k.hdr",
    dawn: "kiara_1_dawn_1k.hdr",
    forest: "forest_slope_1k.hdr",
    lobby: "st_fagans_interior_1k.hdr",
    night: "dikhololo_night_1k.hdr",
    park: "rooitou_park_1k.hdr",
    studio: "studio_small_03_1k.hdr",
    sunset: "venice_sunset_1k.hdr",
    warehouse: "empty_warehouse_01_1k.hdr",
  },
  CUBEMAP_ROOT =
    "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",
  isArray = (s) => Array.isArray(s)
function useEnvironment({
  files: s = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"],
  path: e = "",
  preset: a = void 0,
  encoding: o = void 0,
  extensions: c,
} = {}) {
  var d
  let g = null,
    _ = !1,
    b
  if (a) {
    if (!(a in presetsObj))
      throw new Error(
        "Preset must be one of: " + Object.keys(presetsObj).join(", ")
      )
    ;(s = presetsObj[a]), (e = CUBEMAP_ROOT)
  }
  if (
    ((_ = isArray(s)),
    (b = isArray(s)
      ? "cube"
      : s.startsWith("data:application/exr")
      ? "exr"
      : s.startsWith("data:application/hdr")
      ? "hdr"
      : (d = s.split(".").pop()) == null ||
        (d = d.split("?")) == null ||
        (d = d.shift()) == null
      ? void 0
      : d.toLowerCase()),
    (g = _
      ? CubeTextureLoader
      : b === "hdr"
      ? RGBELoader
      : b === "exr"
      ? EXRLoader
      : null),
    !g)
  )
    throw new Error("useEnvironment: Unrecognized file extension: " + s)
  const j = useLoader(g, _ ? [s] : s, (st) => {
      st.setPath == null || st.setPath(e), c && c(st)
    }),
    $ = _ ? j[0] : j
  $.mapping = _ ? CubeReflectionMapping : EquirectangularReflectionMapping
  const _e = 3001,
    tt = 3e3
  return (
    "colorSpace" in $
      ? ($.colorSpace = o ?? _ ? "srgb" : "srgb-linear")
      : ($.encoding = o ?? _ ? _e : tt),
    $
  )
}
const isRef = (s) => s.current && s.current.isScene,
  resolveScene = (s) => (isRef(s) ? s.current : s)
function setEnvProps(s, e, a, o, c = 0) {
  const d = resolveScene(e || a),
    g = d.background,
    _ = d.environment,
    b = d.backgroundBlurriness || 0
  return (
    s !== "only" && (d.environment = o),
    s && (d.background = o),
    s && d.backgroundBlurriness !== void 0 && (d.backgroundBlurriness = c),
    () => {
      s !== "only" && (d.environment = _),
        s && (d.background = g),
        s && d.backgroundBlurriness !== void 0 && (d.backgroundBlurriness = b)
    }
  )
}
function EnvironmentMap({ scene: s, background: e = !1, blur: a, map: o }) {
  const c = useThree((d) => d.scene)
  return (
    reactExports.useLayoutEffect(() => {
      if (o) return setEnvProps(e, s, c, o, a)
    }, [c, s, o, e, a]),
    null
  )
}
function EnvironmentCube({ background: s = !1, scene: e, blur: a, ...o }) {
  const c = useEnvironment(o),
    d = useThree((g) => g.scene)
  return (
    reactExports.useLayoutEffect(
      () => setEnvProps(s, e, d, c, a),
      [c, s, e, d, a]
    ),
    null
  )
}
function EnvironmentPortal({
  children: s,
  near: e = 1,
  far: a = 1e3,
  resolution: o = 256,
  frames: c = 1,
  map: d,
  background: g = !1,
  blur: _,
  scene: b,
  files: j,
  path: $,
  preset: _e = void 0,
  extensions: tt,
}) {
  const st = useThree((lt) => lt.gl),
    at = useThree((lt) => lt.scene),
    ot = reactExports.useRef(null),
    [ut] = reactExports.useState(() => new Scene()),
    it = reactExports.useMemo(() => {
      const lt = new WebGLCubeRenderTarget(o)
      return (lt.texture.type = HalfFloatType), lt
    }, [o])
  reactExports.useLayoutEffect(
    () => (
      c === 1 && ot.current.update(st, ut), setEnvProps(g, b, at, it.texture, _)
    ),
    [s, ut, it.texture, b, at, g, c, st]
  )
  let ct = 1
  return (
    useFrame(() => {
      ;(c === 1 / 0 || ct < c) && (ot.current.update(st, ut), ct++)
    }),
    reactExports.createElement(
      reactExports.Fragment,
      null,
      createPortal(
        reactExports.createElement(
          reactExports.Fragment,
          null,
          s,
          reactExports.createElement("cubeCamera", {
            ref: ot,
            args: [e, a, it],
          }),
          j || _e
            ? reactExports.createElement(EnvironmentCube, {
                background: !0,
                files: j,
                preset: _e,
                path: $,
                extensions: tt,
              })
            : d
            ? reactExports.createElement(EnvironmentMap, {
                background: !0,
                map: d,
                extensions: tt,
              })
            : null
        ),
        ut
      )
    )
  )
}
function EnvironmentGround(s) {
  var e, a, o, c
  const d = useEnvironment(s),
    g = s.map || d
  reactExports.useMemo(
    () => extend({ GroundProjectedEnvImpl: GroundProjectedEnv }),
    []
  )
  const _ = reactExports.useMemo(() => [g], [g]),
    b = (e = s.ground) == null ? void 0 : e.height,
    j = (a = s.ground) == null ? void 0 : a.radius,
    $ =
      (o = (c = s.ground) == null ? void 0 : c.scale) !== null && o !== void 0
        ? o
        : 1e3
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    reactExports.createElement(EnvironmentMap, _extends$1({}, s, { map: g })),
    reactExports.createElement("groundProjectedEnvImpl", {
      args: _,
      scale: $,
      height: b,
      radius: j,
    })
  )
}
function Environment(s) {
  return s.ground
    ? reactExports.createElement(EnvironmentGround, s)
    : s.map
    ? reactExports.createElement(EnvironmentMap, s)
    : s.children
    ? reactExports.createElement(EnvironmentPortal, s)
    : reactExports.createElement(EnvironmentCube, s)
}
const ContactShadows = reactExports.forwardRef(
  (
    {
      scale: s = 10,
      frames: e = 1 / 0,
      opacity: a = 1,
      width: o = 1,
      height: c = 1,
      blur: d = 1,
      near: g = 0,
      far: _ = 10,
      resolution: b = 512,
      smooth: j = !0,
      color: $ = "#000000",
      depthWrite: _e = !1,
      renderOrder: tt,
      ...st
    },
    at
  ) => {
    const ot = reactExports.useRef(null),
      ut = useThree((Nt) => Nt.scene),
      it = useThree((Nt) => Nt.gl),
      ct = reactExports.useRef(null)
    ;(o = o * (Array.isArray(s) ? s[0] : s || 1)),
      (c = c * (Array.isArray(s) ? s[1] : s || 1))
    const [lt, ht, dt, pt, vt, _t, yt] = reactExports.useMemo(() => {
        const Nt = new WebGLRenderTarget(b, b),
          Dt = new WebGLRenderTarget(b, b)
        Dt.texture.generateMipmaps = Nt.texture.generateMipmaps = !1
        const Mt = new PlaneGeometry(o, c).rotateX(Math.PI / 2),
          wt = new Mesh(Mt),
          gt = new MeshDepthMaterial()
        ;(gt.depthTest = gt.depthWrite = !1),
          (gt.onBeforeCompile = (Tt) => {
            ;(Tt.uniforms = {
              ...Tt.uniforms,
              ucolor: { value: new Color($) },
            }),
              (Tt.fragmentShader = Tt.fragmentShader.replace(
                "void main() {",
                `uniform vec3 ucolor;
           void main() {
          `
              )),
              (Tt.fragmentShader = Tt.fragmentShader.replace(
                "vec4( vec3( 1.0 - fragCoordZ ), opacity );",
                "vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );"
              ))
          })
        const At = new ShaderMaterial(HorizontalBlurShader),
          bt = new ShaderMaterial(VerticalBlurShader)
        return (bt.depthTest = At.depthTest = !1), [Nt, Mt, gt, wt, At, bt, Dt]
      }, [b, o, c, s, $]),
      Et = (Nt) => {
        ;(pt.visible = !0),
          (pt.material = vt),
          (vt.uniforms.tDiffuse.value = lt.texture),
          (vt.uniforms.h.value = (Nt * 1) / 256),
          it.setRenderTarget(yt),
          it.render(pt, ct.current),
          (pt.material = _t),
          (_t.uniforms.tDiffuse.value = yt.texture),
          (_t.uniforms.v.value = (Nt * 1) / 256),
          it.setRenderTarget(lt),
          it.render(pt, ct.current),
          (pt.visible = !1)
      }
    let Rt = 0,
      Ft,
      kt
    return (
      useFrame(() => {
        ct.current &&
          (e === 1 / 0 || Rt < e) &&
          (Rt++,
          (Ft = ut.background),
          (kt = ut.overrideMaterial),
          (ot.current.visible = !1),
          (ut.background = null),
          (ut.overrideMaterial = dt),
          it.setRenderTarget(lt),
          it.render(ut, ct.current),
          Et(d),
          j && Et(d * 0.4),
          it.setRenderTarget(null),
          (ot.current.visible = !0),
          (ut.overrideMaterial = kt),
          (ut.background = Ft))
      }),
      reactExports.useImperativeHandle(at, () => ot.current, []),
      reactExports.createElement(
        "group",
        _extends$1({ "rotation-x": Math.PI / 2 }, st, { ref: ot }),
        reactExports.createElement(
          "mesh",
          {
            renderOrder: tt,
            geometry: ht,
            scale: [1, -1, 1],
            rotation: [-Math.PI / 2, 0, 0],
          },
          reactExports.createElement("meshBasicMaterial", {
            transparent: !0,
            map: lt.texture,
            opacity: a,
            depthWrite: _e,
          })
        ),
        reactExports.createElement("orthographicCamera", {
          ref: ct,
          args: [-o / 2, o / 2, c / 2, -c / 2, g, _],
        })
      )
    )
  }
)
let i, positionRef
const context = reactExports.createContext(null),
  parentMatrix = new Matrix4(),
  position = new Vector3(),
  PointsInstances = reactExports.forwardRef(
    ({ children: s, range: e, limit: a = 1e3, ...o }, c) => {
      const d = reactExports.useRef(null),
        [g, _] = reactExports.useState([]),
        [[b, j, $]] = reactExports.useState(() => [
          new Float32Array(a * 3),
          Float32Array.from({ length: a * 3 }, () => 1),
          Float32Array.from({ length: a }, () => 1),
        ])
      reactExports.useEffect(() => {
        d.current.geometry.attributes.position.needsUpdate = !0
      }),
        useFrame(() => {
          for (
            d.current.updateMatrix(),
              d.current.updateMatrixWorld(),
              parentMatrix.copy(d.current.matrixWorld).invert(),
              d.current.geometry.drawRange.count = Math.min(
                a,
                e !== void 0 ? e : a,
                g.length
              ),
              i = 0;
            i < g.length;
            i++
          )
            (positionRef = g[i].current),
              positionRef.getWorldPosition(position).applyMatrix4(parentMatrix),
              position.toArray(b, i * 3),
              (d.current.geometry.attributes.position.needsUpdate = !0),
              (positionRef.matrixWorldNeedsUpdate = !0),
              positionRef.color.toArray(j, i * 3),
              (d.current.geometry.attributes.color.needsUpdate = !0),
              $.set([positionRef.size], i),
              (d.current.geometry.attributes.size.needsUpdate = !0)
        })
      const _e = reactExports.useMemo(
        () => ({
          getParent: () => d,
          subscribe: (tt) => (
            _((st) => [...st, tt]),
            () => _((st) => st.filter((at) => at.current !== tt.current))
          ),
        }),
        []
      )
      return reactExports.createElement(
        "points",
        _extends$1(
          {
            userData: { instances: g },
            matrixAutoUpdate: !1,
            ref: mergeRefs([c, d]),
            raycast: () => null,
          },
          o
        ),
        reactExports.createElement(
          "bufferGeometry",
          null,
          reactExports.createElement("bufferAttribute", {
            attach: "attributes-position",
            count: b.length / 3,
            array: b,
            itemSize: 3,
            usage: DynamicDrawUsage,
          }),
          reactExports.createElement("bufferAttribute", {
            attach: "attributes-color",
            count: j.length / 3,
            array: j,
            itemSize: 3,
            usage: DynamicDrawUsage,
          }),
          reactExports.createElement("bufferAttribute", {
            attach: "attributes-size",
            count: $.length,
            array: $,
            itemSize: 1,
            usage: DynamicDrawUsage,
          })
        ),
        reactExports.createElement(context.Provider, { value: _e }, s)
      )
    }
  ),
  PointsBuffer = reactExports.forwardRef(
    (
      { children: s, positions: e, colors: a, sizes: o, stride: c = 3, ...d },
      g
    ) => {
      const _ = reactExports.useRef(null)
      return (
        useFrame(() => {
          const b = _.current.geometry.attributes
          ;(b.position.needsUpdate = !0),
            a && (b.color.needsUpdate = !0),
            o && (b.size.needsUpdate = !0)
        }),
        reactExports.createElement(
          "points",
          _extends$1({ ref: mergeRefs([g, _]) }, d),
          reactExports.createElement(
            "bufferGeometry",
            null,
            reactExports.createElement("bufferAttribute", {
              attach: "attributes-position",
              count: e.length / c,
              array: e,
              itemSize: c,
              usage: DynamicDrawUsage,
            }),
            a &&
              reactExports.createElement("bufferAttribute", {
                attach: "attributes-color",
                count: a.length / c,
                array: a,
                itemSize: 3,
                usage: DynamicDrawUsage,
              }),
            o &&
              reactExports.createElement("bufferAttribute", {
                attach: "attributes-size",
                count: o.length / c,
                array: o,
                itemSize: 1,
                usage: DynamicDrawUsage,
              })
          ),
          s
        )
      )
    }
  ),
  Points = reactExports.forwardRef((s, e) =>
    s.positions instanceof Float32Array
      ? reactExports.createElement(PointsBuffer, _extends$1({}, s, { ref: e }))
      : reactExports.createElement(
          PointsInstances,
          _extends$1({}, s, { ref: e })
        )
  )
function Preload({ all: s, scene: e, camera: a }) {
  const o = useThree(({ gl: g }) => g),
    c = useThree(({ camera: g }) => g),
    d = useThree(({ scene: g }) => g)
  return (
    reactExports.useLayoutEffect(() => {
      const g = []
      s &&
        (e || d).traverse((j) => {
          j.visible === !1 && (g.push(j), (j.visible = !0))
        }),
        o.compile(e || d, a || c)
      const _ = new WebGLCubeRenderTarget(128)
      new CubeCamera(0.01, 1e5, _).update(o, e || d),
        _.dispose(),
        g.forEach((j) => (j.visible = !1))
    }, []),
    null
  )
}
const Loader = () => {
    const { progress: s } = useProgress()
    return jsxRuntimeExports.jsx(Html, {
      children: jsxRuntimeExports.jsx("span", {
        className: "canvas-load",
        children: jsxRuntimeExports.jsxs("p", {
          style: {
            fontSize: 14,
            color: "#f1f1f1",
            fontWeight: 800,
            marginTop: 40,
          },
          children: [s.toFixed(2), "%"],
        }),
      }),
    })
  },
  Earth = () => {
    const s = useGLTF("./planet/scene.gltf")
    return jsxRuntimeExports.jsx("primitive", {
      object: s.scene,
      scale: 2.5,
      "position-y": 0,
      "rotation-y": 0,
    })
  },
  EarthCanvas = () =>
    jsxRuntimeExports.jsx(Canvas, {
      shadows: !0,
      className: "cursor-pointer",
      frameloop: "demand",
      dpr: [1, 2],
      gl: { preserveDrawingBuffer: !0 },
      camera: { fov: 45, near: 0.1, far: 100, position: [-4, 3, 6] },
      children: jsxRuntimeExports.jsxs(reactExports.Suspense, {
        fallback: jsxRuntimeExports.jsx(Loader, {}),
        children: [
          jsxRuntimeExports.jsx(OrbitControls, {
            autoRotate: !0,
            enableZoom: !1,
            maxPolarAngle: Math.PI / 2,
            minPolarAngle: Math.PI / 2,
          }),
          jsxRuntimeExports.jsx(Earth, {}),
          jsxRuntimeExports.jsx(Preload, { all: !0 }),
        ],
      }),
    }),
  Ball = (s) => {
    const [e] = useTexture([s.imgUrl])
    return jsxRuntimeExports.jsxs(Float, {
      speed: 2,
      rotationIntensity: 1,
      floatIntensity: 2,
      children: [
        jsxRuntimeExports.jsx("ambientLight", { intensity: 0.25 }),
        jsxRuntimeExports.jsx("hemisphereLight", { intensity: 0.1 }),
        jsxRuntimeExports.jsx("directionalLight", { position: [0, 0, 0.05] }),
        jsxRuntimeExports.jsxs("mesh", {
          castShadow: !0,
          receiveShadow: !0,
          scale: 2.75,
          children: [
            jsxRuntimeExports.jsx("icosahedronGeometry", { args: [1, 1] }),
            jsxRuntimeExports.jsx("meshStandardMaterial", {
              color: "#fff8eb",
              polygonOffset: !0,
              polygonOffsetFactor: -5,
              flatShading: !0,
            }),
            jsxRuntimeExports.jsx(Decal, {
              position: [0, 0, 1],
              rotation: [2 * Math.PI, 0, 6.25],
              scale: 1,
              map: e,
              flatShading: !0,
            }),
          ],
        }),
      ],
    })
  },
  BallCanvas = ({ icon: s }) =>
    jsxRuntimeExports.jsxs(Canvas, {
      frameloop: "always",
      dpr: [1, 2],
      gl: { preserveDrawingBuffer: !0 },
      children: [
        jsxRuntimeExports.jsxs(reactExports.Suspense, {
          fallback: jsxRuntimeExports.jsx(Loader, {}),
          children: [
            jsxRuntimeExports.jsx(OrbitControls, { enableZoom: !1 }),
            jsxRuntimeExports.jsx(Ball, { imgUrl: s }),
          ],
        }),
        jsxRuntimeExports.jsx(Preload, { all: !0 }),
      ],
    }),
  Stars = (s) => {
    const e = reactExports.useRef(),
      [a] = reactExports.useState(() =>
        inSphere(new Float32Array(3e3), { radius: 1.2 })
      )
    return (
      useFrame((o, c) => {
        ;(e.current.rotation.x -= c / 30), (e.current.rotation.y -= c / 50)
      }),
      jsxRuntimeExports.jsx("group", {
        rotation: [0, 0, Math.PI / 4],
        children: jsxRuntimeExports.jsx(Points, {
          ref: e,
          positions: a,
          stride: 3,
          frustumCulled: !0,
          ...s,
          children: jsxRuntimeExports.jsx(PointMaterial, {
            transparent: !0,
            color: "#f272c8",
            size: 0.0017,
            sizeAttenuation: !0,
            depthWrite: !1,
          }),
        }),
      })
    )
  },
  StarsCanvas = () =>
    jsxRuntimeExports.jsx("div", {
      className: "w-full h-auto absolute inset-0 z-[-1]",
      children: jsxRuntimeExports.jsxs(Canvas, {
        camera: { position: [0, 0, 1] },
        children: [
          jsxRuntimeExports.jsx(reactExports.Suspense, {
            fallback: null,
            children: jsxRuntimeExports.jsx(Stars, {}),
          }),
          jsxRuntimeExports.jsx(Preload, { all: !0 }),
        ],
      }),
    }),
  MotionConfigContext = reactExports.createContext({
    transformPagePoint: (s) => s,
    isStatic: !1,
    reducedMotion: "never",
  }),
  MotionContext = reactExports.createContext({}),
  PresenceContext = reactExports.createContext(null),
  isBrowser = typeof document < "u",
  useIsomorphicLayoutEffect = isBrowser
    ? reactExports.useLayoutEffect
    : reactExports.useEffect,
  LazyContext = reactExports.createContext({ strict: !1 }),
  camelToDash = (s) => s.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
  optimizedAppearDataId = "framerAppearId",
  optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId)
function useVisualElement(s, e, a, o) {
  const { visualElement: c } = reactExports.useContext(MotionContext),
    d = reactExports.useContext(LazyContext),
    g = reactExports.useContext(PresenceContext),
    _ = reactExports.useContext(MotionConfigContext).reducedMotion,
    b = reactExports.useRef()
  ;(o = o || d.renderer),
    !b.current &&
      o &&
      (b.current = o(s, {
        visualState: e,
        parent: c,
        props: a,
        presenceContext: g,
        blockInitialAnimation: g ? g.initial === !1 : !1,
        reducedMotionConfig: _,
      }))
  const j = b.current
  reactExports.useInsertionEffect(() => {
    j && j.update(a, g)
  })
  const $ = reactExports.useRef(
    !!(a[optimizedAppearDataAttribute] && !window.HandoffComplete)
  )
  return (
    useIsomorphicLayoutEffect(() => {
      j &&
        (j.render(),
        $.current && j.animationState && j.animationState.animateChanges())
    }),
    reactExports.useEffect(() => {
      j &&
        (j.updateFeatures(),
        !$.current && j.animationState && j.animationState.animateChanges(),
        $.current && (($.current = !1), (window.HandoffComplete = !0)))
    }),
    j
  )
}
function isRefObject(s) {
  return (
    s &&
    typeof s == "object" &&
    Object.prototype.hasOwnProperty.call(s, "current")
  )
}
function useMotionRef(s, e, a) {
  return reactExports.useCallback(
    (o) => {
      o && s.mount && s.mount(o),
        e && (o ? e.mount(o) : e.unmount()),
        a && (typeof a == "function" ? a(o) : isRefObject(a) && (a.current = o))
    },
    [e]
  )
}
function isVariantLabel(s) {
  return typeof s == "string" || Array.isArray(s)
}
function isAnimationControls(s) {
  return s !== null && typeof s == "object" && typeof s.start == "function"
}
const variantPriorityOrder = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  variantProps = ["initial", ...variantPriorityOrder]
function isControllingVariants(s) {
  return (
    isAnimationControls(s.animate) ||
    variantProps.some((e) => isVariantLabel(s[e]))
  )
}
function isVariantNode(s) {
  return !!(isControllingVariants(s) || s.variants)
}
function getCurrentTreeVariants(s, e) {
  if (isControllingVariants(s)) {
    const { initial: a, animate: o } = s
    return {
      initial: a === !1 || isVariantLabel(a) ? a : void 0,
      animate: isVariantLabel(o) ? o : void 0,
    }
  }
  return s.inherit !== !1 ? e : {}
}
function useCreateMotionContext(s) {
  const { initial: e, animate: a } = getCurrentTreeVariants(
    s,
    reactExports.useContext(MotionContext)
  )
  return reactExports.useMemo(
    () => ({ initial: e, animate: a }),
    [variantLabelsAsDependency(e), variantLabelsAsDependency(a)]
  )
}
function variantLabelsAsDependency(s) {
  return Array.isArray(s) ? s.join(" ") : s
}
const featureProps = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  featureDefinitions = {}
for (const s in featureProps)
  featureDefinitions[s] = {
    isEnabled: (e) => featureProps[s].some((a) => !!e[a]),
  }
function loadFeatures(s) {
  for (const e in s)
    featureDefinitions[e] = { ...featureDefinitions[e], ...s[e] }
}
const LayoutGroupContext = reactExports.createContext({}),
  SwitchLayoutGroupContext = reactExports.createContext({}),
  motionComponentSymbol = Symbol.for("motionComponentSymbol")
function createMotionComponent({
  preloadedFeatures: s,
  createVisualElement: e,
  useRender: a,
  useVisualState: o,
  Component: c,
}) {
  s && loadFeatures(s)
  function d(_, b) {
    let j
    const $ = {
        ...reactExports.useContext(MotionConfigContext),
        ..._,
        layoutId: useLayoutId(_),
      },
      { isStatic: _e } = $,
      tt = useCreateMotionContext(_),
      st = o(_, _e)
    if (!_e && isBrowser) {
      tt.visualElement = useVisualElement(c, st, $, e)
      const at = reactExports.useContext(SwitchLayoutGroupContext),
        ot = reactExports.useContext(LazyContext).strict
      tt.visualElement && (j = tt.visualElement.loadFeatures($, ot, s, at))
    }
    return reactExports.createElement(
      MotionContext.Provider,
      { value: tt },
      j && tt.visualElement
        ? reactExports.createElement(j, {
            visualElement: tt.visualElement,
            ...$,
          })
        : null,
      a(c, _, useMotionRef(st, tt.visualElement, b), st, _e, tt.visualElement)
    )
  }
  const g = reactExports.forwardRef(d)
  return (g[motionComponentSymbol] = c), g
}
function useLayoutId({ layoutId: s }) {
  const e = reactExports.useContext(LayoutGroupContext).id
  return e && s !== void 0 ? e + "-" + s : s
}
function createMotionProxy(s) {
  function e(o, c = {}) {
    return createMotionComponent(s(o, c))
  }
  if (typeof Proxy > "u") return e
  const a = new Map()
  return new Proxy(e, { get: (o, c) => (a.has(c) || a.set(c, e(c)), a.get(c)) })
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
]
function isSVGComponent(s) {
  return typeof s != "string" || s.includes("-")
    ? !1
    : !!(lowercaseSVGElements.indexOf(s) > -1 || /[A-Z]/.test(s))
}
const scaleCorrectors = {}
function addScaleCorrector(s) {
  Object.assign(scaleCorrectors, s)
}
const transformPropOrder = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  transformProps = new Set(transformPropOrder)
function isForcedMotionValue(s, { layout: e, layoutId: a }) {
  return (
    transformProps.has(s) ||
    s.startsWith("origin") ||
    ((e || a !== void 0) && (!!scaleCorrectors[s] || s === "opacity"))
  )
}
const isMotionValue = (s) => !!(s && s.getVelocity),
  translateAlias = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  numTransforms = transformPropOrder.length
function buildTransform(
  s,
  { enableHardwareAcceleration: e = !0, allowTransformNone: a = !0 },
  o,
  c
) {
  let d = ""
  for (let g = 0; g < numTransforms; g++) {
    const _ = transformPropOrder[g]
    if (s[_] !== void 0) {
      const b = translateAlias[_] || _
      d += `${b}(${s[_]}) `
    }
  }
  return (
    e && !s.z && (d += "translateZ(0)"),
    (d = d.trim()),
    c ? (d = c(s, o ? "" : d)) : a && o && (d = "none"),
    d
  )
}
const checkStringStartsWith = (s) => (e) =>
    typeof e == "string" && e.startsWith(s),
  isCSSVariableName = checkStringStartsWith("--"),
  isCSSVariableToken = checkStringStartsWith("var(--"),
  cssVariableRegex =
    /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,
  getValueAsType = (s, e) => (e && typeof s == "number" ? e.transform(s) : s),
  clamp$1 = (s, e, a) => Math.min(Math.max(a, s), e),
  number = {
    test: (s) => typeof s == "number",
    parse: parseFloat,
    transform: (s) => s,
  },
  alpha = { ...number, transform: (s) => clamp$1(0, 1, s) },
  scale = { ...number, default: 1 },
  sanitize = (s) => Math.round(s * 1e5) / 1e5,
  floatRegex = /(-)?([\d]*\.?[\d])+/g,
  colorRegex =
    /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
  singleColorRegex =
    /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i
function isString(s) {
  return typeof s == "string"
}
const createUnitType = (s) => ({
    test: (e) => isString(e) && e.endsWith(s) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${s}`,
  }),
  degrees = createUnitType("deg"),
  percent = createUnitType("%"),
  px = createUnitType("px"),
  vh = createUnitType("vh"),
  vw = createUnitType("vw"),
  progressPercentage = {
    ...percent,
    parse: (s) => percent.parse(s) / 100,
    transform: (s) => percent.transform(s * 100),
  },
  int = { ...number, transform: Math.round },
  numberValueTypes = {
    borderWidth: px,
    borderTopWidth: px,
    borderRightWidth: px,
    borderBottomWidth: px,
    borderLeftWidth: px,
    borderRadius: px,
    radius: px,
    borderTopLeftRadius: px,
    borderTopRightRadius: px,
    borderBottomRightRadius: px,
    borderBottomLeftRadius: px,
    width: px,
    maxWidth: px,
    height: px,
    maxHeight: px,
    size: px,
    top: px,
    right: px,
    bottom: px,
    left: px,
    padding: px,
    paddingTop: px,
    paddingRight: px,
    paddingBottom: px,
    paddingLeft: px,
    margin: px,
    marginTop: px,
    marginRight: px,
    marginBottom: px,
    marginLeft: px,
    rotate: degrees,
    rotateX: degrees,
    rotateY: degrees,
    rotateZ: degrees,
    scale,
    scaleX: scale,
    scaleY: scale,
    scaleZ: scale,
    skew: degrees,
    skewX: degrees,
    skewY: degrees,
    distance: px,
    translateX: px,
    translateY: px,
    translateZ: px,
    x: px,
    y: px,
    z: px,
    perspective: px,
    transformPerspective: px,
    opacity: alpha,
    originX: progressPercentage,
    originY: progressPercentage,
    originZ: px,
    zIndex: int,
    fillOpacity: alpha,
    strokeOpacity: alpha,
    numOctaves: int,
  }
function buildHTMLStyles(s, e, a, o) {
  const { style: c, vars: d, transform: g, transformOrigin: _ } = s
  let b = !1,
    j = !1,
    $ = !0
  for (const _e in e) {
    const tt = e[_e]
    if (isCSSVariableName(_e)) {
      d[_e] = tt
      continue
    }
    const st = numberValueTypes[_e],
      at = getValueAsType(tt, st)
    if (transformProps.has(_e)) {
      if (((b = !0), (g[_e] = at), !$)) continue
      tt !== (st.default || 0) && ($ = !1)
    } else _e.startsWith("origin") ? ((j = !0), (_[_e] = at)) : (c[_e] = at)
  }
  if (
    (e.transform ||
      (b || o
        ? (c.transform = buildTransform(s.transform, a, $, o))
        : c.transform && (c.transform = "none")),
    j)
  ) {
    const { originX: _e = "50%", originY: tt = "50%", originZ: st = 0 } = _
    c.transformOrigin = `${_e} ${tt} ${st}`
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {},
})
function copyRawValuesOnly(s, e, a) {
  for (const o in e)
    !isMotionValue(e[o]) && !isForcedMotionValue(o, a) && (s[o] = e[o])
}
function useInitialMotionValues({ transformTemplate: s }, e, a) {
  return reactExports.useMemo(() => {
    const o = createHtmlRenderState()
    return (
      buildHTMLStyles(o, e, { enableHardwareAcceleration: !a }, s),
      Object.assign({}, o.vars, o.style)
    )
  }, [e])
}
function useStyle(s, e, a) {
  const o = s.style || {},
    c = {}
  return (
    copyRawValuesOnly(c, o, s),
    Object.assign(c, useInitialMotionValues(s, e, a)),
    s.transformValues ? s.transformValues(c) : c
  )
}
function useHTMLProps(s, e, a) {
  const o = {},
    c = useStyle(s, e, a)
  return (
    s.drag &&
      s.dragListener !== !1 &&
      ((o.draggable = !1),
      (c.userSelect = c.WebkitUserSelect = c.WebkitTouchCallout = "none"),
      (c.touchAction =
        s.drag === !0 ? "none" : `pan-${s.drag === "x" ? "y" : "x"}`)),
    s.tabIndex === void 0 &&
      (s.onTap || s.onTapStart || s.whileTap) &&
      (o.tabIndex = 0),
    (o.style = c),
    o
  )
}
const validMotionProps = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
])
function isValidMotionProp(s) {
  return (
    s.startsWith("while") ||
    (s.startsWith("drag") && s !== "draggable") ||
    s.startsWith("layout") ||
    s.startsWith("onTap") ||
    s.startsWith("onPan") ||
    s.startsWith("onLayout") ||
    validMotionProps.has(s)
  )
}
let shouldForward = (s) => !isValidMotionProp(s)
function loadExternalIsValidProp(s) {
  s &&
    (shouldForward = (e) => (e.startsWith("on") ? !isValidMotionProp(e) : s(e)))
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default)
} catch {}
function filterProps(s, e, a) {
  const o = {}
  for (const c in s)
    (c === "values" && typeof s.values == "object") ||
      ((shouldForward(c) ||
        (a === !0 && isValidMotionProp(c)) ||
        (!e && !isValidMotionProp(c)) ||
        (s.draggable && c.startsWith("onDrag"))) &&
        (o[c] = s[c]))
  return o
}
function calcOrigin$1(s, e, a) {
  return typeof s == "string" ? s : px.transform(e + a * s)
}
function calcSVGTransformOrigin(s, e, a) {
  const o = calcOrigin$1(e, s.x, s.width),
    c = calcOrigin$1(a, s.y, s.height)
  return `${o} ${c}`
}
const dashKeys = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  camelKeys = { offset: "strokeDashoffset", array: "strokeDasharray" }
function buildSVGPath(s, e, a = 1, o = 0, c = !0) {
  s.pathLength = 1
  const d = c ? dashKeys : camelKeys
  s[d.offset] = px.transform(-o)
  const g = px.transform(e),
    _ = px.transform(a)
  s[d.array] = `${g} ${_}`
}
function buildSVGAttrs(
  s,
  {
    attrX: e,
    attrY: a,
    attrScale: o,
    originX: c,
    originY: d,
    pathLength: g,
    pathSpacing: _ = 1,
    pathOffset: b = 0,
    ...j
  },
  $,
  _e,
  tt
) {
  if ((buildHTMLStyles(s, j, $, tt), _e)) {
    s.style.viewBox && (s.attrs.viewBox = s.style.viewBox)
    return
  }
  ;(s.attrs = s.style), (s.style = {})
  const { attrs: st, style: at, dimensions: ot } = s
  st.transform && (ot && (at.transform = st.transform), delete st.transform),
    ot &&
      (c !== void 0 || d !== void 0 || at.transform) &&
      (at.transformOrigin = calcSVGTransformOrigin(
        ot,
        c !== void 0 ? c : 0.5,
        d !== void 0 ? d : 0.5
      )),
    e !== void 0 && (st.x = e),
    a !== void 0 && (st.y = a),
    o !== void 0 && (st.scale = o),
    g !== void 0 && buildSVGPath(st, g, _, b, !1)
}
const createSvgRenderState = () => ({ ...createHtmlRenderState(), attrs: {} }),
  isSVGTag = (s) => typeof s == "string" && s.toLowerCase() === "svg"
function useSVGProps(s, e, a, o) {
  const c = reactExports.useMemo(() => {
    const d = createSvgRenderState()
    return (
      buildSVGAttrs(
        d,
        e,
        { enableHardwareAcceleration: !1 },
        isSVGTag(o),
        s.transformTemplate
      ),
      { ...d.attrs, style: { ...d.style } }
    )
  }, [e])
  if (s.style) {
    const d = {}
    copyRawValuesOnly(d, s.style, s), (c.style = { ...d, ...c.style })
  }
  return c
}
function createUseRender(s = !1) {
  return (a, o, c, { latestValues: d }, g) => {
    const b = (isSVGComponent(a) ? useSVGProps : useHTMLProps)(o, d, g, a),
      $ = { ...filterProps(o, typeof a == "string", s), ...b, ref: c },
      { children: _e } = o,
      tt = reactExports.useMemo(() => (isMotionValue(_e) ? _e.get() : _e), [_e])
    return reactExports.createElement(a, { ...$, children: tt })
  }
}
function renderHTML(s, { style: e, vars: a }, o, c) {
  Object.assign(s.style, e, c && c.getProjectionStyles(o))
  for (const d in a) s.style.setProperty(d, a[d])
}
const camelCaseAttributes = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
])
function renderSVG(s, e, a, o) {
  renderHTML(s, e, void 0, o)
  for (const c in e.attrs)
    s.setAttribute(camelCaseAttributes.has(c) ? c : camelToDash(c), e.attrs[c])
}
function scrapeMotionValuesFromProps$1(s, e) {
  const { style: a } = s,
    o = {}
  for (const c in a)
    (isMotionValue(a[c]) ||
      (e.style && isMotionValue(e.style[c])) ||
      isForcedMotionValue(c, s)) &&
      (o[c] = a[c])
  return o
}
function scrapeMotionValuesFromProps(s, e) {
  const a = scrapeMotionValuesFromProps$1(s, e)
  for (const o in s)
    if (isMotionValue(s[o]) || isMotionValue(e[o])) {
      const c =
        transformPropOrder.indexOf(o) !== -1
          ? "attr" + o.charAt(0).toUpperCase() + o.substring(1)
          : o
      a[c] = s[o]
    }
  return a
}
function resolveVariantFromProps(s, e, a, o = {}, c = {}) {
  return (
    typeof e == "function" && (e = e(a !== void 0 ? a : s.custom, o, c)),
    typeof e == "string" && (e = s.variants && s.variants[e]),
    typeof e == "function" && (e = e(a !== void 0 ? a : s.custom, o, c)),
    e
  )
}
function useConstant(s) {
  const e = reactExports.useRef(null)
  return e.current === null && (e.current = s()), e.current
}
const isKeyframesTarget = (s) => Array.isArray(s),
  isCustomValue = (s) => !!(s && typeof s == "object" && s.mix && s.toValue),
  resolveFinalValueInKeyframes = (s) =>
    isKeyframesTarget(s) ? s[s.length - 1] || 0 : s
function resolveMotionValue(s) {
  const e = isMotionValue(s) ? s.get() : s
  return isCustomValue(e) ? e.toValue() : e
}
function makeState(
  { scrapeMotionValuesFromProps: s, createRenderState: e, onMount: a },
  o,
  c,
  d
) {
  const g = { latestValues: makeLatestValues(o, c, d, s), renderState: e() }
  return a && (g.mount = (_) => a(o, _, g)), g
}
const makeUseVisualState = (s) => (e, a) => {
  const o = reactExports.useContext(MotionContext),
    c = reactExports.useContext(PresenceContext),
    d = () => makeState(s, e, o, c)
  return a ? d() : useConstant(d)
}
function makeLatestValues(s, e, a, o) {
  const c = {},
    d = o(s, {})
  for (const tt in d) c[tt] = resolveMotionValue(d[tt])
  let { initial: g, animate: _ } = s
  const b = isControllingVariants(s),
    j = isVariantNode(s)
  e &&
    j &&
    !b &&
    s.inherit !== !1 &&
    (g === void 0 && (g = e.initial), _ === void 0 && (_ = e.animate))
  let $ = a ? a.initial === !1 : !1
  $ = $ || g === !1
  const _e = $ ? _ : g
  return (
    _e &&
      typeof _e != "boolean" &&
      !isAnimationControls(_e) &&
      (Array.isArray(_e) ? _e : [_e]).forEach((st) => {
        const at = resolveVariantFromProps(s, st)
        if (!at) return
        const { transitionEnd: ot, transition: ut, ...it } = at
        for (const ct in it) {
          let lt = it[ct]
          if (Array.isArray(lt)) {
            const ht = $ ? lt.length - 1 : 0
            lt = lt[ht]
          }
          lt !== null && (c[ct] = lt)
        }
        for (const ct in ot) c[ct] = ot[ct]
      }),
    c
  )
}
const noop = (s) => s
class Queue {
  constructor() {
    ;(this.order = []), (this.scheduled = new Set())
  }
  add(e) {
    if (!this.scheduled.has(e))
      return this.scheduled.add(e), this.order.push(e), !0
  }
  remove(e) {
    const a = this.order.indexOf(e)
    a !== -1 && (this.order.splice(a, 1), this.scheduled.delete(e))
  }
  clear() {
    ;(this.order.length = 0), this.scheduled.clear()
  }
}
function createRenderStep(s) {
  let e = new Queue(),
    a = new Queue(),
    o = 0,
    c = !1,
    d = !1
  const g = new WeakSet(),
    _ = {
      schedule: (b, j = !1, $ = !1) => {
        const _e = $ && c,
          tt = _e ? e : a
        return j && g.add(b), tt.add(b) && _e && c && (o = e.order.length), b
      },
      cancel: (b) => {
        a.remove(b), g.delete(b)
      },
      process: (b) => {
        if (c) {
          d = !0
          return
        }
        if (((c = !0), ([e, a] = [a, e]), a.clear(), (o = e.order.length), o))
          for (let j = 0; j < o; j++) {
            const $ = e.order[j]
            $(b), g.has($) && (_.schedule($), s())
          }
        ;(c = !1), d && ((d = !1), _.process(b))
      },
    }
  return _
}
const stepsOrder = [
    "prepare",
    "read",
    "update",
    "preRender",
    "render",
    "postRender",
  ],
  maxElapsed = 40
function createRenderBatcher(s, e) {
  let a = !1,
    o = !0
  const c = { delta: 0, timestamp: 0, isProcessing: !1 },
    d = stepsOrder.reduce(
      (_e, tt) => ((_e[tt] = createRenderStep(() => (a = !0))), _e),
      {}
    ),
    g = (_e) => d[_e].process(c),
    _ = () => {
      const _e = performance.now()
      ;(a = !1),
        (c.delta = o
          ? 1e3 / 60
          : Math.max(Math.min(_e - c.timestamp, maxElapsed), 1)),
        (c.timestamp = _e),
        (c.isProcessing = !0),
        stepsOrder.forEach(g),
        (c.isProcessing = !1),
        a && e && ((o = !1), s(_))
    },
    b = () => {
      ;(a = !0), (o = !0), c.isProcessing || s(_)
    }
  return {
    schedule: stepsOrder.reduce((_e, tt) => {
      const st = d[tt]
      return (
        (_e[tt] = (at, ot = !1, ut = !1) => (
          a || b(), st.schedule(at, ot, ut)
        )),
        _e
      )
    }, {}),
    cancel: (_e) => stepsOrder.forEach((tt) => d[tt].cancel(_e)),
    state: c,
    steps: d,
  }
}
const {
    schedule: frame,
    cancel: cancelFrame,
    state: frameData,
    steps,
  } = createRenderBatcher(
    typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop,
    !0
  ),
  svgMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps,
      createRenderState: createSvgRenderState,
      onMount: (s, e, { renderState: a, latestValues: o }) => {
        frame.read(() => {
          try {
            a.dimensions =
              typeof e.getBBox == "function"
                ? e.getBBox()
                : e.getBoundingClientRect()
          } catch {
            a.dimensions = { x: 0, y: 0, width: 0, height: 0 }
          }
        }),
          frame.render(() => {
            buildSVGAttrs(
              a,
              o,
              { enableHardwareAcceleration: !1 },
              isSVGTag(e.tagName),
              s.transformTemplate
            ),
              renderSVG(e, a)
          })
      },
    }),
  },
  htmlMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
      createRenderState: createHtmlRenderState,
    }),
  }
function createDomMotionConfig(s, { forwardMotionProps: e = !1 }, a, o) {
  return {
    ...(isSVGComponent(s) ? svgMotionConfig : htmlMotionConfig),
    preloadedFeatures: a,
    useRender: createUseRender(e),
    createVisualElement: o,
    Component: s,
  }
}
function addDomEvent(s, e, a, o = { passive: !0 }) {
  return s.addEventListener(e, a, o), () => s.removeEventListener(e, a)
}
const isPrimaryPointer = (s) =>
  s.pointerType === "mouse"
    ? typeof s.button != "number" || s.button <= 0
    : s.isPrimary !== !1
function extractEventInfo(s, e = "page") {
  return { point: { x: s[e + "X"], y: s[e + "Y"] } }
}
const addPointerInfo = (s) => (e) =>
  isPrimaryPointer(e) && s(e, extractEventInfo(e))
function addPointerEvent(s, e, a, o) {
  return addDomEvent(s, e, addPointerInfo(a), o)
}
const combineFunctions = (s, e) => (a) => e(s(a)),
  pipe$1 = (...s) => s.reduce(combineFunctions)
function createLock(s) {
  let e = null
  return () => {
    const a = () => {
      e = null
    }
    return e === null ? ((e = s), a) : !1
  }
}
const globalHorizontalLock = createLock("dragHorizontal"),
  globalVerticalLock = createLock("dragVertical")
function getGlobalLock(s) {
  let e = !1
  if (s === "y") e = globalVerticalLock()
  else if (s === "x") e = globalHorizontalLock()
  else {
    const a = globalHorizontalLock(),
      o = globalVerticalLock()
    a && o
      ? (e = () => {
          a(), o()
        })
      : (a && a(), o && o())
  }
  return e
}
function isDragActive() {
  const s = getGlobalLock(!0)
  return s ? (s(), !1) : !0
}
class Feature {
  constructor(e) {
    ;(this.isMounted = !1), (this.node = e)
  }
  update() {}
}
function addHoverEvent(s, e) {
  const a = "pointer" + (e ? "enter" : "leave"),
    o = "onHover" + (e ? "Start" : "End"),
    c = (d, g) => {
      if (d.pointerType === "touch" || isDragActive()) return
      const _ = s.getProps()
      s.animationState &&
        _.whileHover &&
        s.animationState.setActive("whileHover", e),
        _[o] && frame.update(() => _[o](d, g))
    }
  return addPointerEvent(s.current, a, c, { passive: !s.getProps()[o] })
}
class HoverGesture extends Feature {
  mount() {
    this.unmount = pipe$1(
      addHoverEvent(this.node, !0),
      addHoverEvent(this.node, !1)
    )
  }
  unmount() {}
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments), (this.isActive = !1)
  }
  onFocus() {
    let e = !1
    try {
      e = this.node.current.matches(":focus-visible")
    } catch {
      e = !0
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0))
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1))
  }
  mount() {
    this.unmount = pipe$1(
      addDomEvent(this.node.current, "focus", () => this.onFocus()),
      addDomEvent(this.node.current, "blur", () => this.onBlur())
    )
  }
  unmount() {}
}
const isNodeOrChild = (s, e) =>
  e ? (s === e ? !0 : isNodeOrChild(s, e.parentElement)) : !1
function fireSyntheticPointerEvent(s, e) {
  if (!e) return
  const a = new PointerEvent("pointer" + s)
  e(a, extractEventInfo(a))
}
class PressGesture extends Feature {
  constructor() {
    super(...arguments),
      (this.removeStartListeners = noop),
      (this.removeEndListeners = noop),
      (this.removeAccessibleListeners = noop),
      (this.startPointerPress = (e, a) => {
        if (this.isPressing) return
        this.removeEndListeners()
        const o = this.node.getProps(),
          d = addPointerEvent(
            window,
            "pointerup",
            (_, b) => {
              if (!this.checkPressEnd()) return
              const {
                onTap: j,
                onTapCancel: $,
                globalTapTarget: _e,
              } = this.node.getProps()
              frame.update(() => {
                !_e && !isNodeOrChild(this.node.current, _.target)
                  ? $ && $(_, b)
                  : j && j(_, b)
              })
            },
            { passive: !(o.onTap || o.onPointerUp) }
          ),
          g = addPointerEvent(
            window,
            "pointercancel",
            (_, b) => this.cancelPress(_, b),
            { passive: !(o.onTapCancel || o.onPointerCancel) }
          )
        ;(this.removeEndListeners = pipe$1(d, g)), this.startPress(e, a)
      }),
      (this.startAccessiblePress = () => {
        const e = (d) => {
            if (d.key !== "Enter" || this.isPressing) return
            const g = (_) => {
              _.key !== "Enter" ||
                !this.checkPressEnd() ||
                fireSyntheticPointerEvent("up", (b, j) => {
                  const { onTap: $ } = this.node.getProps()
                  $ && frame.update(() => $(b, j))
                })
            }
            this.removeEndListeners(),
              (this.removeEndListeners = addDomEvent(
                this.node.current,
                "keyup",
                g
              )),
              fireSyntheticPointerEvent("down", (_, b) => {
                this.startPress(_, b)
              })
          },
          a = addDomEvent(this.node.current, "keydown", e),
          o = () => {
            this.isPressing &&
              fireSyntheticPointerEvent("cancel", (d, g) =>
                this.cancelPress(d, g)
              )
          },
          c = addDomEvent(this.node.current, "blur", o)
        this.removeAccessibleListeners = pipe$1(a, c)
      })
  }
  startPress(e, a) {
    this.isPressing = !0
    const { onTapStart: o, whileTap: c } = this.node.getProps()
    c &&
      this.node.animationState &&
      this.node.animationState.setActive("whileTap", !0),
      o && frame.update(() => o(e, a))
  }
  checkPressEnd() {
    return (
      this.removeEndListeners(),
      (this.isPressing = !1),
      this.node.getProps().whileTap &&
        this.node.animationState &&
        this.node.animationState.setActive("whileTap", !1),
      !isDragActive()
    )
  }
  cancelPress(e, a) {
    if (!this.checkPressEnd()) return
    const { onTapCancel: o } = this.node.getProps()
    o && frame.update(() => o(e, a))
  }
  mount() {
    const e = this.node.getProps(),
      a = addPointerEvent(
        e.globalTapTarget ? window : this.node.current,
        "pointerdown",
        this.startPointerPress,
        { passive: !(e.onTapStart || e.onPointerStart) }
      ),
      o = addDomEvent(this.node.current, "focus", this.startAccessiblePress)
    this.removeStartListeners = pipe$1(a, o)
  }
  unmount() {
    this.removeStartListeners(),
      this.removeEndListeners(),
      this.removeAccessibleListeners()
  }
}
const observerCallbacks = new WeakMap(),
  observers = new WeakMap(),
  fireObserverCallback = (s) => {
    const e = observerCallbacks.get(s.target)
    e && e(s)
  },
  fireAllObserverCallbacks = (s) => {
    s.forEach(fireObserverCallback)
  }
function initIntersectionObserver({ root: s, ...e }) {
  const a = s || document
  observers.has(a) || observers.set(a, {})
  const o = observers.get(a),
    c = JSON.stringify(e)
  return (
    o[c] ||
      (o[c] = new IntersectionObserver(fireAllObserverCallbacks, {
        root: s,
        ...e,
      })),
    o[c]
  )
}
function observeIntersection(s, e, a) {
  const o = initIntersectionObserver(e)
  return (
    observerCallbacks.set(s, a),
    o.observe(s),
    () => {
      observerCallbacks.delete(s), o.unobserve(s)
    }
  )
}
const thresholdNames = { some: 0, all: 1 }
class InViewFeature extends Feature {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1)
  }
  startObserver() {
    this.unmount()
    const { viewport: e = {} } = this.node.getProps(),
      { root: a, margin: o, amount: c = "some", once: d } = e,
      g = {
        root: a ? a.current : void 0,
        rootMargin: o,
        threshold: typeof c == "number" ? c : thresholdNames[c],
      },
      _ = (b) => {
        const { isIntersecting: j } = b
        if (
          this.isInView === j ||
          ((this.isInView = j), d && !j && this.hasEnteredView)
        )
          return
        j && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", j)
        const { onViewportEnter: $, onViewportLeave: _e } =
            this.node.getProps(),
          tt = j ? $ : _e
        tt && tt(b)
      }
    return observeIntersection(this.node.current, g, _)
  }
  mount() {
    this.startObserver()
  }
  update() {
    if (typeof IntersectionObserver > "u") return
    const { props: e, prevProps: a } = this.node
    ;["amount", "margin", "root"].some(hasViewportOptionChanged(e, a)) &&
      this.startObserver()
  }
  unmount() {}
}
function hasViewportOptionChanged(
  { viewport: s = {} },
  { viewport: e = {} } = {}
) {
  return (a) => s[a] !== e[a]
}
const gestureAnimations = {
  inView: { Feature: InViewFeature },
  tap: { Feature: PressGesture },
  focus: { Feature: FocusGesture },
  hover: { Feature: HoverGesture },
}
function shallowCompare(s, e) {
  if (!Array.isArray(e)) return !1
  const a = e.length
  if (a !== s.length) return !1
  for (let o = 0; o < a; o++) if (e[o] !== s[o]) return !1
  return !0
}
function getCurrent(s) {
  const e = {}
  return s.values.forEach((a, o) => (e[o] = a.get())), e
}
function getVelocity$1(s) {
  const e = {}
  return s.values.forEach((a, o) => (e[o] = a.getVelocity())), e
}
function resolveVariant(s, e, a) {
  const o = s.getProps()
  return resolveVariantFromProps(
    o,
    e,
    a !== void 0 ? a : o.custom,
    getCurrent(s),
    getVelocity$1(s)
  )
}
let warning = noop,
  invariant = noop
const secondsToMilliseconds = (s) => s * 1e3,
  millisecondsToSeconds = (s) => s / 1e3,
  instantAnimationState = { current: !1 },
  isBezierDefinition = (s) => Array.isArray(s) && typeof s[0] == "number"
function isWaapiSupportedEasing(s) {
  return !!(
    !s ||
    (typeof s == "string" && supportedWaapiEasing[s]) ||
    isBezierDefinition(s) ||
    (Array.isArray(s) && s.every(isWaapiSupportedEasing))
  )
}
const cubicBezierAsString = ([s, e, a, o]) =>
    `cubic-bezier(${s}, ${e}, ${a}, ${o})`,
  supportedWaapiEasing = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
    circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
    backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
    backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),
  }
function mapEasingToNativeEasing(s) {
  if (s)
    return isBezierDefinition(s)
      ? cubicBezierAsString(s)
      : Array.isArray(s)
      ? s.map(mapEasingToNativeEasing)
      : supportedWaapiEasing[s]
}
function animateStyle(
  s,
  e,
  a,
  {
    delay: o = 0,
    duration: c,
    repeat: d = 0,
    repeatType: g = "loop",
    ease: _,
    times: b,
  } = {}
) {
  const j = { [e]: a }
  b && (j.offset = b)
  const $ = mapEasingToNativeEasing(_)
  return (
    Array.isArray($) && (j.easing = $),
    s.animate(j, {
      delay: o,
      duration: c,
      easing: Array.isArray($) ? "linear" : $,
      fill: "both",
      iterations: d + 1,
      direction: g === "reverse" ? "alternate" : "normal",
    })
  )
}
function getFinalKeyframe(s, { repeat: e, repeatType: a = "loop" }) {
  const o = e && a !== "loop" && e % 2 === 1 ? 0 : s.length - 1
  return s[o]
}
const calcBezier = (s, e, a) =>
    (((1 - 3 * a + 3 * e) * s + (3 * a - 6 * e)) * s + 3 * e) * s,
  subdivisionPrecision = 1e-7,
  subdivisionMaxIterations = 12
function binarySubdivide(s, e, a, o, c) {
  let d,
    g,
    _ = 0
  do
    (g = e + (a - e) / 2),
      (d = calcBezier(g, o, c) - s),
      d > 0 ? (a = g) : (e = g)
  while (Math.abs(d) > subdivisionPrecision && ++_ < subdivisionMaxIterations)
  return g
}
function cubicBezier(s, e, a, o) {
  if (s === e && a === o) return noop
  const c = (d) => binarySubdivide(d, 0, 1, s, a)
  return (d) => (d === 0 || d === 1 ? d : calcBezier(c(d), e, o))
}
const easeIn = cubicBezier(0.42, 0, 1, 1),
  easeOut = cubicBezier(0, 0, 0.58, 1),
  easeInOut = cubicBezier(0.42, 0, 0.58, 1),
  isEasingArray = (s) => Array.isArray(s) && typeof s[0] != "number",
  mirrorEasing = (s) => (e) =>
    e <= 0.5 ? s(2 * e) / 2 : (2 - s(2 * (1 - e))) / 2,
  reverseEasing = (s) => (e) => 1 - s(1 - e),
  circIn = (s) => 1 - Math.sin(Math.acos(s)),
  circOut = reverseEasing(circIn),
  circInOut = mirrorEasing(circIn),
  backOut = cubicBezier(0.33, 1.53, 0.69, 0.99),
  backIn = reverseEasing(backOut),
  backInOut = mirrorEasing(backIn),
  anticipate = (s) =>
    (s *= 2) < 1 ? 0.5 * backIn(s) : 0.5 * (2 - Math.pow(2, -10 * (s - 1))),
  easingLookup = {
    linear: noop,
    easeIn,
    easeInOut,
    easeOut,
    circIn,
    circInOut,
    circOut,
    backIn,
    backInOut,
    backOut,
    anticipate,
  },
  easingDefinitionToFunction = (s) => {
    if (Array.isArray(s)) {
      invariant(s.length === 4)
      const [e, a, o, c] = s
      return cubicBezier(e, a, o, c)
    } else if (typeof s == "string") return easingLookup[s]
    return s
  },
  isColorString = (s, e) => (a) =>
    !!(
      (isString(a) && singleColorRegex.test(a) && a.startsWith(s)) ||
      (e && Object.prototype.hasOwnProperty.call(a, e))
    ),
  splitColor$1 = (s, e, a) => (o) => {
    if (!isString(o)) return o
    const [c, d, g, _] = o.match(floatRegex)
    return {
      [s]: parseFloat(c),
      [e]: parseFloat(d),
      [a]: parseFloat(g),
      alpha: _ !== void 0 ? parseFloat(_) : 1,
    }
  },
  clampRgbUnit = (s) => clamp$1(0, 255, s),
  rgbUnit = { ...number, transform: (s) => Math.round(clampRgbUnit(s)) },
  rgba = {
    test: isColorString("rgb", "red"),
    parse: splitColor$1("red", "green", "blue"),
    transform: ({ red: s, green: e, blue: a, alpha: o = 1 }) =>
      "rgba(" +
      rgbUnit.transform(s) +
      ", " +
      rgbUnit.transform(e) +
      ", " +
      rgbUnit.transform(a) +
      ", " +
      sanitize(alpha.transform(o)) +
      ")",
  }
function parseHex(s) {
  let e = "",
    a = "",
    o = "",
    c = ""
  return (
    s.length > 5
      ? ((e = s.substring(1, 3)),
        (a = s.substring(3, 5)),
        (o = s.substring(5, 7)),
        (c = s.substring(7, 9)))
      : ((e = s.substring(1, 2)),
        (a = s.substring(2, 3)),
        (o = s.substring(3, 4)),
        (c = s.substring(4, 5)),
        (e += e),
        (a += a),
        (o += o),
        (c += c)),
    {
      red: parseInt(e, 16),
      green: parseInt(a, 16),
      blue: parseInt(o, 16),
      alpha: c ? parseInt(c, 16) / 255 : 1,
    }
  )
}
const hex = {
    test: isColorString("#"),
    parse: parseHex,
    transform: rgba.transform,
  },
  hsla = {
    test: isColorString("hsl", "hue"),
    parse: splitColor$1("hue", "saturation", "lightness"),
    transform: ({ hue: s, saturation: e, lightness: a, alpha: o = 1 }) =>
      "hsla(" +
      Math.round(s) +
      ", " +
      percent.transform(sanitize(e)) +
      ", " +
      percent.transform(sanitize(a)) +
      ", " +
      sanitize(alpha.transform(o)) +
      ")",
  },
  color = {
    test: (s) => rgba.test(s) || hex.test(s) || hsla.test(s),
    parse: (s) =>
      rgba.test(s)
        ? rgba.parse(s)
        : hsla.test(s)
        ? hsla.parse(s)
        : hex.parse(s),
    transform: (s) =>
      isString(s)
        ? s
        : s.hasOwnProperty("red")
        ? rgba.transform(s)
        : hsla.transform(s),
  },
  mix = (s, e, a) => -a * s + a * e + s
function hueToRgb(s, e, a) {
  return (
    a < 0 && (a += 1),
    a > 1 && (a -= 1),
    a < 1 / 6
      ? s + (e - s) * 6 * a
      : a < 1 / 2
      ? e
      : a < 2 / 3
      ? s + (e - s) * (2 / 3 - a) * 6
      : s
  )
}
function hslaToRgba({ hue: s, saturation: e, lightness: a, alpha: o }) {
  ;(s /= 360), (e /= 100), (a /= 100)
  let c = 0,
    d = 0,
    g = 0
  if (!e) c = d = g = a
  else {
    const _ = a < 0.5 ? a * (1 + e) : a + e - a * e,
      b = 2 * a - _
    ;(c = hueToRgb(b, _, s + 1 / 3)),
      (d = hueToRgb(b, _, s)),
      (g = hueToRgb(b, _, s - 1 / 3))
  }
  return {
    red: Math.round(c * 255),
    green: Math.round(d * 255),
    blue: Math.round(g * 255),
    alpha: o,
  }
}
const mixLinearColor = (s, e, a) => {
    const o = s * s
    return Math.sqrt(Math.max(0, a * (e * e - o) + o))
  },
  colorTypes = [hex, rgba, hsla],
  getColorType = (s) => colorTypes.find((e) => e.test(s))
function asRGBA(s) {
  const e = getColorType(s)
  let a = e.parse(s)
  return e === hsla && (a = hslaToRgba(a)), a
}
const mixColor = (s, e) => {
  const a = asRGBA(s),
    o = asRGBA(e),
    c = { ...a }
  return (d) => (
    (c.red = mixLinearColor(a.red, o.red, d)),
    (c.green = mixLinearColor(a.green, o.green, d)),
    (c.blue = mixLinearColor(a.blue, o.blue, d)),
    (c.alpha = mix(a.alpha, o.alpha, d)),
    rgba.transform(c)
  )
}
function test(s) {
  var e, a
  return (
    isNaN(s) &&
    isString(s) &&
    (((e = s.match(floatRegex)) === null || e === void 0 ? void 0 : e.length) ||
      0) +
      (((a = s.match(colorRegex)) === null || a === void 0
        ? void 0
        : a.length) || 0) >
      0
  )
}
const cssVarTokeniser = {
    regex: cssVariableRegex,
    countKey: "Vars",
    token: "${v}",
    parse: noop,
  },
  colorTokeniser = {
    regex: colorRegex,
    countKey: "Colors",
    token: "${c}",
    parse: color.parse,
  },
  numberTokeniser = {
    regex: floatRegex,
    countKey: "Numbers",
    token: "${n}",
    parse: number.parse,
  }
function tokenise(s, { regex: e, countKey: a, token: o, parse: c }) {
  const d = s.tokenised.match(e)
  d &&
    ((s["num" + a] = d.length),
    (s.tokenised = s.tokenised.replace(e, o)),
    s.values.push(...d.map(c)))
}
function analyseComplexValue(s) {
  const e = s.toString(),
    a = {
      value: e,
      tokenised: e,
      values: [],
      numVars: 0,
      numColors: 0,
      numNumbers: 0,
    }
  return (
    a.value.includes("var(--") && tokenise(a, cssVarTokeniser),
    tokenise(a, colorTokeniser),
    tokenise(a, numberTokeniser),
    a
  )
}
function parseComplexValue(s) {
  return analyseComplexValue(s).values
}
function createTransformer(s) {
  const {
      values: e,
      numColors: a,
      numVars: o,
      tokenised: c,
    } = analyseComplexValue(s),
    d = e.length
  return (g) => {
    let _ = c
    for (let b = 0; b < d; b++)
      b < o
        ? (_ = _.replace(cssVarTokeniser.token, g[b]))
        : b < o + a
        ? (_ = _.replace(colorTokeniser.token, color.transform(g[b])))
        : (_ = _.replace(numberTokeniser.token, sanitize(g[b])))
    return _
  }
}
const convertNumbersToZero = (s) => (typeof s == "number" ? 0 : s)
function getAnimatableNone$1(s) {
  const e = parseComplexValue(s)
  return createTransformer(s)(e.map(convertNumbersToZero))
}
const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1,
  },
  mixImmediate = (s, e) => (a) => `${a > 0 ? e : s}`
function getMixer(s, e) {
  return typeof s == "number"
    ? (a) => mix(s, e, a)
    : color.test(s)
    ? mixColor(s, e)
    : s.startsWith("var(")
    ? mixImmediate(s, e)
    : mixComplex(s, e)
}
const mixArray = (s, e) => {
    const a = [...s],
      o = a.length,
      c = s.map((d, g) => getMixer(d, e[g]))
    return (d) => {
      for (let g = 0; g < o; g++) a[g] = c[g](d)
      return a
    }
  },
  mixObject = (s, e) => {
    const a = { ...s, ...e },
      o = {}
    for (const c in a)
      s[c] !== void 0 && e[c] !== void 0 && (o[c] = getMixer(s[c], e[c]))
    return (c) => {
      for (const d in o) a[d] = o[d](c)
      return a
    }
  },
  mixComplex = (s, e) => {
    const a = complex.createTransformer(e),
      o = analyseComplexValue(s),
      c = analyseComplexValue(e)
    return o.numVars === c.numVars &&
      o.numColors === c.numColors &&
      o.numNumbers >= c.numNumbers
      ? pipe$1(mixArray(o.values, c.values), a)
      : mixImmediate(s, e)
  },
  progress = (s, e, a) => {
    const o = e - s
    return o === 0 ? 1 : (a - s) / o
  },
  mixNumber = (s, e) => (a) => mix(s, e, a)
function detectMixerFactory(s) {
  return typeof s == "number"
    ? mixNumber
    : typeof s == "string"
    ? color.test(s)
      ? mixColor
      : mixComplex
    : Array.isArray(s)
    ? mixArray
    : typeof s == "object"
    ? mixObject
    : mixNumber
}
function createMixers(s, e, a) {
  const o = [],
    c = a || detectMixerFactory(s[0]),
    d = s.length - 1
  for (let g = 0; g < d; g++) {
    let _ = c(s[g], s[g + 1])
    if (e) {
      const b = Array.isArray(e) ? e[g] || noop : e
      _ = pipe$1(b, _)
    }
    o.push(_)
  }
  return o
}
function interpolate$1(s, e, { clamp: a = !0, ease: o, mixer: c } = {}) {
  const d = s.length
  if ((invariant(d === e.length), d === 1)) return () => e[0]
  s[0] > s[d - 1] && ((s = [...s].reverse()), (e = [...e].reverse()))
  const g = createMixers(e, o, c),
    _ = g.length,
    b = (j) => {
      let $ = 0
      if (_ > 1) for (; $ < s.length - 2 && !(j < s[$ + 1]); $++);
      const _e = progress(s[$], s[$ + 1], j)
      return g[$](_e)
    }
  return a ? (j) => b(clamp$1(s[0], s[d - 1], j)) : b
}
function fillOffset(s, e) {
  const a = s[s.length - 1]
  for (let o = 1; o <= e; o++) {
    const c = progress(0, e, o)
    s.push(mix(a, 1, c))
  }
}
function defaultOffset(s) {
  const e = [0]
  return fillOffset(e, s.length - 1), e
}
function convertOffsetToTimes(s, e) {
  return s.map((a) => a * e)
}
function defaultEasing(s, e) {
  return s.map(() => e || easeInOut).splice(0, s.length - 1)
}
function keyframes({
  duration: s = 300,
  keyframes: e,
  times: a,
  ease: o = "easeInOut",
}) {
  const c = isEasingArray(o)
      ? o.map(easingDefinitionToFunction)
      : easingDefinitionToFunction(o),
    d = { done: !1, value: e[0] },
    g = convertOffsetToTimes(
      a && a.length === e.length ? a : defaultOffset(e),
      s
    ),
    _ = interpolate$1(g, e, {
      ease: Array.isArray(c) ? c : defaultEasing(e, c),
    })
  return {
    calculatedDuration: s,
    next: (b) => ((d.value = _(b)), (d.done = b >= s), d),
  }
}
function velocityPerSecond(s, e) {
  return e ? s * (1e3 / e) : 0
}
const velocitySampleDuration = 5
function calcGeneratorVelocity(s, e, a) {
  const o = Math.max(e - velocitySampleDuration, 0)
  return velocityPerSecond(a - s(o), e - o)
}
const safeMin = 0.001,
  minDuration = 0.01,
  maxDuration$1 = 10,
  minDamping = 0.05,
  maxDamping = 1
function findSpring({
  duration: s = 800,
  bounce: e = 0.25,
  velocity: a = 0,
  mass: o = 1,
}) {
  let c, d
  warning(s <= secondsToMilliseconds(maxDuration$1))
  let g = 1 - e
  ;(g = clamp$1(minDamping, maxDamping, g)),
    (s = clamp$1(minDuration, maxDuration$1, millisecondsToSeconds(s))),
    g < 1
      ? ((c = (j) => {
          const $ = j * g,
            _e = $ * s,
            tt = $ - a,
            st = calcAngularFreq(j, g),
            at = Math.exp(-_e)
          return safeMin - (tt / st) * at
        }),
        (d = (j) => {
          const _e = j * g * s,
            tt = _e * a + a,
            st = Math.pow(g, 2) * Math.pow(j, 2) * s,
            at = Math.exp(-_e),
            ot = calcAngularFreq(Math.pow(j, 2), g)
          return ((-c(j) + safeMin > 0 ? -1 : 1) * ((tt - st) * at)) / ot
        }))
      : ((c = (j) => {
          const $ = Math.exp(-j * s),
            _e = (j - a) * s + 1
          return -safeMin + $ * _e
        }),
        (d = (j) => {
          const $ = Math.exp(-j * s),
            _e = (a - j) * (s * s)
          return $ * _e
        }))
  const _ = 5 / s,
    b = approximateRoot(c, d, _)
  if (((s = secondsToMilliseconds(s)), isNaN(b)))
    return { stiffness: 100, damping: 10, duration: s }
  {
    const j = Math.pow(b, 2) * o
    return { stiffness: j, damping: g * 2 * Math.sqrt(o * j), duration: s }
  }
}
const rootIterations = 12
function approximateRoot(s, e, a) {
  let o = a
  for (let c = 1; c < rootIterations; c++) o = o - s(o) / e(o)
  return o
}
function calcAngularFreq(s, e) {
  return s * Math.sqrt(1 - e * e)
}
const durationKeys = ["duration", "bounce"],
  physicsKeys = ["stiffness", "damping", "mass"]
function isSpringType(s, e) {
  return e.some((a) => s[a] !== void 0)
}
function getSpringOptions(s) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...s,
  }
  if (!isSpringType(s, physicsKeys) && isSpringType(s, durationKeys)) {
    const a = findSpring(s)
    ;(e = { ...e, ...a, mass: 1 }), (e.isResolvedFromDuration = !0)
  }
  return e
}
function spring({ keyframes: s, restDelta: e, restSpeed: a, ...o }) {
  const c = s[0],
    d = s[s.length - 1],
    g = { done: !1, value: c },
    {
      stiffness: _,
      damping: b,
      mass: j,
      duration: $,
      velocity: _e,
      isResolvedFromDuration: tt,
    } = getSpringOptions({
      ...o,
      velocity: -millisecondsToSeconds(o.velocity || 0),
    }),
    st = _e || 0,
    at = b / (2 * Math.sqrt(_ * j)),
    ot = d - c,
    ut = millisecondsToSeconds(Math.sqrt(_ / j)),
    it = Math.abs(ot) < 5
  a || (a = it ? 0.01 : 2), e || (e = it ? 0.005 : 0.5)
  let ct
  if (at < 1) {
    const lt = calcAngularFreq(ut, at)
    ct = (ht) => {
      const dt = Math.exp(-at * ut * ht)
      return (
        d -
        dt *
          (((st + at * ut * ot) / lt) * Math.sin(lt * ht) +
            ot * Math.cos(lt * ht))
      )
    }
  } else if (at === 1)
    ct = (lt) => d - Math.exp(-ut * lt) * (ot + (st + ut * ot) * lt)
  else {
    const lt = ut * Math.sqrt(at * at - 1)
    ct = (ht) => {
      const dt = Math.exp(-at * ut * ht),
        pt = Math.min(lt * ht, 300)
      return (
        d -
        (dt * ((st + at * ut * ot) * Math.sinh(pt) + lt * ot * Math.cosh(pt))) /
          lt
      )
    }
  }
  return {
    calculatedDuration: (tt && $) || null,
    next: (lt) => {
      const ht = ct(lt)
      if (tt) g.done = lt >= $
      else {
        let dt = st
        lt !== 0 &&
          (at < 1 ? (dt = calcGeneratorVelocity(ct, lt, ht)) : (dt = 0))
        const pt = Math.abs(dt) <= a,
          vt = Math.abs(d - ht) <= e
        g.done = pt && vt
      }
      return (g.value = g.done ? d : ht), g
    },
  }
}
function inertia({
  keyframes: s,
  velocity: e = 0,
  power: a = 0.8,
  timeConstant: o = 325,
  bounceDamping: c = 10,
  bounceStiffness: d = 500,
  modifyTarget: g,
  min: _,
  max: b,
  restDelta: j = 0.5,
  restSpeed: $,
}) {
  const _e = s[0],
    tt = { done: !1, value: _e },
    st = (_t) => (_ !== void 0 && _t < _) || (b !== void 0 && _t > b),
    at = (_t) =>
      _ === void 0
        ? b
        : b === void 0 || Math.abs(_ - _t) < Math.abs(b - _t)
        ? _
        : b
  let ot = a * e
  const ut = _e + ot,
    it = g === void 0 ? ut : g(ut)
  it !== ut && (ot = it - _e)
  const ct = (_t) => -ot * Math.exp(-_t / o),
    lt = (_t) => it + ct(_t),
    ht = (_t) => {
      const yt = ct(_t),
        Et = lt(_t)
      ;(tt.done = Math.abs(yt) <= j), (tt.value = tt.done ? it : Et)
    }
  let dt, pt
  const vt = (_t) => {
    st(tt.value) &&
      ((dt = _t),
      (pt = spring({
        keyframes: [tt.value, at(tt.value)],
        velocity: calcGeneratorVelocity(lt, _t, tt.value),
        damping: c,
        stiffness: d,
        restDelta: j,
        restSpeed: $,
      })))
  }
  return (
    vt(0),
    {
      calculatedDuration: null,
      next: (_t) => {
        let yt = !1
        return (
          !pt && dt === void 0 && ((yt = !0), ht(_t), vt(_t)),
          dt !== void 0 && _t > dt ? pt.next(_t - dt) : (!yt && ht(_t), tt)
        )
      },
    }
  )
}
const frameloopDriver = (s) => {
    const e = ({ timestamp: a }) => s(a)
    return {
      start: () => frame.update(e, !0),
      stop: () => cancelFrame(e),
      now: () =>
        frameData.isProcessing ? frameData.timestamp : performance.now(),
    }
  },
  maxGeneratorDuration = 2e4
function calcGeneratorDuration(s) {
  let e = 0
  const a = 50
  let o = s.next(e)
  for (; !o.done && e < maxGeneratorDuration; ) (e += a), (o = s.next(e))
  return e >= maxGeneratorDuration ? 1 / 0 : e
}
const types = { decay: inertia, inertia, tween: keyframes, keyframes, spring }
function animateValue({
  autoplay: s = !0,
  delay: e = 0,
  driver: a = frameloopDriver,
  keyframes: o,
  type: c = "keyframes",
  repeat: d = 0,
  repeatDelay: g = 0,
  repeatType: _ = "loop",
  onPlay: b,
  onStop: j,
  onComplete: $,
  onUpdate: _e,
  ...tt
}) {
  let st = 1,
    at = !1,
    ot,
    ut
  const it = () => {
    ut = new Promise((Tt) => {
      ot = Tt
    })
  }
  it()
  let ct
  const lt = types[c] || keyframes
  let ht
  lt !== keyframes &&
    typeof o[0] != "number" &&
    ((ht = interpolate$1([0, 100], o, { clamp: !1 })), (o = [0, 100]))
  const dt = lt({ ...tt, keyframes: o })
  let pt
  _ === "mirror" &&
    (pt = lt({
      ...tt,
      keyframes: [...o].reverse(),
      velocity: -(tt.velocity || 0),
    }))
  let vt = "idle",
    _t = null,
    yt = null,
    Et = null
  dt.calculatedDuration === null &&
    d &&
    (dt.calculatedDuration = calcGeneratorDuration(dt))
  const { calculatedDuration: Rt } = dt
  let Ft = 1 / 0,
    kt = 1 / 0
  Rt !== null && ((Ft = Rt + g), (kt = Ft * (d + 1) - g))
  let Nt = 0
  const Dt = (Tt) => {
      if (yt === null) return
      st > 0 && (yt = Math.min(yt, Tt)),
        st < 0 && (yt = Math.min(Tt - kt / st, yt)),
        _t !== null ? (Nt = _t) : (Nt = Math.round(Tt - yt) * st)
      const It = Nt - e * (st >= 0 ? 1 : -1),
        $t = st >= 0 ? It < 0 : It > kt
      ;(Nt = Math.max(It, 0)), vt === "finished" && _t === null && (Nt = kt)
      let Xt = Nt,
        qt = dt
      if (d) {
        const $n = Math.min(Nt, kt) / Ft
        let Vn = Math.floor($n),
          gn = $n % 1
        !gn && $n >= 1 && (gn = 1),
          gn === 1 && Vn--,
          (Vn = Math.min(Vn, d + 1)),
          !!(Vn % 2) &&
            (_ === "reverse"
              ? ((gn = 1 - gn), g && (gn -= g / Ft))
              : _ === "mirror" && (qt = pt)),
          (Xt = clamp$1(0, 1, gn) * Ft)
      }
      const en = $t ? { done: !1, value: o[0] } : qt.next(Xt)
      ht && (en.value = ht(en.value))
      let { done: yn } = en
      !$t && Rt !== null && (yn = st >= 0 ? Nt >= kt : Nt <= 0)
      const Tn = _t === null && (vt === "finished" || (vt === "running" && yn))
      return _e && _e(en.value), Tn && gt(), en
    },
    Mt = () => {
      ct && ct.stop(), (ct = void 0)
    },
    wt = () => {
      ;(vt = "idle"), Mt(), ot(), it(), (yt = Et = null)
    },
    gt = () => {
      ;(vt = "finished"), $ && $(), Mt(), ot()
    },
    At = () => {
      if (at) return
      ct || (ct = a(Dt))
      const Tt = ct.now()
      b && b(),
        _t !== null ? (yt = Tt - _t) : (!yt || vt === "finished") && (yt = Tt),
        vt === "finished" && it(),
        (Et = yt),
        (_t = null),
        (vt = "running"),
        ct.start()
    }
  s && At()
  const bt = {
    then(Tt, It) {
      return ut.then(Tt, It)
    },
    get time() {
      return millisecondsToSeconds(Nt)
    },
    set time(Tt) {
      ;(Tt = secondsToMilliseconds(Tt)),
        (Nt = Tt),
        _t !== null || !ct || st === 0 ? (_t = Tt) : (yt = ct.now() - Tt / st)
    },
    get duration() {
      const Tt =
        dt.calculatedDuration === null
          ? calcGeneratorDuration(dt)
          : dt.calculatedDuration
      return millisecondsToSeconds(Tt)
    },
    get speed() {
      return st
    },
    set speed(Tt) {
      Tt === st || !ct || ((st = Tt), (bt.time = millisecondsToSeconds(Nt)))
    },
    get state() {
      return vt
    },
    play: At,
    pause: () => {
      ;(vt = "paused"), (_t = Nt)
    },
    stop: () => {
      ;(at = !0), vt !== "idle" && ((vt = "idle"), j && j(), wt())
    },
    cancel: () => {
      Et !== null && Dt(Et), wt()
    },
    complete: () => {
      vt = "finished"
    },
    sample: (Tt) => ((yt = 0), Dt(Tt)),
  }
  return bt
}
function memo(s) {
  let e
  return () => (e === void 0 && (e = s()), e)
}
const supportsWaapi = memo(() =>
    Object.hasOwnProperty.call(Element.prototype, "animate")
  ),
  acceleratedValues = new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform",
    "backgroundColor",
  ]),
  sampleDelta = 10,
  maxDuration = 2e4,
  requiresPregeneratedKeyframes = (s, e) =>
    e.type === "spring" ||
    s === "backgroundColor" ||
    !isWaapiSupportedEasing(e.ease)
function createAcceleratedAnimation(
  s,
  e,
  { onUpdate: a, onComplete: o, ...c }
) {
  if (
    !(
      supportsWaapi() &&
      acceleratedValues.has(e) &&
      !c.repeatDelay &&
      c.repeatType !== "mirror" &&
      c.damping !== 0 &&
      c.type !== "inertia"
    )
  )
    return !1
  let g = !1,
    _,
    b,
    j = !1
  const $ = () => {
    b = new Promise((lt) => {
      _ = lt
    })
  }
  $()
  let { keyframes: _e, duration: tt = 300, ease: st, times: at } = c
  if (requiresPregeneratedKeyframes(e, c)) {
    const lt = animateValue({ ...c, repeat: 0, delay: 0 })
    let ht = { done: !1, value: _e[0] }
    const dt = []
    let pt = 0
    for (; !ht.done && pt < maxDuration; )
      (ht = lt.sample(pt)), dt.push(ht.value), (pt += sampleDelta)
    ;(at = void 0), (_e = dt), (tt = pt - sampleDelta), (st = "linear")
  }
  const ot = animateStyle(s.owner.current, e, _e, {
      ...c,
      duration: tt,
      ease: st,
      times: at,
    }),
    ut = () => {
      ;(j = !1), ot.cancel()
    },
    it = () => {
      ;(j = !0), frame.update(ut), _(), $()
    }
  return (
    (ot.onfinish = () => {
      j || (s.set(getFinalKeyframe(_e, c)), o && o(), it())
    }),
    {
      then(lt, ht) {
        return b.then(lt, ht)
      },
      attachTimeline(lt) {
        return (ot.timeline = lt), (ot.onfinish = null), noop
      },
      get time() {
        return millisecondsToSeconds(ot.currentTime || 0)
      },
      set time(lt) {
        ot.currentTime = secondsToMilliseconds(lt)
      },
      get speed() {
        return ot.playbackRate
      },
      set speed(lt) {
        ot.playbackRate = lt
      },
      get duration() {
        return millisecondsToSeconds(tt)
      },
      play: () => {
        g || (ot.play(), cancelFrame(ut))
      },
      pause: () => ot.pause(),
      stop: () => {
        if (((g = !0), ot.playState === "idle")) return
        const { currentTime: lt } = ot
        if (lt) {
          const ht = animateValue({ ...c, autoplay: !1 })
          s.setWithVelocity(
            ht.sample(lt - sampleDelta).value,
            ht.sample(lt).value,
            sampleDelta
          )
        }
        it()
      },
      complete: () => {
        j || ot.finish()
      },
      cancel: it,
    }
  )
}
function createInstantAnimation({
  keyframes: s,
  delay: e,
  onUpdate: a,
  onComplete: o,
}) {
  const c = () => (
    a && a(s[s.length - 1]),
    o && o(),
    {
      time: 0,
      speed: 1,
      duration: 0,
      play: noop,
      pause: noop,
      stop: noop,
      then: (d) => (d(), Promise.resolve()),
      cancel: noop,
      complete: noop,
    }
  )
  return e
    ? animateValue({ keyframes: [0, 1], duration: 0, delay: e, onComplete: c })
    : c()
}
const underDampedSpring = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10,
  },
  criticallyDampedSpring = (s) => ({
    type: "spring",
    stiffness: 550,
    damping: s === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  keyframesTransition = { type: "keyframes", duration: 0.8 },
  ease = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  getDefaultTransition = (s, { keyframes: e }) =>
    e.length > 2
      ? keyframesTransition
      : transformProps.has(s)
      ? s.startsWith("scale")
        ? criticallyDampedSpring(e[1])
        : underDampedSpring
      : ease,
  isAnimatable = (s, e) =>
    s === "zIndex"
      ? !1
      : !!(
          typeof e == "number" ||
          Array.isArray(e) ||
          (typeof e == "string" &&
            (complex.test(e) || e === "0") &&
            !e.startsWith("url("))
        ),
  maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"])
function applyDefaultFilter(s) {
  const [e, a] = s.slice(0, -1).split("(")
  if (e === "drop-shadow") return s
  const [o] = a.match(floatRegex) || []
  if (!o) return s
  const c = a.replace(o, "")
  let d = maxDefaults.has(e) ? 1 : 0
  return o !== a && (d *= 100), e + "(" + d + c + ")"
}
const functionRegex = /([a-z-]*)\(.*?\)/g,
  filter = {
    ...complex,
    getAnimatableNone: (s) => {
      const e = s.match(functionRegex)
      return e ? e.map(applyDefaultFilter).join(" ") : s
    },
  },
  defaultValueTypes = {
    ...numberValueTypes,
    color,
    backgroundColor: color,
    outlineColor: color,
    fill: color,
    stroke: color,
    borderColor: color,
    borderTopColor: color,
    borderRightColor: color,
    borderBottomColor: color,
    borderLeftColor: color,
    filter,
    WebkitFilter: filter,
  },
  getDefaultValueType = (s) => defaultValueTypes[s]
function getAnimatableNone(s, e) {
  let a = getDefaultValueType(s)
  return (
    a !== filter && (a = complex),
    a.getAnimatableNone ? a.getAnimatableNone(e) : void 0
  )
}
const isZeroValueString = (s) => /^0[^.\s]+$/.test(s)
function isNone(s) {
  if (typeof s == "number") return s === 0
  if (s !== null) return s === "none" || s === "0" || isZeroValueString(s)
}
function getKeyframes(s, e, a, o) {
  const c = isAnimatable(e, a)
  let d
  Array.isArray(a) ? (d = [...a]) : (d = [null, a])
  const g = o.from !== void 0 ? o.from : s.get()
  let _
  const b = []
  for (let j = 0; j < d.length; j++)
    d[j] === null && (d[j] = j === 0 ? g : d[j - 1]),
      isNone(d[j]) && b.push(j),
      typeof d[j] == "string" && d[j] !== "none" && d[j] !== "0" && (_ = d[j])
  if (c && b.length && _)
    for (let j = 0; j < b.length; j++) {
      const $ = b[j]
      d[$] = getAnimatableNone(e, _)
    }
  return d
}
function isTransitionDefined({
  when: s,
  delay: e,
  delayChildren: a,
  staggerChildren: o,
  staggerDirection: c,
  repeat: d,
  repeatType: g,
  repeatDelay: _,
  from: b,
  elapsed: j,
  ...$
}) {
  return !!Object.keys($).length
}
function getValueTransition(s, e) {
  return s[e] || s.default || s
}
const MotionGlobalConfig = { skipAnimations: !1 },
  animateMotionValue =
    (s, e, a, o = {}) =>
    (c) => {
      const d = getValueTransition(o, s) || {},
        g = d.delay || o.delay || 0
      let { elapsed: _ = 0 } = o
      _ = _ - secondsToMilliseconds(g)
      const b = getKeyframes(e, s, a, d),
        j = b[0],
        $ = b[b.length - 1],
        _e = isAnimatable(s, j),
        tt = isAnimatable(s, $)
      let st = {
        keyframes: b,
        velocity: e.getVelocity(),
        ease: "easeOut",
        ...d,
        delay: -_,
        onUpdate: (at) => {
          e.set(at), d.onUpdate && d.onUpdate(at)
        },
        onComplete: () => {
          c(), d.onComplete && d.onComplete()
        },
      }
      if (
        (isTransitionDefined(d) ||
          (st = { ...st, ...getDefaultTransition(s, st) }),
        st.duration && (st.duration = secondsToMilliseconds(st.duration)),
        st.repeatDelay &&
          (st.repeatDelay = secondsToMilliseconds(st.repeatDelay)),
        !_e ||
          !tt ||
          instantAnimationState.current ||
          d.type === !1 ||
          MotionGlobalConfig.skipAnimations)
      )
        return createInstantAnimation(st)
      if (
        !o.isHandoff &&
        e.owner &&
        e.owner.current instanceof HTMLElement &&
        !e.owner.getProps().onUpdate
      ) {
        const at = createAcceleratedAnimation(e, s, st)
        if (at) return at
      }
      return animateValue(st)
    }
function isWillChangeMotionValue(s) {
  return !!(isMotionValue(s) && s.add)
}
const isNumericalString = (s) => /^\-?\d*\.?\d+$/.test(s)
function addUniqueItem(s, e) {
  s.indexOf(e) === -1 && s.push(e)
}
function removeItem(s, e) {
  const a = s.indexOf(e)
  a > -1 && s.splice(a, 1)
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = []
  }
  add(e) {
    return (
      addUniqueItem(this.subscriptions, e),
      () => removeItem(this.subscriptions, e)
    )
  }
  notify(e, a, o) {
    const c = this.subscriptions.length
    if (c)
      if (c === 1) this.subscriptions[0](e, a, o)
      else
        for (let d = 0; d < c; d++) {
          const g = this.subscriptions[d]
          g && g(e, a, o)
        }
  }
  getSize() {
    return this.subscriptions.length
  }
  clear() {
    this.subscriptions.length = 0
  }
}
const isFloat = (s) => !isNaN(parseFloat(s))
class MotionValue {
  constructor(e, a = {}) {
    ;(this.version = "10.18.0"),
      (this.timeDelta = 0),
      (this.lastUpdated = 0),
      (this.canTrackVelocity = !1),
      (this.events = {}),
      (this.updateAndNotify = (o, c = !0) => {
        ;(this.prev = this.current), (this.current = o)
        const { delta: d, timestamp: g } = frameData
        this.lastUpdated !== g &&
          ((this.timeDelta = d),
          (this.lastUpdated = g),
          frame.postRender(this.scheduleVelocityCheck)),
          this.prev !== this.current &&
            this.events.change &&
            this.events.change.notify(this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()),
          c &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current)
      }),
      (this.scheduleVelocityCheck = () => frame.postRender(this.velocityCheck)),
      (this.velocityCheck = ({ timestamp: o }) => {
        o !== this.lastUpdated &&
          ((this.prev = this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()))
      }),
      (this.hasAnimated = !1),
      (this.prev = this.current = e),
      (this.canTrackVelocity = isFloat(this.current)),
      (this.owner = a.owner)
  }
  onChange(e) {
    return this.on("change", e)
  }
  on(e, a) {
    this.events[e] || (this.events[e] = new SubscriptionManager())
    const o = this.events[e].add(a)
    return e === "change"
      ? () => {
          o(),
            frame.read(() => {
              this.events.change.getSize() || this.stop()
            })
        }
      : o
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear()
  }
  attach(e, a) {
    ;(this.passiveEffect = e), (this.stopPassiveEffect = a)
  }
  set(e, a = !0) {
    !a || !this.passiveEffect
      ? this.updateAndNotify(e, a)
      : this.passiveEffect(e, this.updateAndNotify)
  }
  setWithVelocity(e, a, o) {
    this.set(a), (this.prev = e), (this.timeDelta = o)
  }
  jump(e) {
    this.updateAndNotify(e),
      (this.prev = e),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect()
  }
  get() {
    return this.current
  }
  getPrevious() {
    return this.prev
  }
  getVelocity() {
    return this.canTrackVelocity
      ? velocityPerSecond(
          parseFloat(this.current) - parseFloat(this.prev),
          this.timeDelta
        )
      : 0
  }
  start(e) {
    return (
      this.stop(),
      new Promise((a) => {
        ;(this.hasAnimated = !0),
          (this.animation = e(a)),
          this.events.animationStart && this.events.animationStart.notify()
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation()
      })
    )
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation()
  }
  isAnimating() {
    return !!this.animation
  }
  clearAnimation() {
    delete this.animation
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect()
  }
}
function motionValue(s, e) {
  return new MotionValue(s, e)
}
const testValueType = (s) => (e) => e.test(s),
  auto = { test: (s) => s === "auto", parse: (s) => s },
  dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto],
  findDimensionValueType = (s) => dimensionValueTypes.find(testValueType(s)),
  valueTypes = [...dimensionValueTypes, color, complex],
  findValueType = (s) => valueTypes.find(testValueType(s))
function setMotionValue(s, e, a) {
  s.hasValue(e) ? s.getValue(e).set(a) : s.addValue(e, motionValue(a))
}
function setTarget(s, e) {
  const a = resolveVariant(s, e)
  let {
    transitionEnd: o = {},
    transition: c = {},
    ...d
  } = a ? s.makeTargetAnimatable(a, !1) : {}
  d = { ...d, ...o }
  for (const g in d) {
    const _ = resolveFinalValueInKeyframes(d[g])
    setMotionValue(s, g, _)
  }
}
function checkTargetForNewValues(s, e, a) {
  var o, c
  const d = Object.keys(e).filter((_) => !s.hasValue(_)),
    g = d.length
  if (g)
    for (let _ = 0; _ < g; _++) {
      const b = d[_],
        j = e[b]
      let $ = null
      Array.isArray(j) && ($ = j[0]),
        $ === null &&
          ($ =
            (c = (o = a[b]) !== null && o !== void 0 ? o : s.readValue(b)) !==
              null && c !== void 0
              ? c
              : e[b]),
        $ != null &&
          (typeof $ == "string" &&
          (isNumericalString($) || isZeroValueString($))
            ? ($ = parseFloat($))
            : !findValueType($) &&
              complex.test(j) &&
              ($ = getAnimatableNone(b, j)),
          s.addValue(b, motionValue($, { owner: s })),
          a[b] === void 0 && (a[b] = $),
          $ !== null && s.setBaseTarget(b, $))
    }
}
function getOriginFromTransition(s, e) {
  return e ? (e[s] || e.default || e).from : void 0
}
function getOrigin(s, e, a) {
  const o = {}
  for (const c in s) {
    const d = getOriginFromTransition(c, e)
    if (d !== void 0) o[c] = d
    else {
      const g = a.getValue(c)
      g && (o[c] = g.get())
    }
  }
  return o
}
function shouldBlockAnimation({ protectedKeys: s, needsAnimating: e }, a) {
  const o = s.hasOwnProperty(a) && e[a] !== !0
  return (e[a] = !1), o
}
function hasKeyframesChanged(s, e) {
  const a = s.get()
  if (Array.isArray(e)) {
    for (let o = 0; o < e.length; o++) if (e[o] !== a) return !0
  } else return a !== e
}
function animateTarget(
  s,
  e,
  { delay: a = 0, transitionOverride: o, type: c } = {}
) {
  let {
    transition: d = s.getDefaultTransition(),
    transitionEnd: g,
    ..._
  } = s.makeTargetAnimatable(e)
  const b = s.getValue("willChange")
  o && (d = o)
  const j = [],
    $ = c && s.animationState && s.animationState.getState()[c]
  for (const _e in _) {
    const tt = s.getValue(_e),
      st = _[_e]
    if (!tt || st === void 0 || ($ && shouldBlockAnimation($, _e))) continue
    const at = { delay: a, elapsed: 0, ...getValueTransition(d || {}, _e) }
    if (window.HandoffAppearAnimations) {
      const it = s.getProps()[optimizedAppearDataAttribute]
      if (it) {
        const ct = window.HandoffAppearAnimations(it, _e, tt, frame)
        ct !== null && ((at.elapsed = ct), (at.isHandoff = !0))
      }
    }
    let ot = !at.isHandoff && !hasKeyframesChanged(tt, st)
    if (
      (at.type === "spring" && (tt.getVelocity() || at.velocity) && (ot = !1),
      tt.animation && (ot = !1),
      ot)
    )
      continue
    tt.start(
      animateMotionValue(
        _e,
        tt,
        st,
        s.shouldReduceMotion && transformProps.has(_e) ? { type: !1 } : at
      )
    )
    const ut = tt.animation
    isWillChangeMotionValue(b) && (b.add(_e), ut.then(() => b.remove(_e))),
      j.push(ut)
  }
  return (
    g &&
      Promise.all(j).then(() => {
        g && setTarget(s, g)
      }),
    j
  )
}
function animateVariant(s, e, a = {}) {
  const o = resolveVariant(s, e, a.custom)
  let { transition: c = s.getDefaultTransition() || {} } = o || {}
  a.transitionOverride && (c = a.transitionOverride)
  const d = o
      ? () => Promise.all(animateTarget(s, o, a))
      : () => Promise.resolve(),
    g =
      s.variantChildren && s.variantChildren.size
        ? (b = 0) => {
            const {
              delayChildren: j = 0,
              staggerChildren: $,
              staggerDirection: _e,
            } = c
            return animateChildren(s, e, j + b, $, _e, a)
          }
        : () => Promise.resolve(),
    { when: _ } = c
  if (_) {
    const [b, j] = _ === "beforeChildren" ? [d, g] : [g, d]
    return b().then(() => j())
  } else return Promise.all([d(), g(a.delay)])
}
function animateChildren(s, e, a = 0, o = 0, c = 1, d) {
  const g = [],
    _ = (s.variantChildren.size - 1) * o,
    b = c === 1 ? (j = 0) => j * o : (j = 0) => _ - j * o
  return (
    Array.from(s.variantChildren)
      .sort(sortByTreeOrder)
      .forEach((j, $) => {
        j.notify("AnimationStart", e),
          g.push(
            animateVariant(j, e, { ...d, delay: a + b($) }).then(() =>
              j.notify("AnimationComplete", e)
            )
          )
      }),
    Promise.all(g)
  )
}
function sortByTreeOrder(s, e) {
  return s.sortNodePosition(e)
}
function animateVisualElement(s, e, a = {}) {
  s.notify("AnimationStart", e)
  let o
  if (Array.isArray(e)) {
    const c = e.map((d) => animateVariant(s, d, a))
    o = Promise.all(c)
  } else if (typeof e == "string") o = animateVariant(s, e, a)
  else {
    const c = typeof e == "function" ? resolveVariant(s, e, a.custom) : e
    o = Promise.all(animateTarget(s, c, a))
  }
  return o.then(() => s.notify("AnimationComplete", e))
}
const reversePriorityOrder = [...variantPriorityOrder].reverse(),
  numAnimationTypes = variantPriorityOrder.length
function animateList(s) {
  return (e) =>
    Promise.all(
      e.map(({ animation: a, options: o }) => animateVisualElement(s, a, o))
    )
}
function createAnimationState(s) {
  let e = animateList(s)
  const a = createState()
  let o = !0
  const c = (b, j) => {
    const $ = resolveVariant(s, j)
    if ($) {
      const { transition: _e, transitionEnd: tt, ...st } = $
      b = { ...b, ...st, ...tt }
    }
    return b
  }
  function d(b) {
    e = b(s)
  }
  function g(b, j) {
    const $ = s.getProps(),
      _e = s.getVariantContext(!0) || {},
      tt = [],
      st = new Set()
    let at = {},
      ot = 1 / 0
    for (let it = 0; it < numAnimationTypes; it++) {
      const ct = reversePriorityOrder[it],
        lt = a[ct],
        ht = $[ct] !== void 0 ? $[ct] : _e[ct],
        dt = isVariantLabel(ht),
        pt = ct === j ? lt.isActive : null
      pt === !1 && (ot = it)
      let vt = ht === _e[ct] && ht !== $[ct] && dt
      if (
        (vt && o && s.manuallyAnimateOnMount && (vt = !1),
        (lt.protectedKeys = { ...at }),
        (!lt.isActive && pt === null) ||
          (!ht && !lt.prevProp) ||
          isAnimationControls(ht) ||
          typeof ht == "boolean")
      )
        continue
      let yt =
          checkVariantsDidChange(lt.prevProp, ht) ||
          (ct === j && lt.isActive && !vt && dt) ||
          (it > ot && dt),
        Et = !1
      const Rt = Array.isArray(ht) ? ht : [ht]
      let Ft = Rt.reduce(c, {})
      pt === !1 && (Ft = {})
      const { prevResolvedValues: kt = {} } = lt,
        Nt = { ...kt, ...Ft },
        Dt = (Mt) => {
          ;(yt = !0),
            st.has(Mt) && ((Et = !0), st.delete(Mt)),
            (lt.needsAnimating[Mt] = !0)
        }
      for (const Mt in Nt) {
        const wt = Ft[Mt],
          gt = kt[Mt]
        if (at.hasOwnProperty(Mt)) continue
        let At = !1
        isKeyframesTarget(wt) && isKeyframesTarget(gt)
          ? (At = !shallowCompare(wt, gt))
          : (At = wt !== gt),
          At
            ? wt !== void 0
              ? Dt(Mt)
              : st.add(Mt)
            : wt !== void 0 && st.has(Mt)
            ? Dt(Mt)
            : (lt.protectedKeys[Mt] = !0)
      }
      ;(lt.prevProp = ht),
        (lt.prevResolvedValues = Ft),
        lt.isActive && (at = { ...at, ...Ft }),
        o && s.blockInitialAnimation && (yt = !1),
        yt &&
          (!vt || Et) &&
          tt.push(
            ...Rt.map((Mt) => ({ animation: Mt, options: { type: ct, ...b } }))
          )
    }
    if (st.size) {
      const it = {}
      st.forEach((ct) => {
        const lt = s.getBaseTarget(ct)
        lt !== void 0 && (it[ct] = lt)
      }),
        tt.push({ animation: it })
    }
    let ut = !!tt.length
    return (
      o &&
        ($.initial === !1 || $.initial === $.animate) &&
        !s.manuallyAnimateOnMount &&
        (ut = !1),
      (o = !1),
      ut ? e(tt) : Promise.resolve()
    )
  }
  function _(b, j, $) {
    var _e
    if (a[b].isActive === j) return Promise.resolve()
    ;(_e = s.variantChildren) === null ||
      _e === void 0 ||
      _e.forEach((st) => {
        var at
        return (at = st.animationState) === null || at === void 0
          ? void 0
          : at.setActive(b, j)
      }),
      (a[b].isActive = j)
    const tt = g($, b)
    for (const st in a) a[st].protectedKeys = {}
    return tt
  }
  return {
    animateChanges: g,
    setActive: _,
    setAnimateFunction: d,
    getState: () => a,
  }
}
function checkVariantsDidChange(s, e) {
  return typeof e == "string"
    ? e !== s
    : Array.isArray(e)
    ? !shallowCompare(e, s)
    : !1
}
function createTypeState(s = !1) {
  return {
    isActive: s,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  }
}
function createState() {
  return {
    animate: createTypeState(!0),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState(),
  }
}
class AnimationFeature extends Feature {
  constructor(e) {
    super(e), e.animationState || (e.animationState = createAnimationState(e))
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps()
    this.unmount(),
      isAnimationControls(e) && (this.unmount = e.subscribe(this.node))
  }
  mount() {
    this.updateAnimationControlsSubscription()
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: a } = this.node.prevProps || {}
    e !== a && this.updateAnimationControlsSubscription()
  }
  unmount() {}
}
let id$1 = 0
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments), (this.id = id$1++)
  }
  update() {
    if (!this.node.presenceContext) return
    const {
        isPresent: e,
        onExitComplete: a,
        custom: o,
      } = this.node.presenceContext,
      { isPresent: c } = this.node.prevPresenceContext || {}
    if (!this.node.animationState || e === c) return
    const d = this.node.animationState.setActive("exit", !e, {
      custom: o ?? this.node.getProps().custom,
    })
    a && !e && d.then(() => a(this.id))
  }
  mount() {
    const { register: e } = this.node.presenceContext || {}
    e && (this.unmount = e(this.id))
  }
  unmount() {}
}
const animations = {
    animation: { Feature: AnimationFeature },
    exit: { Feature: ExitAnimationFeature },
  },
  distance = (s, e) => Math.abs(s - e)
function distance2D(s, e) {
  const a = distance(s.x, e.x),
    o = distance(s.y, e.y)
  return Math.sqrt(a ** 2 + o ** 2)
}
class PanSession {
  constructor(
    e,
    a,
    { transformPagePoint: o, contextWindow: c, dragSnapToOrigin: d = !1 } = {}
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return
        const _e = getPanInfo(this.lastMoveEventInfo, this.history),
          tt = this.startEvent !== null,
          st = distance2D(_e.offset, { x: 0, y: 0 }) >= 3
        if (!tt && !st) return
        const { point: at } = _e,
          { timestamp: ot } = frameData
        this.history.push({ ...at, timestamp: ot })
        const { onStart: ut, onMove: it } = this.handlers
        tt ||
          (ut && ut(this.lastMoveEvent, _e),
          (this.startEvent = this.lastMoveEvent)),
          it && it(this.lastMoveEvent, _e)
      }),
      (this.handlePointerMove = (_e, tt) => {
        ;(this.lastMoveEvent = _e),
          (this.lastMoveEventInfo = transformPoint(
            tt,
            this.transformPagePoint
          )),
          frame.update(this.updatePoint, !0)
      }),
      (this.handlePointerUp = (_e, tt) => {
        this.end()
        const {
          onEnd: st,
          onSessionEnd: at,
          resumeAnimation: ot,
        } = this.handlers
        if (
          (this.dragSnapToOrigin && ot && ot(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return
        const ut = getPanInfo(
          _e.type === "pointercancel"
            ? this.lastMoveEventInfo
            : transformPoint(tt, this.transformPagePoint),
          this.history
        )
        this.startEvent && st && st(_e, ut), at && at(_e, ut)
      }),
      !isPrimaryPointer(e))
    )
      return
    ;(this.dragSnapToOrigin = d),
      (this.handlers = a),
      (this.transformPagePoint = o),
      (this.contextWindow = c || window)
    const g = extractEventInfo(e),
      _ = transformPoint(g, this.transformPagePoint),
      { point: b } = _,
      { timestamp: j } = frameData
    this.history = [{ ...b, timestamp: j }]
    const { onSessionStart: $ } = a
    $ && $(e, getPanInfo(_, this.history)),
      (this.removeListeners = pipe$1(
        addPointerEvent(
          this.contextWindow,
          "pointermove",
          this.handlePointerMove
        ),
        addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp),
        addPointerEvent(
          this.contextWindow,
          "pointercancel",
          this.handlePointerUp
        )
      ))
  }
  updateHandlers(e) {
    this.handlers = e
  }
  end() {
    this.removeListeners && this.removeListeners(),
      cancelFrame(this.updatePoint)
  }
}
function transformPoint(s, e) {
  return e ? { point: e(s.point) } : s
}
function subtractPoint(s, e) {
  return { x: s.x - e.x, y: s.y - e.y }
}
function getPanInfo({ point: s }, e) {
  return {
    point: s,
    delta: subtractPoint(s, lastDevicePoint(e)),
    offset: subtractPoint(s, startDevicePoint(e)),
    velocity: getVelocity(e, 0.1),
  }
}
function startDevicePoint(s) {
  return s[0]
}
function lastDevicePoint(s) {
  return s[s.length - 1]
}
function getVelocity(s, e) {
  if (s.length < 2) return { x: 0, y: 0 }
  let a = s.length - 1,
    o = null
  const c = lastDevicePoint(s)
  for (
    ;
    a >= 0 &&
    ((o = s[a]), !(c.timestamp - o.timestamp > secondsToMilliseconds(e)));

  )
    a--
  if (!o) return { x: 0, y: 0 }
  const d = millisecondsToSeconds(c.timestamp - o.timestamp)
  if (d === 0) return { x: 0, y: 0 }
  const g = { x: (c.x - o.x) / d, y: (c.y - o.y) / d }
  return g.x === 1 / 0 && (g.x = 0), g.y === 1 / 0 && (g.y = 0), g
}
function calcLength(s) {
  return s.max - s.min
}
function isNear(s, e = 0, a = 0.01) {
  return Math.abs(s - e) <= a
}
function calcAxisDelta(s, e, a, o = 0.5) {
  ;(s.origin = o),
    (s.originPoint = mix(e.min, e.max, s.origin)),
    (s.scale = calcLength(a) / calcLength(e)),
    (isNear(s.scale, 1, 1e-4) || isNaN(s.scale)) && (s.scale = 1),
    (s.translate = mix(a.min, a.max, s.origin) - s.originPoint),
    (isNear(s.translate) || isNaN(s.translate)) && (s.translate = 0)
}
function calcBoxDelta(s, e, a, o) {
  calcAxisDelta(s.x, e.x, a.x, o ? o.originX : void 0),
    calcAxisDelta(s.y, e.y, a.y, o ? o.originY : void 0)
}
function calcRelativeAxis(s, e, a) {
  ;(s.min = a.min + e.min), (s.max = s.min + calcLength(e))
}
function calcRelativeBox(s, e, a) {
  calcRelativeAxis(s.x, e.x, a.x), calcRelativeAxis(s.y, e.y, a.y)
}
function calcRelativeAxisPosition(s, e, a) {
  ;(s.min = e.min - a.min), (s.max = s.min + calcLength(e))
}
function calcRelativePosition(s, e, a) {
  calcRelativeAxisPosition(s.x, e.x, a.x),
    calcRelativeAxisPosition(s.y, e.y, a.y)
}
function applyConstraints(s, { min: e, max: a }, o) {
  return (
    e !== void 0 && s < e
      ? (s = o ? mix(e, s, o.min) : Math.max(s, e))
      : a !== void 0 && s > a && (s = o ? mix(a, s, o.max) : Math.min(s, a)),
    s
  )
}
function calcRelativeAxisConstraints(s, e, a) {
  return {
    min: e !== void 0 ? s.min + e : void 0,
    max: a !== void 0 ? s.max + a - (s.max - s.min) : void 0,
  }
}
function calcRelativeConstraints(s, { top: e, left: a, bottom: o, right: c }) {
  return {
    x: calcRelativeAxisConstraints(s.x, a, c),
    y: calcRelativeAxisConstraints(s.y, e, o),
  }
}
function calcViewportAxisConstraints(s, e) {
  let a = e.min - s.min,
    o = e.max - s.max
  return e.max - e.min < s.max - s.min && ([a, o] = [o, a]), { min: a, max: o }
}
function calcViewportConstraints(s, e) {
  return {
    x: calcViewportAxisConstraints(s.x, e.x),
    y: calcViewportAxisConstraints(s.y, e.y),
  }
}
function calcOrigin(s, e) {
  let a = 0.5
  const o = calcLength(s),
    c = calcLength(e)
  return (
    c > o
      ? (a = progress(e.min, e.max - o, s.min))
      : o > c && (a = progress(s.min, s.max - c, e.min)),
    clamp$1(0, 1, a)
  )
}
function rebaseAxisConstraints(s, e) {
  const a = {}
  return (
    e.min !== void 0 && (a.min = e.min - s.min),
    e.max !== void 0 && (a.max = e.max - s.min),
    a
  )
}
const defaultElastic = 0.35
function resolveDragElastic(s = defaultElastic) {
  return (
    s === !1 ? (s = 0) : s === !0 && (s = defaultElastic),
    {
      x: resolveAxisElastic(s, "left", "right"),
      y: resolveAxisElastic(s, "top", "bottom"),
    }
  )
}
function resolveAxisElastic(s, e, a) {
  return { min: resolvePointElastic(s, e), max: resolvePointElastic(s, a) }
}
function resolvePointElastic(s, e) {
  return typeof s == "number" ? s : s[e] || 0
}
const createAxisDelta = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0,
  }),
  createDelta = () => ({ x: createAxisDelta(), y: createAxisDelta() }),
  createAxis = () => ({ min: 0, max: 0 }),
  createBox = () => ({ x: createAxis(), y: createAxis() })
function eachAxis(s) {
  return [s("x"), s("y")]
}
function convertBoundingBoxToBox({ top: s, left: e, right: a, bottom: o }) {
  return { x: { min: e, max: a }, y: { min: s, max: o } }
}
function convertBoxToBoundingBox({ x: s, y: e }) {
  return { top: e.min, right: s.max, bottom: e.max, left: s.min }
}
function transformBoxPoints(s, e) {
  if (!e) return s
  const a = e({ x: s.left, y: s.top }),
    o = e({ x: s.right, y: s.bottom })
  return { top: a.y, left: a.x, bottom: o.y, right: o.x }
}
function isIdentityScale(s) {
  return s === void 0 || s === 1
}
function hasScale({ scale: s, scaleX: e, scaleY: a }) {
  return !isIdentityScale(s) || !isIdentityScale(e) || !isIdentityScale(a)
}
function hasTransform(s) {
  return (
    hasScale(s) ||
    has2DTranslate(s) ||
    s.z ||
    s.rotate ||
    s.rotateX ||
    s.rotateY
  )
}
function has2DTranslate(s) {
  return is2DTranslate(s.x) || is2DTranslate(s.y)
}
function is2DTranslate(s) {
  return s && s !== "0%"
}
function scalePoint(s, e, a) {
  const o = s - a,
    c = e * o
  return a + c
}
function applyPointDelta(s, e, a, o, c) {
  return c !== void 0 && (s = scalePoint(s, c, o)), scalePoint(s, a, o) + e
}
function applyAxisDelta(s, e = 0, a = 1, o, c) {
  ;(s.min = applyPointDelta(s.min, e, a, o, c)),
    (s.max = applyPointDelta(s.max, e, a, o, c))
}
function applyBoxDelta(s, { x: e, y: a }) {
  applyAxisDelta(s.x, e.translate, e.scale, e.originPoint),
    applyAxisDelta(s.y, a.translate, a.scale, a.originPoint)
}
function applyTreeDeltas(s, e, a, o = !1) {
  const c = a.length
  if (!c) return
  e.x = e.y = 1
  let d, g
  for (let _ = 0; _ < c; _++) {
    ;(d = a[_]), (g = d.projectionDelta)
    const b = d.instance
    ;(b && b.style && b.style.display === "contents") ||
      (o &&
        d.options.layoutScroll &&
        d.scroll &&
        d !== d.root &&
        transformBox(s, { x: -d.scroll.offset.x, y: -d.scroll.offset.y }),
      g && ((e.x *= g.x.scale), (e.y *= g.y.scale), applyBoxDelta(s, g)),
      o && hasTransform(d.latestValues) && transformBox(s, d.latestValues))
  }
  ;(e.x = snapToDefault(e.x)), (e.y = snapToDefault(e.y))
}
function snapToDefault(s) {
  return Number.isInteger(s) || s > 1.0000000000001 || s < 0.999999999999
    ? s
    : 1
}
function translateAxis(s, e) {
  ;(s.min = s.min + e), (s.max = s.max + e)
}
function transformAxis(s, e, [a, o, c]) {
  const d = e[c] !== void 0 ? e[c] : 0.5,
    g = mix(s.min, s.max, d)
  applyAxisDelta(s, e[a], e[o], g, e.scale)
}
const xKeys$1 = ["x", "scaleX", "originX"],
  yKeys$1 = ["y", "scaleY", "originY"]
function transformBox(s, e) {
  transformAxis(s.x, e, xKeys$1), transformAxis(s.y, e, yKeys$1)
}
function measureViewportBox(s, e) {
  return convertBoundingBoxToBox(
    transformBoxPoints(s.getBoundingClientRect(), e)
  )
}
function measurePageBox(s, e, a) {
  const o = measureViewportBox(s, a),
    { scroll: c } = e
  return (
    c && (translateAxis(o.x, c.offset.x), translateAxis(o.y, c.offset.y)), o
  )
}
const getContextWindow = ({ current: s }) =>
    s ? s.ownerDocument.defaultView : null,
  elementDragControls = new WeakMap()
class VisualElementDragControls {
  constructor(e) {
    ;(this.openGlobalLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = createBox()),
      (this.visualElement = e)
  }
  start(e, { snapToCursor: a = !1 } = {}) {
    const { presenceContext: o } = this.visualElement
    if (o && o.isPresent === !1) return
    const c = ($) => {
        const { dragSnapToOrigin: _e } = this.getProps()
        _e ? this.pauseAnimation() : this.stopAnimation(),
          a && this.snapToCursor(extractEventInfo($, "page").point)
      },
      d = ($, _e) => {
        const {
          drag: tt,
          dragPropagation: st,
          onDragStart: at,
        } = this.getProps()
        if (
          tt &&
          !st &&
          (this.openGlobalLock && this.openGlobalLock(),
          (this.openGlobalLock = getGlobalLock(tt)),
          !this.openGlobalLock)
        )
          return
        ;(this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          eachAxis((ut) => {
            let it = this.getAxisMotionValue(ut).get() || 0
            if (percent.test(it)) {
              const { projection: ct } = this.visualElement
              if (ct && ct.layout) {
                const lt = ct.layout.layoutBox[ut]
                lt && (it = calcLength(lt) * (parseFloat(it) / 100))
              }
            }
            this.originPoint[ut] = it
          }),
          at && frame.update(() => at($, _e), !1, !0)
        const { animationState: ot } = this.visualElement
        ot && ot.setActive("whileDrag", !0)
      },
      g = ($, _e) => {
        const {
          dragPropagation: tt,
          dragDirectionLock: st,
          onDirectionLock: at,
          onDrag: ot,
        } = this.getProps()
        if (!tt && !this.openGlobalLock) return
        const { offset: ut } = _e
        if (st && this.currentDirection === null) {
          ;(this.currentDirection = getCurrentDirection(ut)),
            this.currentDirection !== null && at && at(this.currentDirection)
          return
        }
        this.updateAxis("x", _e.point, ut),
          this.updateAxis("y", _e.point, ut),
          this.visualElement.render(),
          ot && ot($, _e)
      },
      _ = ($, _e) => this.stop($, _e),
      b = () =>
        eachAxis(($) => {
          var _e
          return (
            this.getAnimationState($) === "paused" &&
            ((_e = this.getAxisMotionValue($).animation) === null ||
            _e === void 0
              ? void 0
              : _e.play())
          )
        }),
      { dragSnapToOrigin: j } = this.getProps()
    this.panSession = new PanSession(
      e,
      {
        onSessionStart: c,
        onStart: d,
        onMove: g,
        onSessionEnd: _,
        resumeAnimation: b,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: j,
        contextWindow: getContextWindow(this.visualElement),
      }
    )
  }
  stop(e, a) {
    const o = this.isDragging
    if ((this.cancel(), !o)) return
    const { velocity: c } = a
    this.startAnimation(c)
    const { onDragEnd: d } = this.getProps()
    d && frame.update(() => d(e, a))
  }
  cancel() {
    this.isDragging = !1
    const { projection: e, animationState: a } = this.visualElement
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0)
    const { dragPropagation: o } = this.getProps()
    !o &&
      this.openGlobalLock &&
      (this.openGlobalLock(), (this.openGlobalLock = null)),
      a && a.setActive("whileDrag", !1)
  }
  updateAxis(e, a, o) {
    const { drag: c } = this.getProps()
    if (!o || !shouldDrag(e, c, this.currentDirection)) return
    const d = this.getAxisMotionValue(e)
    let g = this.originPoint[e] + o[e]
    this.constraints &&
      this.constraints[e] &&
      (g = applyConstraints(g, this.constraints[e], this.elastic[e])),
      d.set(g)
  }
  resolveConstraints() {
    var e
    const { dragConstraints: a, dragElastic: o } = this.getProps(),
      c =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (e = this.visualElement.projection) === null || e === void 0
          ? void 0
          : e.layout,
      d = this.constraints
    a && isRefObject(a)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : a && c
      ? (this.constraints = calcRelativeConstraints(c.layoutBox, a))
      : (this.constraints = !1),
      (this.elastic = resolveDragElastic(o)),
      d !== this.constraints &&
        c &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        eachAxis((g) => {
          this.getAxisMotionValue(g) &&
            (this.constraints[g] = rebaseAxisConstraints(
              c.layoutBox[g],
              this.constraints[g]
            ))
        })
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: a } = this.getProps()
    if (!e || !isRefObject(e)) return !1
    const o = e.current,
      { projection: c } = this.visualElement
    if (!c || !c.layout) return !1
    const d = measurePageBox(
      o,
      c.root,
      this.visualElement.getTransformPagePoint()
    )
    let g = calcViewportConstraints(c.layout.layoutBox, d)
    if (a) {
      const _ = a(convertBoxToBoundingBox(g))
      ;(this.hasMutatedConstraints = !!_), _ && (g = convertBoundingBoxToBox(_))
    }
    return g
  }
  startAnimation(e) {
    const {
        drag: a,
        dragMomentum: o,
        dragElastic: c,
        dragTransition: d,
        dragSnapToOrigin: g,
        onDragTransitionEnd: _,
      } = this.getProps(),
      b = this.constraints || {},
      j = eachAxis(($) => {
        if (!shouldDrag($, a, this.currentDirection)) return
        let _e = (b && b[$]) || {}
        g && (_e = { min: 0, max: 0 })
        const tt = c ? 200 : 1e6,
          st = c ? 40 : 1e7,
          at = {
            type: "inertia",
            velocity: o ? e[$] : 0,
            bounceStiffness: tt,
            bounceDamping: st,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...d,
            ..._e,
          }
        return this.startAxisValueAnimation($, at)
      })
    return Promise.all(j).then(_)
  }
  startAxisValueAnimation(e, a) {
    const o = this.getAxisMotionValue(e)
    return o.start(animateMotionValue(e, o, 0, a))
  }
  stopAnimation() {
    eachAxis((e) => this.getAxisMotionValue(e).stop())
  }
  pauseAnimation() {
    eachAxis((e) => {
      var a
      return (a = this.getAxisMotionValue(e).animation) === null || a === void 0
        ? void 0
        : a.pause()
    })
  }
  getAnimationState(e) {
    var a
    return (a = this.getAxisMotionValue(e).animation) === null || a === void 0
      ? void 0
      : a.state
  }
  getAxisMotionValue(e) {
    const a = "_drag" + e.toUpperCase(),
      o = this.visualElement.getProps(),
      c = o[a]
    return (
      c ||
      this.visualElement.getValue(e, (o.initial ? o.initial[e] : void 0) || 0)
    )
  }
  snapToCursor(e) {
    eachAxis((a) => {
      const { drag: o } = this.getProps()
      if (!shouldDrag(a, o, this.currentDirection)) return
      const { projection: c } = this.visualElement,
        d = this.getAxisMotionValue(a)
      if (c && c.layout) {
        const { min: g, max: _ } = c.layout.layoutBox[a]
        d.set(e[a] - mix(g, _, 0.5))
      }
    })
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return
    const { drag: e, dragConstraints: a } = this.getProps(),
      { projection: o } = this.visualElement
    if (!isRefObject(a) || !o || !this.constraints) return
    this.stopAnimation()
    const c = { x: 0, y: 0 }
    eachAxis((g) => {
      const _ = this.getAxisMotionValue(g)
      if (_) {
        const b = _.get()
        c[g] = calcOrigin({ min: b, max: b }, this.constraints[g])
      }
    })
    const { transformTemplate: d } = this.visualElement.getProps()
    ;(this.visualElement.current.style.transform = d ? d({}, "") : "none"),
      o.root && o.root.updateScroll(),
      o.updateLayout(),
      this.resolveConstraints(),
      eachAxis((g) => {
        if (!shouldDrag(g, e, null)) return
        const _ = this.getAxisMotionValue(g),
          { min: b, max: j } = this.constraints[g]
        _.set(mix(b, j, c[g]))
      })
  }
  addListeners() {
    if (!this.visualElement.current) return
    elementDragControls.set(this.visualElement, this)
    const e = this.visualElement.current,
      a = addPointerEvent(e, "pointerdown", (b) => {
        const { drag: j, dragListener: $ = !0 } = this.getProps()
        j && $ && this.start(b)
      }),
      o = () => {
        const { dragConstraints: b } = this.getProps()
        isRefObject(b) && (this.constraints = this.resolveRefConstraints())
      },
      { projection: c } = this.visualElement,
      d = c.addEventListener("measure", o)
    c && !c.layout && (c.root && c.root.updateScroll(), c.updateLayout()), o()
    const g = addDomEvent(window, "resize", () =>
        this.scalePositionWithinConstraints()
      ),
      _ = c.addEventListener(
        "didUpdate",
        ({ delta: b, hasLayoutChanged: j }) => {
          this.isDragging &&
            j &&
            (eachAxis(($) => {
              const _e = this.getAxisMotionValue($)
              _e &&
                ((this.originPoint[$] += b[$].translate),
                _e.set(_e.get() + b[$].translate))
            }),
            this.visualElement.render())
        }
      )
    return () => {
      g(), a(), d(), _ && _()
    }
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: a = !1,
        dragDirectionLock: o = !1,
        dragPropagation: c = !1,
        dragConstraints: d = !1,
        dragElastic: g = defaultElastic,
        dragMomentum: _ = !0,
      } = e
    return {
      ...e,
      drag: a,
      dragDirectionLock: o,
      dragPropagation: c,
      dragConstraints: d,
      dragElastic: g,
      dragMomentum: _,
    }
  }
}
function shouldDrag(s, e, a) {
  return (e === !0 || e === s) && (a === null || a === s)
}
function getCurrentDirection(s, e = 10) {
  let a = null
  return Math.abs(s.y) > e ? (a = "y") : Math.abs(s.x) > e && (a = "x"), a
}
class DragGesture extends Feature {
  constructor(e) {
    super(e),
      (this.removeGroupControls = noop),
      (this.removeListeners = noop),
      (this.controls = new VisualElementDragControls(e))
  }
  mount() {
    const { dragControls: e } = this.node.getProps()
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || noop)
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners()
  }
}
const asyncHandler = (s) => (e, a) => {
  s && frame.update(() => s(e, a))
}
class PanGesture extends Feature {
  constructor() {
    super(...arguments), (this.removePointerDownListener = noop)
  }
  onPointerDown(e) {
    this.session = new PanSession(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node),
    })
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: a,
      onPan: o,
      onPanEnd: c,
    } = this.node.getProps()
    return {
      onSessionStart: asyncHandler(e),
      onStart: asyncHandler(a),
      onMove: o,
      onEnd: (d, g) => {
        delete this.session, c && frame.update(() => c(d, g))
      },
    }
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(
      this.node.current,
      "pointerdown",
      (e) => this.onPointerDown(e)
    )
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers())
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end()
  }
}
function usePresence() {
  const s = reactExports.useContext(PresenceContext)
  if (s === null) return [!0, null]
  const { isPresent: e, onExitComplete: a, register: o } = s,
    c = reactExports.useId()
  return (
    reactExports.useEffect(() => o(c), []),
    !e && a ? [!1, () => a && a(c)] : [!0]
  )
}
const globalProjectionState = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }
function pixelsToPercent(s, e) {
  return e.max === e.min ? 0 : (s / (e.max - e.min)) * 100
}
const correctBorderRadius = {
    correct: (s, e) => {
      if (!e.target) return s
      if (typeof s == "string")
        if (px.test(s)) s = parseFloat(s)
        else return s
      const a = pixelsToPercent(s, e.target.x),
        o = pixelsToPercent(s, e.target.y)
      return `${a}% ${o}%`
    },
  },
  correctBoxShadow = {
    correct: (s, { treeScale: e, projectionDelta: a }) => {
      const o = s,
        c = complex.parse(s)
      if (c.length > 5) return o
      const d = complex.createTransformer(s),
        g = typeof c[0] != "number" ? 1 : 0,
        _ = a.x.scale * e.x,
        b = a.y.scale * e.y
      ;(c[0 + g] /= _), (c[1 + g] /= b)
      const j = mix(_, b, 0.5)
      return (
        typeof c[2 + g] == "number" && (c[2 + g] /= j),
        typeof c[3 + g] == "number" && (c[3 + g] /= j),
        d(c)
      )
    },
  }
class MeasureLayoutWithContext extends React.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: a,
        switchLayoutGroup: o,
        layoutId: c,
      } = this.props,
      { projection: d } = e
    addScaleCorrector(defaultScaleCorrectors),
      d &&
        (a.group && a.group.add(d),
        o && o.register && c && o.register(d),
        d.root.didUpdate(),
        d.addEventListener("animationComplete", () => {
          this.safeToRemove()
        }),
        d.setOptions({
          ...d.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (globalProjectionState.hasEverUpdated = !0)
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: a,
        visualElement: o,
        drag: c,
        isPresent: d,
      } = this.props,
      g = o.projection
    return (
      g &&
        ((g.isPresent = d),
        c || e.layoutDependency !== a || a === void 0
          ? g.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== d &&
          (d
            ? g.promote()
            : g.relegate() ||
              frame.postRender(() => {
                const _ = g.getStack()
                ;(!_ || !_.members.length) && this.safeToRemove()
              }))),
      null
    )
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement
    e &&
      (e.root.didUpdate(),
      queueMicrotask(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove()
      }))
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: a,
        switchLayoutGroup: o,
      } = this.props,
      { projection: c } = e
    c &&
      (c.scheduleCheckAfterUnmount(),
      a && a.group && a.group.remove(c),
      o && o.deregister && o.deregister(c))
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props
    e && e()
  }
  render() {
    return null
  }
}
function MeasureLayout(s) {
  const [e, a] = usePresence(),
    o = reactExports.useContext(LayoutGroupContext)
  return React.createElement(MeasureLayoutWithContext, {
    ...s,
    layoutGroup: o,
    switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
    isPresent: e,
    safeToRemove: a,
  })
}
const defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
      ],
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow,
  },
  borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  numBorders = borders.length,
  asNumber = (s) => (typeof s == "string" ? parseFloat(s) : s),
  isPx = (s) => typeof s == "number" || px.test(s)
function mixValues(s, e, a, o, c, d) {
  c
    ? ((s.opacity = mix(
        0,
        a.opacity !== void 0 ? a.opacity : 1,
        easeCrossfadeIn(o)
      )),
      (s.opacityExit = mix(
        e.opacity !== void 0 ? e.opacity : 1,
        0,
        easeCrossfadeOut(o)
      )))
    : d &&
      (s.opacity = mix(
        e.opacity !== void 0 ? e.opacity : 1,
        a.opacity !== void 0 ? a.opacity : 1,
        o
      ))
  for (let g = 0; g < numBorders; g++) {
    const _ = `border${borders[g]}Radius`
    let b = getRadius(e, _),
      j = getRadius(a, _)
    if (b === void 0 && j === void 0) continue
    b || (b = 0),
      j || (j = 0),
      b === 0 || j === 0 || isPx(b) === isPx(j)
        ? ((s[_] = Math.max(mix(asNumber(b), asNumber(j), o), 0)),
          (percent.test(j) || percent.test(b)) && (s[_] += "%"))
        : (s[_] = j)
  }
  ;(e.rotate || a.rotate) && (s.rotate = mix(e.rotate || 0, a.rotate || 0, o))
}
function getRadius(s, e) {
  return s[e] !== void 0 ? s[e] : s.borderRadius
}
const easeCrossfadeIn = compress(0, 0.5, circOut),
  easeCrossfadeOut = compress(0.5, 0.95, noop)
function compress(s, e, a) {
  return (o) => (o < s ? 0 : o > e ? 1 : a(progress(s, e, o)))
}
function copyAxisInto(s, e) {
  ;(s.min = e.min), (s.max = e.max)
}
function copyBoxInto(s, e) {
  copyAxisInto(s.x, e.x), copyAxisInto(s.y, e.y)
}
function removePointDelta(s, e, a, o, c) {
  return (
    (s -= e),
    (s = scalePoint(s, 1 / a, o)),
    c !== void 0 && (s = scalePoint(s, 1 / c, o)),
    s
  )
}
function removeAxisDelta(s, e = 0, a = 1, o = 0.5, c, d = s, g = s) {
  if (
    (percent.test(e) &&
      ((e = parseFloat(e)), (e = mix(g.min, g.max, e / 100) - g.min)),
    typeof e != "number")
  )
    return
  let _ = mix(d.min, d.max, o)
  s === d && (_ -= e),
    (s.min = removePointDelta(s.min, e, a, _, c)),
    (s.max = removePointDelta(s.max, e, a, _, c))
}
function removeAxisTransforms(s, e, [a, o, c], d, g) {
  removeAxisDelta(s, e[a], e[o], e[c], e.scale, d, g)
}
const xKeys = ["x", "scaleX", "originX"],
  yKeys = ["y", "scaleY", "originY"]
function removeBoxTransforms(s, e, a, o) {
  removeAxisTransforms(s.x, e, xKeys, a ? a.x : void 0, o ? o.x : void 0),
    removeAxisTransforms(s.y, e, yKeys, a ? a.y : void 0, o ? o.y : void 0)
}
function isAxisDeltaZero(s) {
  return s.translate === 0 && s.scale === 1
}
function isDeltaZero(s) {
  return isAxisDeltaZero(s.x) && isAxisDeltaZero(s.y)
}
function boxEquals(s, e) {
  return (
    s.x.min === e.x.min &&
    s.x.max === e.x.max &&
    s.y.min === e.y.min &&
    s.y.max === e.y.max
  )
}
function boxEqualsRounded(s, e) {
  return (
    Math.round(s.x.min) === Math.round(e.x.min) &&
    Math.round(s.x.max) === Math.round(e.x.max) &&
    Math.round(s.y.min) === Math.round(e.y.min) &&
    Math.round(s.y.max) === Math.round(e.y.max)
  )
}
function aspectRatio(s) {
  return calcLength(s.x) / calcLength(s.y)
}
class NodeStack {
  constructor() {
    this.members = []
  }
  add(e) {
    addUniqueItem(this.members, e), e.scheduleRender()
  }
  remove(e) {
    if (
      (removeItem(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const a = this.members[this.members.length - 1]
      a && this.promote(a)
    }
  }
  relegate(e) {
    const a = this.members.findIndex((c) => e === c)
    if (a === 0) return !1
    let o
    for (let c = a; c >= 0; c--) {
      const d = this.members[c]
      if (d.isPresent !== !1) {
        o = d
        break
      }
    }
    return o ? (this.promote(o), !0) : !1
  }
  promote(e, a) {
    const o = this.lead
    if (e !== o && ((this.prevLead = o), (this.lead = e), e.show(), o)) {
      o.instance && o.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = o),
        a && (e.resumeFrom.preserveOpacity = !0),
        o.snapshot &&
          ((e.snapshot = o.snapshot),
          (e.snapshot.latestValues = o.animationValues || o.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0)
      const { crossfade: c } = e.options
      c === !1 && o.hide()
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: a, resumingFrom: o } = e
      a.onExitComplete && a.onExitComplete(),
        o && o.options.onExitComplete && o.options.onExitComplete()
    })
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1)
    })
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
  }
}
function buildProjectionTransform(s, e, a) {
  let o = ""
  const c = s.x.translate / e.x,
    d = s.y.translate / e.y
  if (
    ((c || d) && (o = `translate3d(${c}px, ${d}px, 0) `),
    (e.x !== 1 || e.y !== 1) && (o += `scale(${1 / e.x}, ${1 / e.y}) `),
    a)
  ) {
    const { rotate: b, rotateX: j, rotateY: $ } = a
    b && (o += `rotate(${b}deg) `),
      j && (o += `rotateX(${j}deg) `),
      $ && (o += `rotateY(${$}deg) `)
  }
  const g = s.x.scale * e.x,
    _ = s.y.scale * e.y
  return (g !== 1 || _ !== 1) && (o += `scale(${g}, ${_})`), o || "none"
}
const compareByDepth = (s, e) => s.depth - e.depth
class FlatTree {
  constructor() {
    ;(this.children = []), (this.isDirty = !1)
  }
  add(e) {
    addUniqueItem(this.children, e), (this.isDirty = !0)
  }
  remove(e) {
    removeItem(this.children, e), (this.isDirty = !0)
  }
  forEach(e) {
    this.isDirty && this.children.sort(compareByDepth),
      (this.isDirty = !1),
      this.children.forEach(e)
  }
}
function delay(s, e) {
  const a = performance.now(),
    o = ({ timestamp: c }) => {
      const d = c - a
      d >= e && (cancelFrame(o), s(d - e))
    }
  return frame.read(o, !0), () => cancelFrame(o)
}
function record(s) {
  window.MotionDebug && window.MotionDebug.record(s)
}
function isSVGElement(s) {
  return s instanceof SVGElement && s.tagName !== "svg"
}
function animateSingleValue(s, e, a) {
  const o = isMotionValue(s) ? s : motionValue(s)
  return o.start(animateMotionValue("", o, e, a)), o.animation
}
const transformAxes = ["", "X", "Y", "Z"],
  hiddenVisibility = { visibility: "hidden" },
  animationTarget = 1e3
let id = 0
const projectionFrameData = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0,
}
function createProjectionNode({
  attachResizeListener: s,
  defaultParent: e,
  measureScroll: a,
  checkIsScrollRoot: o,
  resetTransform: c,
}) {
  return class {
    constructor(g = {}, _ = e == null ? void 0 : e()) {
      ;(this.id = id++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots())
        }),
        (this.updateProjection = () => {
          ;(this.projectionUpdateScheduled = !1),
            (projectionFrameData.totalNodes =
              projectionFrameData.resolvedTargetDeltas =
              projectionFrameData.recalculatedProjection =
                0),
            this.nodes.forEach(propagateDirtyNodes),
            this.nodes.forEach(resolveTargetDelta),
            this.nodes.forEach(calcProjection),
            this.nodes.forEach(cleanDirtyNodes),
            record(projectionFrameData)
        }),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = g),
        (this.root = _ ? _.root || _ : this),
        (this.path = _ ? [..._.path, _] : []),
        (this.parent = _),
        (this.depth = _ ? _.depth + 1 : 0)
      for (let b = 0; b < this.path.length; b++)
        this.path[b].shouldResetTransform = !0
      this.root === this && (this.nodes = new FlatTree())
    }
    addEventListener(g, _) {
      return (
        this.eventHandlers.has(g) ||
          this.eventHandlers.set(g, new SubscriptionManager()),
        this.eventHandlers.get(g).add(_)
      )
    }
    notifyListeners(g, ..._) {
      const b = this.eventHandlers.get(g)
      b && b.notify(..._)
    }
    hasListeners(g) {
      return this.eventHandlers.has(g)
    }
    mount(g, _ = this.root.hasTreeAnimated) {
      if (this.instance) return
      ;(this.isSVG = isSVGElement(g)), (this.instance = g)
      const { layoutId: b, layout: j, visualElement: $ } = this.options
      if (
        ($ && !$.current && $.mount(g),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        _ && (j || b) && (this.isLayoutDirty = !0),
        s)
      ) {
        let _e
        const tt = () => (this.root.updateBlockedByResize = !1)
        s(g, () => {
          ;(this.root.updateBlockedByResize = !0),
            _e && _e(),
            (_e = delay(tt, 250)),
            globalProjectionState.hasAnimatedSinceResize &&
              ((globalProjectionState.hasAnimatedSinceResize = !1),
              this.nodes.forEach(finishAnimation))
        })
      }
      b && this.root.registerSharedNode(b, this),
        this.options.animate !== !1 &&
          $ &&
          (b || j) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: _e,
              hasLayoutChanged: tt,
              hasRelativeTargetChanged: st,
              layout: at,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                ;(this.target = void 0), (this.relativeTarget = void 0)
                return
              }
              const ot =
                  this.options.transition ||
                  $.getDefaultTransition() ||
                  defaultLayoutTransition,
                { onLayoutAnimationStart: ut, onLayoutAnimationComplete: it } =
                  $.getProps(),
                ct =
                  !this.targetLayout ||
                  !boxEqualsRounded(this.targetLayout, at) ||
                  st,
                lt = !tt && st
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                lt ||
                (tt && (ct || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(_e, lt)
                const ht = {
                  ...getValueTransition(ot, "layout"),
                  onPlay: ut,
                  onComplete: it,
                }
                ;($.shouldReduceMotion || this.options.layoutRoot) &&
                  ((ht.delay = 0), (ht.type = !1)),
                  this.startAnimation(ht)
              } else
                tt || finishAnimation(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete()
              this.targetLayout = at
            }
          )
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this)
      const g = this.getStack()
      g && g.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        cancelFrame(this.updateProjection)
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      )
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(resetRotation),
        this.animationId++)
    }
    getTransformTemplate() {
      const { visualElement: g } = this.options
      return g && g.getProps().transformTemplate
    }
    willUpdate(g = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete()
        return
      }
      if (
        (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
      )
        return
      this.isLayoutDirty = !0
      for (let $ = 0; $ < this.path.length; $++) {
        const _e = this.path[$]
        ;(_e.shouldResetTransform = !0),
          _e.updateScroll("snapshot"),
          _e.options.layoutRoot && _e.willUpdate(!1)
      }
      const { layoutId: _, layout: b } = this.options
      if (_ === void 0 && !b) return
      const j = this.getTransformTemplate()
      ;(this.prevTransformTemplateValue = j
        ? j(this.latestValues, "")
        : void 0),
        this.updateSnapshot(),
        g && this.notifyListeners("willUpdate")
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(),
          this.clearAllSnapshots(),
          this.nodes.forEach(clearMeasurements)
        return
      }
      this.isUpdating || this.nodes.forEach(clearIsLayoutDirty),
        (this.isUpdating = !1),
        this.nodes.forEach(resetTransformStyle),
        this.nodes.forEach(updateLayout),
        this.nodes.forEach(notifyLayoutUpdate),
        this.clearAllSnapshots()
      const _ = performance.now()
      ;(frameData.delta = clamp$1(0, 1e3 / 60, _ - frameData.timestamp)),
        (frameData.timestamp = _),
        (frameData.isProcessing = !0),
        steps.update.process(frameData),
        steps.preRender.process(frameData),
        steps.render.process(frameData),
        (frameData.isProcessing = !1)
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), queueMicrotask(() => this.update()))
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot),
        this.sharedNodes.forEach(removeLeadSnapshots)
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        frame.preRender(this.updateProjection, !1, !0))
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed()
      })
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure())
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let b = 0; b < this.path.length; b++) this.path[b].updateScroll()
      const g = this.layout
      ;(this.layout = this.measure(!1)),
        (this.layoutCorrected = createBox()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox)
      const { visualElement: _ } = this.options
      _ &&
        _.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          g ? g.layoutBox : void 0
        )
    }
    updateScroll(g = "measure") {
      let _ = !!(this.options.layoutScroll && this.instance)
      this.scroll &&
        this.scroll.animationId === this.root.animationId &&
        this.scroll.phase === g &&
        (_ = !1),
        _ &&
          (this.scroll = {
            animationId: this.root.animationId,
            phase: g,
            isRoot: o(this.instance),
            offset: a(this.instance),
          })
    }
    resetTransform() {
      if (!c) return
      const g = this.isLayoutDirty || this.shouldResetTransform,
        _ = this.projectionDelta && !isDeltaZero(this.projectionDelta),
        b = this.getTransformTemplate(),
        j = b ? b(this.latestValues, "") : void 0,
        $ = j !== this.prevTransformTemplateValue
      g &&
        (_ || hasTransform(this.latestValues) || $) &&
        (c(this.instance, j),
        (this.shouldResetTransform = !1),
        this.scheduleRender())
    }
    measure(g = !0) {
      const _ = this.measurePageBox()
      let b = this.removeElementScroll(_)
      return (
        g && (b = this.removeTransform(b)),
        roundBox(b),
        {
          animationId: this.root.animationId,
          measuredBox: _,
          layoutBox: b,
          latestValues: {},
          source: this.id,
        }
      )
    }
    measurePageBox() {
      const { visualElement: g } = this.options
      if (!g) return createBox()
      const _ = g.measureViewportBox(),
        { scroll: b } = this.root
      return (
        b && (translateAxis(_.x, b.offset.x), translateAxis(_.y, b.offset.y)), _
      )
    }
    removeElementScroll(g) {
      const _ = createBox()
      copyBoxInto(_, g)
      for (let b = 0; b < this.path.length; b++) {
        const j = this.path[b],
          { scroll: $, options: _e } = j
        if (j !== this.root && $ && _e.layoutScroll) {
          if ($.isRoot) {
            copyBoxInto(_, g)
            const { scroll: tt } = this.root
            tt &&
              (translateAxis(_.x, -tt.offset.x),
              translateAxis(_.y, -tt.offset.y))
          }
          translateAxis(_.x, $.offset.x), translateAxis(_.y, $.offset.y)
        }
      }
      return _
    }
    applyTransform(g, _ = !1) {
      const b = createBox()
      copyBoxInto(b, g)
      for (let j = 0; j < this.path.length; j++) {
        const $ = this.path[j]
        !_ &&
          $.options.layoutScroll &&
          $.scroll &&
          $ !== $.root &&
          transformBox(b, { x: -$.scroll.offset.x, y: -$.scroll.offset.y }),
          hasTransform($.latestValues) && transformBox(b, $.latestValues)
      }
      return (
        hasTransform(this.latestValues) && transformBox(b, this.latestValues), b
      )
    }
    removeTransform(g) {
      const _ = createBox()
      copyBoxInto(_, g)
      for (let b = 0; b < this.path.length; b++) {
        const j = this.path[b]
        if (!j.instance || !hasTransform(j.latestValues)) continue
        hasScale(j.latestValues) && j.updateSnapshot()
        const $ = createBox(),
          _e = j.measurePageBox()
        copyBoxInto($, _e),
          removeBoxTransforms(
            _,
            j.latestValues,
            j.snapshot ? j.snapshot.layoutBox : void 0,
            $
          )
      }
      return (
        hasTransform(this.latestValues) &&
          removeBoxTransforms(_, this.latestValues),
        _
      )
    }
    setTargetDelta(g) {
      ;(this.targetDelta = g),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0)
    }
    setOptions(g) {
      this.options = {
        ...this.options,
        ...g,
        crossfade: g.crossfade !== void 0 ? g.crossfade : !0,
      }
    }
    clearMeasurements() {
      ;(this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1)
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp &&
        this.relativeParent.resolveTargetDelta(!0)
    }
    resolveTargetDelta(g = !1) {
      var _
      const b = this.getLead()
      this.isProjectionDirty || (this.isProjectionDirty = b.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = b.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = b.isSharedProjectionDirty)
      const j = !!this.resumingFrom || this !== b
      if (
        !(
          g ||
          (j && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((_ = this.parent) === null || _ === void 0) &&
            _.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget
        )
      )
        return
      const { layout: _e, layoutId: tt } = this.options
      if (!(!this.layout || !(_e || tt))) {
        if (
          ((this.resolvedRelativeTargetAt = frameData.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const st = this.getClosestProjectingParent()
          st && st.layout && this.animationProgress !== 1
            ? ((this.relativeParent = st),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = createBox()),
              (this.relativeTargetOrigin = createBox()),
              calcRelativePosition(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                st.layout.layoutBox
              ),
              copyBoxInto(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0)
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = createBox()),
              (this.targetWithTransforms = createBox())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                calcRelativeBox(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target
                ))
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : copyBoxInto(this.target, this.layout.layoutBox),
                applyBoxDelta(this.target, this.targetDelta))
              : copyBoxInto(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1
            const st = this.getClosestProjectingParent()
            st &&
            !!st.resumingFrom == !!this.resumingFrom &&
            !st.options.layoutScroll &&
            st.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = st),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = createBox()),
                (this.relativeTargetOrigin = createBox()),
                calcRelativePosition(
                  this.relativeTargetOrigin,
                  this.target,
                  st.target
                ),
                copyBoxInto(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0)
          }
          projectionFrameData.resolvedTargetDeltas++
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          hasScale(this.parent.latestValues) ||
          has2DTranslate(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent()
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      )
    }
    calcProjection() {
      var g
      const _ = this.getLead(),
        b = !!this.resumingFrom || this !== _
      let j = !0
      if (
        ((this.isProjectionDirty ||
          (!((g = this.parent) === null || g === void 0) &&
            g.isProjectionDirty)) &&
          (j = !1),
        b &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (j = !1),
        this.resolvedRelativeTargetAt === frameData.timestamp && (j = !1),
        j)
      )
        return
      const { layout: $, layoutId: _e } = this.options
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !($ || _e))
      )
        return
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox)
      const tt = this.treeScale.x,
        st = this.treeScale.y
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, b),
        _.layout &&
          !_.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          (_.target = _.layout.layoutBox)
      const { target: at } = _
      if (!at) {
        this.projectionTransform &&
          ((this.projectionDelta = createDelta()),
          (this.projectionTransform = "none"),
          this.scheduleRender())
        return
      }
      this.projectionDelta ||
        ((this.projectionDelta = createDelta()),
        (this.projectionDeltaWithTransform = createDelta()))
      const ot = this.projectionTransform
      calcBoxDelta(
        this.projectionDelta,
        this.layoutCorrected,
        at,
        this.latestValues
      ),
        (this.projectionTransform = buildProjectionTransform(
          this.projectionDelta,
          this.treeScale
        )),
        (this.projectionTransform !== ot ||
          this.treeScale.x !== tt ||
          this.treeScale.y !== st) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", at)),
        projectionFrameData.recalculatedProjection++
    }
    hide() {
      this.isVisible = !1
    }
    show() {
      this.isVisible = !0
    }
    scheduleRender(g = !0) {
      if ((this.options.scheduleRender && this.options.scheduleRender(), g)) {
        const _ = this.getStack()
        _ && _.scheduleRender()
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0)
    }
    setAnimationOrigin(g, _ = !1) {
      const b = this.snapshot,
        j = b ? b.latestValues : {},
        $ = { ...this.latestValues },
        _e = createDelta()
      ;(!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !_)
      const tt = createBox(),
        st = b ? b.source : void 0,
        at = this.layout ? this.layout.source : void 0,
        ot = st !== at,
        ut = this.getStack(),
        it = !ut || ut.members.length <= 1,
        ct = !!(
          ot &&
          !it &&
          this.options.crossfade === !0 &&
          !this.path.some(hasOpacityCrossfade)
        )
      this.animationProgress = 0
      let lt
      ;(this.mixTargetDelta = (ht) => {
        const dt = ht / 1e3
        mixAxisDelta(_e.x, g.x, dt),
          mixAxisDelta(_e.y, g.y, dt),
          this.setTargetDelta(_e),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (calcRelativePosition(
              tt,
              this.layout.layoutBox,
              this.relativeParent.layout.layoutBox
            ),
            mixBox(this.relativeTarget, this.relativeTargetOrigin, tt, dt),
            lt &&
              boxEquals(this.relativeTarget, lt) &&
              (this.isProjectionDirty = !1),
            lt || (lt = createBox()),
            copyBoxInto(lt, this.relativeTarget)),
          ot &&
            ((this.animationValues = $),
            mixValues($, j, this.latestValues, dt, ct, it)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = dt)
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
    }
    startAnimation(g) {
      this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (cancelFrame(this.pendingAnimation),
          (this.pendingAnimation = void 0)),
        (this.pendingAnimation = frame.update(() => {
          ;(globalProjectionState.hasAnimatedSinceResize = !0),
            (this.currentAnimation = animateSingleValue(0, animationTarget, {
              ...g,
              onUpdate: (_) => {
                this.mixTargetDelta(_), g.onUpdate && g.onUpdate(_)
              },
              onComplete: () => {
                g.onComplete && g.onComplete(), this.completeAnimation()
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0)
        }))
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0))
      const g = this.getStack()
      g && g.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete")
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(animationTarget),
        this.currentAnimation.stop()),
        this.completeAnimation()
    }
    applyTransformsToTarget() {
      const g = this.getLead()
      let { targetWithTransforms: _, target: b, layout: j, latestValues: $ } = g
      if (!(!_ || !b || !j)) {
        if (
          this !== g &&
          this.layout &&
          j &&
          shouldAnimatePositionOnly(
            this.options.animationType,
            this.layout.layoutBox,
            j.layoutBox
          )
        ) {
          b = this.target || createBox()
          const _e = calcLength(this.layout.layoutBox.x)
          ;(b.x.min = g.target.x.min), (b.x.max = b.x.min + _e)
          const tt = calcLength(this.layout.layoutBox.y)
          ;(b.y.min = g.target.y.min), (b.y.max = b.y.min + tt)
        }
        copyBoxInto(_, b),
          transformBox(_, $),
          calcBoxDelta(
            this.projectionDeltaWithTransform,
            this.layoutCorrected,
            _,
            $
          )
      }
    }
    registerSharedNode(g, _) {
      this.sharedNodes.has(g) || this.sharedNodes.set(g, new NodeStack()),
        this.sharedNodes.get(g).add(_)
      const j = _.options.initialPromotionConfig
      _.promote({
        transition: j ? j.transition : void 0,
        preserveFollowOpacity:
          j && j.shouldPreserveFollowOpacity
            ? j.shouldPreserveFollowOpacity(_)
            : void 0,
      })
    }
    isLead() {
      const g = this.getStack()
      return g ? g.lead === this : !0
    }
    getLead() {
      var g
      const { layoutId: _ } = this.options
      return _
        ? ((g = this.getStack()) === null || g === void 0 ? void 0 : g.lead) ||
            this
        : this
    }
    getPrevLead() {
      var g
      const { layoutId: _ } = this.options
      return _
        ? (g = this.getStack()) === null || g === void 0
          ? void 0
          : g.prevLead
        : void 0
    }
    getStack() {
      const { layoutId: g } = this.options
      if (g) return this.root.sharedNodes.get(g)
    }
    promote({ needsReset: g, transition: _, preserveFollowOpacity: b } = {}) {
      const j = this.getStack()
      j && j.promote(this, b),
        g && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        _ && this.setOptions({ transition: _ })
    }
    relegate() {
      const g = this.getStack()
      return g ? g.relegate(this) : !1
    }
    resetRotation() {
      const { visualElement: g } = this.options
      if (!g) return
      let _ = !1
      const { latestValues: b } = g
      if (((b.rotate || b.rotateX || b.rotateY || b.rotateZ) && (_ = !0), !_))
        return
      const j = {}
      for (let $ = 0; $ < transformAxes.length; $++) {
        const _e = "rotate" + transformAxes[$]
        b[_e] && ((j[_e] = b[_e]), g.setStaticValue(_e, 0))
      }
      g.render()
      for (const $ in j) g.setStaticValue($, j[$])
      g.scheduleRender()
    }
    getProjectionStyles(g) {
      var _, b
      if (!this.instance || this.isSVG) return
      if (!this.isVisible) return hiddenVisibility
      const j = { visibility: "" },
        $ = this.getTransformTemplate()
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (j.opacity = ""),
          (j.pointerEvents =
            resolveMotionValue(g == null ? void 0 : g.pointerEvents) || ""),
          (j.transform = $ ? $(this.latestValues, "") : "none"),
          j
        )
      const _e = this.getLead()
      if (!this.projectionDelta || !this.layout || !_e.target) {
        const ot = {}
        return (
          this.options.layoutId &&
            ((ot.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (ot.pointerEvents =
              resolveMotionValue(g == null ? void 0 : g.pointerEvents) || "")),
          this.hasProjected &&
            !hasTransform(this.latestValues) &&
            ((ot.transform = $ ? $({}, "") : "none"), (this.hasProjected = !1)),
          ot
        )
      }
      const tt = _e.animationValues || _e.latestValues
      this.applyTransformsToTarget(),
        (j.transform = buildProjectionTransform(
          this.projectionDeltaWithTransform,
          this.treeScale,
          tt
        )),
        $ && (j.transform = $(tt, j.transform))
      const { x: st, y: at } = this.projectionDelta
      ;(j.transformOrigin = `${st.origin * 100}% ${at.origin * 100}% 0`),
        _e.animationValues
          ? (j.opacity =
              _e === this
                ? (b =
                    (_ = tt.opacity) !== null && _ !== void 0
                      ? _
                      : this.latestValues.opacity) !== null && b !== void 0
                  ? b
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : tt.opacityExit)
          : (j.opacity =
              _e === this
                ? tt.opacity !== void 0
                  ? tt.opacity
                  : ""
                : tt.opacityExit !== void 0
                ? tt.opacityExit
                : 0)
      for (const ot in scaleCorrectors) {
        if (tt[ot] === void 0) continue
        const { correct: ut, applyTo: it } = scaleCorrectors[ot],
          ct = j.transform === "none" ? tt[ot] : ut(tt[ot], _e)
        if (it) {
          const lt = it.length
          for (let ht = 0; ht < lt; ht++) j[it[ht]] = ct
        } else j[ot] = ct
      }
      return (
        this.options.layoutId &&
          (j.pointerEvents =
            _e === this
              ? resolveMotionValue(g == null ? void 0 : g.pointerEvents) || ""
              : "none"),
        j
      )
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0
    }
    resetTree() {
      this.root.nodes.forEach((g) => {
        var _
        return (_ = g.currentAnimation) === null || _ === void 0
          ? void 0
          : _.stop()
      }),
        this.root.nodes.forEach(clearMeasurements),
        this.root.sharedNodes.clear()
    }
  }
}
function updateLayout(s) {
  s.updateLayout()
}
function notifyLayoutUpdate(s) {
  var e
  const a =
    ((e = s.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    s.snapshot
  if (s.isLead() && s.layout && a && s.hasListeners("didUpdate")) {
    const { layoutBox: o, measuredBox: c } = s.layout,
      { animationType: d } = s.options,
      g = a.source !== s.layout.source
    d === "size"
      ? eachAxis((_e) => {
          const tt = g ? a.measuredBox[_e] : a.layoutBox[_e],
            st = calcLength(tt)
          ;(tt.min = o[_e].min), (tt.max = tt.min + st)
        })
      : shouldAnimatePositionOnly(d, a.layoutBox, o) &&
        eachAxis((_e) => {
          const tt = g ? a.measuredBox[_e] : a.layoutBox[_e],
            st = calcLength(o[_e])
          ;(tt.max = tt.min + st),
            s.relativeTarget &&
              !s.currentAnimation &&
              ((s.isProjectionDirty = !0),
              (s.relativeTarget[_e].max = s.relativeTarget[_e].min + st))
        })
    const _ = createDelta()
    calcBoxDelta(_, o, a.layoutBox)
    const b = createDelta()
    g
      ? calcBoxDelta(b, s.applyTransform(c, !0), a.measuredBox)
      : calcBoxDelta(b, o, a.layoutBox)
    const j = !isDeltaZero(_)
    let $ = !1
    if (!s.resumeFrom) {
      const _e = s.getClosestProjectingParent()
      if (_e && !_e.resumeFrom) {
        const { snapshot: tt, layout: st } = _e
        if (tt && st) {
          const at = createBox()
          calcRelativePosition(at, a.layoutBox, tt.layoutBox)
          const ot = createBox()
          calcRelativePosition(ot, o, st.layoutBox),
            boxEqualsRounded(at, ot) || ($ = !0),
            _e.options.layoutRoot &&
              ((s.relativeTarget = ot),
              (s.relativeTargetOrigin = at),
              (s.relativeParent = _e))
        }
      }
    }
    s.notifyListeners("didUpdate", {
      layout: o,
      snapshot: a,
      delta: b,
      layoutDelta: _,
      hasLayoutChanged: j,
      hasRelativeTargetChanged: $,
    })
  } else if (s.isLead()) {
    const { onExitComplete: o } = s.options
    o && o()
  }
  s.options.transition = void 0
}
function propagateDirtyNodes(s) {
  projectionFrameData.totalNodes++,
    s.parent &&
      (s.isProjecting() || (s.isProjectionDirty = s.parent.isProjectionDirty),
      s.isSharedProjectionDirty ||
        (s.isSharedProjectionDirty = !!(
          s.isProjectionDirty ||
          s.parent.isProjectionDirty ||
          s.parent.isSharedProjectionDirty
        )),
      s.isTransformDirty || (s.isTransformDirty = s.parent.isTransformDirty))
}
function cleanDirtyNodes(s) {
  s.isProjectionDirty = s.isSharedProjectionDirty = s.isTransformDirty = !1
}
function clearSnapshot(s) {
  s.clearSnapshot()
}
function clearMeasurements(s) {
  s.clearMeasurements()
}
function clearIsLayoutDirty(s) {
  s.isLayoutDirty = !1
}
function resetTransformStyle(s) {
  const { visualElement: e } = s.options
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    s.resetTransform()
}
function finishAnimation(s) {
  s.finishAnimation(),
    (s.targetDelta = s.relativeTarget = s.target = void 0),
    (s.isProjectionDirty = !0)
}
function resolveTargetDelta(s) {
  s.resolveTargetDelta()
}
function calcProjection(s) {
  s.calcProjection()
}
function resetRotation(s) {
  s.resetRotation()
}
function removeLeadSnapshots(s) {
  s.removeLeadSnapshot()
}
function mixAxisDelta(s, e, a) {
  ;(s.translate = mix(e.translate, 0, a)),
    (s.scale = mix(e.scale, 1, a)),
    (s.origin = e.origin),
    (s.originPoint = e.originPoint)
}
function mixAxis(s, e, a, o) {
  ;(s.min = mix(e.min, a.min, o)), (s.max = mix(e.max, a.max, o))
}
function mixBox(s, e, a, o) {
  mixAxis(s.x, e.x, a.x, o), mixAxis(s.y, e.y, a.y, o)
}
function hasOpacityCrossfade(s) {
  return s.animationValues && s.animationValues.opacityExit !== void 0
}
const defaultLayoutTransition = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
  userAgentContains = (s) =>
    typeof navigator < "u" && navigator.userAgent.toLowerCase().includes(s),
  roundPoint =
    userAgentContains("applewebkit/") && !userAgentContains("chrome/")
      ? Math.round
      : noop
function roundAxis(s) {
  ;(s.min = roundPoint(s.min)), (s.max = roundPoint(s.max))
}
function roundBox(s) {
  roundAxis(s.x), roundAxis(s.y)
}
function shouldAnimatePositionOnly(s, e, a) {
  return (
    s === "position" ||
    (s === "preserve-aspect" && !isNear(aspectRatio(e), aspectRatio(a), 0.2))
  )
}
const DocumentProjectionNode = createProjectionNode({
    attachResizeListener: (s, e) => addDomEvent(s, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  rootProjectionNode = { current: void 0 },
  HTMLProjectionNode = createProjectionNode({
    measureScroll: (s) => ({ x: s.scrollLeft, y: s.scrollTop }),
    defaultParent: () => {
      if (!rootProjectionNode.current) {
        const s = new DocumentProjectionNode({})
        s.mount(window),
          s.setOptions({ layoutScroll: !0 }),
          (rootProjectionNode.current = s)
      }
      return rootProjectionNode.current
    },
    resetTransform: (s, e) => {
      s.style.transform = e !== void 0 ? e : "none"
    },
    checkIsScrollRoot: (s) => window.getComputedStyle(s).position === "fixed",
  }),
  drag = {
    pan: { Feature: PanGesture },
    drag: {
      Feature: DragGesture,
      ProjectionNode: HTMLProjectionNode,
      MeasureLayout,
    },
  },
  splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/
function parseCSSVariable(s) {
  const e = splitCSSVariableRegex.exec(s)
  if (!e) return [,]
  const [, a, o] = e
  return [a, o]
}
function getVariableValue(s, e, a = 1) {
  const [o, c] = parseCSSVariable(s)
  if (!o) return
  const d = window.getComputedStyle(e).getPropertyValue(o)
  if (d) {
    const g = d.trim()
    return isNumericalString(g) ? parseFloat(g) : g
  } else return isCSSVariableToken(c) ? getVariableValue(c, e, a + 1) : c
}
function resolveCSSVariables(s, { ...e }, a) {
  const o = s.current
  if (!(o instanceof Element)) return { target: e, transitionEnd: a }
  a && (a = { ...a }),
    s.values.forEach((c) => {
      const d = c.get()
      if (!isCSSVariableToken(d)) return
      const g = getVariableValue(d, o)
      g && c.set(g)
    })
  for (const c in e) {
    const d = e[c]
    if (!isCSSVariableToken(d)) continue
    const g = getVariableValue(d, o)
    g && ((e[c] = g), a || (a = {}), a[c] === void 0 && (a[c] = d))
  }
  return { target: e, transitionEnd: a }
}
const positionalKeys = new Set([
    "width",
    "height",
    "top",
    "left",
    "right",
    "bottom",
    "x",
    "y",
    "translateX",
    "translateY",
  ]),
  isPositionalKey = (s) => positionalKeys.has(s),
  hasPositionalKey = (s) => Object.keys(s).some(isPositionalKey),
  isNumOrPxType = (s) => s === number || s === px,
  getPosFromMatrix = (s, e) => parseFloat(s.split(", ")[e]),
  getTranslateFromMatrix =
    (s, e) =>
    (a, { transform: o }) => {
      if (o === "none" || !o) return 0
      const c = o.match(/^matrix3d\((.+)\)$/)
      if (c) return getPosFromMatrix(c[1], e)
      {
        const d = o.match(/^matrix\((.+)\)$/)
        return d ? getPosFromMatrix(d[1], s) : 0
      }
    },
  transformKeys = new Set(["x", "y", "z"]),
  nonTranslationalTransformKeys = transformPropOrder.filter(
    (s) => !transformKeys.has(s)
  )
function removeNonTranslationalTransform(s) {
  const e = []
  return (
    nonTranslationalTransformKeys.forEach((a) => {
      const o = s.getValue(a)
      o !== void 0 &&
        (e.push([a, o.get()]), o.set(a.startsWith("scale") ? 1 : 0))
    }),
    e.length && s.render(),
    e
  )
}
const positionalValues = {
  width: ({ x: s }, { paddingLeft: e = "0", paddingRight: a = "0" }) =>
    s.max - s.min - parseFloat(e) - parseFloat(a),
  height: ({ y: s }, { paddingTop: e = "0", paddingBottom: a = "0" }) =>
    s.max - s.min - parseFloat(e) - parseFloat(a),
  top: (s, { top: e }) => parseFloat(e),
  left: (s, { left: e }) => parseFloat(e),
  bottom: ({ y: s }, { top: e }) => parseFloat(e) + (s.max - s.min),
  right: ({ x: s }, { left: e }) => parseFloat(e) + (s.max - s.min),
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14),
}
positionalValues.translateX = positionalValues.x
positionalValues.translateY = positionalValues.y
const convertChangedValueTypes = (s, e, a) => {
    const o = e.measureViewportBox(),
      c = e.current,
      d = getComputedStyle(c),
      { display: g } = d,
      _ = {}
    g === "none" && e.setStaticValue("display", s.display || "block"),
      a.forEach((j) => {
        _[j] = positionalValues[j](o, d)
      }),
      e.render()
    const b = e.measureViewportBox()
    return (
      a.forEach((j) => {
        const $ = e.getValue(j)
        $ && $.jump(_[j]), (s[j] = positionalValues[j](b, d))
      }),
      s
    )
  },
  checkAndConvertChangedValueTypes = (s, e, a = {}, o = {}) => {
    ;(e = { ...e }), (o = { ...o })
    const c = Object.keys(e).filter(isPositionalKey)
    let d = [],
      g = !1
    const _ = []
    if (
      (c.forEach((b) => {
        const j = s.getValue(b)
        if (!s.hasValue(b)) return
        let $ = a[b],
          _e = findDimensionValueType($)
        const tt = e[b]
        let st
        if (isKeyframesTarget(tt)) {
          const at = tt.length,
            ot = tt[0] === null ? 1 : 0
          ;($ = tt[ot]), (_e = findDimensionValueType($))
          for (let ut = ot; ut < at && tt[ut] !== null; ut++)
            st
              ? invariant(findDimensionValueType(tt[ut]) === st)
              : (st = findDimensionValueType(tt[ut]))
        } else st = findDimensionValueType(tt)
        if (_e !== st)
          if (isNumOrPxType(_e) && isNumOrPxType(st)) {
            const at = j.get()
            typeof at == "string" && j.set(parseFloat(at)),
              typeof tt == "string"
                ? (e[b] = parseFloat(tt))
                : Array.isArray(tt) && st === px && (e[b] = tt.map(parseFloat))
          } else
            _e != null &&
            _e.transform &&
            st != null &&
            st.transform &&
            ($ === 0 || tt === 0)
              ? $ === 0
                ? j.set(st.transform($))
                : (e[b] = _e.transform(tt))
              : (g || ((d = removeNonTranslationalTransform(s)), (g = !0)),
                _.push(b),
                (o[b] = o[b] !== void 0 ? o[b] : e[b]),
                j.jump(tt))
      }),
      _.length)
    ) {
      const b = _.indexOf("height") >= 0 ? window.pageYOffset : null,
        j = convertChangedValueTypes(e, s, _)
      return (
        d.length &&
          d.forEach(([$, _e]) => {
            s.getValue($).set(_e)
          }),
        s.render(),
        isBrowser && b !== null && window.scrollTo({ top: b }),
        { target: j, transitionEnd: o }
      )
    } else return { target: e, transitionEnd: o }
  }
function unitConversion(s, e, a, o) {
  return hasPositionalKey(e)
    ? checkAndConvertChangedValueTypes(s, e, a, o)
    : { target: e, transitionEnd: o }
}
const parseDomVariant = (s, e, a, o) => {
    const c = resolveCSSVariables(s, e, o)
    return (e = c.target), (o = c.transitionEnd), unitConversion(s, e, a, o)
  },
  prefersReducedMotion = { current: null },
  hasReducedMotionListener = { current: !1 }
function initPrefersReducedMotion() {
  if (((hasReducedMotionListener.current = !0), !!isBrowser))
    if (window.matchMedia) {
      const s = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (prefersReducedMotion.current = s.matches)
      s.addListener(e), e()
    } else prefersReducedMotion.current = !1
}
function updateMotionValuesFromProps(s, e, a) {
  const { willChange: o } = e
  for (const c in e) {
    const d = e[c],
      g = a[c]
    if (isMotionValue(d))
      s.addValue(c, d), isWillChangeMotionValue(o) && o.add(c)
    else if (isMotionValue(g))
      s.addValue(c, motionValue(d, { owner: s })),
        isWillChangeMotionValue(o) && o.remove(c)
    else if (g !== d)
      if (s.hasValue(c)) {
        const _ = s.getValue(c)
        !_.hasAnimated && _.set(d)
      } else {
        const _ = s.getStaticValue(c)
        s.addValue(c, motionValue(_ !== void 0 ? _ : d, { owner: s }))
      }
  }
  for (const c in a) e[c] === void 0 && s.removeValue(c)
  return e
}
const visualElementStore = new WeakMap(),
  featureNames = Object.keys(featureDefinitions),
  numFeatures = featureNames.length,
  propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete",
  ],
  numVariantProps = variantProps.length
class VisualElement {
  constructor(
    {
      parent: e,
      props: a,
      presenceContext: o,
      reducedMotionConfig: c,
      visualState: d,
    },
    g = {}
  ) {
    ;(this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ))
      }),
      (this.scheduleRender = () => frame.render(this.render, !1, !0))
    const { latestValues: _, renderState: b } = d
    ;(this.latestValues = _),
      (this.baseTarget = { ..._ }),
      (this.initialValues = a.initial ? { ..._ } : {}),
      (this.renderState = b),
      (this.parent = e),
      (this.props = a),
      (this.presenceContext = o),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = c),
      (this.options = g),
      (this.isControllingVariants = isControllingVariants(a)),
      (this.isVariantNode = isVariantNode(a)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current))
    const { willChange: j, ...$ } = this.scrapeMotionValuesFromProps(a, {})
    for (const _e in $) {
      const tt = $[_e]
      _[_e] !== void 0 &&
        isMotionValue(tt) &&
        (tt.set(_[_e], !1), isWillChangeMotionValue(j) && j.add(_e))
    }
  }
  scrapeMotionValuesFromProps(e, a) {
    return {}
  }
  mount(e) {
    ;(this.current = e),
      visualElementStore.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((a, o) => this.bindToMotionValue(o, a)),
      hasReducedMotionListener.current || initPrefersReducedMotion(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
          ? !0
          : prefersReducedMotion.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext)
  }
  unmount() {
    visualElementStore.delete(this.current),
      this.projection && this.projection.unmount(),
      cancelFrame(this.notifyUpdate),
      cancelFrame(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this)
    for (const e in this.events) this.events[e].clear()
    for (const e in this.features) this.features[e].unmount()
    this.current = null
  }
  bindToMotionValue(e, a) {
    const o = transformProps.has(e),
      c = a.on("change", (g) => {
        ;(this.latestValues[e] = g),
          this.props.onUpdate && frame.update(this.notifyUpdate, !1, !0),
          o && this.projection && (this.projection.isTransformDirty = !0)
      }),
      d = a.on("renderRequest", this.scheduleRender)
    this.valueSubscriptions.set(e, () => {
      c(), d()
    })
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current)
  }
  loadFeatures({ children: e, ...a }, o, c, d) {
    let g, _
    for (let b = 0; b < numFeatures; b++) {
      const j = featureNames[b],
        {
          isEnabled: $,
          Feature: _e,
          ProjectionNode: tt,
          MeasureLayout: st,
        } = featureDefinitions[j]
      tt && (g = tt),
        $(a) &&
          (!this.features[j] && _e && (this.features[j] = new _e(this)),
          st && (_ = st))
    }
    if (
      (this.type === "html" || this.type === "svg") &&
      !this.projection &&
      g
    ) {
      this.projection = new g(
        this.latestValues,
        this.parent && this.parent.projection
      )
      const {
        layoutId: b,
        layout: j,
        drag: $,
        dragConstraints: _e,
        layoutScroll: tt,
        layoutRoot: st,
      } = a
      this.projection.setOptions({
        layoutId: b,
        layout: j,
        alwaysMeasureLayout: !!$ || (_e && isRefObject(_e)),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        animationType: typeof j == "string" ? j : "both",
        initialPromotionConfig: d,
        layoutScroll: tt,
        layoutRoot: st,
      })
    }
    return _
  }
  updateFeatures() {
    for (const e in this.features) {
      const a = this.features[e]
      a.isMounted ? a.update() : (a.mount(), (a.isMounted = !0))
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props)
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : createBox()
  }
  getStaticValue(e) {
    return this.latestValues[e]
  }
  setStaticValue(e, a) {
    this.latestValues[e] = a
  }
  makeTargetAnimatable(e, a = !0) {
    return this.makeTargetAnimatableFromInstance(e, this.props, a)
  }
  update(e, a) {
    ;(e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = a)
    for (let o = 0; o < propEventHandlers.length; o++) {
      const c = propEventHandlers[o]
      this.propEventSubscriptions[c] &&
        (this.propEventSubscriptions[c](),
        delete this.propEventSubscriptions[c])
      const d = e["on" + c]
      d && (this.propEventSubscriptions[c] = this.on(c, d))
    }
    ;(this.prevMotionValues = updateMotionValuesFromProps(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue()
  }
  getProps() {
    return this.props
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0
  }
  getDefaultTransition() {
    return this.props.transition
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0
  }
  getVariantContext(e = !1) {
    if (e) return this.parent ? this.parent.getVariantContext() : void 0
    if (!this.isControllingVariants) {
      const o = this.parent ? this.parent.getVariantContext() || {} : {}
      return (
        this.props.initial !== void 0 && (o.initial = this.props.initial), o
      )
    }
    const a = {}
    for (let o = 0; o < numVariantProps; o++) {
      const c = variantProps[o],
        d = this.props[c]
      ;(isVariantLabel(d) || d === !1) && (a[c] = d)
    }
    return a
  }
  addVariantChild(e) {
    const a = this.getClosestVariantNode()
    if (a)
      return (
        a.variantChildren && a.variantChildren.add(e),
        () => a.variantChildren.delete(e)
      )
  }
  addValue(e, a) {
    a !== this.values.get(e) &&
      (this.removeValue(e), this.bindToMotionValue(e, a)),
      this.values.set(e, a),
      (this.latestValues[e] = a.get())
  }
  removeValue(e) {
    this.values.delete(e)
    const a = this.valueSubscriptions.get(e)
    a && (a(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState)
  }
  hasValue(e) {
    return this.values.has(e)
  }
  getValue(e, a) {
    if (this.props.values && this.props.values[e]) return this.props.values[e]
    let o = this.values.get(e)
    return (
      o === void 0 &&
        a !== void 0 &&
        ((o = motionValue(a, { owner: this })), this.addValue(e, o)),
      o
    )
  }
  readValue(e) {
    var a
    return this.latestValues[e] !== void 0 || !this.current
      ? this.latestValues[e]
      : (a = this.getBaseTargetFromProps(this.props, e)) !== null &&
        a !== void 0
      ? a
      : this.readValueFromInstance(this.current, e, this.options)
  }
  setBaseTarget(e, a) {
    this.baseTarget[e] = a
  }
  getBaseTarget(e) {
    var a
    const { initial: o } = this.props,
      c =
        typeof o == "string" || typeof o == "object"
          ? (a = resolveVariantFromProps(this.props, o)) === null ||
            a === void 0
            ? void 0
            : a[e]
          : void 0
    if (o && c !== void 0) return c
    const d = this.getBaseTargetFromProps(this.props, e)
    return d !== void 0 && !isMotionValue(d)
      ? d
      : this.initialValues[e] !== void 0 && c === void 0
      ? void 0
      : this.baseTarget[e]
  }
  on(e, a) {
    return (
      this.events[e] || (this.events[e] = new SubscriptionManager()),
      this.events[e].add(a)
    )
  }
  notify(e, ...a) {
    this.events[e] && this.events[e].notify(...a)
  }
}
class DOMVisualElement extends VisualElement {
  sortInstanceNodePosition(e, a) {
    return e.compareDocumentPosition(a) & 2 ? 1 : -1
  }
  getBaseTargetFromProps(e, a) {
    return e.style ? e.style[a] : void 0
  }
  removeValueFromRenderState(e, { vars: a, style: o }) {
    delete a[e], delete o[e]
  }
  makeTargetAnimatableFromInstance(
    { transition: e, transitionEnd: a, ...o },
    { transformValues: c },
    d
  ) {
    let g = getOrigin(o, e || {}, this)
    if ((c && (a && (a = c(a)), o && (o = c(o)), g && (g = c(g))), d)) {
      checkTargetForNewValues(this, o, g)
      const _ = parseDomVariant(this, o, g, a)
      ;(a = _.transitionEnd), (o = _.target)
    }
    return { transition: e, transitionEnd: a, ...o }
  }
}
function getComputedStyle$1(s) {
  return window.getComputedStyle(s)
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), (this.type = "html")
  }
  readValueFromInstance(e, a) {
    if (transformProps.has(a)) {
      const o = getDefaultValueType(a)
      return (o && o.default) || 0
    } else {
      const o = getComputedStyle$1(e),
        c = (isCSSVariableName(a) ? o.getPropertyValue(a) : o[a]) || 0
      return typeof c == "string" ? c.trim() : c
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: a }) {
    return measureViewportBox(e, a)
  }
  build(e, a, o, c) {
    buildHTMLStyles(e, a, o, c.transformTemplate)
  }
  scrapeMotionValuesFromProps(e, a) {
    return scrapeMotionValuesFromProps$1(e, a)
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription)
    const { children: e } = this.props
    isMotionValue(e) &&
      (this.childSubscription = e.on("change", (a) => {
        this.current && (this.current.textContent = `${a}`)
      }))
  }
  renderInstance(e, a, o, c) {
    renderHTML(e, a, o, c)
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), (this.type = "svg"), (this.isSVGTag = !1)
  }
  getBaseTargetFromProps(e, a) {
    return e[a]
  }
  readValueFromInstance(e, a) {
    if (transformProps.has(a)) {
      const o = getDefaultValueType(a)
      return (o && o.default) || 0
    }
    return (
      (a = camelCaseAttributes.has(a) ? a : camelToDash(a)), e.getAttribute(a)
    )
  }
  measureInstanceViewportBox() {
    return createBox()
  }
  scrapeMotionValuesFromProps(e, a) {
    return scrapeMotionValuesFromProps(e, a)
  }
  build(e, a, o, c) {
    buildSVGAttrs(e, a, o, this.isSVGTag, c.transformTemplate)
  }
  renderInstance(e, a, o, c) {
    renderSVG(e, a, o, c)
  }
  mount(e) {
    ;(this.isSVGTag = isSVGTag(e.tagName)), super.mount(e)
  }
}
const createDomVisualElement = (s, e) =>
    isSVGComponent(s)
      ? new SVGVisualElement(e, { enableHardwareAcceleration: !1 })
      : new HTMLVisualElement(e, { enableHardwareAcceleration: !0 }),
  layout = { layout: { ProjectionNode: HTMLProjectionNode, MeasureLayout } },
  preloadedFeatures = {
    ...animations,
    ...gestureAnimations,
    ...drag,
    ...layout,
  },
  motion = createMotionProxy((s, e) =>
    createDomMotionConfig(s, e, preloadedFeatures, createDomVisualElement)
  ),
  styles = {
    paddingX: "sm:px-16 px-6",
    paddingY: "sm:py-16 py-6",
    padding: "sm:px-16 px-6 sm:py-16 py-10",
    heroHeadText:
      "font-black text-white lg:text-[80px] sm:text-[60px] xs:text-[50px] text-[40px] lg:leading-[98px] mt-2",
    heroSubText:
      "text-[#dfd9ff] font-medium lg:text-[30px] sm:text-[26px] xs:text-[20px] text-[16px] lg:leading-[40px]",
    sectionHeadText:
      "text-white font-black md:text-[60px] sm:text-[50px] xs:text-[40px] text-[30px]",
    sectionSubText:
      "sm:text-[18px] text-[14px] text-secondary uppercase tracking-wider",
  }
function _assertThisInitialized(s) {
  if (s === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return s
}
function _inheritsLoose$1(s, e) {
  ;(s.prototype = Object.create(e.prototype)),
    (s.prototype.constructor = s),
    (s.__proto__ = e)
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  _defaults = { duration: 0.5, overwrite: !1, delay: 0 },
  _suppressOverwrites,
  _reverting$1,
  _context,
  _bigNum$1 = 1e8,
  _tinyNum = 1 / _bigNum$1,
  _2PI = Math.PI * 2,
  _HALF_PI = _2PI / 4,
  _gsID = 0,
  _sqrt = Math.sqrt,
  _cos = Math.cos,
  _sin = Math.sin,
  _isString = function (e) {
    return typeof e == "string"
  },
  _isFunction = function (e) {
    return typeof e == "function"
  },
  _isNumber = function (e) {
    return typeof e == "number"
  },
  _isUndefined = function (e) {
    return typeof e > "u"
  },
  _isObject = function (e) {
    return typeof e == "object"
  },
  _isNotFalse = function (e) {
    return e !== !1
  },
  _windowExists$1 = function () {
    return typeof window < "u"
  },
  _isFuncOrString = function (e) {
    return _isFunction(e) || _isString(e)
  },
  _isTypedArray =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  _isArray = Array.isArray,
  _strictNumExp = /(?:-?\.?\d|\.)+/gi,
  _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  _relExp = /[+-]=-?[.\d]+/,
  _delimitedValueExp = /[^,'"\[\]\s]+/gi,
  _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  _globalTimeline,
  _win$1,
  _coreInitted,
  _doc$1,
  _globals = {},
  _installScope = {},
  _coreReady,
  _install = function (e) {
    return (_installScope = _merge(e, _globals)) && gsap
  },
  _missingPlugin = function (e, a) {
    return console.warn(
      "Invalid property",
      e,
      "set to",
      a,
      "Missing plugin? gsap.registerPlugin()"
    )
  },
  _warn = function (e, a) {
    return !a && console.warn(e)
  },
  _addGlobal = function (e, a) {
    return (
      (e && (_globals[e] = a) && _installScope && (_installScope[e] = a)) ||
      _globals
    )
  },
  _emptyFunc = function () {
    return 0
  },
  _startAtRevertConfig = { suppressEvents: !0, isStart: !0, kill: !1 },
  _revertConfigNoKill = { suppressEvents: !0, kill: !1 },
  _revertConfig = { suppressEvents: !0 },
  _reservedProps = {},
  _lazyTweens = [],
  _lazyLookup = {},
  _lastRenderedFrame,
  _plugins = {},
  _effects = {},
  _nextGCFrame = 30,
  _harnessPlugins = [],
  _callbackNames = "",
  _harness = function (e) {
    var a = e[0],
      o,
      c
    if (
      (_isObject(a) || _isFunction(a) || (e = [e]),
      !(o = (a._gsap || {}).harness))
    ) {
      for (
        c = _harnessPlugins.length;
        c-- && !_harnessPlugins[c].targetTest(a);

      );
      o = _harnessPlugins[c]
    }
    for (c = e.length; c--; )
      (e[c] && (e[c]._gsap || (e[c]._gsap = new GSCache(e[c], o)))) ||
        e.splice(c, 1)
    return e
  },
  _getCache = function (e) {
    return e._gsap || _harness(toArray(e))[0]._gsap
  },
  _getProperty = function (e, a, o) {
    return (o = e[a]) && _isFunction(o)
      ? e[a]()
      : (_isUndefined(o) && e.getAttribute && e.getAttribute(a)) || o
  },
  _forEachName = function (e, a) {
    return (e = e.split(",")).forEach(a) || e
  },
  _round = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0
  },
  _roundPrecise = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0
  },
  _parseRelative = function (e, a) {
    var o = a.charAt(0),
      c = parseFloat(a.substr(2))
    return (
      (e = parseFloat(e)),
      o === "+" ? e + c : o === "-" ? e - c : o === "*" ? e * c : e / c
    )
  },
  _arrayContainsAny = function (e, a) {
    for (var o = a.length, c = 0; e.indexOf(a[c]) < 0 && ++c < o; );
    return c < o
  },
  _lazyRender = function () {
    var e = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      o,
      c
    for (_lazyLookup = {}, _lazyTweens.length = 0, o = 0; o < e; o++)
      (c = a[o]),
        c && c._lazy && (c.render(c._lazy[0], c._lazy[1], !0)._lazy = 0)
  },
  _lazySafeRender = function (e, a, o, c) {
    _lazyTweens.length && !_reverting$1 && _lazyRender(),
      e.render(
        a,
        o,
        c || (_reverting$1 && a < 0 && (e._initted || e._startAt))
      ),
      _lazyTweens.length && !_reverting$1 && _lazyRender()
  },
  _numericIfPossible = function (e) {
    var a = parseFloat(e)
    return (a || a === 0) && (e + "").match(_delimitedValueExp).length < 2
      ? a
      : _isString(e)
      ? e.trim()
      : e
  },
  _passThrough = function (e) {
    return e
  },
  _setDefaults = function (e, a) {
    for (var o in a) o in e || (e[o] = a[o])
    return e
  },
  _setKeyframeDefaults = function (e) {
    return function (a, o) {
      for (var c in o)
        c in a || (c === "duration" && e) || c === "ease" || (a[c] = o[c])
    }
  },
  _merge = function (e, a) {
    for (var o in a) e[o] = a[o]
    return e
  },
  _mergeDeep = function s(e, a) {
    for (var o in a)
      o !== "__proto__" &&
        o !== "constructor" &&
        o !== "prototype" &&
        (e[o] = _isObject(a[o]) ? s(e[o] || (e[o] = {}), a[o]) : a[o])
    return e
  },
  _copyExcluding = function (e, a) {
    var o = {},
      c
    for (c in e) c in a || (o[c] = e[c])
    return o
  },
  _inheritDefaults = function (e) {
    var a = e.parent || _globalTimeline,
      o = e.keyframes
        ? _setKeyframeDefaults(_isArray(e.keyframes))
        : _setDefaults
    if (_isNotFalse(e.inherit))
      for (; a; ) o(e, a.vars.defaults), (a = a.parent || a._dp)
    return e
  },
  _arraysMatch = function (e, a) {
    for (var o = e.length, c = o === a.length; c && o-- && e[o] === a[o]; );
    return o < 0
  },
  _addLinkedListItem = function (e, a, o, c, d) {
    o === void 0 && (o = "_first"), c === void 0 && (c = "_last")
    var g = e[c],
      _
    if (d) for (_ = a[d]; g && g[d] > _; ) g = g._prev
    return (
      g ? ((a._next = g._next), (g._next = a)) : ((a._next = e[o]), (e[o] = a)),
      a._next ? (a._next._prev = a) : (e[c] = a),
      (a._prev = g),
      (a.parent = a._dp = e),
      a
    )
  },
  _removeLinkedListItem = function (e, a, o, c) {
    o === void 0 && (o = "_first"), c === void 0 && (c = "_last")
    var d = a._prev,
      g = a._next
    d ? (d._next = g) : e[o] === a && (e[o] = g),
      g ? (g._prev = d) : e[c] === a && (e[c] = d),
      (a._next = a._prev = a.parent = null)
  },
  _removeFromParent = function (e, a) {
    e.parent &&
      (!a || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0)
  },
  _uncache = function (e, a) {
    if (e && (!a || a._end > e._dur || a._start < 0))
      for (var o = e; o; ) (o._dirty = 1), (o = o.parent)
    return e
  },
  _recacheAncestors = function (e) {
    for (var a = e.parent; a && a.parent; )
      (a._dirty = 1), a.totalDuration(), (a = a.parent)
    return e
  },
  _rewindStartAt = function (e, a, o, c) {
    return (
      e._startAt &&
      (_reverting$1
        ? e._startAt.revert(_revertConfigNoKill)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(a, !0, c))
    )
  },
  _hasNoPausedAncestors = function s(e) {
    return !e || (e._ts && s(e.parent))
  },
  _elapsedCycleDuration = function (e) {
    return e._repeat
      ? _animationCycle(e._tTime, (e = e.duration() + e._rDelay)) * e
      : 0
  },
  _animationCycle = function (e, a) {
    var o = Math.floor((e /= a))
    return e && o === e ? o - 1 : o
  },
  _parentToChildTotalTime = function (e, a) {
    return (
      (e - a._start) * a._ts +
      (a._ts >= 0 ? 0 : a._dirty ? a.totalDuration() : a._tDur)
    )
  },
  _setEnd = function (e) {
    return (e._end = _roundPrecise(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || _tinyNum) || 0)
    ))
  },
  _alignPlayhead = function (e, a) {
    var o = e._dp
    return (
      o &&
        o.smoothChildTiming &&
        e._ts &&
        ((e._start = _roundPrecise(
          o._time -
            (e._ts > 0
              ? a / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - a) / -e._ts)
        )),
        _setEnd(e),
        o._dirty || _uncache(o, e)),
      e
    )
  },
  _postAddChecks = function (e, a) {
    var o
    if (
      ((a._time ||
        (!a._dur && a._initted) ||
        (a._start < e._time && (a._dur || !a.add))) &&
        ((o = _parentToChildTotalTime(e.rawTime(), a)),
        (!a._dur || _clamp(0, a.totalDuration(), o) - a._tTime > _tinyNum) &&
          a.render(o, !0)),
      _uncache(e, a)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (o = e; o._dp; )
          o.rawTime() >= 0 && o.totalTime(o._tTime), (o = o._dp)
      e._zTime = -_tinyNum
    }
  },
  _addToTimeline = function (e, a, o, c) {
    return (
      a.parent && _removeFromParent(a),
      (a._start = _roundPrecise(
        (_isNumber(o)
          ? o
          : o || e !== _globalTimeline
          ? _parsePosition(e, o, a)
          : e._time) + a._delay
      )),
      (a._end = _roundPrecise(
        a._start + (a.totalDuration() / Math.abs(a.timeScale()) || 0)
      )),
      _addLinkedListItem(e, a, "_first", "_last", e._sort ? "_start" : 0),
      _isFromOrFromStart(a) || (e._recent = a),
      c || _postAddChecks(e, a),
      e._ts < 0 && _alignPlayhead(e, e._tTime),
      e
    )
  },
  _scrollTrigger = function (e, a) {
    return (
      (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", a)) &&
      _globals.ScrollTrigger.create(a, e)
    )
  },
  _attemptInitTween = function (e, a, o, c, d) {
    if ((_initTween(e, a, d), !e._initted)) return 1
    if (
      !o &&
      e._pt &&
      !_reverting$1 &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      _lastRenderedFrame !== _ticker.frame
    )
      return _lazyTweens.push(e), (e._lazy = [d, c]), 1
  },
  _parentPlayheadIsBeforeStart = function s(e) {
    var a = e.parent
    return a && a._ts && a._initted && !a._lock && (a.rawTime() < 0 || s(a))
  },
  _isFromOrFromStart = function (e) {
    var a = e.data
    return a === "isFromStart" || a === "isStart"
  },
  _renderZeroDurationTween = function (e, a, o, c) {
    var d = e.ratio,
      g =
        a < 0 ||
        (!a &&
          ((!e._start &&
            _parentPlayheadIsBeforeStart(e) &&
            !(!e._initted && _isFromOrFromStart(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !_isFromOrFromStart(e))))
          ? 0
          : 1,
      _ = e._rDelay,
      b = 0,
      j,
      $,
      _e
    if (
      (_ &&
        e._repeat &&
        ((b = _clamp(0, e._tDur, a)),
        ($ = _animationCycle(b, _)),
        e._yoyo && $ & 1 && (g = 1 - g),
        $ !== _animationCycle(e._tTime, _) &&
          ((d = 1 - g), e.vars.repeatRefresh && e._initted && e.invalidate())),
      g !== d || _reverting$1 || c || e._zTime === _tinyNum || (!a && e._zTime))
    ) {
      if (!e._initted && _attemptInitTween(e, a, c, o, b)) return
      for (
        _e = e._zTime,
          e._zTime = a || (o ? _tinyNum : 0),
          o || (o = a && !_e),
          e.ratio = g,
          e._from && (g = 1 - g),
          e._time = 0,
          e._tTime = b,
          j = e._pt;
        j;

      )
        j.r(g, j.d), (j = j._next)
      a < 0 && _rewindStartAt(e, a, o, !0),
        e._onUpdate && !o && _callback(e, "onUpdate"),
        b && e._repeat && !o && e.parent && _callback(e, "onRepeat"),
        (a >= e._tDur || a < 0) &&
          e.ratio === g &&
          (g && _removeFromParent(e, 1),
          !o &&
            !_reverting$1 &&
            (_callback(e, g ? "onComplete" : "onReverseComplete", !0),
            e._prom && e._prom()))
    } else e._zTime || (e._zTime = a)
  },
  _findNextPauseTween = function (e, a, o) {
    var c
    if (o > a)
      for (c = e._first; c && c._start <= o; ) {
        if (c.data === "isPause" && c._start > a) return c
        c = c._next
      }
    else
      for (c = e._last; c && c._start >= o; ) {
        if (c.data === "isPause" && c._start < a) return c
        c = c._prev
      }
  },
  _setDuration = function (e, a, o, c) {
    var d = e._repeat,
      g = _roundPrecise(a) || 0,
      _ = e._tTime / e._tDur
    return (
      _ && !c && (e._time *= g / e._dur),
      (e._dur = g),
      (e._tDur = d
        ? d < 0
          ? 1e10
          : _roundPrecise(g * (d + 1) + e._rDelay * d)
        : g),
      _ > 0 && !c && _alignPlayhead(e, (e._tTime = e._tDur * _)),
      e.parent && _setEnd(e),
      o || _uncache(e.parent, e),
      e
    )
  },
  _onUpdateTotalDuration = function (e) {
    return e instanceof Timeline ? _uncache(e) : _setDuration(e, e._dur)
  },
  _zeroPosition = { _start: 0, endTime: _emptyFunc, totalDuration: _emptyFunc },
  _parsePosition = function s(e, a, o) {
    var c = e.labels,
      d = e._recent || _zeroPosition,
      g = e.duration() >= _bigNum$1 ? d.endTime(!1) : e._dur,
      _,
      b,
      j
    return _isString(a) && (isNaN(a) || a in c)
      ? ((b = a.charAt(0)),
        (j = a.substr(-1) === "%"),
        (_ = a.indexOf("=")),
        b === "<" || b === ">"
          ? (_ >= 0 && (a = a.replace(/=/, "")),
            (b === "<" ? d._start : d.endTime(d._repeat >= 0)) +
              (parseFloat(a.substr(1)) || 0) *
                (j ? (_ < 0 ? d : o).totalDuration() / 100 : 1))
          : _ < 0
          ? (a in c || (c[a] = g), c[a])
          : ((b = parseFloat(a.charAt(_ - 1) + a.substr(_ + 1))),
            j &&
              o &&
              (b = (b / 100) * (_isArray(o) ? o[0] : o).totalDuration()),
            _ > 1 ? s(e, a.substr(0, _ - 1), o) + b : g + b))
      : a == null
      ? g
      : +a
  },
  _createTweenType = function (e, a, o) {
    var c = _isNumber(a[1]),
      d = (c ? 2 : 1) + (e < 2 ? 0 : 1),
      g = a[d],
      _,
      b
    if ((c && (g.duration = a[1]), (g.parent = o), e)) {
      for (_ = g, b = o; b && !("immediateRender" in _); )
        (_ = b.vars.defaults || {}),
          (b = _isNotFalse(b.vars.inherit) && b.parent)
      ;(g.immediateRender = _isNotFalse(_.immediateRender)),
        e < 2 ? (g.runBackwards = 1) : (g.startAt = a[d - 1])
    }
    return new Tween(a[0], g, a[d + 1])
  },
  _conditionalReturn = function (e, a) {
    return e || e === 0 ? a(e) : a
  },
  _clamp = function (e, a, o) {
    return o < e ? e : o > a ? a : o
  },
  getUnit = function (e, a) {
    return !_isString(e) || !(a = _unitExp.exec(e)) ? "" : a[1]
  },
  clamp = function (e, a, o) {
    return _conditionalReturn(o, function (c) {
      return _clamp(e, a, c)
    })
  },
  _slice = [].slice,
  _isArrayLike = function (e, a) {
    return (
      e &&
      _isObject(e) &&
      "length" in e &&
      ((!a && !e.length) || (e.length - 1 in e && _isObject(e[0]))) &&
      !e.nodeType &&
      e !== _win$1
    )
  },
  _flatten = function (e, a, o) {
    return (
      o === void 0 && (o = []),
      e.forEach(function (c) {
        var d
        return (_isString(c) && !a) || _isArrayLike(c, 1)
          ? (d = o).push.apply(d, toArray(c))
          : o.push(c)
      }) || o
    )
  },
  toArray = function (e, a, o) {
    return _context && !a && _context.selector
      ? _context.selector(e)
      : _isString(e) && !o && (_coreInitted || !_wake())
      ? _slice.call((a || _doc$1).querySelectorAll(e), 0)
      : _isArray(e)
      ? _flatten(e, o)
      : _isArrayLike(e)
      ? _slice.call(e, 0)
      : e
      ? [e]
      : []
  },
  selector = function (e) {
    return (
      (e = toArray(e)[0] || _warn("Invalid scope") || {}),
      function (a) {
        var o = e.current || e.nativeElement || e
        return toArray(
          a,
          o.querySelectorAll
            ? o
            : o === e
            ? _warn("Invalid scope") || _doc$1.createElement("div")
            : e
        )
      }
    )
  },
  shuffle = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random()
    })
  },
  distribute = function (e) {
    if (_isFunction(e)) return e
    var a = _isObject(e) ? e : { each: e },
      o = _parseEase(a.ease),
      c = a.from || 0,
      d = parseFloat(a.base) || 0,
      g = {},
      _ = c > 0 && c < 1,
      b = isNaN(c) || _,
      j = a.axis,
      $ = c,
      _e = c
    return (
      _isString(c)
        ? ($ = _e = { center: 0.5, edges: 0.5, end: 1 }[c] || 0)
        : !_ && b && (($ = c[0]), (_e = c[1])),
      function (tt, st, at) {
        var ot = (at || a).length,
          ut = g[ot],
          it,
          ct,
          lt,
          ht,
          dt,
          pt,
          vt,
          _t,
          yt
        if (!ut) {
          if (
            ((yt = a.grid === "auto" ? 0 : (a.grid || [1, _bigNum$1])[1]), !yt)
          ) {
            for (
              vt = -_bigNum$1;
              vt < (vt = at[yt++].getBoundingClientRect().left) && yt < ot;

            );
            yt < ot && yt--
          }
          for (
            ut = g[ot] = [],
              it = b ? Math.min(yt, ot) * $ - 0.5 : c % yt,
              ct =
                yt === _bigNum$1 ? 0 : b ? (ot * _e) / yt - 0.5 : (c / yt) | 0,
              vt = 0,
              _t = _bigNum$1,
              pt = 0;
            pt < ot;
            pt++
          )
            (lt = (pt % yt) - it),
              (ht = ct - ((pt / yt) | 0)),
              (ut[pt] = dt =
                j ? Math.abs(j === "y" ? ht : lt) : _sqrt(lt * lt + ht * ht)),
              dt > vt && (vt = dt),
              dt < _t && (_t = dt)
          c === "random" && shuffle(ut),
            (ut.max = vt - _t),
            (ut.min = _t),
            (ut.v = ot =
              (parseFloat(a.amount) ||
                parseFloat(a.each) *
                  (yt > ot
                    ? ot - 1
                    : j
                    ? j === "y"
                      ? ot / yt
                      : yt
                    : Math.max(yt, ot / yt)) ||
                0) * (c === "edges" ? -1 : 1)),
            (ut.b = ot < 0 ? d - ot : d),
            (ut.u = getUnit(a.amount || a.each) || 0),
            (o = o && ot < 0 ? _invertEase(o) : o)
        }
        return (
          (ot = (ut[tt] - ut.min) / ut.max || 0),
          _roundPrecise(ut.b + (o ? o(ot) : ot) * ut.v) + ut.u
        )
      }
    )
  },
  _roundModifier = function (e) {
    var a = Math.pow(10, ((e + "").split(".")[1] || "").length)
    return function (o) {
      var c = _roundPrecise(Math.round(parseFloat(o) / e) * e * a)
      return (c - (c % 1)) / a + (_isNumber(o) ? 0 : getUnit(o))
    }
  },
  snap = function (e, a) {
    var o = _isArray(e),
      c,
      d
    return (
      !o &&
        _isObject(e) &&
        ((c = o = e.radius || _bigNum$1),
        e.values
          ? ((e = toArray(e.values)), (d = !_isNumber(e[0])) && (c *= c))
          : (e = _roundModifier(e.increment))),
      _conditionalReturn(
        a,
        o
          ? _isFunction(e)
            ? function (g) {
                return (d = e(g)), Math.abs(d - g) <= c ? d : g
              }
            : function (g) {
                for (
                  var _ = parseFloat(d ? g.x : g),
                    b = parseFloat(d ? g.y : 0),
                    j = _bigNum$1,
                    $ = 0,
                    _e = e.length,
                    tt,
                    st;
                  _e--;

                )
                  d
                    ? ((tt = e[_e].x - _),
                      (st = e[_e].y - b),
                      (tt = tt * tt + st * st))
                    : (tt = Math.abs(e[_e] - _)),
                    tt < j && ((j = tt), ($ = _e))
                return (
                  ($ = !c || j <= c ? e[$] : g),
                  d || $ === g || _isNumber(g) ? $ : $ + getUnit(g)
                )
              }
          : _roundModifier(e)
      )
    )
  },
  random = function (e, a, o, c) {
    return _conditionalReturn(
      _isArray(e) ? !a : o === !0 ? !!(o = 0) : !c,
      function () {
        return _isArray(e)
          ? e[~~(Math.random() * e.length)]
          : (o = o || 1e-5) &&
              (c = o < 1 ? Math.pow(10, (o + "").length - 2) : 1) &&
              Math.floor(
                Math.round(
                  (e - o / 2 + Math.random() * (a - e + o * 0.99)) / o
                ) *
                  o *
                  c
              ) / c
      }
    )
  },
  pipe = function () {
    for (var e = arguments.length, a = new Array(e), o = 0; o < e; o++)
      a[o] = arguments[o]
    return function (c) {
      return a.reduce(function (d, g) {
        return g(d)
      }, c)
    }
  },
  unitize = function (e, a) {
    return function (o) {
      return e(parseFloat(o)) + (a || getUnit(o))
    }
  },
  normalize = function (e, a, o) {
    return mapRange(e, a, 0, 1, o)
  },
  _wrapArray = function (e, a, o) {
    return _conditionalReturn(o, function (c) {
      return e[~~a(c)]
    })
  },
  wrap = function s(e, a, o) {
    var c = a - e
    return _isArray(e)
      ? _wrapArray(e, s(0, e.length), a)
      : _conditionalReturn(o, function (d) {
          return ((c + ((d - e) % c)) % c) + e
        })
  },
  wrapYoyo = function s(e, a, o) {
    var c = a - e,
      d = c * 2
    return _isArray(e)
      ? _wrapArray(e, s(0, e.length - 1), a)
      : _conditionalReturn(o, function (g) {
          return (g = (d + ((g - e) % d)) % d || 0), e + (g > c ? d - g : g)
        })
  },
  _replaceRandom = function (e) {
    for (var a = 0, o = "", c, d, g, _; ~(c = e.indexOf("random(", a)); )
      (g = e.indexOf(")", c)),
        (_ = e.charAt(c + 7) === "["),
        (d = e
          .substr(c + 7, g - c - 7)
          .match(_ ? _delimitedValueExp : _strictNumExp)),
        (o +=
          e.substr(a, c - a) +
          random(_ ? d : +d[0], _ ? 0 : +d[1], +d[2] || 1e-5)),
        (a = g + 1)
    return o + e.substr(a, e.length - a)
  },
  mapRange = function (e, a, o, c, d) {
    var g = a - e,
      _ = c - o
    return _conditionalReturn(d, function (b) {
      return o + (((b - e) / g) * _ || 0)
    })
  },
  interpolate = function s(e, a, o, c) {
    var d = isNaN(e + a)
      ? 0
      : function (st) {
          return (1 - st) * e + st * a
        }
    if (!d) {
      var g = _isString(e),
        _ = {},
        b,
        j,
        $,
        _e,
        tt
      if ((o === !0 && (c = 1) && (o = null), g)) (e = { p: e }), (a = { p: a })
      else if (_isArray(e) && !_isArray(a)) {
        for ($ = [], _e = e.length, tt = _e - 2, j = 1; j < _e; j++)
          $.push(s(e[j - 1], e[j]))
        _e--,
          (d = function (at) {
            at *= _e
            var ot = Math.min(tt, ~~at)
            return $[ot](at - ot)
          }),
          (o = a)
      } else c || (e = _merge(_isArray(e) ? [] : {}, e))
      if (!$) {
        for (b in a) _addPropTween.call(_, e, b, "get", a[b])
        d = function (at) {
          return _renderPropTweens(at, _) || (g ? e.p : e)
        }
      }
    }
    return _conditionalReturn(o, d)
  },
  _getLabelInDirection = function (e, a, o) {
    var c = e.labels,
      d = _bigNum$1,
      g,
      _,
      b
    for (g in c)
      (_ = c[g] - a),
        _ < 0 == !!o && _ && d > (_ = Math.abs(_)) && ((b = g), (d = _))
    return b
  },
  _callback = function (e, a, o) {
    var c = e.vars,
      d = c[a],
      g = _context,
      _ = e._ctx,
      b,
      j,
      $
    if (d)
      return (
        (b = c[a + "Params"]),
        (j = c.callbackScope || e),
        o && _lazyTweens.length && _lazyRender(),
        _ && (_context = _),
        ($ = b ? d.apply(j, b) : d.call(j)),
        (_context = g),
        $
      )
  },
  _interrupt = function (e) {
    return (
      _removeFromParent(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!_reverting$1),
      e.progress() < 1 && _callback(e, "onInterrupt"),
      e
    )
  },
  _quickTween,
  _registerPluginQueue = [],
  _createPlugin = function (e) {
    if (e)
      if (
        ((e = (!e.name && e.default) || e), _windowExists$1() || e.headless)
      ) {
        var a = e.name,
          o = _isFunction(e),
          c =
            a && !o && e.init
              ? function () {
                  this._props = []
                }
              : e,
          d = {
            init: _emptyFunc,
            render: _renderPropTweens,
            add: _addPropTween,
            kill: _killPropTweensOf,
            modifier: _addPluginModifier,
            rawVars: 0,
          },
          g = {
            targetTest: 0,
            get: 0,
            getSetter: _getSetter,
            aliases: {},
            register: 0,
          }
        if ((_wake(), e !== c)) {
          if (_plugins[a]) return
          _setDefaults(c, _setDefaults(_copyExcluding(e, d), g)),
            _merge(c.prototype, _merge(d, _copyExcluding(e, g))),
            (_plugins[(c.prop = a)] = c),
            e.targetTest && (_harnessPlugins.push(c), (_reservedProps[a] = 1)),
            (a =
              (a === "css" ? "CSS" : a.charAt(0).toUpperCase() + a.substr(1)) +
              "Plugin")
        }
        _addGlobal(a, c), e.register && e.register(gsap, c, PropTween)
      } else _registerPluginQueue.push(e)
  },
  _255 = 255,
  _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0],
  },
  _hue = function (e, a, o) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? a + (o - a) * e * 6
        : e < 0.5
        ? o
        : e * 3 < 2
        ? a + (o - a) * (2 / 3 - e) * 6
        : a) *
        _255 +
        0.5) |
        0
    )
  },
  splitColor = function (e, a, o) {
    var c = e
        ? _isNumber(e)
          ? [e >> 16, (e >> 8) & _255, e & _255]
          : 0
        : _colorLookup.black,
      d,
      g,
      _,
      b,
      j,
      $,
      _e,
      tt,
      st,
      at
    if (!c) {
      if (
        (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)),
        _colorLookup[e])
      )
        c = _colorLookup[e]
      else if (e.charAt(0) === "#") {
        if (
          (e.length < 6 &&
            ((d = e.charAt(1)),
            (g = e.charAt(2)),
            (_ = e.charAt(3)),
            (e =
              "#" +
              d +
              d +
              g +
              g +
              _ +
              _ +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
          e.length === 9)
        )
          return (
            (c = parseInt(e.substr(1, 6), 16)),
            [
              c >> 16,
              (c >> 8) & _255,
              c & _255,
              parseInt(e.substr(7), 16) / 255,
            ]
          )
        ;(e = parseInt(e.substr(1), 16)),
          (c = [e >> 16, (e >> 8) & _255, e & _255])
      } else if (e.substr(0, 3) === "hsl") {
        if (((c = at = e.match(_strictNumExp)), !a))
          (b = (+c[0] % 360) / 360),
            (j = +c[1] / 100),
            ($ = +c[2] / 100),
            (g = $ <= 0.5 ? $ * (j + 1) : $ + j - $ * j),
            (d = $ * 2 - g),
            c.length > 3 && (c[3] *= 1),
            (c[0] = _hue(b + 1 / 3, d, g)),
            (c[1] = _hue(b, d, g)),
            (c[2] = _hue(b - 1 / 3, d, g))
        else if (~e.indexOf("="))
          return (c = e.match(_numExp)), o && c.length < 4 && (c[3] = 1), c
      } else c = e.match(_strictNumExp) || _colorLookup.transparent
      c = c.map(Number)
    }
    return (
      a &&
        !at &&
        ((d = c[0] / _255),
        (g = c[1] / _255),
        (_ = c[2] / _255),
        (_e = Math.max(d, g, _)),
        (tt = Math.min(d, g, _)),
        ($ = (_e + tt) / 2),
        _e === tt
          ? (b = j = 0)
          : ((st = _e - tt),
            (j = $ > 0.5 ? st / (2 - _e - tt) : st / (_e + tt)),
            (b =
              _e === d
                ? (g - _) / st + (g < _ ? 6 : 0)
                : _e === g
                ? (_ - d) / st + 2
                : (d - g) / st + 4),
            (b *= 60)),
        (c[0] = ~~(b + 0.5)),
        (c[1] = ~~(j * 100 + 0.5)),
        (c[2] = ~~($ * 100 + 0.5))),
      o && c.length < 4 && (c[3] = 1),
      c
    )
  },
  _colorOrderData = function (e) {
    var a = [],
      o = [],
      c = -1
    return (
      e.split(_colorExp).forEach(function (d) {
        var g = d.match(_numWithUnitExp) || []
        a.push.apply(a, g), o.push((c += g.length + 1))
      }),
      (a.c = o),
      a
    )
  },
  _formatColors = function (e, a, o) {
    var c = "",
      d = (e + c).match(_colorExp),
      g = a ? "hsla(" : "rgba(",
      _ = 0,
      b,
      j,
      $,
      _e
    if (!d) return e
    if (
      ((d = d.map(function (tt) {
        return (
          (tt = splitColor(tt, a, 1)) &&
          g +
            (a
              ? tt[0] + "," + tt[1] + "%," + tt[2] + "%," + tt[3]
              : tt.join(",")) +
            ")"
        )
      })),
      o && (($ = _colorOrderData(e)), (b = o.c), b.join(c) !== $.c.join(c)))
    )
      for (
        j = e.replace(_colorExp, "1").split(_numWithUnitExp), _e = j.length - 1;
        _ < _e;
        _++
      )
        c +=
          j[_] +
          (~b.indexOf(_)
            ? d.shift() || g + "0,0,0,0)"
            : ($.length ? $ : d.length ? d : o).shift())
    if (!j)
      for (j = e.split(_colorExp), _e = j.length - 1; _ < _e; _++)
        c += j[_] + d[_]
    return c + j[_e]
  },
  _colorExp = (function () {
    var s =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      e
    for (e in _colorLookup) s += "|" + e + "\\b"
    return new RegExp(s + ")", "gi")
  })(),
  _hslExp = /hsl[a]?\(/,
  _colorStringFilter = function (e) {
    var a = e.join(" "),
      o
    if (((_colorExp.lastIndex = 0), _colorExp.test(a)))
      return (
        (o = _hslExp.test(a)),
        (e[1] = _formatColors(e[1], o)),
        (e[0] = _formatColors(e[0], o, _colorOrderData(e[1]))),
        !0
      )
  },
  _tickerActive,
  _ticker = (function () {
    var s = Date.now,
      e = 500,
      a = 33,
      o = s(),
      c = o,
      d = 1e3 / 240,
      g = d,
      _ = [],
      b,
      j,
      $,
      _e,
      tt,
      st,
      at = function ot(ut) {
        var it = s() - c,
          ct = ut === !0,
          lt,
          ht,
          dt,
          pt
        if (
          ((it > e || it < 0) && (o += it - a),
          (c += it),
          (dt = c - o),
          (lt = dt - g),
          (lt > 0 || ct) &&
            ((pt = ++_e.frame),
            (tt = dt - _e.time * 1e3),
            (_e.time = dt = dt / 1e3),
            (g += lt + (lt >= d ? 4 : d - lt)),
            (ht = 1)),
          ct || (b = j(ot)),
          ht)
        )
          for (st = 0; st < _.length; st++) _[st](dt, tt, pt, ut)
      }
    return (
      (_e = {
        time: 0,
        frame: 0,
        tick: function () {
          at(!0)
        },
        deltaRatio: function (ut) {
          return tt / (1e3 / (ut || 60))
        },
        wake: function () {
          _coreReady &&
            (!_coreInitted &&
              _windowExists$1() &&
              ((_win$1 = _coreInitted = window),
              (_doc$1 = _win$1.document || {}),
              (_globals.gsap = gsap),
              (_win$1.gsapVersions || (_win$1.gsapVersions = [])).push(
                gsap.version
              ),
              _install(
                _installScope ||
                  _win$1.GreenSockGlobals ||
                  (!_win$1.gsap && _win$1) ||
                  {}
              ),
              _registerPluginQueue.forEach(_createPlugin)),
            ($ = typeof requestAnimationFrame < "u" && requestAnimationFrame),
            b && _e.sleep(),
            (j =
              $ ||
              function (ut) {
                return setTimeout(ut, (g - _e.time * 1e3 + 1) | 0)
              }),
            (_tickerActive = 1),
            at(2))
        },
        sleep: function () {
          ;($ ? cancelAnimationFrame : clearTimeout)(b),
            (_tickerActive = 0),
            (j = _emptyFunc)
        },
        lagSmoothing: function (ut, it) {
          ;(e = ut || 1 / 0), (a = Math.min(it || 33, e))
        },
        fps: function (ut) {
          ;(d = 1e3 / (ut || 240)), (g = _e.time * 1e3 + d)
        },
        add: function (ut, it, ct) {
          var lt = it
            ? function (ht, dt, pt, vt) {
                ut(ht, dt, pt, vt), _e.remove(lt)
              }
            : ut
          return _e.remove(ut), _[ct ? "unshift" : "push"](lt), _wake(), lt
        },
        remove: function (ut, it) {
          ~(it = _.indexOf(ut)) && _.splice(it, 1) && st >= it && st--
        },
        _listeners: _,
      }),
      _e
    )
  })(),
  _wake = function () {
    return !_tickerActive && _ticker.wake()
  },
  _easeMap = {},
  _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
  _quotesExp = /["']/g,
  _parseObjectInString = function (e) {
    for (
      var a = {},
        o = e.substr(1, e.length - 3).split(":"),
        c = o[0],
        d = 1,
        g = o.length,
        _,
        b,
        j;
      d < g;
      d++
    )
      (b = o[d]),
        (_ = d !== g - 1 ? b.lastIndexOf(",") : b.length),
        (j = b.substr(0, _)),
        (a[c] = isNaN(j) ? j.replace(_quotesExp, "").trim() : +j),
        (c = b.substr(_ + 1).trim())
    return a
  },
  _valueInParentheses = function (e) {
    var a = e.indexOf("(") + 1,
      o = e.indexOf(")"),
      c = e.indexOf("(", a)
    return e.substring(a, ~c && c < o ? e.indexOf(")", o + 1) : o)
  },
  _configEaseFromString = function (e) {
    var a = (e + "").split("("),
      o = _easeMap[a[0]]
    return o && a.length > 1 && o.config
      ? o.config.apply(
          null,
          ~e.indexOf("{")
            ? [_parseObjectInString(a[1])]
            : _valueInParentheses(e).split(",").map(_numericIfPossible)
        )
      : _easeMap._CE && _customEaseExp.test(e)
      ? _easeMap._CE("", e)
      : o
  },
  _invertEase = function (e) {
    return function (a) {
      return 1 - e(1 - a)
    }
  },
  _propagateYoyoEase = function s(e, a) {
    for (var o = e._first, c; o; )
      o instanceof Timeline
        ? s(o, a)
        : o.vars.yoyoEase &&
          (!o._yoyo || !o._repeat) &&
          o._yoyo !== a &&
          (o.timeline
            ? s(o.timeline, a)
            : ((c = o._ease),
              (o._ease = o._yEase),
              (o._yEase = c),
              (o._yoyo = a))),
        (o = o._next)
  },
  _parseEase = function (e, a) {
    return (
      (e && (_isFunction(e) ? e : _easeMap[e] || _configEaseFromString(e))) || a
    )
  },
  _insertEase = function (e, a, o, c) {
    o === void 0 &&
      (o = function (b) {
        return 1 - a(1 - b)
      }),
      c === void 0 &&
        (c = function (b) {
          return b < 0.5 ? a(b * 2) / 2 : 1 - a((1 - b) * 2) / 2
        })
    var d = { easeIn: a, easeOut: o, easeInOut: c },
      g
    return (
      _forEachName(e, function (_) {
        ;(_easeMap[_] = _globals[_] = d), (_easeMap[(g = _.toLowerCase())] = o)
        for (var b in d)
          _easeMap[
            g + (b === "easeIn" ? ".in" : b === "easeOut" ? ".out" : ".inOut")
          ] = _easeMap[_ + "." + b] = d[b]
      }),
      d
    )
  },
  _easeInOutFromOut = function (e) {
    return function (a) {
      return a < 0.5 ? (1 - e(1 - a * 2)) / 2 : 0.5 + e((a - 0.5) * 2) / 2
    }
  },
  _configElastic = function s(e, a, o) {
    var c = a >= 1 ? a : 1,
      d = (o || (e ? 0.3 : 0.45)) / (a < 1 ? a : 1),
      g = (d / _2PI) * (Math.asin(1 / c) || 0),
      _ = function ($) {
        return $ === 1 ? 1 : c * Math.pow(2, -10 * $) * _sin(($ - g) * d) + 1
      },
      b =
        e === "out"
          ? _
          : e === "in"
          ? function (j) {
              return 1 - _(1 - j)
            }
          : _easeInOutFromOut(_)
    return (
      (d = _2PI / d),
      (b.config = function (j, $) {
        return s(e, j, $)
      }),
      b
    )
  },
  _configBack = function s(e, a) {
    a === void 0 && (a = 1.70158)
    var o = function (g) {
        return g ? --g * g * ((a + 1) * g + a) + 1 : 0
      },
      c =
        e === "out"
          ? o
          : e === "in"
          ? function (d) {
              return 1 - o(1 - d)
            }
          : _easeInOutFromOut(o)
    return (
      (c.config = function (d) {
        return s(e, d)
      }),
      c
    )
  }
_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (s, e) {
  var a = e < 5 ? e + 1 : e
  _insertEase(
    s + ",Power" + (a - 1),
    e
      ? function (o) {
          return Math.pow(o, a)
        }
      : function (o) {
          return o
        },
    function (o) {
      return 1 - Math.pow(1 - o, a)
    },
    function (o) {
      return o < 0.5 ? Math.pow(o * 2, a) / 2 : 1 - Math.pow((1 - o) * 2, a) / 2
    }
  )
})
_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn
_insertEase(
  "Elastic",
  _configElastic("in"),
  _configElastic("out"),
  _configElastic()
)
;(function (s, e) {
  var a = 1 / e,
    o = 2 * a,
    c = 2.5 * a,
    d = function (_) {
      return _ < a
        ? s * _ * _
        : _ < o
        ? s * Math.pow(_ - 1.5 / e, 2) + 0.75
        : _ < c
        ? s * (_ -= 2.25 / e) * _ + 0.9375
        : s * Math.pow(_ - 2.625 / e, 2) + 0.984375
    }
  _insertEase(
    "Bounce",
    function (g) {
      return 1 - d(1 - g)
    },
    d
  )
})(7.5625, 2.75)
_insertEase("Expo", function (s) {
  return s ? Math.pow(2, 10 * (s - 1)) : 0
})
_insertEase("Circ", function (s) {
  return -(_sqrt(1 - s * s) - 1)
})
_insertEase("Sine", function (s) {
  return s === 1 ? 1 : -_cos(s * _HALF_PI) + 1
})
_insertEase("Back", _configBack("in"), _configBack("out"), _configBack())
_easeMap.SteppedEase =
  _easeMap.steps =
  _globals.SteppedEase =
    {
      config: function (e, a) {
        e === void 0 && (e = 1)
        var o = 1 / e,
          c = e + (a ? 0 : 1),
          d = a ? 1 : 0,
          g = 1 - _tinyNum
        return function (_) {
          return (((c * _clamp(0, g, _)) | 0) + d) * o
        }
      },
    }
_defaults.ease = _easeMap["quad.out"]
_forEachName(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (s) {
    return (_callbackNames += s + "," + s + "Params,")
  }
)
var GSCache = function (e, a) {
    ;(this.id = _gsID++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = a),
      (this.get = a ? a.get : _getProperty),
      (this.set = a ? a.getSetter : _getSetter)
  },
  Animation$1 = (function () {
    function s(a) {
      ;(this.vars = a),
        (this._delay = +a.delay || 0),
        (this._repeat = a.repeat === 1 / 0 ? -2 : a.repeat || 0) &&
          ((this._rDelay = a.repeatDelay || 0),
          (this._yoyo = !!a.yoyo || !!a.yoyoEase)),
        (this._ts = 1),
        _setDuration(this, +a.duration, 1, 1),
        (this.data = a.data),
        _context && ((this._ctx = _context), _context.data.push(this)),
        _tickerActive || _ticker.wake()
    }
    var e = s.prototype
    return (
      (e.delay = function (o) {
        return o || o === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + o - this._delay),
            (this._delay = o),
            this)
          : this._delay
      }),
      (e.duration = function (o) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? o + (o + this._rDelay) * this._repeat : o
            )
          : this.totalDuration() && this._dur
      }),
      (e.totalDuration = function (o) {
        return arguments.length
          ? ((this._dirty = 0),
            _setDuration(
              this,
              this._repeat < 0
                ? o
                : (o - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur
      }),
      (e.totalTime = function (o, c) {
        if ((_wake(), !arguments.length)) return this._tTime
        var d = this._dp
        if (d && d.smoothChildTiming && this._ts) {
          for (
            _alignPlayhead(this, o),
              !d._dp || d.parent || _postAddChecks(d, this);
            d && d.parent;

          )
            d.parent._time !==
              d._start +
                (d._ts >= 0
                  ? d._tTime / d._ts
                  : (d.totalDuration() - d._tTime) / -d._ts) &&
              d.totalTime(d._tTime, !0),
              (d = d.parent)
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && o < this._tDur) ||
              (this._ts < 0 && o > 0) ||
              (!this._tDur && !o)) &&
            _addToTimeline(this._dp, this, this._start - this._delay)
        }
        return (
          (this._tTime !== o ||
            (!this._dur && !c) ||
            (this._initted && Math.abs(this._zTime) === _tinyNum) ||
            (!o && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = o), _lazySafeRender(this, o, c)),
          this
        )
      }),
      (e.time = function (o, c) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), o + _elapsedCycleDuration(this)) %
                (this._dur + this._rDelay) || (o ? this._dur : 0),
              c
            )
          : this._time
      }),
      (e.totalProgress = function (o, c) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * o, c)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.rawTime() > 0
          ? 1
          : 0
      }),
      (e.progress = function (o, c) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - o : o) +
                _elapsedCycleDuration(this),
              c
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.rawTime() > 0
          ? 1
          : 0
      }),
      (e.iteration = function (o, c) {
        var d = this.duration() + this._rDelay
        return arguments.length
          ? this.totalTime(this._time + (o - 1) * d, c)
          : this._repeat
          ? _animationCycle(this._tTime, d) + 1
          : 1
      }),
      (e.timeScale = function (o, c) {
        if (!arguments.length) return this._rts === -_tinyNum ? 0 : this._rts
        if (this._rts === o) return this
        var d =
          this.parent && this._ts
            ? _parentToChildTotalTime(this.parent._time, this)
            : this._tTime
        return (
          (this._rts = +o || 0),
          (this._ts = this._ps || o === -_tinyNum ? 0 : this._rts),
          this.totalTime(
            _clamp(-Math.abs(this._delay), this._tDur, d),
            c !== !1
          ),
          _setEnd(this),
          _recacheAncestors(this)
        )
      }),
      (e.paused = function (o) {
        return arguments.length
          ? (this._ps !== o &&
              ((this._ps = o),
              o
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (_wake(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== _tinyNum &&
                      (this._tTime -= _tinyNum)
                  ))),
            this)
          : this._ps
      }),
      (e.startTime = function (o) {
        if (arguments.length) {
          this._start = o
          var c = this.parent || this._dp
          return (
            c &&
              (c._sort || !this.parent) &&
              _addToTimeline(c, this, o - this._delay),
            this
          )
        }
        return this._start
      }),
      (e.endTime = function (o) {
        return (
          this._start +
          (_isNotFalse(o) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        )
      }),
      (e.rawTime = function (o) {
        var c = this.parent || this._dp
        return c
          ? o &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? _parentToChildTotalTime(c.rawTime(o), this)
            : this._tTime
          : this._tTime
      }),
      (e.revert = function (o) {
        o === void 0 && (o = _revertConfig)
        var c = _reverting$1
        return (
          (_reverting$1 = o),
          (this._initted || this._startAt) &&
            (this.timeline && this.timeline.revert(o),
            this.totalTime(-0.01, o.suppressEvents)),
          this.data !== "nested" && o.kill !== !1 && this.kill(),
          (_reverting$1 = c),
          this
        )
      }),
      (e.globalTime = function (o) {
        for (var c = this, d = arguments.length ? o : c.rawTime(); c; )
          (d = c._start + d / (Math.abs(c._ts) || 1)), (c = c._dp)
        return !this.parent && this._sat ? this._sat.globalTime(o) : d
      }),
      (e.repeat = function (o) {
        return arguments.length
          ? ((this._repeat = o === 1 / 0 ? -2 : o),
            _onUpdateTotalDuration(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat
      }),
      (e.repeatDelay = function (o) {
        if (arguments.length) {
          var c = this._time
          return (
            (this._rDelay = o),
            _onUpdateTotalDuration(this),
            c ? this.time(c) : this
          )
        }
        return this._rDelay
      }),
      (e.yoyo = function (o) {
        return arguments.length ? ((this._yoyo = o), this) : this._yoyo
      }),
      (e.seek = function (o, c) {
        return this.totalTime(_parsePosition(this, o), _isNotFalse(c))
      }),
      (e.restart = function (o, c) {
        return this.play().totalTime(o ? -this._delay : 0, _isNotFalse(c))
      }),
      (e.play = function (o, c) {
        return o != null && this.seek(o, c), this.reversed(!1).paused(!1)
      }),
      (e.reverse = function (o, c) {
        return (
          o != null && this.seek(o || this.totalDuration(), c),
          this.reversed(!0).paused(!1)
        )
      }),
      (e.pause = function (o, c) {
        return o != null && this.seek(o, c), this.paused(!0)
      }),
      (e.resume = function () {
        return this.paused(!1)
      }),
      (e.reversed = function (o) {
        return arguments.length
          ? (!!o !== this.reversed() &&
              this.timeScale(-this._rts || (o ? -_tinyNum : 0)),
            this)
          : this._rts < 0
      }),
      (e.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -_tinyNum), this
      }),
      (e.isActive = function () {
        var o = this.parent || this._dp,
          c = this._start,
          d
        return !!(
          !o ||
          (this._ts &&
            this._initted &&
            o.isActive() &&
            (d = o.rawTime(!0)) >= c &&
            d < this.endTime(!0) - _tinyNum)
        )
      }),
      (e.eventCallback = function (o, c, d) {
        var g = this.vars
        return arguments.length > 1
          ? (c
              ? ((g[o] = c),
                d && (g[o + "Params"] = d),
                o === "onUpdate" && (this._onUpdate = c))
              : delete g[o],
            this)
          : g[o]
      }),
      (e.then = function (o) {
        var c = this
        return new Promise(function (d) {
          var g = _isFunction(o) ? o : _passThrough,
            _ = function () {
              var j = c.then
              ;(c.then = null),
                _isFunction(g) &&
                  (g = g(c)) &&
                  (g.then || g === c) &&
                  (c.then = j),
                d(g),
                (c.then = j)
            }
          ;(c._initted && c.totalProgress() === 1 && c._ts >= 0) ||
          (!c._tTime && c._ts < 0)
            ? _()
            : (c._prom = _)
        })
      }),
      (e.kill = function () {
        _interrupt(this)
      }),
      s
    )
  })()
_setDefaults(Animation$1.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: !1,
  _rts: 1,
})
var Timeline = (function (s) {
  _inheritsLoose$1(e, s)
  function e(o, c) {
    var d
    return (
      o === void 0 && (o = {}),
      (d = s.call(this, o) || this),
      (d.labels = {}),
      (d.smoothChildTiming = !!o.smoothChildTiming),
      (d.autoRemoveChildren = !!o.autoRemoveChildren),
      (d._sort = _isNotFalse(o.sortChildren)),
      _globalTimeline &&
        _addToTimeline(
          o.parent || _globalTimeline,
          _assertThisInitialized(d),
          c
        ),
      o.reversed && d.reverse(),
      o.paused && d.paused(!0),
      o.scrollTrigger &&
        _scrollTrigger(_assertThisInitialized(d), o.scrollTrigger),
      d
    )
  }
  var a = e.prototype
  return (
    (a.to = function (c, d, g) {
      return _createTweenType(0, arguments, this), this
    }),
    (a.from = function (c, d, g) {
      return _createTweenType(1, arguments, this), this
    }),
    (a.fromTo = function (c, d, g, _) {
      return _createTweenType(2, arguments, this), this
    }),
    (a.set = function (c, d, g) {
      return (
        (d.duration = 0),
        (d.parent = this),
        _inheritDefaults(d).repeatDelay || (d.repeat = 0),
        (d.immediateRender = !!d.immediateRender),
        new Tween(c, d, _parsePosition(this, g), 1),
        this
      )
    }),
    (a.call = function (c, d, g) {
      return _addToTimeline(this, Tween.delayedCall(0, c, d), g)
    }),
    (a.staggerTo = function (c, d, g, _, b, j, $) {
      return (
        (g.duration = d),
        (g.stagger = g.stagger || _),
        (g.onComplete = j),
        (g.onCompleteParams = $),
        (g.parent = this),
        new Tween(c, g, _parsePosition(this, b)),
        this
      )
    }),
    (a.staggerFrom = function (c, d, g, _, b, j, $) {
      return (
        (g.runBackwards = 1),
        (_inheritDefaults(g).immediateRender = _isNotFalse(g.immediateRender)),
        this.staggerTo(c, d, g, _, b, j, $)
      )
    }),
    (a.staggerFromTo = function (c, d, g, _, b, j, $, _e) {
      return (
        (_.startAt = g),
        (_inheritDefaults(_).immediateRender = _isNotFalse(_.immediateRender)),
        this.staggerTo(c, d, _, b, j, $, _e)
      )
    }),
    (a.render = function (c, d, g) {
      var _ = this._time,
        b = this._dirty ? this.totalDuration() : this._tDur,
        j = this._dur,
        $ = c <= 0 ? 0 : _roundPrecise(c),
        _e = this._zTime < 0 != c < 0 && (this._initted || !j),
        tt,
        st,
        at,
        ot,
        ut,
        it,
        ct,
        lt,
        ht,
        dt,
        pt,
        vt
      if (
        (this !== _globalTimeline && $ > b && c >= 0 && ($ = b),
        $ !== this._tTime || g || _e)
      ) {
        if (
          (_ !== this._time &&
            j &&
            (($ += this._time - _), (c += this._time - _)),
          (tt = $),
          (ht = this._start),
          (lt = this._ts),
          (it = !lt),
          _e && (j || (_ = this._zTime), (c || !d) && (this._zTime = c)),
          this._repeat)
        ) {
          if (
            ((pt = this._yoyo),
            (ut = j + this._rDelay),
            this._repeat < -1 && c < 0)
          )
            return this.totalTime(ut * 100 + c, d, g)
          if (
            ((tt = _roundPrecise($ % ut)),
            $ === b
              ? ((ot = this._repeat), (tt = j))
              : ((ot = ~~($ / ut)),
                ot && ot === $ / ut && ((tt = j), ot--),
                tt > j && (tt = j)),
            (dt = _animationCycle(this._tTime, ut)),
            !_ &&
              this._tTime &&
              dt !== ot &&
              this._tTime - dt * ut - this._dur <= 0 &&
              (dt = ot),
            pt && ot & 1 && ((tt = j - tt), (vt = 1)),
            ot !== dt && !this._lock)
          ) {
            var _t = pt && dt & 1,
              yt = _t === (pt && ot & 1)
            if (
              (ot < dt && (_t = !_t),
              (_ = _t ? 0 : $ % j ? j : $),
              (this._lock = 1),
              (this.render(
                _ || (vt ? 0 : _roundPrecise(ot * ut)),
                d,
                !j
              )._lock = 0),
              (this._tTime = $),
              !d && this.parent && _callback(this, "onRepeat"),
              this.vars.repeatRefresh && !vt && (this.invalidate()._lock = 1),
              (_ && _ !== this._time) ||
                it !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this
            if (
              ((j = this._dur),
              (b = this._tDur),
              yt &&
                ((this._lock = 2),
                (_ = _t ? j : -1e-4),
                this.render(_, !0),
                this.vars.repeatRefresh && !vt && this.invalidate()),
              (this._lock = 0),
              !this._ts && !it)
            )
              return this
            _propagateYoyoEase(this, vt)
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((ct = _findNextPauseTween(
              this,
              _roundPrecise(_),
              _roundPrecise(tt)
            )),
            ct && ($ -= tt - (tt = ct._start))),
          (this._tTime = $),
          (this._time = tt),
          (this._act = !lt),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = c),
            (_ = 0)),
          !_ &&
            tt &&
            !d &&
            !ot &&
            (_callback(this, "onStart"), this._tTime !== $))
        )
          return this
        if (tt >= _ && c >= 0)
          for (st = this._first; st; ) {
            if (
              ((at = st._next),
              (st._act || tt >= st._start) && st._ts && ct !== st)
            ) {
              if (st.parent !== this) return this.render(c, d, g)
              if (
                (st.render(
                  st._ts > 0
                    ? (tt - st._start) * st._ts
                    : (st._dirty ? st.totalDuration() : st._tDur) +
                        (tt - st._start) * st._ts,
                  d,
                  g
                ),
                tt !== this._time || (!this._ts && !it))
              ) {
                ;(ct = 0), at && ($ += this._zTime = -_tinyNum)
                break
              }
            }
            st = at
          }
        else {
          st = this._last
          for (var Et = c < 0 ? c : tt; st; ) {
            if (
              ((at = st._prev),
              (st._act || Et <= st._end) && st._ts && ct !== st)
            ) {
              if (st.parent !== this) return this.render(c, d, g)
              if (
                (st.render(
                  st._ts > 0
                    ? (Et - st._start) * st._ts
                    : (st._dirty ? st.totalDuration() : st._tDur) +
                        (Et - st._start) * st._ts,
                  d,
                  g || (_reverting$1 && (st._initted || st._startAt))
                ),
                tt !== this._time || (!this._ts && !it))
              ) {
                ;(ct = 0), at && ($ += this._zTime = Et ? -_tinyNum : _tinyNum)
                break
              }
            }
            st = at
          }
        }
        if (
          ct &&
          !d &&
          (this.pause(),
          (ct.render(tt >= _ ? 0 : -_tinyNum)._zTime = tt >= _ ? 1 : -1),
          this._ts)
        )
          return (this._start = ht), _setEnd(this), this.render(c, d, g)
        this._onUpdate && !d && _callback(this, "onUpdate", !0),
          (($ === b && this._tTime >= this.totalDuration()) || (!$ && _)) &&
            (ht === this._start || Math.abs(lt) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((c || !j) &&
                (($ === b && this._ts > 0) || (!$ && this._ts < 0)) &&
                _removeFromParent(this, 1),
              !d &&
                !(c < 0 && !_) &&
                ($ || _ || !b) &&
                (_callback(
                  this,
                  $ === b && c >= 0 ? "onComplete" : "onReverseComplete",
                  !0
                ),
                this._prom &&
                  !($ < b && this.timeScale() > 0) &&
                  this._prom())))
      }
      return this
    }),
    (a.add = function (c, d) {
      var g = this
      if (
        (_isNumber(d) || (d = _parsePosition(this, d, c)),
        !(c instanceof Animation$1))
      ) {
        if (_isArray(c))
          return (
            c.forEach(function (_) {
              return g.add(_, d)
            }),
            this
          )
        if (_isString(c)) return this.addLabel(c, d)
        if (_isFunction(c)) c = Tween.delayedCall(0, c)
        else return this
      }
      return this !== c ? _addToTimeline(this, c, d) : this
    }),
    (a.getChildren = function (c, d, g, _) {
      c === void 0 && (c = !0),
        d === void 0 && (d = !0),
        g === void 0 && (g = !0),
        _ === void 0 && (_ = -_bigNum$1)
      for (var b = [], j = this._first; j; )
        j._start >= _ &&
          (j instanceof Tween
            ? d && b.push(j)
            : (g && b.push(j), c && b.push.apply(b, j.getChildren(!0, d, g)))),
          (j = j._next)
      return b
    }),
    (a.getById = function (c) {
      for (var d = this.getChildren(1, 1, 1), g = d.length; g--; )
        if (d[g].vars.id === c) return d[g]
    }),
    (a.remove = function (c) {
      return _isString(c)
        ? this.removeLabel(c)
        : _isFunction(c)
        ? this.killTweensOf(c)
        : (_removeLinkedListItem(this, c),
          c === this._recent && (this._recent = this._last),
          _uncache(this))
    }),
    (a.totalTime = function (c, d) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = _roundPrecise(
              _ticker.time -
                (this._ts > 0
                  ? c / this._ts
                  : (this.totalDuration() - c) / -this._ts)
            )),
          s.prototype.totalTime.call(this, c, d),
          (this._forcing = 0),
          this)
        : this._tTime
    }),
    (a.addLabel = function (c, d) {
      return (this.labels[c] = _parsePosition(this, d)), this
    }),
    (a.removeLabel = function (c) {
      return delete this.labels[c], this
    }),
    (a.addPause = function (c, d, g) {
      var _ = Tween.delayedCall(0, d || _emptyFunc, g)
      return (
        (_.data = "isPause"),
        (this._hasPause = 1),
        _addToTimeline(this, _, _parsePosition(this, c))
      )
    }),
    (a.removePause = function (c) {
      var d = this._first
      for (c = _parsePosition(this, c); d; )
        d._start === c && d.data === "isPause" && _removeFromParent(d),
          (d = d._next)
    }),
    (a.killTweensOf = function (c, d, g) {
      for (var _ = this.getTweensOf(c, g), b = _.length; b--; )
        _overwritingTween !== _[b] && _[b].kill(c, d)
      return this
    }),
    (a.getTweensOf = function (c, d) {
      for (
        var g = [], _ = toArray(c), b = this._first, j = _isNumber(d), $;
        b;

      )
        b instanceof Tween
          ? _arrayContainsAny(b._targets, _) &&
            (j
              ? (!_overwritingTween || (b._initted && b._ts)) &&
                b.globalTime(0) <= d &&
                b.globalTime(b.totalDuration()) > d
              : !d || b.isActive()) &&
            g.push(b)
          : ($ = b.getTweensOf(_, d)).length && g.push.apply(g, $),
          (b = b._next)
      return g
    }),
    (a.tweenTo = function (c, d) {
      d = d || {}
      var g = this,
        _ = _parsePosition(g, c),
        b = d,
        j = b.startAt,
        $ = b.onStart,
        _e = b.onStartParams,
        tt = b.immediateRender,
        st,
        at = Tween.to(
          g,
          _setDefaults(
            {
              ease: d.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: _,
              overwrite: "auto",
              duration:
                d.duration ||
                Math.abs(
                  (_ - (j && "time" in j ? j.time : g._time)) / g.timeScale()
                ) ||
                _tinyNum,
              onStart: function () {
                if ((g.pause(), !st)) {
                  var ut =
                    d.duration ||
                    Math.abs(
                      (_ - (j && "time" in j ? j.time : g._time)) /
                        g.timeScale()
                    )
                  at._dur !== ut &&
                    _setDuration(at, ut, 0, 1).render(at._time, !0, !0),
                    (st = 1)
                }
                $ && $.apply(at, _e || [])
              },
            },
            d
          )
        )
      return tt ? at.render(0) : at
    }),
    (a.tweenFromTo = function (c, d, g) {
      return this.tweenTo(
        d,
        _setDefaults({ startAt: { time: _parsePosition(this, c) } }, g)
      )
    }),
    (a.recent = function () {
      return this._recent
    }),
    (a.nextLabel = function (c) {
      return (
        c === void 0 && (c = this._time),
        _getLabelInDirection(this, _parsePosition(this, c))
      )
    }),
    (a.previousLabel = function (c) {
      return (
        c === void 0 && (c = this._time),
        _getLabelInDirection(this, _parsePosition(this, c), 1)
      )
    }),
    (a.currentLabel = function (c) {
      return arguments.length
        ? this.seek(c, !0)
        : this.previousLabel(this._time + _tinyNum)
    }),
    (a.shiftChildren = function (c, d, g) {
      g === void 0 && (g = 0)
      for (var _ = this._first, b = this.labels, j; _; )
        _._start >= g && ((_._start += c), (_._end += c)), (_ = _._next)
      if (d) for (j in b) b[j] >= g && (b[j] += c)
      return _uncache(this)
    }),
    (a.invalidate = function (c) {
      var d = this._first
      for (this._lock = 0; d; ) d.invalidate(c), (d = d._next)
      return s.prototype.invalidate.call(this, c)
    }),
    (a.clear = function (c) {
      c === void 0 && (c = !0)
      for (var d = this._first, g; d; ) (g = d._next), this.remove(d), (d = g)
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        c && (this.labels = {}),
        _uncache(this)
      )
    }),
    (a.totalDuration = function (c) {
      var d = 0,
        g = this,
        _ = g._last,
        b = _bigNum$1,
        j,
        $,
        _e
      if (arguments.length)
        return g.timeScale(
          (g._repeat < 0 ? g.duration() : g.totalDuration()) /
            (g.reversed() ? -c : c)
        )
      if (g._dirty) {
        for (_e = g.parent; _; )
          (j = _._prev),
            _._dirty && _.totalDuration(),
            ($ = _._start),
            $ > b && g._sort && _._ts && !g._lock
              ? ((g._lock = 1),
                (_addToTimeline(g, _, $ - _._delay, 1)._lock = 0))
              : (b = $),
            $ < 0 &&
              _._ts &&
              ((d -= $),
              ((!_e && !g._dp) || (_e && _e.smoothChildTiming)) &&
                ((g._start += $ / g._ts), (g._time -= $), (g._tTime -= $)),
              g.shiftChildren(-$, !1, -1 / 0),
              (b = 0)),
            _._end > d && _._ts && (d = _._end),
            (_ = j)
        _setDuration(
          g,
          g === _globalTimeline && g._time > d ? g._time : d,
          1,
          1
        ),
          (g._dirty = 0)
      }
      return g._tDur
    }),
    (e.updateRoot = function (c) {
      if (
        (_globalTimeline._ts &&
          (_lazySafeRender(
            _globalTimeline,
            _parentToChildTotalTime(c, _globalTimeline)
          ),
          (_lastRenderedFrame = _ticker.frame)),
        _ticker.frame >= _nextGCFrame)
      ) {
        _nextGCFrame += _config.autoSleep || 120
        var d = _globalTimeline._first
        if (
          (!d || !d._ts) &&
          _config.autoSleep &&
          _ticker._listeners.length < 2
        ) {
          for (; d && !d._ts; ) d = d._next
          d || _ticker.sleep()
        }
      }
    }),
    e
  )
})(Animation$1)
_setDefaults(Timeline.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 })
var _addComplexStringPropTween = function (e, a, o, c, d, g, _) {
    var b = new PropTween(this._pt, e, a, 0, 1, _renderComplexString, null, d),
      j = 0,
      $ = 0,
      _e,
      tt,
      st,
      at,
      ot,
      ut,
      it,
      ct
    for (
      b.b = o,
        b.e = c,
        o += "",
        c += "",
        (it = ~c.indexOf("random(")) && (c = _replaceRandom(c)),
        g && ((ct = [o, c]), g(ct, e, a), (o = ct[0]), (c = ct[1])),
        tt = o.match(_complexStringNumExp) || [];
      (_e = _complexStringNumExp.exec(c));

    )
      (at = _e[0]),
        (ot = c.substring(j, _e.index)),
        st ? (st = (st + 1) % 5) : ot.substr(-5) === "rgba(" && (st = 1),
        at !== tt[$++] &&
          ((ut = parseFloat(tt[$ - 1]) || 0),
          (b._pt = {
            _next: b._pt,
            p: ot || $ === 1 ? ot : ",",
            s: ut,
            c:
              at.charAt(1) === "="
                ? _parseRelative(ut, at) - ut
                : parseFloat(at) - ut,
            m: st && st < 4 ? Math.round : 0,
          }),
          (j = _complexStringNumExp.lastIndex))
    return (
      (b.c = j < c.length ? c.substring(j, c.length) : ""),
      (b.fp = _),
      (_relExp.test(c) || it) && (b.e = 0),
      (this._pt = b),
      b
    )
  },
  _addPropTween = function (e, a, o, c, d, g, _, b, j, $) {
    _isFunction(c) && (c = c(d || 0, e, g))
    var _e = e[a],
      tt =
        o !== "get"
          ? o
          : _isFunction(_e)
          ? j
            ? e[
                a.indexOf("set") || !_isFunction(e["get" + a.substr(3)])
                  ? a
                  : "get" + a.substr(3)
              ](j)
            : e[a]()
          : _e,
      st = _isFunction(_e)
        ? j
          ? _setterFuncWithParam
          : _setterFunc
        : _setterPlain,
      at
    if (
      (_isString(c) &&
        (~c.indexOf("random(") && (c = _replaceRandom(c)),
        c.charAt(1) === "=" &&
          ((at = _parseRelative(tt, c) + (getUnit(tt) || 0)),
          (at || at === 0) && (c = at))),
      !$ || tt !== c || _forceAllPropTweens)
    )
      return !isNaN(tt * c) && c !== ""
        ? ((at = new PropTween(
            this._pt,
            e,
            a,
            +tt || 0,
            c - (tt || 0),
            typeof _e == "boolean" ? _renderBoolean : _renderPlain,
            0,
            st
          )),
          j && (at.fp = j),
          _ && at.modifier(_, this, e),
          (this._pt = at))
        : (!_e && !(a in e) && _missingPlugin(a, c),
          _addComplexStringPropTween.call(
            this,
            e,
            a,
            tt,
            c,
            st,
            b || _config.stringFilter,
            j
          ))
  },
  _processVars = function (e, a, o, c, d) {
    if (
      (_isFunction(e) && (e = _parseFuncOrString(e, d, a, o, c)),
      !_isObject(e) ||
        (e.style && e.nodeType) ||
        _isArray(e) ||
        _isTypedArray(e))
    )
      return _isString(e) ? _parseFuncOrString(e, d, a, o, c) : e
    var g = {},
      _
    for (_ in e) g[_] = _parseFuncOrString(e[_], d, a, o, c)
    return g
  },
  _checkPlugin = function (e, a, o, c, d, g) {
    var _, b, j, $
    if (
      _plugins[e] &&
      (_ = new _plugins[e]()).init(
        d,
        _.rawVars ? a[e] : _processVars(a[e], c, d, g, o),
        o,
        c,
        g
      ) !== !1 &&
      ((o._pt = b =
        new PropTween(o._pt, d, e, 0, 1, _.render, _, 0, _.priority)),
      o !== _quickTween)
    )
      for (j = o._ptLookup[o._targets.indexOf(d)], $ = _._props.length; $--; )
        j[_._props[$]] = b
    return _
  },
  _overwritingTween,
  _forceAllPropTweens,
  _initTween = function s(e, a, o) {
    var c = e.vars,
      d = c.ease,
      g = c.startAt,
      _ = c.immediateRender,
      b = c.lazy,
      j = c.onUpdate,
      $ = c.runBackwards,
      _e = c.yoyoEase,
      tt = c.keyframes,
      st = c.autoRevert,
      at = e._dur,
      ot = e._startAt,
      ut = e._targets,
      it = e.parent,
      ct = it && it.data === "nested" ? it.vars.targets : ut,
      lt = e._overwrite === "auto" && !_suppressOverwrites,
      ht = e.timeline,
      dt,
      pt,
      vt,
      _t,
      yt,
      Et,
      Rt,
      Ft,
      kt,
      Nt,
      Dt,
      Mt,
      wt
    if (
      (ht && (!tt || !d) && (d = "none"),
      (e._ease = _parseEase(d, _defaults.ease)),
      (e._yEase = _e
        ? _invertEase(_parseEase(_e === !0 ? d : _e, _defaults.ease))
        : 0),
      _e &&
        e._yoyo &&
        !e._repeat &&
        ((_e = e._yEase), (e._yEase = e._ease), (e._ease = _e)),
      (e._from = !ht && !!c.runBackwards),
      !ht || (tt && !c.stagger))
    ) {
      if (
        ((Ft = ut[0] ? _getCache(ut[0]).harness : 0),
        (Mt = Ft && c[Ft.prop]),
        (dt = _copyExcluding(c, _reservedProps)),
        ot &&
          (ot._zTime < 0 && ot.progress(1),
          a < 0 && $ && _ && !st
            ? ot.render(-1, !0)
            : ot.revert($ && at ? _revertConfigNoKill : _startAtRevertConfig),
          (ot._lazy = 0)),
        g)
      ) {
        if (
          (_removeFromParent(
            (e._startAt = Tween.set(
              ut,
              _setDefaults(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: it,
                  immediateRender: !0,
                  lazy: !ot && _isNotFalse(b),
                  startAt: null,
                  delay: 0,
                  onUpdate:
                    j &&
                    function () {
                      return _callback(e, "onUpdate")
                    },
                  stagger: 0,
                },
                g
              )
            ))
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          a < 0 &&
            (_reverting$1 || (!_ && !st)) &&
            e._startAt.revert(_revertConfigNoKill),
          _ && at && a <= 0 && o <= 0)
        ) {
          a && (e._zTime = a)
          return
        }
      } else if ($ && at && !ot) {
        if (
          (a && (_ = !1),
          (vt = _setDefaults(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: _ && !ot && _isNotFalse(b),
              immediateRender: _,
              stagger: 0,
              parent: it,
            },
            dt
          )),
          Mt && (vt[Ft.prop] = Mt),
          _removeFromParent((e._startAt = Tween.set(ut, vt))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          a < 0 &&
            (_reverting$1
              ? e._startAt.revert(_revertConfigNoKill)
              : e._startAt.render(-1, !0)),
          (e._zTime = a),
          !_)
        )
          s(e._startAt, _tinyNum, _tinyNum)
        else if (!a) return
      }
      for (
        e._pt = e._ptCache = 0,
          b = (at && _isNotFalse(b)) || (b && !at),
          pt = 0;
        pt < ut.length;
        pt++
      ) {
        if (
          ((yt = ut[pt]),
          (Rt = yt._gsap || _harness(ut)[pt]._gsap),
          (e._ptLookup[pt] = Nt = {}),
          _lazyLookup[Rt.id] && _lazyTweens.length && _lazyRender(),
          (Dt = ct === ut ? pt : ct.indexOf(yt)),
          Ft &&
            (kt = new Ft()).init(yt, Mt || dt, e, Dt, ct) !== !1 &&
            ((e._pt = _t =
              new PropTween(
                e._pt,
                yt,
                kt.name,
                0,
                1,
                kt.render,
                kt,
                0,
                kt.priority
              )),
            kt._props.forEach(function (gt) {
              Nt[gt] = _t
            }),
            kt.priority && (Et = 1)),
          !Ft || Mt)
        )
          for (vt in dt)
            _plugins[vt] && (kt = _checkPlugin(vt, dt, e, Dt, yt, ct))
              ? kt.priority && (Et = 1)
              : (Nt[vt] = _t =
                  _addPropTween.call(
                    e,
                    yt,
                    vt,
                    "get",
                    dt[vt],
                    Dt,
                    ct,
                    0,
                    c.stringFilter
                  ))
        e._op && e._op[pt] && e.kill(yt, e._op[pt]),
          lt &&
            e._pt &&
            ((_overwritingTween = e),
            _globalTimeline.killTweensOf(yt, Nt, e.globalTime(a)),
            (wt = !e.parent),
            (_overwritingTween = 0)),
          e._pt && b && (_lazyLookup[Rt.id] = 1)
      }
      Et && _sortPropTweensByPriority(e), e._onInit && e._onInit(e)
    }
    ;(e._onUpdate = j),
      (e._initted = (!e._op || e._pt) && !wt),
      tt && a <= 0 && ht.render(_bigNum$1, !0, !0)
  },
  _updatePropTweens = function (e, a, o, c, d, g, _, b) {
    var j = ((e._pt && e._ptCache) || (e._ptCache = {}))[a],
      $,
      _e,
      tt,
      st
    if (!j)
      for (
        j = e._ptCache[a] = [], tt = e._ptLookup, st = e._targets.length;
        st--;

      ) {
        if ((($ = tt[st][a]), $ && $.d && $.d._pt))
          for ($ = $.d._pt; $ && $.p !== a && $.fp !== a; ) $ = $._next
        if (!$)
          return (
            (_forceAllPropTweens = 1),
            (e.vars[a] = "+=0"),
            _initTween(e, _),
            (_forceAllPropTweens = 0),
            b ? _warn(a + " not eligible for reset") : 1
          )
        j.push($)
      }
    for (st = j.length; st--; )
      (_e = j[st]),
        ($ = _e._pt || _e),
        ($.s = (c || c === 0) && !d ? c : $.s + (c || 0) + g * $.c),
        ($.c = o - $.s),
        _e.e && (_e.e = _round(o) + getUnit(_e.e)),
        _e.b && (_e.b = $.s + getUnit(_e.b))
  },
  _addAliasesToVars = function (e, a) {
    var o = e[0] ? _getCache(e[0]).harness : 0,
      c = o && o.aliases,
      d,
      g,
      _,
      b
    if (!c) return a
    d = _merge({}, a)
    for (g in c)
      if (g in d) for (b = c[g].split(","), _ = b.length; _--; ) d[b[_]] = d[g]
    return d
  },
  _parseKeyframe = function (e, a, o, c) {
    var d = a.ease || c || "power1.inOut",
      g,
      _
    if (_isArray(a))
      (_ = o[e] || (o[e] = [])),
        a.forEach(function (b, j) {
          return _.push({ t: (j / (a.length - 1)) * 100, v: b, e: d })
        })
    else
      for (g in a)
        (_ = o[g] || (o[g] = [])),
          g === "ease" || _.push({ t: parseFloat(e), v: a[g], e: d })
  },
  _parseFuncOrString = function (e, a, o, c, d) {
    return _isFunction(e)
      ? e.call(a, o, c, d)
      : _isString(e) && ~e.indexOf("random(")
      ? _replaceRandom(e)
      : e
  },
  _staggerTweenProps =
    _callbackNames +
    "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
  _staggerPropsToSkip = {}
_forEachName(
  _staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger",
  function (s) {
    return (_staggerPropsToSkip[s] = 1)
  }
)
var Tween = (function (s) {
  _inheritsLoose$1(e, s)
  function e(o, c, d, g) {
    var _
    typeof c == "number" && ((d.duration = c), (c = d), (d = null)),
      (_ = s.call(this, g ? c : _inheritDefaults(c)) || this)
    var b = _.vars,
      j = b.duration,
      $ = b.delay,
      _e = b.immediateRender,
      tt = b.stagger,
      st = b.overwrite,
      at = b.keyframes,
      ot = b.defaults,
      ut = b.scrollTrigger,
      it = b.yoyoEase,
      ct = c.parent || _globalTimeline,
      lt = (_isArray(o) || _isTypedArray(o) ? _isNumber(o[0]) : "length" in c)
        ? [o]
        : toArray(o),
      ht,
      dt,
      pt,
      vt,
      _t,
      yt,
      Et,
      Rt
    if (
      ((_._targets = lt.length
        ? _harness(lt)
        : _warn(
            "GSAP target " + o + " not found. https://gsap.com",
            !_config.nullTargetWarn
          ) || []),
      (_._ptLookup = []),
      (_._overwrite = st),
      at || tt || _isFuncOrString(j) || _isFuncOrString($))
    ) {
      if (
        ((c = _.vars),
        (ht = _.timeline =
          new Timeline({
            data: "nested",
            defaults: ot || {},
            targets: ct && ct.data === "nested" ? ct.vars.targets : lt,
          })),
        ht.kill(),
        (ht.parent = ht._dp = _assertThisInitialized(_)),
        (ht._start = 0),
        tt || _isFuncOrString(j) || _isFuncOrString($))
      ) {
        if (((vt = lt.length), (Et = tt && distribute(tt)), _isObject(tt)))
          for (_t in tt)
            ~_staggerTweenProps.indexOf(_t) &&
              (Rt || (Rt = {}), (Rt[_t] = tt[_t]))
        for (dt = 0; dt < vt; dt++)
          (pt = _copyExcluding(c, _staggerPropsToSkip)),
            (pt.stagger = 0),
            it && (pt.yoyoEase = it),
            Rt && _merge(pt, Rt),
            (yt = lt[dt]),
            (pt.duration = +_parseFuncOrString(
              j,
              _assertThisInitialized(_),
              dt,
              yt,
              lt
            )),
            (pt.delay =
              (+_parseFuncOrString($, _assertThisInitialized(_), dt, yt, lt) ||
                0) - _._delay),
            !tt &&
              vt === 1 &&
              pt.delay &&
              ((_._delay = $ = pt.delay), (_._start += $), (pt.delay = 0)),
            ht.to(yt, pt, Et ? Et(dt, yt, lt) : 0),
            (ht._ease = _easeMap.none)
        ht.duration() ? (j = $ = 0) : (_.timeline = 0)
      } else if (at) {
        _inheritDefaults(_setDefaults(ht.vars.defaults, { ease: "none" })),
          (ht._ease = _parseEase(at.ease || c.ease || "none"))
        var Ft = 0,
          kt,
          Nt,
          Dt
        if (_isArray(at))
          at.forEach(function (Mt) {
            return ht.to(lt, Mt, ">")
          }),
            ht.duration()
        else {
          pt = {}
          for (_t in at)
            _t === "ease" ||
              _t === "easeEach" ||
              _parseKeyframe(_t, at[_t], pt, at.easeEach)
          for (_t in pt)
            for (
              kt = pt[_t].sort(function (Mt, wt) {
                return Mt.t - wt.t
              }),
                Ft = 0,
                dt = 0;
              dt < kt.length;
              dt++
            )
              (Nt = kt[dt]),
                (Dt = {
                  ease: Nt.e,
                  duration: ((Nt.t - (dt ? kt[dt - 1].t : 0)) / 100) * j,
                }),
                (Dt[_t] = Nt.v),
                ht.to(lt, Dt, Ft),
                (Ft += Dt.duration)
          ht.duration() < j && ht.to({}, { duration: j - ht.duration() })
        }
      }
      j || _.duration((j = ht.duration()))
    } else _.timeline = 0
    return (
      st === !0 &&
        !_suppressOverwrites &&
        ((_overwritingTween = _assertThisInitialized(_)),
        _globalTimeline.killTweensOf(lt),
        (_overwritingTween = 0)),
      _addToTimeline(ct, _assertThisInitialized(_), d),
      c.reversed && _.reverse(),
      c.paused && _.paused(!0),
      (_e ||
        (!j &&
          !at &&
          _._start === _roundPrecise(ct._time) &&
          _isNotFalse(_e) &&
          _hasNoPausedAncestors(_assertThisInitialized(_)) &&
          ct.data !== "nested")) &&
        ((_._tTime = -_tinyNum), _.render(Math.max(0, -$) || 0)),
      ut && _scrollTrigger(_assertThisInitialized(_), ut),
      _
    )
  }
  var a = e.prototype
  return (
    (a.render = function (c, d, g) {
      var _ = this._time,
        b = this._tDur,
        j = this._dur,
        $ = c < 0,
        _e = c > b - _tinyNum && !$ ? b : c < _tinyNum ? 0 : c,
        tt,
        st,
        at,
        ot,
        ut,
        it,
        ct,
        lt,
        ht
      if (!j) _renderZeroDurationTween(this, c, d, g)
      else if (
        _e !== this._tTime ||
        !c ||
        g ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== $)
      ) {
        if (((tt = _e), (lt = this.timeline), this._repeat)) {
          if (((ot = j + this._rDelay), this._repeat < -1 && $))
            return this.totalTime(ot * 100 + c, d, g)
          if (
            ((tt = _roundPrecise(_e % ot)),
            _e === b
              ? ((at = this._repeat), (tt = j))
              : ((at = ~~(_e / ot)),
                at && at === _roundPrecise(_e / ot) && ((tt = j), at--),
                tt > j && (tt = j)),
            (it = this._yoyo && at & 1),
            it && ((ht = this._yEase), (tt = j - tt)),
            (ut = _animationCycle(this._tTime, ot)),
            tt === _ && !g && this._initted && at === ut)
          )
            return (this._tTime = _e), this
          at !== ut &&
            (lt && this._yEase && _propagateYoyoEase(lt, it),
            this.vars.repeatRefresh &&
              !it &&
              !this._lock &&
              this._time !== ot &&
              this._initted &&
              ((this._lock = g = 1),
              (this.render(_roundPrecise(ot * at), !0).invalidate()._lock = 0)))
        }
        if (!this._initted) {
          if (_attemptInitTween(this, $ ? c : tt, g, d, _e))
            return (this._tTime = 0), this
          if (_ !== this._time && !(g && this.vars.repeatRefresh && at !== ut))
            return this
          if (j !== this._dur) return this.render(c, d, g)
        }
        if (
          ((this._tTime = _e),
          (this._time = tt),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = ct = (ht || this._ease)(tt / j)),
          this._from && (this.ratio = ct = 1 - ct),
          tt &&
            !_ &&
            !d &&
            !at &&
            (_callback(this, "onStart"), this._tTime !== _e))
        )
          return this
        for (st = this._pt; st; ) st.r(ct, st.d), (st = st._next)
        ;(lt &&
          lt.render(c < 0 ? c : lt._dur * lt._ease(tt / this._dur), d, g)) ||
          (this._startAt && (this._zTime = c)),
          this._onUpdate &&
            !d &&
            ($ && _rewindStartAt(this, c, d, g), _callback(this, "onUpdate")),
          this._repeat &&
            at !== ut &&
            this.vars.onRepeat &&
            !d &&
            this.parent &&
            _callback(this, "onRepeat"),
          (_e === this._tDur || !_e) &&
            this._tTime === _e &&
            ($ && !this._onUpdate && _rewindStartAt(this, c, !0, !0),
            (c || !j) &&
              ((_e === this._tDur && this._ts > 0) || (!_e && this._ts < 0)) &&
              _removeFromParent(this, 1),
            !d &&
              !($ && !_) &&
              (_e || _ || it) &&
              (_callback(
                this,
                _e === b ? "onComplete" : "onReverseComplete",
                !0
              ),
              this._prom && !(_e < b && this.timeScale() > 0) && this._prom()))
      }
      return this
    }),
    (a.targets = function () {
      return this._targets
    }),
    (a.invalidate = function (c) {
      return (
        (!c || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(c),
        s.prototype.invalidate.call(this, c)
      )
    }),
    (a.resetTo = function (c, d, g, _, b) {
      _tickerActive || _ticker.wake(), this._ts || this.play()
      var j = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        $
      return (
        this._initted || _initTween(this, j),
        ($ = this._ease(j / this._dur)),
        _updatePropTweens(this, c, d, g, _, $, j, b)
          ? this.resetTo(c, d, g, _, 1)
          : (_alignPlayhead(this, 0),
            this.parent ||
              _addLinkedListItem(
                this._dp,
                this,
                "_first",
                "_last",
                this._dp._sort ? "_start" : 0
              ),
            this.render(0))
      )
    }),
    (a.kill = function (c, d) {
      if ((d === void 0 && (d = "all"), !c && (!d || d === "all")))
        return (
          (this._lazy = this._pt = 0), this.parent ? _interrupt(this) : this
        )
      if (this.timeline) {
        var g = this.timeline.totalDuration()
        return (
          this.timeline.killTweensOf(
            c,
            d,
            _overwritingTween && _overwritingTween.vars.overwrite !== !0
          )._first || _interrupt(this),
          this.parent &&
            g !== this.timeline.totalDuration() &&
            _setDuration(this, (this._dur * this.timeline._tDur) / g, 0, 1),
          this
        )
      }
      var _ = this._targets,
        b = c ? toArray(c) : _,
        j = this._ptLookup,
        $ = this._pt,
        _e,
        tt,
        st,
        at,
        ot,
        ut,
        it
      if ((!d || d === "all") && _arraysMatch(_, b))
        return d === "all" && (this._pt = 0), _interrupt(this)
      for (
        _e = this._op = this._op || [],
          d !== "all" &&
            (_isString(d) &&
              ((ot = {}),
              _forEachName(d, function (ct) {
                return (ot[ct] = 1)
              }),
              (d = ot)),
            (d = _addAliasesToVars(_, d))),
          it = _.length;
        it--;

      )
        if (~b.indexOf(_[it])) {
          ;(tt = j[it]),
            d === "all"
              ? ((_e[it] = d), (at = tt), (st = {}))
              : ((st = _e[it] = _e[it] || {}), (at = d))
          for (ot in at)
            (ut = tt && tt[ot]),
              ut &&
                ((!("kill" in ut.d) || ut.d.kill(ot) === !0) &&
                  _removeLinkedListItem(this, ut, "_pt"),
                delete tt[ot]),
              st !== "all" && (st[ot] = 1)
        }
      return this._initted && !this._pt && $ && _interrupt(this), this
    }),
    (e.to = function (c, d) {
      return new e(c, d, arguments[2])
    }),
    (e.from = function (c, d) {
      return _createTweenType(1, arguments)
    }),
    (e.delayedCall = function (c, d, g, _) {
      return new e(d, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: c,
        onComplete: d,
        onReverseComplete: d,
        onCompleteParams: g,
        onReverseCompleteParams: g,
        callbackScope: _,
      })
    }),
    (e.fromTo = function (c, d, g) {
      return _createTweenType(2, arguments)
    }),
    (e.set = function (c, d) {
      return (d.duration = 0), d.repeatDelay || (d.repeat = 0), new e(c, d)
    }),
    (e.killTweensOf = function (c, d, g) {
      return _globalTimeline.killTweensOf(c, d, g)
    }),
    e
  )
})(Animation$1)
_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0,
})
_forEachName("staggerTo,staggerFrom,staggerFromTo", function (s) {
  Tween[s] = function () {
    var e = new Timeline(),
      a = _slice.call(arguments, 0)
    return a.splice(s === "staggerFromTo" ? 5 : 4, 0, 0), e[s].apply(e, a)
  }
})
var _setterPlain = function (e, a, o) {
    return (e[a] = o)
  },
  _setterFunc = function (e, a, o) {
    return e[a](o)
  },
  _setterFuncWithParam = function (e, a, o, c) {
    return e[a](c.fp, o)
  },
  _setterAttribute = function (e, a, o) {
    return e.setAttribute(a, o)
  },
  _getSetter = function (e, a) {
    return _isFunction(e[a])
      ? _setterFunc
      : _isUndefined(e[a]) && e.setAttribute
      ? _setterAttribute
      : _setterPlain
  },
  _renderPlain = function (e, a) {
    return a.set(a.t, a.p, Math.round((a.s + a.c * e) * 1e6) / 1e6, a)
  },
  _renderBoolean = function (e, a) {
    return a.set(a.t, a.p, !!(a.s + a.c * e), a)
  },
  _renderComplexString = function (e, a) {
    var o = a._pt,
      c = ""
    if (!e && a.b) c = a.b
    else if (e === 1 && a.e) c = a.e
    else {
      for (; o; )
        (c =
          o.p +
          (o.m ? o.m(o.s + o.c * e) : Math.round((o.s + o.c * e) * 1e4) / 1e4) +
          c),
          (o = o._next)
      c += a.c
    }
    a.set(a.t, a.p, c, a)
  },
  _renderPropTweens = function (e, a) {
    for (var o = a._pt; o; ) o.r(e, o.d), (o = o._next)
  },
  _addPluginModifier = function (e, a, o, c) {
    for (var d = this._pt, g; d; )
      (g = d._next), d.p === c && d.modifier(e, a, o), (d = g)
  },
  _killPropTweensOf = function (e) {
    for (var a = this._pt, o, c; a; )
      (c = a._next),
        (a.p === e && !a.op) || a.op === e
          ? _removeLinkedListItem(this, a, "_pt")
          : a.dep || (o = 1),
        (a = c)
    return !o
  },
  _setterWithModifier = function (e, a, o, c) {
    c.mSet(e, a, c.m.call(c.tween, o, c.mt), c)
  },
  _sortPropTweensByPriority = function (e) {
    for (var a = e._pt, o, c, d, g; a; ) {
      for (o = a._next, c = d; c && c.pr > a.pr; ) c = c._next
      ;(a._prev = c ? c._prev : g) ? (a._prev._next = a) : (d = a),
        (a._next = c) ? (c._prev = a) : (g = a),
        (a = o)
    }
    e._pt = d
  },
  PropTween = (function () {
    function s(a, o, c, d, g, _, b, j, $) {
      ;(this.t = o),
        (this.s = d),
        (this.c = g),
        (this.p = c),
        (this.r = _ || _renderPlain),
        (this.d = b || this),
        (this.set = j || _setterPlain),
        (this.pr = $ || 0),
        (this._next = a),
        a && (a._prev = this)
    }
    var e = s.prototype
    return (
      (e.modifier = function (o, c, d) {
        ;(this.mSet = this.mSet || this.set),
          (this.set = _setterWithModifier),
          (this.m = o),
          (this.mt = d),
          (this.tween = c)
      }),
      s
    )
  })()
_forEachName(
  _callbackNames +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (s) {
    return (_reservedProps[s] = 1)
  }
)
_globals.TweenMax = _globals.TweenLite = Tween
_globals.TimelineLite = _globals.TimelineMax = Timeline
_globalTimeline = new Timeline({
  sortChildren: !1,
  defaults: _defaults,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
})
_config.stringFilter = _colorStringFilter
var _media = [],
  _listeners = {},
  _emptyArray = [],
  _lastMediaTime = 0,
  _contextID = 0,
  _dispatch = function (e) {
    return (_listeners[e] || _emptyArray).map(function (a) {
      return a()
    })
  },
  _onMediaChange = function () {
    var e = Date.now(),
      a = []
    e - _lastMediaTime > 2 &&
      (_dispatch("matchMediaInit"),
      _media.forEach(function (o) {
        var c = o.queries,
          d = o.conditions,
          g,
          _,
          b,
          j
        for (_ in c)
          (g = _win$1.matchMedia(c[_]).matches),
            g && (b = 1),
            g !== d[_] && ((d[_] = g), (j = 1))
        j && (o.revert(), b && a.push(o))
      }),
      _dispatch("matchMediaRevert"),
      a.forEach(function (o) {
        return o.onMatch(o, function (c) {
          return o.add(null, c)
        })
      }),
      (_lastMediaTime = e),
      _dispatch("matchMedia"))
  },
  Context = (function () {
    function s(a, o) {
      ;(this.selector = o && selector(o)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = _contextID++),
        a && this.add(a)
    }
    var e = s.prototype
    return (
      (e.add = function (o, c, d) {
        _isFunction(o) && ((d = c), (c = o), (o = _isFunction))
        var g = this,
          _ = function () {
            var j = _context,
              $ = g.selector,
              _e
            return (
              j && j !== g && j.data.push(g),
              d && (g.selector = selector(d)),
              (_context = g),
              (_e = c.apply(g, arguments)),
              _isFunction(_e) && g._r.push(_e),
              (_context = j),
              (g.selector = $),
              (g.isReverted = !1),
              _e
            )
          }
        return (
          (g.last = _),
          o === _isFunction
            ? _(g, function (b) {
                return g.add(null, b)
              })
            : o
            ? (g[o] = _)
            : _
        )
      }),
      (e.ignore = function (o) {
        var c = _context
        ;(_context = null), o(this), (_context = c)
      }),
      (e.getTweens = function () {
        var o = []
        return (
          this.data.forEach(function (c) {
            return c instanceof s
              ? o.push.apply(o, c.getTweens())
              : c instanceof Tween &&
                  !(c.parent && c.parent.data === "nested") &&
                  o.push(c)
          }),
          o
        )
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0
      }),
      (e.kill = function (o, c) {
        var d = this
        if (
          (o
            ? (function () {
                for (var _ = d.getTweens(), b = d.data.length, j; b--; )
                  (j = d.data[b]),
                    j.data === "isFlip" &&
                      (j.revert(),
                      j.getChildren(!0, !0, !1).forEach(function ($) {
                        return _.splice(_.indexOf($), 1)
                      }))
                for (
                  _.map(function ($) {
                    return {
                      g:
                        $._dur ||
                        $._delay ||
                        ($._sat && !$._sat.vars.immediateRender)
                          ? $.globalTime(0)
                          : -1 / 0,
                      t: $,
                    }
                  })
                    .sort(function ($, _e) {
                      return _e.g - $.g || -1 / 0
                    })
                    .forEach(function ($) {
                      return $.t.revert(o)
                    }),
                    b = d.data.length;
                  b--;

                )
                  (j = d.data[b]),
                    j instanceof Timeline
                      ? j.data !== "nested" &&
                        (j.scrollTrigger && j.scrollTrigger.revert(), j.kill())
                      : !(j instanceof Tween) && j.revert && j.revert(o)
                d._r.forEach(function ($) {
                  return $(o, d)
                }),
                  (d.isReverted = !0)
              })()
            : this.data.forEach(function (_) {
                return _.kill && _.kill()
              }),
          this.clear(),
          c)
        )
          for (var g = _media.length; g--; )
            _media[g].id === this.id && _media.splice(g, 1)
      }),
      (e.revert = function (o) {
        this.kill(o || {})
      }),
      s
    )
  })(),
  MatchMedia = (function () {
    function s(a) {
      ;(this.contexts = []),
        (this.scope = a),
        _context && _context.data.push(this)
    }
    var e = s.prototype
    return (
      (e.add = function (o, c, d) {
        _isObject(o) || (o = { matches: o })
        var g = new Context(0, d || this.scope),
          _ = (g.conditions = {}),
          b,
          j,
          $
        _context && !g.selector && (g.selector = _context.selector),
          this.contexts.push(g),
          (c = g.add("onMatch", c)),
          (g.queries = o)
        for (j in o)
          j === "all"
            ? ($ = 1)
            : ((b = _win$1.matchMedia(o[j])),
              b &&
                (_media.indexOf(g) < 0 && _media.push(g),
                (_[j] = b.matches) && ($ = 1),
                b.addListener
                  ? b.addListener(_onMediaChange)
                  : b.addEventListener("change", _onMediaChange)))
        return (
          $ &&
            c(g, function (_e) {
              return g.add(null, _e)
            }),
          this
        )
      }),
      (e.revert = function (o) {
        this.kill(o || {})
      }),
      (e.kill = function (o) {
        this.contexts.forEach(function (c) {
          return c.kill(o, !0)
        })
      }),
      s
    )
  })(),
  _gsap = {
    registerPlugin: function () {
      for (var e = arguments.length, a = new Array(e), o = 0; o < e; o++)
        a[o] = arguments[o]
      a.forEach(function (c) {
        return _createPlugin(c)
      })
    },
    timeline: function (e) {
      return new Timeline(e)
    },
    getTweensOf: function (e, a) {
      return _globalTimeline.getTweensOf(e, a)
    },
    getProperty: function (e, a, o, c) {
      _isString(e) && (e = toArray(e)[0])
      var d = _getCache(e || {}).get,
        g = o ? _passThrough : _numericIfPossible
      return (
        o === "native" && (o = ""),
        e &&
          (a
            ? g(((_plugins[a] && _plugins[a].get) || d)(e, a, o, c))
            : function (_, b, j) {
                return g(((_plugins[_] && _plugins[_].get) || d)(e, _, b, j))
              })
      )
    },
    quickSetter: function (e, a, o) {
      if (((e = toArray(e)), e.length > 1)) {
        var c = e.map(function ($) {
            return gsap.quickSetter($, a, o)
          }),
          d = c.length
        return function ($) {
          for (var _e = d; _e--; ) c[_e]($)
        }
      }
      e = e[0] || {}
      var g = _plugins[a],
        _ = _getCache(e),
        b = (_.harness && (_.harness.aliases || {})[a]) || a,
        j = g
          ? function ($) {
              var _e = new g()
              ;(_quickTween._pt = 0),
                _e.init(e, o ? $ + o : $, _quickTween, 0, [e]),
                _e.render(1, _e),
                _quickTween._pt && _renderPropTweens(1, _quickTween)
            }
          : _.set(e, b)
      return g
        ? j
        : function ($) {
            return j(e, b, o ? $ + o : $, _, 1)
          }
    },
    quickTo: function (e, a, o) {
      var c,
        d = gsap.to(
          e,
          _merge(((c = {}), (c[a] = "+=0.1"), (c.paused = !0), c), o || {})
        ),
        g = function (b, j, $) {
          return d.resetTo(a, b, j, $)
        }
      return (g.tween = d), g
    },
    isTweening: function (e) {
      return _globalTimeline.getTweensOf(e, !0).length > 0
    },
    defaults: function (e) {
      return (
        e && e.ease && (e.ease = _parseEase(e.ease, _defaults.ease)),
        _mergeDeep(_defaults, e || {})
      )
    },
    config: function (e) {
      return _mergeDeep(_config, e || {})
    },
    registerEffect: function (e) {
      var a = e.name,
        o = e.effect,
        c = e.plugins,
        d = e.defaults,
        g = e.extendTimeline
      ;(c || "").split(",").forEach(function (_) {
        return (
          _ &&
          !_plugins[_] &&
          !_globals[_] &&
          _warn(a + " effect requires " + _ + " plugin.")
        )
      }),
        (_effects[a] = function (_, b, j) {
          return o(toArray(_), _setDefaults(b || {}, d), j)
        }),
        g &&
          (Timeline.prototype[a] = function (_, b, j) {
            return this.add(
              _effects[a](_, _isObject(b) ? b : (j = b) && {}, this),
              j
            )
          })
    },
    registerEase: function (e, a) {
      _easeMap[e] = _parseEase(a)
    },
    parseEase: function (e, a) {
      return arguments.length ? _parseEase(e, a) : _easeMap
    },
    getById: function (e) {
      return _globalTimeline.getById(e)
    },
    exportRoot: function (e, a) {
      e === void 0 && (e = {})
      var o = new Timeline(e),
        c,
        d
      for (
        o.smoothChildTiming = _isNotFalse(e.smoothChildTiming),
          _globalTimeline.remove(o),
          o._dp = 0,
          o._time = o._tTime = _globalTimeline._time,
          c = _globalTimeline._first;
        c;

      )
        (d = c._next),
          (a ||
            !(
              !c._dur &&
              c instanceof Tween &&
              c.vars.onComplete === c._targets[0]
            )) &&
            _addToTimeline(o, c, c._start - c._delay),
          (c = d)
      return _addToTimeline(_globalTimeline, o, 0), o
    },
    context: function (e, a) {
      return e ? new Context(e, a) : _context
    },
    matchMedia: function (e) {
      return new MatchMedia(e)
    },
    matchMediaRefresh: function () {
      return (
        _media.forEach(function (e) {
          var a = e.conditions,
            o,
            c
          for (c in a) a[c] && ((a[c] = !1), (o = 1))
          o && e.revert()
        }) || _onMediaChange()
      )
    },
    addEventListener: function (e, a) {
      var o = _listeners[e] || (_listeners[e] = [])
      ~o.indexOf(a) || o.push(a)
    },
    removeEventListener: function (e, a) {
      var o = _listeners[e],
        c = o && o.indexOf(a)
      c >= 0 && o.splice(c, 1)
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle,
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation: Animation$1,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function () {
        return _reverting$1
      },
      context: function (e) {
        return (
          e && _context && (_context.data.push(e), (e._ctx = _context)),
          _context
        )
      },
      suppressOverwrites: function (e) {
        return (_suppressOverwrites = e)
      },
    },
  }
_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (s) {
  return (_gsap[s] = Tween[s])
})
_ticker.add(Timeline.updateRoot)
_quickTween = _gsap.to({}, { duration: 0 })
var _getPluginPropTween = function (e, a) {
    for (var o = e._pt; o && o.p !== a && o.op !== a && o.fp !== a; )
      o = o._next
    return o
  },
  _addModifiers = function (e, a) {
    var o = e._targets,
      c,
      d,
      g
    for (c in a)
      for (d = o.length; d--; )
        (g = e._ptLookup[d][c]),
          g &&
            (g = g.d) &&
            (g._pt && (g = _getPluginPropTween(g, c)),
            g && g.modifier && g.modifier(a[c], e, o[d], c))
  },
  _buildModifierPlugin = function (e, a) {
    return {
      name: e,
      rawVars: 1,
      init: function (c, d, g) {
        g._onInit = function (_) {
          var b, j
          if (
            (_isString(d) &&
              ((b = {}),
              _forEachName(d, function ($) {
                return (b[$] = 1)
              }),
              (d = b)),
            a)
          ) {
            b = {}
            for (j in d) b[j] = a(d[j])
            d = b
          }
          _addModifiers(_, d)
        }
      },
    }
  },
  gsap =
    _gsap.registerPlugin(
      {
        name: "attr",
        init: function (e, a, o, c, d) {
          var g, _, b
          this.tween = o
          for (g in a)
            (b = e.getAttribute(g) || ""),
              (_ = this.add(
                e,
                "setAttribute",
                (b || 0) + "",
                a[g],
                c,
                d,
                0,
                0,
                g
              )),
              (_.op = g),
              (_.b = b),
              this._props.push(g)
        },
        render: function (e, a) {
          for (var o = a._pt; o; )
            _reverting$1 ? o.set(o.t, o.p, o.b, o) : o.r(e, o.d), (o = o._next)
        },
      },
      {
        name: "endArray",
        init: function (e, a) {
          for (var o = a.length; o--; )
            this.add(e, o, e[o] || 0, a[o], 0, 0, 0, 0, 0, 1)
        },
      },
      _buildModifierPlugin("roundProps", _roundModifier),
      _buildModifierPlugin("modifiers"),
      _buildModifierPlugin("snap", snap)
    ) || _gsap
Tween.version = Timeline.version = gsap.version = "3.12.5"
_coreReady = 1
_windowExists$1() && _wake()
_easeMap.Power0
_easeMap.Power1
_easeMap.Power2
_easeMap.Power3
_easeMap.Power4
_easeMap.Linear
_easeMap.Quad
_easeMap.Cubic
_easeMap.Quart
_easeMap.Quint
_easeMap.Strong
_easeMap.Elastic
_easeMap.Back
_easeMap.SteppedEase
_easeMap.Bounce
_easeMap.Sine
_easeMap.Expo
_easeMap.Circ
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var _win,
  _doc,
  _docElement,
  _pluginInitted,
  _tempDiv,
  _recentSetterPlugin,
  _reverting,
  _windowExists = function () {
    return typeof window < "u"
  },
  _transformProps = {},
  _RAD2DEG = 180 / Math.PI,
  _DEG2RAD = Math.PI / 180,
  _atan2 = Math.atan2,
  _bigNum = 1e8,
  _capsExp = /([A-Z])/g,
  _horizontalExp = /(left|right|width|margin|padding|x)/i,
  _complexExp = /[\s,\(]\S/,
  _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  _renderCSSProp = function (e, a) {
    return a.set(a.t, a.p, Math.round((a.s + a.c * e) * 1e4) / 1e4 + a.u, a)
  },
  _renderPropWithEnd = function (e, a) {
    return a.set(
      a.t,
      a.p,
      e === 1 ? a.e : Math.round((a.s + a.c * e) * 1e4) / 1e4 + a.u,
      a
    )
  },
  _renderCSSPropWithBeginning = function (e, a) {
    return a.set(
      a.t,
      a.p,
      e ? Math.round((a.s + a.c * e) * 1e4) / 1e4 + a.u : a.b,
      a
    )
  },
  _renderRoundedCSSProp = function (e, a) {
    var o = a.s + a.c * e
    a.set(a.t, a.p, ~~(o + (o < 0 ? -0.5 : 0.5)) + a.u, a)
  },
  _renderNonTweeningValue = function (e, a) {
    return a.set(a.t, a.p, e ? a.e : a.b, a)
  },
  _renderNonTweeningValueOnlyAtEnd = function (e, a) {
    return a.set(a.t, a.p, e !== 1 ? a.b : a.e, a)
  },
  _setterCSSStyle = function (e, a, o) {
    return (e.style[a] = o)
  },
  _setterCSSProp = function (e, a, o) {
    return e.style.setProperty(a, o)
  },
  _setterTransform = function (e, a, o) {
    return (e._gsap[a] = o)
  },
  _setterScale = function (e, a, o) {
    return (e._gsap.scaleX = e._gsap.scaleY = o)
  },
  _setterScaleWithRender = function (e, a, o, c, d) {
    var g = e._gsap
    ;(g.scaleX = g.scaleY = o), g.renderTransform(d, g)
  },
  _setterTransformWithRender = function (e, a, o, c, d) {
    var g = e._gsap
    ;(g[a] = o), g.renderTransform(d, g)
  },
  _transformProp = "transform",
  _transformOriginProp = _transformProp + "Origin",
  _saveStyle = function s(e, a) {
    var o = this,
      c = this.target,
      d = c.style,
      g = c._gsap
    if (e in _transformProps && d) {
      if (((this.tfm = this.tfm || {}), e !== "transform"))
        (e = _propertyAliases[e] || e),
          ~e.indexOf(",")
            ? e.split(",").forEach(function (_) {
                return (o.tfm[_] = _get(c, _))
              })
            : (this.tfm[e] = g.x ? g[e] : _get(c, e)),
          e === _transformOriginProp && (this.tfm.zOrigin = g.zOrigin)
      else
        return _propertyAliases.transform.split(",").forEach(function (_) {
          return s.call(o, _, a)
        })
      if (this.props.indexOf(_transformProp) >= 0) return
      g.svg &&
        ((this.svgo = c.getAttribute("data-svg-origin")),
        this.props.push(_transformOriginProp, a, "")),
        (e = _transformProp)
    }
    ;(d || a) && this.props.push(e, a, d[e])
  },
  _removeIndependentTransforms = function (e) {
    e.translate &&
      (e.removeProperty("translate"),
      e.removeProperty("scale"),
      e.removeProperty("rotate"))
  },
  _revertStyle = function () {
    var e = this.props,
      a = this.target,
      o = a.style,
      c = a._gsap,
      d,
      g
    for (d = 0; d < e.length; d += 3)
      e[d + 1]
        ? (a[e[d]] = e[d + 2])
        : e[d + 2]
        ? (o[e[d]] = e[d + 2])
        : o.removeProperty(
            e[d].substr(0, 2) === "--"
              ? e[d]
              : e[d].replace(_capsExp, "-$1").toLowerCase()
          )
    if (this.tfm) {
      for (g in this.tfm) c[g] = this.tfm[g]
      c.svg &&
        (c.renderTransform(),
        a.setAttribute("data-svg-origin", this.svgo || "")),
        (d = _reverting()),
        (!d || !d.isStart) &&
          !o[_transformProp] &&
          (_removeIndependentTransforms(o),
          c.zOrigin &&
            o[_transformOriginProp] &&
            ((o[_transformOriginProp] += " " + c.zOrigin + "px"),
            (c.zOrigin = 0),
            c.renderTransform()),
          (c.uncache = 1))
    }
  },
  _getStyleSaver = function (e, a) {
    var o = { target: e, props: [], revert: _revertStyle, save: _saveStyle }
    return (
      e._gsap || gsap.core.getCache(e),
      a &&
        a.split(",").forEach(function (c) {
          return o.save(c)
        }),
      o
    )
  },
  _supports3D,
  _createElement = function (e, a) {
    var o = _doc.createElementNS
      ? _doc.createElementNS(
          (a || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          e
        )
      : _doc.createElement(e)
    return o && o.style ? o : _doc.createElement(e)
  },
  _getComputedProperty = function s(e, a, o) {
    var c = getComputedStyle(e)
    return (
      c[a] ||
      c.getPropertyValue(a.replace(_capsExp, "-$1").toLowerCase()) ||
      c.getPropertyValue(a) ||
      (!o && s(e, _checkPropPrefix(a) || a, 1)) ||
      ""
    )
  },
  _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
  _checkPropPrefix = function (e, a, o) {
    var c = a || _tempDiv,
      d = c.style,
      g = 5
    if (e in d && !o) return e
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      g-- && !(_prefixes[g] + e in d);

    );
    return g < 0 ? null : (g === 3 ? "ms" : g >= 0 ? _prefixes[g] : "") + e
  },
  _initCore = function () {
    _windowExists() &&
      window.document &&
      ((_win = window),
      (_doc = _win.document),
      (_docElement = _doc.documentElement),
      (_tempDiv = _createElement("div") || { style: {} }),
      _createElement("div"),
      (_transformProp = _checkPropPrefix(_transformProp)),
      (_transformOriginProp = _transformProp + "Origin"),
      (_tempDiv.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      (_supports3D = !!_checkPropPrefix("perspective")),
      (_reverting = gsap.core.reverting),
      (_pluginInitted = 1))
  },
  _getBBoxHack = function s(e) {
    var a = _createElement(
        "svg",
        (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) ||
          "http://www.w3.org/2000/svg"
      ),
      o = this.parentNode,
      c = this.nextSibling,
      d = this.style.cssText,
      g
    if (
      (_docElement.appendChild(a),
      a.appendChild(this),
      (this.style.display = "block"),
      e)
    )
      try {
        ;(g = this.getBBox()),
          (this._gsapBBox = this.getBBox),
          (this.getBBox = s)
      } catch {}
    else this._gsapBBox && (g = this._gsapBBox())
    return (
      o && (c ? o.insertBefore(this, c) : o.appendChild(this)),
      _docElement.removeChild(a),
      (this.style.cssText = d),
      g
    )
  },
  _getAttributeFallbacks = function (e, a) {
    for (var o = a.length; o--; )
      if (e.hasAttribute(a[o])) return e.getAttribute(a[o])
  },
  _getBBox = function (e) {
    var a
    try {
      a = e.getBBox()
    } catch {
      a = _getBBoxHack.call(e, !0)
    }
    return (
      (a && (a.width || a.height)) ||
        e.getBBox === _getBBoxHack ||
        (a = _getBBoxHack.call(e, !0)),
      a && !a.width && !a.x && !a.y
        ? {
            x: +_getAttributeFallbacks(e, ["x", "cx", "x1"]) || 0,
            y: +_getAttributeFallbacks(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : a
    )
  },
  _isSVG = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e))
  },
  _removeProperty = function (e, a) {
    if (a) {
      var o = e.style,
        c
      a in _transformProps &&
        a !== _transformOriginProp &&
        (a = _transformProp),
        o.removeProperty
          ? ((c = a.substr(0, 2)),
            (c === "ms" || a.substr(0, 6) === "webkit") && (a = "-" + a),
            o.removeProperty(
              c === "--" ? a : a.replace(_capsExp, "-$1").toLowerCase()
            ))
          : o.removeAttribute(a)
    }
  },
  _addNonTweeningPT = function (e, a, o, c, d, g) {
    var _ = new PropTween(
      e._pt,
      a,
      o,
      0,
      1,
      g ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue
    )
    return (e._pt = _), (_.b = c), (_.e = d), e._props.push(o), _
  },
  _nonConvertibleUnits = { deg: 1, rad: 1, turn: 1 },
  _nonStandardLayouts = { grid: 1, flex: 1 },
  _convertToUnit = function s(e, a, o, c) {
    var d = parseFloat(o) || 0,
      g = (o + "").trim().substr((d + "").length) || "px",
      _ = _tempDiv.style,
      b = _horizontalExp.test(a),
      j = e.tagName.toLowerCase() === "svg",
      $ = (j ? "client" : "offset") + (b ? "Width" : "Height"),
      _e = 100,
      tt = c === "px",
      st = c === "%",
      at,
      ot,
      ut,
      it
    if (c === g || !d || _nonConvertibleUnits[c] || _nonConvertibleUnits[g])
      return d
    if (
      (g !== "px" && !tt && (d = s(e, a, o, "px")),
      (it = e.getCTM && _isSVG(e)),
      (st || g === "%") && (_transformProps[a] || ~a.indexOf("adius")))
    )
      return (
        (at = it ? e.getBBox()[b ? "width" : "height"] : e[$]),
        _round(st ? (d / at) * _e : (d / 100) * at)
      )
    if (
      ((_[b ? "width" : "height"] = _e + (tt ? g : c)),
      (ot =
        ~a.indexOf("adius") || (c === "em" && e.appendChild && !j)
          ? e
          : e.parentNode),
      it && (ot = (e.ownerSVGElement || {}).parentNode),
      (!ot || ot === _doc || !ot.appendChild) && (ot = _doc.body),
      (ut = ot._gsap),
      ut && st && ut.width && b && ut.time === _ticker.time && !ut.uncache)
    )
      return _round((d / ut.width) * _e)
    if (st && (a === "height" || a === "width")) {
      var ct = e.style[a]
      ;(e.style[a] = _e + c),
        (at = e[$]),
        ct ? (e.style[a] = ct) : _removeProperty(e, a)
    } else
      (st || g === "%") &&
        !_nonStandardLayouts[_getComputedProperty(ot, "display")] &&
        (_.position = _getComputedProperty(e, "position")),
        ot === e && (_.position = "static"),
        ot.appendChild(_tempDiv),
        (at = _tempDiv[$]),
        ot.removeChild(_tempDiv),
        (_.position = "absolute")
    return (
      b &&
        st &&
        ((ut = _getCache(ot)), (ut.time = _ticker.time), (ut.width = ot[$])),
      _round(tt ? (at * d) / _e : at && d ? (_e / at) * d : 0)
    )
  },
  _get = function (e, a, o, c) {
    var d
    return (
      _pluginInitted || _initCore(),
      a in _propertyAliases &&
        a !== "transform" &&
        ((a = _propertyAliases[a]), ~a.indexOf(",") && (a = a.split(",")[0])),
      _transformProps[a] && a !== "transform"
        ? ((d = _parseTransform(e, c)),
          (d =
            a !== "transformOrigin"
              ? d[a]
              : d.svg
              ? d.origin
              : _firstTwoOnly(_getComputedProperty(e, _transformOriginProp)) +
                " " +
                d.zOrigin +
                "px"))
        : ((d = e.style[a]),
          (!d || d === "auto" || c || ~(d + "").indexOf("calc(")) &&
            (d =
              (_specialProps[a] && _specialProps[a](e, a, o)) ||
              _getComputedProperty(e, a) ||
              _getProperty(e, a) ||
              (a === "opacity" ? 1 : 0))),
      o && !~(d + "").trim().indexOf(" ") ? _convertToUnit(e, a, d, o) + o : d
    )
  },
  _tweenComplexCSSString = function (e, a, o, c) {
    if (!o || o === "none") {
      var d = _checkPropPrefix(a, e, 1),
        g = d && _getComputedProperty(e, d, 1)
      g && g !== o
        ? ((a = d), (o = g))
        : a === "borderColor" && (o = _getComputedProperty(e, "borderTopColor"))
    }
    var _ = new PropTween(this._pt, e.style, a, 0, 1, _renderComplexString),
      b = 0,
      j = 0,
      $,
      _e,
      tt,
      st,
      at,
      ot,
      ut,
      it,
      ct,
      lt,
      ht,
      dt
    if (
      ((_.b = o),
      (_.e = c),
      (o += ""),
      (c += ""),
      c === "auto" &&
        ((ot = e.style[a]),
        (e.style[a] = c),
        (c = _getComputedProperty(e, a) || c),
        ot ? (e.style[a] = ot) : _removeProperty(e, a)),
      ($ = [o, c]),
      _colorStringFilter($),
      (o = $[0]),
      (c = $[1]),
      (tt = o.match(_numWithUnitExp) || []),
      (dt = c.match(_numWithUnitExp) || []),
      dt.length)
    ) {
      for (; (_e = _numWithUnitExp.exec(c)); )
        (ut = _e[0]),
          (ct = c.substring(b, _e.index)),
          at
            ? (at = (at + 1) % 5)
            : (ct.substr(-5) === "rgba(" || ct.substr(-5) === "hsla(") &&
              (at = 1),
          ut !== (ot = tt[j++] || "") &&
            ((st = parseFloat(ot) || 0),
            (ht = ot.substr((st + "").length)),
            ut.charAt(1) === "=" && (ut = _parseRelative(st, ut) + ht),
            (it = parseFloat(ut)),
            (lt = ut.substr((it + "").length)),
            (b = _numWithUnitExp.lastIndex - lt.length),
            lt ||
              ((lt = lt || _config.units[a] || ht),
              b === c.length && ((c += lt), (_.e += lt))),
            ht !== lt && (st = _convertToUnit(e, a, ot, lt) || 0),
            (_._pt = {
              _next: _._pt,
              p: ct || j === 1 ? ct : ",",
              s: st,
              c: it - st,
              m: (at && at < 4) || a === "zIndex" ? Math.round : 0,
            }))
      _.c = b < c.length ? c.substring(b, c.length) : ""
    } else
      _.r =
        a === "display" && c === "none"
          ? _renderNonTweeningValueOnlyAtEnd
          : _renderNonTweeningValue
    return _relExp.test(c) && (_.e = 0), (this._pt = _), _
  },
  _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%",
  },
  _convertKeywordsToPercentages = function (e) {
    var a = e.split(" "),
      o = a[0],
      c = a[1] || "50%"
    return (
      (o === "top" || o === "bottom" || c === "left" || c === "right") &&
        ((e = o), (o = c), (c = e)),
      (a[0] = _keywordToPercent[o] || o),
      (a[1] = _keywordToPercent[c] || c),
      a.join(" ")
    )
  },
  _renderClearProps = function (e, a) {
    if (a.tween && a.tween._time === a.tween._dur) {
      var o = a.t,
        c = o.style,
        d = a.u,
        g = o._gsap,
        _,
        b,
        j
      if (d === "all" || d === !0) (c.cssText = ""), (b = 1)
      else
        for (d = d.split(","), j = d.length; --j > -1; )
          (_ = d[j]),
            _transformProps[_] &&
              ((b = 1),
              (_ =
                _ === "transformOrigin"
                  ? _transformOriginProp
                  : _transformProp)),
            _removeProperty(o, _)
      b &&
        (_removeProperty(o, _transformProp),
        g &&
          (g.svg && o.removeAttribute("transform"),
          _parseTransform(o, 1),
          (g.uncache = 1),
          _removeIndependentTransforms(c)))
    }
  },
  _specialProps = {
    clearProps: function (e, a, o, c, d) {
      if (d.data !== "isFromStart") {
        var g = (e._pt = new PropTween(e._pt, a, o, 0, 0, _renderClearProps))
        return (g.u = c), (g.pr = -10), (g.tween = d), e._props.push(o), 1
      }
    },
  },
  _identity2DMatrix = [1, 0, 0, 1, 0, 0],
  _rotationalProperties = {},
  _isNullTransform = function (e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
  },
  _getComputedTransformMatrixAsArray = function (e) {
    var a = _getComputedProperty(e, _transformProp)
    return _isNullTransform(a)
      ? _identity2DMatrix
      : a.substr(7).match(_numExp).map(_round)
  },
  _getMatrix = function (e, a) {
    var o = e._gsap || _getCache(e),
      c = e.style,
      d = _getComputedTransformMatrixAsArray(e),
      g,
      _,
      b,
      j
    return o.svg && e.getAttribute("transform")
      ? ((b = e.transform.baseVal.consolidate().matrix),
        (d = [b.a, b.b, b.c, b.d, b.e, b.f]),
        d.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : d)
      : (d === _identity2DMatrix &&
          !e.offsetParent &&
          e !== _docElement &&
          !o.svg &&
          ((b = c.display),
          (c.display = "block"),
          (g = e.parentNode),
          (!g || !e.offsetParent) &&
            ((j = 1), (_ = e.nextElementSibling), _docElement.appendChild(e)),
          (d = _getComputedTransformMatrixAsArray(e)),
          b ? (c.display = b) : _removeProperty(e, "display"),
          j &&
            (_
              ? g.insertBefore(e, _)
              : g
              ? g.appendChild(e)
              : _docElement.removeChild(e))),
        a && d.length > 6 ? [d[0], d[1], d[4], d[5], d[12], d[13]] : d)
  },
  _applySVGOrigin = function (e, a, o, c, d, g) {
    var _ = e._gsap,
      b = d || _getMatrix(e, !0),
      j = _.xOrigin || 0,
      $ = _.yOrigin || 0,
      _e = _.xOffset || 0,
      tt = _.yOffset || 0,
      st = b[0],
      at = b[1],
      ot = b[2],
      ut = b[3],
      it = b[4],
      ct = b[5],
      lt = a.split(" "),
      ht = parseFloat(lt[0]) || 0,
      dt = parseFloat(lt[1]) || 0,
      pt,
      vt,
      _t,
      yt
    o
      ? b !== _identity2DMatrix &&
        (vt = st * ut - at * ot) &&
        ((_t = ht * (ut / vt) + dt * (-ot / vt) + (ot * ct - ut * it) / vt),
        (yt = ht * (-at / vt) + dt * (st / vt) - (st * ct - at * it) / vt),
        (ht = _t),
        (dt = yt))
      : ((pt = _getBBox(e)),
        (ht = pt.x + (~lt[0].indexOf("%") ? (ht / 100) * pt.width : ht)),
        (dt =
          pt.y +
          (~(lt[1] || lt[0]).indexOf("%") ? (dt / 100) * pt.height : dt))),
      c || (c !== !1 && _.smooth)
        ? ((it = ht - j),
          (ct = dt - $),
          (_.xOffset = _e + (it * st + ct * ot) - it),
          (_.yOffset = tt + (it * at + ct * ut) - ct))
        : (_.xOffset = _.yOffset = 0),
      (_.xOrigin = ht),
      (_.yOrigin = dt),
      (_.smooth = !!c),
      (_.origin = a),
      (_.originIsAbsolute = !!o),
      (e.style[_transformOriginProp] = "0px 0px"),
      g &&
        (_addNonTweeningPT(g, _, "xOrigin", j, ht),
        _addNonTweeningPT(g, _, "yOrigin", $, dt),
        _addNonTweeningPT(g, _, "xOffset", _e, _.xOffset),
        _addNonTweeningPT(g, _, "yOffset", tt, _.yOffset)),
      e.setAttribute("data-svg-origin", ht + " " + dt)
  },
  _parseTransform = function (e, a) {
    var o = e._gsap || new GSCache(e)
    if ("x" in o && !a && !o.uncache) return o
    var c = e.style,
      d = o.scaleX < 0,
      g = "px",
      _ = "deg",
      b = getComputedStyle(e),
      j = _getComputedProperty(e, _transformOriginProp) || "0",
      $,
      _e,
      tt,
      st,
      at,
      ot,
      ut,
      it,
      ct,
      lt,
      ht,
      dt,
      pt,
      vt,
      _t,
      yt,
      Et,
      Rt,
      Ft,
      kt,
      Nt,
      Dt,
      Mt,
      wt,
      gt,
      At,
      bt,
      Tt,
      It,
      $t,
      Xt,
      qt
    return (
      ($ = _e = tt = ot = ut = it = ct = lt = ht = 0),
      (st = at = 1),
      (o.svg = !!(e.getCTM && _isSVG(e))),
      b.translate &&
        ((b.translate !== "none" ||
          b.scale !== "none" ||
          b.rotate !== "none") &&
          (c[_transformProp] =
            (b.translate !== "none"
              ? "translate3d(" +
                (b.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                ") "
              : "") +
            (b.rotate !== "none" ? "rotate(" + b.rotate + ") " : "") +
            (b.scale !== "none"
              ? "scale(" + b.scale.split(" ").join(",") + ") "
              : "") +
            (b[_transformProp] !== "none" ? b[_transformProp] : "")),
        (c.scale = c.rotate = c.translate = "none")),
      (vt = _getMatrix(e, o.svg)),
      o.svg &&
        (o.uncache
          ? ((gt = e.getBBox()),
            (j = o.xOrigin - gt.x + "px " + (o.yOrigin - gt.y) + "px"),
            (wt = ""))
          : (wt = !a && e.getAttribute("data-svg-origin")),
        _applySVGOrigin(
          e,
          wt || j,
          !!wt || o.originIsAbsolute,
          o.smooth !== !1,
          vt
        )),
      (dt = o.xOrigin || 0),
      (pt = o.yOrigin || 0),
      vt !== _identity2DMatrix &&
        ((Rt = vt[0]),
        (Ft = vt[1]),
        (kt = vt[2]),
        (Nt = vt[3]),
        ($ = Dt = vt[4]),
        (_e = Mt = vt[5]),
        vt.length === 6
          ? ((st = Math.sqrt(Rt * Rt + Ft * Ft)),
            (at = Math.sqrt(Nt * Nt + kt * kt)),
            (ot = Rt || Ft ? _atan2(Ft, Rt) * _RAD2DEG : 0),
            (ct = kt || Nt ? _atan2(kt, Nt) * _RAD2DEG + ot : 0),
            ct && (at *= Math.abs(Math.cos(ct * _DEG2RAD))),
            o.svg &&
              (($ -= dt - (dt * Rt + pt * kt)),
              (_e -= pt - (dt * Ft + pt * Nt))))
          : ((qt = vt[6]),
            ($t = vt[7]),
            (bt = vt[8]),
            (Tt = vt[9]),
            (It = vt[10]),
            (Xt = vt[11]),
            ($ = vt[12]),
            (_e = vt[13]),
            (tt = vt[14]),
            (_t = _atan2(qt, It)),
            (ut = _t * _RAD2DEG),
            _t &&
              ((yt = Math.cos(-_t)),
              (Et = Math.sin(-_t)),
              (wt = Dt * yt + bt * Et),
              (gt = Mt * yt + Tt * Et),
              (At = qt * yt + It * Et),
              (bt = Dt * -Et + bt * yt),
              (Tt = Mt * -Et + Tt * yt),
              (It = qt * -Et + It * yt),
              (Xt = $t * -Et + Xt * yt),
              (Dt = wt),
              (Mt = gt),
              (qt = At)),
            (_t = _atan2(-kt, It)),
            (it = _t * _RAD2DEG),
            _t &&
              ((yt = Math.cos(-_t)),
              (Et = Math.sin(-_t)),
              (wt = Rt * yt - bt * Et),
              (gt = Ft * yt - Tt * Et),
              (At = kt * yt - It * Et),
              (Xt = Nt * Et + Xt * yt),
              (Rt = wt),
              (Ft = gt),
              (kt = At)),
            (_t = _atan2(Ft, Rt)),
            (ot = _t * _RAD2DEG),
            _t &&
              ((yt = Math.cos(_t)),
              (Et = Math.sin(_t)),
              (wt = Rt * yt + Ft * Et),
              (gt = Dt * yt + Mt * Et),
              (Ft = Ft * yt - Rt * Et),
              (Mt = Mt * yt - Dt * Et),
              (Rt = wt),
              (Dt = gt)),
            ut &&
              Math.abs(ut) + Math.abs(ot) > 359.9 &&
              ((ut = ot = 0), (it = 180 - it)),
            (st = _round(Math.sqrt(Rt * Rt + Ft * Ft + kt * kt))),
            (at = _round(Math.sqrt(Mt * Mt + qt * qt))),
            (_t = _atan2(Dt, Mt)),
            (ct = Math.abs(_t) > 2e-4 ? _t * _RAD2DEG : 0),
            (ht = Xt ? 1 / (Xt < 0 ? -Xt : Xt) : 0)),
        o.svg &&
          ((wt = e.getAttribute("transform")),
          (o.forceCSS =
            e.setAttribute("transform", "") ||
            !_isNullTransform(_getComputedProperty(e, _transformProp))),
          wt && e.setAttribute("transform", wt))),
      Math.abs(ct) > 90 &&
        Math.abs(ct) < 270 &&
        (d
          ? ((st *= -1),
            (ct += ot <= 0 ? 180 : -180),
            (ot += ot <= 0 ? 180 : -180))
          : ((at *= -1), (ct += ct <= 0 ? 180 : -180))),
      (a = a || o.uncache),
      (o.x =
        $ -
        ((o.xPercent =
          $ &&
          ((!a && o.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-$) ? -50 : 0)))
          ? (e.offsetWidth * o.xPercent) / 100
          : 0) +
        g),
      (o.y =
        _e -
        ((o.yPercent =
          _e &&
          ((!a && o.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-_e) ? -50 : 0)))
          ? (e.offsetHeight * o.yPercent) / 100
          : 0) +
        g),
      (o.z = tt + g),
      (o.scaleX = _round(st)),
      (o.scaleY = _round(at)),
      (o.rotation = _round(ot) + _),
      (o.rotationX = _round(ut) + _),
      (o.rotationY = _round(it) + _),
      (o.skewX = ct + _),
      (o.skewY = lt + _),
      (o.transformPerspective = ht + g),
      (o.zOrigin = parseFloat(j.split(" ")[2]) || (!a && o.zOrigin) || 0) &&
        (c[_transformOriginProp] = _firstTwoOnly(j)),
      (o.xOffset = o.yOffset = 0),
      (o.force3D = _config.force3D),
      (o.renderTransform = o.svg
        ? _renderSVGTransforms
        : _supports3D
        ? _renderCSSTransforms
        : _renderNon3DTransforms),
      (o.uncache = 0),
      o
    )
  },
  _firstTwoOnly = function (e) {
    return (e = e.split(" "))[0] + " " + e[1]
  },
  _addPxTranslate = function (e, a, o) {
    var c = getUnit(a)
    return (
      _round(parseFloat(a) + parseFloat(_convertToUnit(e, "x", o + "px", c))) +
      c
    )
  },
  _renderNon3DTransforms = function (e, a) {
    ;(a.z = "0px"),
      (a.rotationY = a.rotationX = "0deg"),
      (a.force3D = 0),
      _renderCSSTransforms(e, a)
  },
  _zeroDeg = "0deg",
  _zeroPx = "0px",
  _endParenthesis = ") ",
  _renderCSSTransforms = function (e, a) {
    var o = a || this,
      c = o.xPercent,
      d = o.yPercent,
      g = o.x,
      _ = o.y,
      b = o.z,
      j = o.rotation,
      $ = o.rotationY,
      _e = o.rotationX,
      tt = o.skewX,
      st = o.skewY,
      at = o.scaleX,
      ot = o.scaleY,
      ut = o.transformPerspective,
      it = o.force3D,
      ct = o.target,
      lt = o.zOrigin,
      ht = "",
      dt = (it === "auto" && e && e !== 1) || it === !0
    if (lt && (_e !== _zeroDeg || $ !== _zeroDeg)) {
      var pt = parseFloat($) * _DEG2RAD,
        vt = Math.sin(pt),
        _t = Math.cos(pt),
        yt
      ;(pt = parseFloat(_e) * _DEG2RAD),
        (yt = Math.cos(pt)),
        (g = _addPxTranslate(ct, g, vt * yt * -lt)),
        (_ = _addPxTranslate(ct, _, -Math.sin(pt) * -lt)),
        (b = _addPxTranslate(ct, b, _t * yt * -lt + lt))
    }
    ut !== _zeroPx && (ht += "perspective(" + ut + _endParenthesis),
      (c || d) && (ht += "translate(" + c + "%, " + d + "%) "),
      (dt || g !== _zeroPx || _ !== _zeroPx || b !== _zeroPx) &&
        (ht +=
          b !== _zeroPx || dt
            ? "translate3d(" + g + ", " + _ + ", " + b + ") "
            : "translate(" + g + ", " + _ + _endParenthesis),
      j !== _zeroDeg && (ht += "rotate(" + j + _endParenthesis),
      $ !== _zeroDeg && (ht += "rotateY(" + $ + _endParenthesis),
      _e !== _zeroDeg && (ht += "rotateX(" + _e + _endParenthesis),
      (tt !== _zeroDeg || st !== _zeroDeg) &&
        (ht += "skew(" + tt + ", " + st + _endParenthesis),
      (at !== 1 || ot !== 1) &&
        (ht += "scale(" + at + ", " + ot + _endParenthesis),
      (ct.style[_transformProp] = ht || "translate(0, 0)")
  },
  _renderSVGTransforms = function (e, a) {
    var o = a || this,
      c = o.xPercent,
      d = o.yPercent,
      g = o.x,
      _ = o.y,
      b = o.rotation,
      j = o.skewX,
      $ = o.skewY,
      _e = o.scaleX,
      tt = o.scaleY,
      st = o.target,
      at = o.xOrigin,
      ot = o.yOrigin,
      ut = o.xOffset,
      it = o.yOffset,
      ct = o.forceCSS,
      lt = parseFloat(g),
      ht = parseFloat(_),
      dt,
      pt,
      vt,
      _t,
      yt
    ;(b = parseFloat(b)),
      (j = parseFloat(j)),
      ($ = parseFloat($)),
      $ && (($ = parseFloat($)), (j += $), (b += $)),
      b || j
        ? ((b *= _DEG2RAD),
          (j *= _DEG2RAD),
          (dt = Math.cos(b) * _e),
          (pt = Math.sin(b) * _e),
          (vt = Math.sin(b - j) * -tt),
          (_t = Math.cos(b - j) * tt),
          j &&
            (($ *= _DEG2RAD),
            (yt = Math.tan(j - $)),
            (yt = Math.sqrt(1 + yt * yt)),
            (vt *= yt),
            (_t *= yt),
            $ &&
              ((yt = Math.tan($)),
              (yt = Math.sqrt(1 + yt * yt)),
              (dt *= yt),
              (pt *= yt))),
          (dt = _round(dt)),
          (pt = _round(pt)),
          (vt = _round(vt)),
          (_t = _round(_t)))
        : ((dt = _e), (_t = tt), (pt = vt = 0)),
      ((lt && !~(g + "").indexOf("px")) || (ht && !~(_ + "").indexOf("px"))) &&
        ((lt = _convertToUnit(st, "x", g, "px")),
        (ht = _convertToUnit(st, "y", _, "px"))),
      (at || ot || ut || it) &&
        ((lt = _round(lt + at - (at * dt + ot * vt) + ut)),
        (ht = _round(ht + ot - (at * pt + ot * _t) + it))),
      (c || d) &&
        ((yt = st.getBBox()),
        (lt = _round(lt + (c / 100) * yt.width)),
        (ht = _round(ht + (d / 100) * yt.height))),
      (yt =
        "matrix(" +
        dt +
        "," +
        pt +
        "," +
        vt +
        "," +
        _t +
        "," +
        lt +
        "," +
        ht +
        ")"),
      st.setAttribute("transform", yt),
      ct && (st.style[_transformProp] = yt)
  },
  _addRotationalPropTween = function (e, a, o, c, d) {
    var g = 360,
      _ = _isString(d),
      b = parseFloat(d) * (_ && ~d.indexOf("rad") ? _RAD2DEG : 1),
      j = b - c,
      $ = c + j + "deg",
      _e,
      tt
    return (
      _ &&
        ((_e = d.split("_")[1]),
        _e === "short" &&
          ((j %= g), j !== j % (g / 2) && (j += j < 0 ? g : -g)),
        _e === "cw" && j < 0
          ? (j = ((j + g * _bigNum) % g) - ~~(j / g) * g)
          : _e === "ccw" &&
            j > 0 &&
            (j = ((j - g * _bigNum) % g) - ~~(j / g) * g)),
      (e._pt = tt = new PropTween(e._pt, a, o, c, j, _renderPropWithEnd)),
      (tt.e = $),
      (tt.u = "deg"),
      e._props.push(o),
      tt
    )
  },
  _assign = function (e, a) {
    for (var o in a) e[o] = a[o]
    return e
  },
  _addRawTransformPTs = function (e, a, o) {
    var c = _assign({}, o._gsap),
      d = "perspective,force3D,transformOrigin,svgOrigin",
      g = o.style,
      _,
      b,
      j,
      $,
      _e,
      tt,
      st,
      at
    c.svg
      ? ((j = o.getAttribute("transform")),
        o.setAttribute("transform", ""),
        (g[_transformProp] = a),
        (_ = _parseTransform(o, 1)),
        _removeProperty(o, _transformProp),
        o.setAttribute("transform", j))
      : ((j = getComputedStyle(o)[_transformProp]),
        (g[_transformProp] = a),
        (_ = _parseTransform(o, 1)),
        (g[_transformProp] = j))
    for (b in _transformProps)
      (j = c[b]),
        ($ = _[b]),
        j !== $ &&
          d.indexOf(b) < 0 &&
          ((st = getUnit(j)),
          (at = getUnit($)),
          (_e = st !== at ? _convertToUnit(o, b, j, at) : parseFloat(j)),
          (tt = parseFloat($)),
          (e._pt = new PropTween(e._pt, _, b, _e, tt - _e, _renderCSSProp)),
          (e._pt.u = at || 0),
          e._props.push(b))
    _assign(_, c)
  }
_forEachName("padding,margin,Width,Radius", function (s, e) {
  var a = "Top",
    o = "Right",
    c = "Bottom",
    d = "Left",
    g = (e < 3 ? [a, o, c, d] : [a + d, a + o, c + o, c + d]).map(function (_) {
      return e < 2 ? s + _ : "border" + _ + s
    })
  _specialProps[e > 1 ? "border" + s : s] = function (_, b, j, $, _e) {
    var tt, st
    if (arguments.length < 4)
      return (
        (tt = g.map(function (at) {
          return _get(_, at, j)
        })),
        (st = tt.join(" ")),
        st.split(tt[0]).length === 5 ? tt[0] : st
      )
    ;(tt = ($ + "").split(" ")),
      (st = {}),
      g.forEach(function (at, ot) {
        return (st[at] = tt[ot] = tt[ot] || tt[((ot - 1) / 2) | 0])
      }),
      _.init(b, st, _e)
  }
})
var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function (e) {
    return e.style && e.nodeType
  },
  init: function (e, a, o, c, d) {
    var g = this._props,
      _ = e.style,
      b = o.vars.startAt,
      j,
      $,
      _e,
      tt,
      st,
      at,
      ot,
      ut,
      it,
      ct,
      lt,
      ht,
      dt,
      pt,
      vt,
      _t
    _pluginInitted || _initCore(),
      (this.styles = this.styles || _getStyleSaver(e)),
      (_t = this.styles.props),
      (this.tween = o)
    for (ot in a)
      if (
        ot !== "autoRound" &&
        (($ = a[ot]), !(_plugins[ot] && _checkPlugin(ot, a, o, c, e, d)))
      ) {
        if (
          ((st = typeof $),
          (at = _specialProps[ot]),
          st === "function" && (($ = $.call(o, c, e, d)), (st = typeof $)),
          st === "string" && ~$.indexOf("random(") && ($ = _replaceRandom($)),
          at)
        )
          at(this, e, ot, $, o) && (vt = 1)
        else if (ot.substr(0, 2) === "--")
          (j = (getComputedStyle(e).getPropertyValue(ot) + "").trim()),
            ($ += ""),
            (_colorExp.lastIndex = 0),
            _colorExp.test(j) || ((ut = getUnit(j)), (it = getUnit($))),
            it
              ? ut !== it && (j = _convertToUnit(e, ot, j, it) + it)
              : ut && ($ += ut),
            this.add(_, "setProperty", j, $, c, d, 0, 0, ot),
            g.push(ot),
            _t.push(ot, 0, _[ot])
        else if (st !== "undefined") {
          if (
            (b && ot in b
              ? ((j =
                  typeof b[ot] == "function" ? b[ot].call(o, c, e, d) : b[ot]),
                _isString(j) &&
                  ~j.indexOf("random(") &&
                  (j = _replaceRandom(j)),
                getUnit(j + "") ||
                  j === "auto" ||
                  (j += _config.units[ot] || getUnit(_get(e, ot)) || ""),
                (j + "").charAt(1) === "=" && (j = _get(e, ot)))
              : (j = _get(e, ot)),
            (tt = parseFloat(j)),
            (ct = st === "string" && $.charAt(1) === "=" && $.substr(0, 2)),
            ct && ($ = $.substr(2)),
            (_e = parseFloat($)),
            ot in _propertyAliases &&
              (ot === "autoAlpha" &&
                (tt === 1 &&
                  _get(e, "visibility") === "hidden" &&
                  _e &&
                  (tt = 0),
                _t.push("visibility", 0, _.visibility),
                _addNonTweeningPT(
                  this,
                  _,
                  "visibility",
                  tt ? "inherit" : "hidden",
                  _e ? "inherit" : "hidden",
                  !_e
                )),
              ot !== "scale" &&
                ot !== "transform" &&
                ((ot = _propertyAliases[ot]),
                ~ot.indexOf(",") && (ot = ot.split(",")[0]))),
            (lt = ot in _transformProps),
            lt)
          ) {
            if (
              (this.styles.save(ot),
              ht ||
                ((dt = e._gsap),
                (dt.renderTransform && !a.parseTransform) ||
                  _parseTransform(e, a.parseTransform),
                (pt = a.smoothOrigin !== !1 && dt.smooth),
                (ht = this._pt =
                  new PropTween(
                    this._pt,
                    _,
                    _transformProp,
                    0,
                    1,
                    dt.renderTransform,
                    dt,
                    0,
                    -1
                  )),
                (ht.dep = 1)),
              ot === "scale")
            )
              (this._pt = new PropTween(
                this._pt,
                dt,
                "scaleY",
                dt.scaleY,
                (ct ? _parseRelative(dt.scaleY, ct + _e) : _e) - dt.scaleY || 0,
                _renderCSSProp
              )),
                (this._pt.u = 0),
                g.push("scaleY", ot),
                (ot += "X")
            else if (ot === "transformOrigin") {
              _t.push(_transformOriginProp, 0, _[_transformOriginProp]),
                ($ = _convertKeywordsToPercentages($)),
                dt.svg
                  ? _applySVGOrigin(e, $, 0, pt, 0, this)
                  : ((it = parseFloat($.split(" ")[2]) || 0),
                    it !== dt.zOrigin &&
                      _addNonTweeningPT(this, dt, "zOrigin", dt.zOrigin, it),
                    _addNonTweeningPT(
                      this,
                      _,
                      ot,
                      _firstTwoOnly(j),
                      _firstTwoOnly($)
                    ))
              continue
            } else if (ot === "svgOrigin") {
              _applySVGOrigin(e, $, 1, pt, 0, this)
              continue
            } else if (ot in _rotationalProperties) {
              _addRotationalPropTween(
                this,
                dt,
                ot,
                tt,
                ct ? _parseRelative(tt, ct + $) : $
              )
              continue
            } else if (ot === "smoothOrigin") {
              _addNonTweeningPT(this, dt, "smooth", dt.smooth, $)
              continue
            } else if (ot === "force3D") {
              dt[ot] = $
              continue
            } else if (ot === "transform") {
              _addRawTransformPTs(this, $, e)
              continue
            }
          } else ot in _ || (ot = _checkPropPrefix(ot) || ot)
          if (
            lt ||
            ((_e || _e === 0) &&
              (tt || tt === 0) &&
              !_complexExp.test($) &&
              ot in _)
          )
            (ut = (j + "").substr((tt + "").length)),
              _e || (_e = 0),
              (it =
                getUnit($) || (ot in _config.units ? _config.units[ot] : ut)),
              ut !== it && (tt = _convertToUnit(e, ot, j, it)),
              (this._pt = new PropTween(
                this._pt,
                lt ? dt : _,
                ot,
                tt,
                (ct ? _parseRelative(tt, ct + _e) : _e) - tt,
                !lt && (it === "px" || ot === "zIndex") && a.autoRound !== !1
                  ? _renderRoundedCSSProp
                  : _renderCSSProp
              )),
              (this._pt.u = it || 0),
              ut !== it &&
                it !== "%" &&
                ((this._pt.b = j), (this._pt.r = _renderCSSPropWithBeginning))
          else if (ot in _)
            _tweenComplexCSSString.call(this, e, ot, j, ct ? ct + $ : $)
          else if (ot in e) this.add(e, ot, j || e[ot], ct ? ct + $ : $, c, d)
          else if (ot !== "parseTransform") {
            _missingPlugin(ot, $)
            continue
          }
          lt || (ot in _ ? _t.push(ot, 0, _[ot]) : _t.push(ot, 1, j || e[ot])),
            g.push(ot)
        }
      }
    vt && _sortPropTweensByPriority(this)
  },
  render: function (e, a) {
    if (a.tween._time || !_reverting())
      for (var o = a._pt; o; ) o.r(e, o.d), (o = o._next)
    else a.styles.revert()
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function (e, a, o) {
    var c = _propertyAliases[a]
    return (
      c && c.indexOf(",") < 0 && (a = c),
      a in _transformProps &&
      a !== _transformOriginProp &&
      (e._gsap.x || _get(e, "x"))
        ? o && _recentSetterPlugin === o
          ? a === "scale"
            ? _setterScale
            : _setterTransform
          : (_recentSetterPlugin = o || {}) &&
            (a === "scale"
              ? _setterScaleWithRender
              : _setterTransformWithRender)
        : e.style && !_isUndefined(e.style[a])
        ? _setterCSSStyle
        : ~a.indexOf("-")
        ? _setterCSSProp
        : _getSetter(e, a)
    )
  },
  core: { _removeProperty, _getMatrix },
}
gsap.utils.checkPrefix = _checkPropPrefix
gsap.core.getStyleSaver = _getStyleSaver
;(function (s, e, a, o) {
  var c = _forEachName(s + "," + e + "," + a, function (d) {
    _transformProps[d] = 1
  })
  _forEachName(e, function (d) {
    ;(_config.units[d] = "deg"), (_rotationalProperties[d] = 1)
  }),
    (_propertyAliases[c[13]] = s + "," + e),
    _forEachName(o, function (d) {
      var g = d.split(":")
      _propertyAliases[g[1]] = c[g[0]]
    })
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
)
_forEachName(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (s) {
    _config.units[s] = "px"
  }
)
gsap.registerPlugin(CSSPlugin)
var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap
gsapWithCSS.core.Tween
function Shapes() {
  return jsxRuntimeExports.jsx("div", {
    className:
      "row-span-1 row-start-1 -mt-9 aspect-square  md:col-span-1 md:col-start-2 md:mt-0",
    children: jsxRuntimeExports.jsx(Canvas, {
      className: "z-50  overflow-visible",
      shadows: !0,
      gl: { antialias: !1 },
      dpr: [1, 1.5],
      camera: { position: [0, 0, 25], fov: 30, near: 1, far: 40 },
      children: jsxRuntimeExports.jsxs(reactExports.Suspense, {
        fallback: null,
        children: [
          jsxRuntimeExports.jsx(OrbitControls, { enableZoom: !0 }),
          jsxRuntimeExports.jsx(Geometries, {}),
          jsxRuntimeExports.jsx(ContactShadows, {
            position: [0, -3.5, 0],
            opacity: 0.65,
            scale: 40,
            blur: 1,
            far: 9,
          }),
          jsxRuntimeExports.jsx(Environment, { preset: "studio" }),
        ],
      }),
    }),
  })
}
function Geometries() {
  const s = [
      {
        position: [1.6, 1.6, -4],
        r: 0.7,
        geometry: new OctahedronGeometry(1.5),
      },
      {
        position: [0, 0, 0],
        r: 0.3,
        geometry: new SphereGeometry(
          2,
          4,
          32,
          6.283185307179586,
          6.283185307179586,
          6.283185307179586,
          6.283185307179586
        ),
      },
      {
        position: [1, -0.75, 4],
        r: 0.4,
        geometry: new CapsuleGeometry(0.5, 1.6, 2, 16),
      },
      {
        position: [-1.4, 2, -4],
        r: 0.6,
        geometry: new DodecahedronGeometry(1.5),
      },
      {
        position: [-0.8, -0.75, 5],
        r: 0.5,
        geometry: new TorusGeometry(0.6, 0.25, 16, 32),
      },
    ],
    e = [
      new Audio("/sounds/hit2.ogg"),
      new Audio("/sounds/hit3.ogg"),
      new Audio("/sounds/hit4.ogg"),
    ],
    a = [
      new MeshNormalMaterial(),
      new MeshStandardMaterial({ color: 3066993, roughness: 0 }),
      new MeshStandardMaterial({ color: 15844367, roughness: 0.4 }),
      new MeshStandardMaterial({ color: 15158332, roughness: 0.1 }),
      new MeshStandardMaterial({ color: 9323693, roughness: 0.1 }),
      new MeshStandardMaterial({ color: 1752220, roughness: 0.1 }),
      new MeshStandardMaterial({
        roughness: 0,
        metalness: 0.5,
        color: 2719929,
      }),
      new MeshStandardMaterial({
        color: 2899536,
        roughness: 0.1,
        metalness: 0.5,
      }),
    ]
  return s.map(({ position: o, r: c, geometry: d }) =>
    jsxRuntimeExports.jsx(
      Geometry,
      {
        position: o.map((g) => g * 2),
        geometry: d,
        soundEffects: e,
        materials: a,
        r: c,
      },
      JSON.stringify(o)
    )
  )
}
function Geometry({
  r: s,
  position: e,
  geometry: a,
  soundEffects: o,
  materials: c,
}) {
  const d = reactExports.useRef(),
    [g, _] = reactExports.useState(!1),
    b = j()
  function j() {
    return gsapWithCSS.utils.random(c)
  }
  function $(st) {
    const at = st.object
    gsapWithCSS.utils.random(o).play(),
      gsapWithCSS.to(at.rotation, {
        x: `+=${gsapWithCSS.utils.random(0, 2)}`,
        y: `+=${gsapWithCSS.utils.random(0, 2)}`,
        z: `+=${gsapWithCSS.utils.random(0, 2)}`,
        duration: 1.3,
        ease: "elastic.out(1,0.3)",
        yoyo: !0,
      }),
      (at.material = j())
  }
  const _e = () => {
      document.body.style.cursor = "pointer"
    },
    tt = () => {
      document.body.style.cursor = "default"
    }
  return (
    reactExports.useEffect(() => {
      let st = gsapWithCSS.context(() => {
        _(!0),
          gsapWithCSS.from(d.current.scale, {
            x: 0,
            y: 0,
            z: 0,
            duration: gsapWithCSS.utils.random(0.8, 1.2),
            ease: "elastic.out(1,0.3)",
            delay: gsapWithCSS.utils.random(0, 0.5),
          })
      })
      return () => st.revert()
    }, []),
    reactExports.useEffect(() => {
      d.current &&
        gsapWithCSS.to(d.current, {
          rotationY: 360,
          rotationX: 360,
          rotationZ: 360,
          duration: 2,
          repeat: -1,
          ease: "power1.inOut",
        })
    }, [d.current]),
    jsxRuntimeExports.jsx("group", {
      position: e,
      ref: d,
      children: jsxRuntimeExports.jsx(Float, {
        speed: 5 * s,
        rotationIntensity: 6 * s,
        floatIntensity: 5 * s,
        children: jsxRuntimeExports.jsx("mesh", {
          geometry: a,
          onClick: $,
          onPointerOver: _e,
          onPointerOut: tt,
          visible: g,
          material: b,
        }),
      }),
    })
  )
}
const Hero = () =>
    jsxRuntimeExports.jsxs("section", {
      className: "relative w-full h-screen mx-auto ",
      children: [
        jsxRuntimeExports.jsxs("div", {
          className: "flex flex-wrap  justify-center  ",
          children: [
            jsxRuntimeExports.jsxs("div", {
              className: ` ${styles.paddingX} flex flex-row items-start gap-5 mt-24`,
              children: [
                jsxRuntimeExports.jsxs("div", {
                  className: "flex flex-col justify-center items-center mt-5",
                  children: [
                    jsxRuntimeExports.jsx("div", {
                      className: "w-5 h-5 rounded-full bg-[#915EFF]",
                    }),
                    jsxRuntimeExports.jsx("div", {
                      className: "w-1 sm:h-80 h-40 violet-gradient",
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs("div", {
                  children: [
                    jsxRuntimeExports.jsxs("h1", {
                      className: `${styles.heroHeadText} text-white`,
                      children: [
                        "Hi, I'm ",
                        jsxRuntimeExports.jsx("span", {
                          className: "text-[#915EFF]",
                          children: "Ali",
                        }),
                      ],
                    }),
                    jsxRuntimeExports.jsxs("p", {
                      className: `${styles.heroSubText} mt-2 text-white-100`,
                      children: [
                        "I develop 3D visuals, user ",
                        jsxRuntimeExports.jsx("br", {
                          className: "sm:block hidden  ",
                        }),
                        "interfaces and web applications",
                      ],
                    }),
                  ],
                }),
              ],
            }),
            jsxRuntimeExports.jsx("div", {
              className: "w-[40%] h-[50%]  right-1",
              children: jsxRuntimeExports.jsx(Shapes, {}),
            }),
          ],
        }),
        jsxRuntimeExports.jsx("div", {
          className:
            " absolute xs:bottom-10 bottom-32 w-full flex justify-center items-center",
          children: jsxRuntimeExports.jsx("a", {
            href: "#about",
            children: jsxRuntimeExports.jsx("div", {
              className:
                "w-[35px] h-[64px] rounded-3xl border-4 border-secondary flex justify-center items-start p-2",
              children: jsxRuntimeExports.jsx(motion.div, {
                animate: { y: [0, 24, 0] },
                transition: {
                  duration: 1.5,
                  repeat: 1 / 0,
                  repeatType: "loop",
                },
                className: "w-3 h-3 rounded-full bg-secondary mb-1",
              }),
            }),
          }),
        }),
      ],
    }),
  backend = "/assets/backend-565fc01f.png",
  creator = "/assets/creator-dbbffaec.png",
  mobile = "/assets/mobile-896ef2f5.png",
  web = "/assets/web-0d05165f.png",
  github = "/assets/github-3b4e1609.png",
  menu = "/assets/menu-b5599218.svg",
  close = "/assets/close-54702a70.svg",
  css = "/assets/css-79a7f026.png",
  figma = "/assets/figma-184a11e6.png",
  git =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAANG0lEQVR4nO2dX6xcRR2AD9QYgpYElEDv3fltqdUSHtSISNWIiIE09vbuzMKa+GBq4p/4hoIGEx/qSxOiL1T62Adj4kN90gegSXnQxAdCIiYkloQKSKKQpo3c7szeikrXzPZCW3r39uzdc2bOzPm+5Jc0t7t7dn4z386cc+bMFAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQFs415cdVqtHrJZjzqgTToudhFEn/N/8//nXxP6eAHAJIy13Oi3HnZFxqdBy3L+HJAJEZLy/e5016og1cr60vGvh3+Pf6z+DSgQIzGhZLVgjz80q7hUia/XC6mCHUIEAgfDCWS2vzCvvJRK/zrkxQILyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMbSe1OVFYmgtuciLxNBKnJE/xJaucomNeu1cr7s9dm4Baie3HpieGFoHEgMkDhIDJA4SAyQOEgMkDhIDNASn5YDV8vis70NigMg4LT++eFsFibnFBMngjPzoynujSIzE0Hhsv/vo9AkOSIzE0Fj8vrtXn6WExEgMjcMa9cPyUw2RGImhMVijfjD7fGEkRmKIjtXq4c1P+kdiJIZojLR8z+9wP9+TO0iMxBAcp+W788qLxDyKCBFwRr5TlbxIjMQQENeTb1st71QpLxIjMSQ2bJ4qsVE/m/V7+SVs/FI2l/8YqDeslmecVof9ebYPp9Uhq9VTTqtTdZahwlywPA80v+etSmJn5EVn5Aln5DPjorhm2mvHB4prR8uLd1stB61Wb8YWFYmhVlxPfSuUvPNcnd4M46Vt1zsjjzmj3oot6/RcqNfP9WVHiHxAZjit9oeWN7TEntGgs2i1PB9bViSGynB9+WYseecZTs/ZGx+NLesGueCcGMphtfq6NfLfRjTcgD3xeFBssUY9HbvM03PBcBqugjUyaIq8MSRe2Ss3Oi0vxy4zEsPMDI081DR5Y0g87KkvxS4vEkOyw+ZpMdTdfqhqndxHbkCZp/6gcU4MKfS8lzTYf9t9t90SqtZGpnNX7DIjMVwV36tZrf7T/MYqvwtdnc7IycbnRXNhq7WMTNekIK+PkVbfD50fp9UvY5e73I+b4hZT2xhp1bNavR278ZUWeHnx7tA5clqWYpcbieEKRj21LyV5fQwHt94cuipX9nV2xi43EsNlONPZY7U6F7uxzRrjwR0fDF2Vp5d3bY1d7pkl1pwTZ4vrd7/mr+bGbmSbEnhp2/Wh8+VnZsUu96YkNpwTZ4fT6oEUe953Y7W3oELn7MyenTfELvemJdb0xNmQurwTgXX386Hz5h/ji13uuSQ29MTJY42632pZjd2Y5m6MWj0S42Jf7HIjcYuxPflqDvJeEFh+Hzx/Wv0idrmRuKXYfvcr1sgoduOpTmD1dsiplH5ZnhRmYrmy+WM4nQ621703J3nfC61+GvJ2W/TyInH7GPbli06Ljd1Y6gl11hnZFiKPq4MdYrW8Er/M1Ybl6nRzmTzHmq28a6HVb0Llc70la3MIy3C6eZztyRecUcPYjSNIA9Tq4VB5pSeG2mmTvBcElv9Z3flGqKZFTwy1MTLd3WvnhtHFCiqx3yVCq59stIh7lSAxVI7fhcAZ+VdsmaKGlj8Ol+WOEM2L4TRUvORLc3cUCH6PWKtfj3Tnc3U3MXpimJvRg+qzyLu+zGVz6Iz81hn1Vy/krPlHYtg0rtf9tDNyJnav19Qoncc59x5iOA0zg7zVC4zEst4pCRuqVY0z2z9Fz1uPwEgsSFwn9sHFTzojp2MPT3MWGIkFietg2O/e3vSNqHMRGIkFiZE3bYGRWJC4Cs4ub99ltXojdo/WRoGRWJAYedMWGIkFiTfV8+qFT1gj/4zdk6UaVQqMxILEM8nbX/w48jZLYCQWJEbedHvgeR+CX2/apb+2Mdl/WKvDfuNyH06rQ1arp5xWp2KPYlyN+cgSvweP1fKP2JWSQ5TNechG69/jjLzojDzhnyDb6BHI8YHiWr+Rm9VysOm3Dy0SF8Vqf3s3x2VbchQ49DRDv52MM/JYkx9csW2edom86Qkco9GOBp1Fq+X52LK6huSjEZzbJ7f5gsdOfm5RNv+pDR/XeuOjsfPrGpKPqIyW1QLD5rQFjiLxl4sPOC3HY8vqNsiHb9tFzoz3d6+zRp6Lnexco2w9pDp8XNkrNzotL8fOs5uejz/H2Ao2GNaoI7GTnHOUrYdKG23gntjvvBE7z27jfBwpcn0g32p5J3aCc47SdVF1ow3cE0/uIzcg3269XBg5P9JyZ5EbTT5/ySVK10Utx+/sKYIuahg/31NDy/EiJ1LfLDqVKFsfNRz7ZKg1qt/FGvVq7HxvFFndWrL97qOxE9qGKFsfVR/XGvXzelvQOmXQ6lDsfDdtU/basFqOxU5oG6JsfVR93FFP7au3Ba1TBi1LsfO9Ufg2X+SC0+ql2AltQ5SujwyGi34OvWtAzqeGVi8VudCmzcdiRvn6qPa4p5d3bS0C44/pGpDz6aGGRS4gcN4CjwfFliIw/pguuqRtEZghdN4C33/Lh4rAJNADnyhygYtYeQvMObDkfRHLX1KP/4uYf5StjxqOvbfeFpTiVWiVz22ktVUZoic19yhbH5UfW6tD9bag9cqgnoyd79ZM5PAwlTJfgf2sqCIwjZ6JpTObSunxE7z9RO/oyc04ytZFHcf285OLQDR5LrTN9WEGD48T5iuwf0KoCESzn0ZSeT5O6OGB/nwFXut97qt/w7vOPbEldW19oN/Dkjr5CuyfSloZdG6qq+34z3ZG/hZbVNfWJXXeZXWwQ6yWV2InPbcom/96v4d61q9fVcfMK2vU07Fz7NaJdq5Muc6q/UQOAk/iaJVDySavSmnbtCLl+6EnrrYxlc17oIb9F7/2d87rQts29rzvB4nzFHgSWqzf++jMnp03zNou/PzqJu/MYJH3IgynMxX4YmN/0+93NDLd3X7/ow33RjLd3U3fG8m2edg8DSTOV+DLQqtTk4tRl+9OeHjtb43fndAi73QYTrdA4ITDMmy+OkiMwLFFdcg7H0hMDxxbWEfPi8ShG1rZjMcWIqWwDJvpiRE4vogOeePAcJoeGHkTB4kZQtPzJg4Scw7MsDlxkJiLWJzzJg4ScxWaC1aJw7TL99/qkHesVk+VzZ9/LZuty8X8MT0yPEh8YQE1a+RXK1p9bNb8+ff497Z9oUGLvPFos8RWq7/bXvfeeXPoP8N/VuzyIG9LaeM58eQB90H31qpyOFza9lGn1Z/alUPFw/hNoU09sV/p4tTg5g9XnUP/mf6zW5LD13iet2G0QWL/kPtqb0HVlUP/2U1+kB55Myf34fTQyEN159AaGWQrr2bY3Hiy7YkD7reT4z5WlmFzOuTYE1uj7g+VP6fVA1nlTtPzJkdmPfHJcVFcEyp3/lj+mFnIa7hglSwZ9cRPhM6d3/M3eXk1PW/y5CDxsCcPhs6bv2AWu9zIC1kMp4f97u2hq9IfM3a5NxuWYXN+pNwTn9ULHwmdr8nsrBTl1QybsyXVnriO3f6uhj9mcvIaLlhlT4o9sd8nKHSeTi/v2pqUvJqetzWk1hPH2AFvZV9nZzLyGnre1pGYxHtD58dpWWpAuZEXMhhOa3UodD06o56MXu6rhGXYDClI7B+4D11T1qhXY5cbeSGb4fTIdO4KVZ3+WI2Wl3NeSK0ntlqeCVVrVsux5uaBq82QqsRG7qu78ob9zj2xy4m8kKXE/rzUz5Cqq3pXBp2bmvoUEj0vZCGxM+rZOmZmjQfFFmvU0/HLh7yQ/4Wto+OlbddXVdH+s/xnNqBcVwQXrCDLntivILna396dt3pHg87iZJnaJpaRC1aQs8ROi7VaHj+zZ+cNs5bLz692Rh5zRr0VvRzICy0eTk+Wm7VaDo5Md/f4QHHttHL4//Ov8a9t8vKxDJuhdRK/F1qdmlyM0uqw7519TP594W+non8/5IVYNHo4nUFwzgu1g8TIC4mDxPS8kDhIzLAZEgeJOeeFxEFiLlhB4iAxV5shcZCYW0WQOEjMfV5IHCRmkgYkDhIzwwoSB4mZHgmJ03aJmdsMydNWiZEXsqFtEiMvZEdbJEZeyJbcJUZeyJ5cJUZeaA25SYy80DpykRh5obWkLjHyQutJVWLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFCMxoWS1YI89VIO8L/geBCgQIzHh/9zpr1BFr5PzM4ho579/rP4OKA4jISMudTsvx0gJrOe7fQ6UBNIhzfdlhtXrEajnmjDrhtNhJGHXC/83/n39N7O8JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFCE4v/t8177cNMPugAAAABJRU5ErkJggg==",
  html = "/assets/html-92b76a73.png",
  javascript =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAOgElEQVR4nO2dCdCVZRXHz8Pnwi4groElmijuK6m4YCqJpZmJqJla40qGWjgYZZQL5p4GJZlboKKTGzoouWSAiQsuqONY42Q1LVrZYlpZnebcy51B6uO7977LeZ/7/H4z/wGGmfve5zznf577vu+ziAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtIW+JIqIQafkgKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyB/Sp+yKQJHwmlft+3l4kumiN62dmixx8WdJ9dg246LOjggUH79A4aQv3v79sg6Oab1P//pAlBL50iev9s0b8tq3bBkdTwDnjsisHA7zwj+v1viB62f9C+vbN9395rBx03JuhV00TfXFrF/kgM74DHriob+A8/EZ16YtChg7N9x+40oF/QyccGfXVhlfojMbwDHruqaOB3l4teMkV00IBijLuq1loz6PRJov94rgr9kRjeAY9dVTPwy/eJ7rZtOcZdVVtvHvSp2737IzG8DRC7qmTghdeWN+p2p769g94zEwNj4AqYMyYDz7tcdI0uX/PKCtn3mP01r/5IDG8DxK4qGPjumdUxr6yQvY6aezEGxsAVMGmVDWz3vAP7+xtWunnltGRu2f2RGN4GiF2eBranvttu4W9UWY3WHxL0tYcwMAaugFmrZuDzJ2e/fhkaN6a82WaSGt4GiF1eBv79Y6L9+/qbs1ndcCEGxsAVMGxVDDztZH9TtqIh64Ra0Sm+PxLD2wCxy8PANtNqw6H+pmxWgwcGvWZ6Wf2RGN4GiF0eBr732/nd+24/MugVU0WfuUP09cX11Ub259J5oldPE917l/oroXY//9hDgr6xpMz+SAxvA8QuDwNPOjq7cfv1qd+X/ufFnq9nr4J22LK1z990WKgtPyy/PxLD2wCxy8PANuc46/vZR29qfR3xxPE9f3ZXV9Azjwv61tNe/ZEY3gaIXWUb+O/PSs0kWa553ufba+u/losefuDqf44/eZt3fySGtwFiV9kGfnF+tmvarht/far99trIOmqz//3MGWeK/vP5KvRHYngHPHaVbeAHr8t2zQP2yD6pwh54NeZejx0d9JUFVeqPxPAOeOwq28C2cCHL9T57eD6zor46SfTa85p7CKal9kdieAc8dpVt4NuvzHZN28ius/sjMbwDHrvKNnDWd8AH7omBOwpvA8Susg38yA2S+f2v7VLZuf2RGN4Bj11lG9geGGW95qxzO7k/EsM74LGrbAPb6NmrV7Zrrjso6E/v79T+SAzvgMeusg1s2nJEtmuaRgwPtd08Oq8/EsM74LHLw8C2QCDrdU22Fc+NM6r3Kkgz9UdieAc8dnkY+KaL8t2Jw1YcPXZzp/RHYngHPHZ5GNiOTFlzjfwM3JAdZLZgduz9kRjeAY9dHgY2fXI1iwqyasetgt5yaTXmNmvL/ZEY3gGPXV4GtuWARRm4ITti1FYu/XZRTP2RGN4Bj11eBjbZrKqiTWxae62gnz406LN3xtAfieEd8NjlaeDn75LayYBlmHjl1UwPfLe6T64lNbwDHrs8DWz6+uk+e0NvNzLozZeI/vsF/z54b38khnfAY5e3gc1AB+9TvoEbsu19bruiSv2RGN4Bj13eBja9uVRqI6KXiUWCfvhD/mcDY+AKGCI2VcHApt8tzr7ZXVZ1dQX94gm+q50kNbwNELuqYmDTHx+X2mQMTxOLBN1qRNAnnDa3k9TwNkDsqpKBGycW2iiYdcVSVq3RFfSCM8p/Wi2p4W2A2FU1Azf0w+9JbSKG92h81MGhthUuBsbA7maNycAmO0zshMP8R+OD9irvvlhSw9sAsavKBl55G9j9Rvua+JCxobYxPAbGwO6mjc3ADc2fJbrLNn4mPuv44tsqqeFtgNgVk4EbWjRH9KP7Zjt1sB2FEGq7ahbbH4nhbYDYFaOBG3ruzvo9sh12VpaJN14/29EuPfdHYngbIHbFbOCVZ3JdeY7o+zcux8TnnlZcmyU1vJMndnWCgRt6d7norZeJ7jSqWAMP7B/0z08U1R+J4Z00sauTDLyyFl4rtfnNRZn4m18qqj8SwztRYlenGrghO+93/93zN/Do7Yppt6SGd4LErk43cEN3Xi26wbr5GbhXr6C/frSI/kgM78SIXakY2GR7Y+21c34mnnd5Ef2RGN5JEbtSMrDpradF99gxHwN/4YT82y6p4Z0QMcvm96ZmYNNrD0ntlMOsbT94HwyMgR0T+fXF1TSwLWIouu02LTJr27f5IAbGwE0m3M8flNrWqLboPa8kthP+sibxkQeFXN/jXnhGfXRcOq9YAy+Zm73t6w3BwBi4h0Sz0wVmnCnat3c9aU6ekF/S3Ped7El83Mfz+T7L737vQoVRmxW7DtemQ2Zte78+GBgD93CavW3vsuqE+rtn5pPENtplTeJTJ4bMo+75k6W2+fqqn33OScXeX2e9D+7qwsAYuJvXHXYEZ3erbQYPDPri/OwJvOdO2e8Dp3wm28buq5v2aNva2ESMIsxra3vt87O0vX9fDIyBV9kjeda5UjNoT8lj281kOaX+hXvy2VDdFhG0c1tgG7o3cyrDpsOCvrEkfwO/ujB7+zdaDwNj4BUJZXsS79riYvWhg4P+6Mb2Rp8xOYy+pjuuau3adj6RnR7YyjXGjs7/fvjqadkNvN1IDJy8gf+0VPRzx9Tvp9qd0jfp6FA7c7eZxH17mdQ2asvDvCZbk9vsqDt9UvvnAo/fO799qexzNt8ke9uPGIeBkzbw3ItFNxyaj5HsKfVJE0LtyfJfnnzvdWxr1JfvE71iqtR+kuZlXrumPYTqqZ3LfiC6fQ4nL9i+WLYBfNa4n35MddcFS2p4m7Bd/eyB7A9RVie7jx4xPOjwDetGK+Ia9hCsmbbuvkN+17T7zgWz24u5/QyffGx+3+XB6/LPC0kNbyNmkY2YRRm4DH3l1OYMvHiO5L5/1d671I8JbWanSNss/pZLpfZuOa/r9+1dzHtqSQ1vE2aRLUfLY06ul1o5DGzi+OJ+adi9qE12ue4CqW06d89M0RtnSO1khUP3C7ruoPyvO3E864GTN7Al9mVn+5yPm1X287yVY0dsAYFtReP9vfPSw9cXU9QlNbxH0awyE4wb45+QrcoKT6tttZ+x3t87D+00qrXihYE72MCm3/xYdP0h/onZrGwktddf7bT1xCP8v38VH17pCklqeJsvz3nPZe5vnEUXndV+O+09dB6vlLw0oeD1z5Ia3sbLU3d9q9hXS3nIJkBkffpqvzi2+IB/W1rVsA3yXc6JgTvMwCZ7elr2kSHNymZR5bVO95cP5zuppGj171vOod+SGt6GK0L2sKdPQZMvsuiqafkvKLCn2d7tkh5kSx3vb3PyCAZO0MAmq/Z2Do938jY07eRi7v1spZFNyvBun3SjQQPaWzCCgRMegRv61SP5rNnNIvs5bxMiimynzaf+8intL+goStuPDPrSveX2uaSGt8nKWCN8zfTm1gjnLZvBZBuil9XWx28t/lyjZrTWmkGnnljslj4YOBEDr7xLx6c+Vl8+WMaoa69L7Jplt9PmNl9/gc+9ca9eQT9xQNBXFvj1s6SGt7HKlu2kYdvt/L89pLLKfsIeMra1Oc5FydYP28O8Mu6P1xkQ9JQjQ23JpXe7JTW8A+4l2zvZTsjbd7f63lFZRh3bCcS2uPnFw/7t6u5p9SVT6mbOa7KLvdO1bXptR5F3ctooIA9JangHvAqyA65tIf9XJ4kefmDQnbcOtamZNrJYstpobffQm2xUX8NrezmbYefPqm/u7v39W5GZbdGc+t5hpx1VPx1hhy1DbWMEa2OjmA3oV//3ZsNDbfsgWz1kC/Bvv7K+Ftu7HdqNJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBBoiiMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEg+/BceiofdqS/+vQAAAABJRU5ErkJggg==",
  mongodb = "/assets/mongodb-54000b2b.png",
  nodejs = "/assets/nodejs-d83eb6dd.png",
  reactjs = "/assets/reactjs-966214a8.png",
  redux = "/assets/redux-171787ca.png",
  tailwind = "/assets/tailwind-6ece120d.png",
  typescript =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAANMUlEQVR4nO2d+48V9RXAv//Gtw/balttayOpjVZr06TPqLRJ09Q+09Yaa01sapNWKqiAqCiU+MJXfSGC+ADxQa1AK0WMogJW2L3syrIvdpcL+95ln7B7mu8Y7GaD9N7ZmXvuzPl8kvOLMXsvZ87nnLkz852vcwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsfDX7BaCHOSlBpw1tBNOkAOPwAhMI6AReCYwRUAjyHYNOGtoJ5wgBx6BEZhGQCPwTGCKgEaQ7Rpw1tBOOEEOPAIjMI2ARuCZwBQBjSDbNeCsoZ1wghx4BEZgGgGNwDOBKQIaQbZrwFlDO+EEOfAIjMA0AhqBZwJTBDSCbNeAs4Z2wgly4BEYgWkENALPBKYIaATZrgFnDe2EE+TAIzAC0whoBJ4JTBHQCLJdA84a2gknyIFHYASmEdAIPBOYIqARZLsGnDW0E06QA4/ACEwjoBF4JjBFQCPIdg04a2gnnCAHHoERmEZAI/BMYIqARpDtGnDW0E44QQ48AiMwjYBG4JnAFAGNINs14KyhnXCCHHgERmAaAY3AM4EpAhpBtmvAWUM74QQ58AiMwDQCGoFnAlMENIJs14CzhnbCCXLgERiBaQQ0As8EpghoBNmuAWcN7YQT5MAjMALTCGgEnglMEdAIsl0DzhraCSfIgUdgBKYR0Ag8E5gioBFkuwacNbQTTpADj8AITCOgEXgmMEVAI8h2DThraCecIAcegRGYRkAj8ExgioBGkO0acNbQTjhBDjwCIzCNgEbgmcAUAY0g2zXgrKGdcIIceARGYBoBjcAzgSkCGkG2a8BZQzvhBDnwCIzANAIagWcCUwQ0gmzXgLOGdsIJcuARGIFpBDQCzwSmCGgE2a4BZw3thBPkwCMwAtMIaASeCUwR0AiyXQPOGtoJJ8iBR2AEphHQCDwTmCKgEWS7Bpw1tBNOkAOPwAhMI6AReCYwRUAjyHYNOGtoJ5wgBx6BEZhGQCPwTGCKgEaQ7Rpw1tBOOEEOPALnW+Dm7jEBkYUbOiqW81mLCvKjBxrl6qcPyF83FeXJt3tk275BebdtWJq6xqJj0jt0TPqG34+uI0ej/7bv8Gj0/2ypH5BndvbKfVs7ZcGLHXLlE61y0d0N8vkFtUzgJNGWE4GrQ+ALltbL3Ofa5eXafin2j6faL/uGj8nOliFZub1b5jzbJrOXN8ip82oS+Xc4a2jLicB6Ap97a100XeuLo6LNsYnJaHqv3dUrf17XJucsrkNgBM4XSQl88fIG+fue/kiaamXVm90IjMD5YqYCn3dbnWzY3SeT1evtBzz0WhcCI3C+iCvwR+bsjk5Lh8YmJCvc9cphBEbgfBFH4NOuq4kuTGWNpZuKCIzAtgU+a1FB9rQPSxa5MebZhrOG9hXmUoL7wOULfPoNtZmVN3Dt+nYERmCbAn/8L3vk9f1HJMtc/fQBBEZgmwIv23xIss4Vq1sQGIHtCXzhXfuq+v5uqfxqRTMCI7A9gbc1DEoeuOTBRgRGYFsC/+zhJskL37unAYER2JbAm/cOVOy7tHSPyT9q+qNHHu/d2im3bSxGz1U/uK0zWoUUvktrT/xVZN++Yx8CI7Adgc++ZW+qv33D395U6JdLH2uWMxcWSpbrjPm10bLEIPiOliEp9SuG1VHcB87JfeCfPNQol61sTiX+8NSBxIo8rKZJ63uGCM8yf1iOwprbtAjPT4cGkcSxPHNhQf74zAF5s+nkt7m+HPPznDW05dSOLywsJFbobzUNqf070jh9Hj82Kb9/sjW173zB0nr527ZOOXKCZ7TDcYnzN501tAXSjjwIHB7cGBxNdqFCONX93er05PXTTrPDKXb/8LEPPj/uAn9nDW2BtCMPAn9tab0kzYo34i3n8zMUOVwQC5P/o3Pi/Q1nDW2BtCMPAoeHHpIknNKWc6HKJxxxL2CFcNbQFkg78iBwuDqdJC/u7lM/Lj5mOGtoJ1w78iDwPf8+LEnyp7Vt6sfFxwxnDe2Ea0ceBH709S5JknDbTvu4+JjhrKGdcO3Ig8BP7eiRJJkd8zFGXwXhrKGdcO3Ig8DPvtMrSfLrmCuBfBWEs4Z2wrUjDwKvfrNbkiQ8XKF9XHzMcNbQTrh25EHgIFzSOyeEV/JoHxsfI5w1tBOuHXkQOOnbSIGwF5L2sfExwllDO+HakQeBw0KHNAgbk2kfH19mOGtoJ1w78iBwWKWUFkHi8Ky19nHyJYazhnbCtSMPAoc4NHBU0mJX69BJlzL6KgpnDe2Ea0deBF6f8K2k6QyMTERrjk+5trqnsbOGdsK1Iy8Cp/U7eDphc+/wWWG/Je1j5xEYgfMi8Kfm1UjP0P/W06bN7rbhaBVUtYnsrKGdcO3Ii8Ah7t6S7KKGUgjbt1y2sjn2+l0ERmAEnrKZ2YleT1MJ6oujctWaVvUr1s4a2h1TO/I0gUOEV7tq0tw9Fu1FrHWxy1lDu+C0I28Cf3LunujtmNp09I3L9S90yCfmVlZkZw3tgtOOvAkc4uLlDdF7paqBtt7xaKfBj1Xo1NpZQ7vYtCOPAoeY+1y7VBP1xVH56UNNCIzACFyqxPe/muwqpSR4/t0+mXVTMi+JP1E4a2hPCu3I6wQ+HmGvompjYGRC5jybznu3nDW0C0w78i5weNDikYTfmZXk2y9PT3jdsbOGdoFpR94FnrpmuBo3/m7qGpPv3BlvJ0IERmAzAof4wX37pXMwvVVLcRken4i9off0cNbQLirtsCRwiHMW18n2xpPvDKjByPiE/PzhmV+ldtbQLijtsCZwiPDc8rzn22VI6bHLDyPcu/7lozOT2FlDu5i0w6LAx+PcW+vklbrktyWdCeFZ7m/e/h4CIzAClypy+P1ZODgi1UJz95h85nq2F2UCM4FLljisIpq7vj3VV/OUw+Pbu2NNYWcN7dM47bB8Cn2iCIsPwmqiorLIE5MiF91d/hYvzhraBaMdCHzivJx2XY3c/NLBir7lYzqvNRxBYARG4Jk0uPBbdMnGovQP64h84V3lPeThrKE9AbWDCVxank6fXyu3//OQDI5W9tbTk2XuEOGsoS2QdiBw+fkKq5wqtd64f/hYWS8FcNbQFkg7EDhe3r66pF42FSpzD/mSMh6zdNbQFkg7EHhm+fvNymbpPpLuFetlmw8hMAIjcFpNcNaigrz63mBqAoenxZjATGAmcIpnMqdcu0c27O5LReDGzlEERmAErsTTXBtr+xMXOFwwK3UHCGcN7d+g2sFv4GTz+bkFtan8Jj51XmnPRjtraAukHQicfE6XbT6UuMBfvLGAwAiMwJV6L3XShEbLBGYCM4ErIPCXbt6buMBh90UERmAEroDA5y+pT1Te8DK+Uj/bWaMSB7SaIw+/gc+7rS5662Slti/5fzH7nobEH6cs9bOdNbQPtnbkQeCvL3t/4r3dPDSj19EkFQs3dEiS1HaMlPzZzhraB1s78iTw8dPN8CL3M0u86JNGvHNgWJIkPCBS6mc7a2gLpB15E3jqy+Hu/Neh6L5sJb/LLx5pkqRZvuVwyZ/vrKEtkHbkVeCp+xA98GpndGEp7e9x1qKCtPeOS9L8dlULAiOwTYGnvmMqLAq49LHmkm/JlBPnL6lPZWPxycnSH+II4ayhUXDVFFYEnn56Hbb5vGJVi3z6uppE3p01mNKbOuqKpV/AQuAqEAqB0xd4KuGiV6FjRNa81RNt+fndO/eddMfAcKsqbM9y5ROt0etuwil6moTX+CAwE5gJXCZh25XwgvW9B0fk3bbhaBK29oxV7FU6x0+fwz1uBEZgBM4gbzTyWll+A/MbOLNcEmPLUWcN7d+g2mHxIlZep69HYH2hEBiBx45OyjdiPhLqrKEtkHYwgauPhRs6Yh9PZw1tgbQDgauLTYX+aANyBEZgBM4YO1uGogdDZtKQnTW0J6B2MIGrg+2NR+SM+TNfeOGsoS2QdiCwPuvf6S1r/yMERmAErgIGRiaizcSTbMjOGtoTUDvyMIG/cmtd9OhjVpiYFFm7q1fOvmVv4rlw1tAWSDvyIHCIcAr64wcb5d6tnbKjZaiizyyXSvhOz/+nT751R3qv/XHW0BZIO/Ii8PQIOxn88P79smRjUbbUD1R8Y+6p1LSPyOKXizLrpuQnLgJXQbEhcPo5CPdWw6L7yx9viXZOeGlPv9QXR2X06GTiK4hausdk3a5euWZdW9mriRCYCVxWEeR1Ape7Pej3722Qq9a0yvwXO6I1uCve6IpOd7e+NxhtHTo9Nu8diNYDh/duXf9CR7Q+ePbyBvnsDcm/7aOccNbQLh6CHHgERmAaAY3AM4EpAhpBtmvAWUM74QQ58AiMwDQCGoFnAlMENIJs14CzhnbCCXLgERiBaQQ0As8EpghoBNmuAWcN7YQT5MAjMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4bf4LtvMh68AvCz8AAAAASUVORK5CYII=",
  threejs = "/assets/threejs-fe160e71.svg",
  tripguide = "/assets/tripguide-892dd3b1.png",
  sompo = "/assets/sompo-d1b28256.png",
  poznan = "/assets/poznan-5db4fa04.png",
  eru = "/assets/eru-12c163ae.png",
  patika = "/assets/patika-7cd15c94.png",
  fiver = "/assets/fiverr-5e61ac0b.jpg",
  nakilport = "/assets/nakilport2-fbe62820.png",
  MercanSoft = "/assets/mercansoft-7f3250cb.png",
  ecommerce = "/assets/art-952c261b.png",
  garden = "/assets/garden-71c88a6e.png",
  navLinks = [
    { id: "about", title: "About" },
    { id: "work", title: "Work" },
    { id: "contact", title: "Contact" },
  ],
  services = [
    { title: "Web Developer", icon: web },
    { title: "React Developer", icon: mobile },
    { title: "Backend Developer", icon: backend },
    { title: "Content Creator", icon: creator },
  ],
  technologies = [
    { name: "HTML 5", icon: html },
    { name: "CSS 3", icon: css },
    { name: "JavaScript", icon: javascript },
    { name: "TypeScript", icon: typescript },
    { name: "React JS", icon: reactjs },
    { name: "Redux Toolkit", icon: redux },
    { name: "Tailwind CSS", icon: tailwind },
    { name: "Node JS", icon: nodejs },
    { name: "MongoDB", icon: mongodb },
    { name: "Three JS", icon: threejs },
    { name: "git", icon: git },
    { name: "figma", icon: figma },
  ],
  experiences = [
    {
      title: "Full stack Developer",
      company_name: "fiverr",
      location: "Remote",
      icon: fiver,
      iconBg: "#E6DEDD",
      date: "September 2023 - Present",
      points: [
        "Successfully utilized Next.js to build fast-loading, server-rendered React applications.",
        "Proactively reached out to clients to understand their needs and offered helpful suggestions.",
        "Worked on API development, ensuring efficient and secure data exchange.",
        "Managed databases to ensure data integrity and optimal performance.",
        "Optimized servers for improved application speed and reliability.",
      ],
    },
    {
      title: "Frontend Developer intern",
      company_name: "Sompo Sigorta",
      icon: sompo,
      location: "Istanbul, Turkey (Remote)",
      iconBg: "#383E56",
      date: "February 2023 - September 2023",
      points: [
        "Technologies: Vue.js, React.js, PrimeReact, Tailwind.",
        "Maintained and improved the client portal web applications.",
        "Implementing responsive design and ensuring cross-browser compatibility.",
        "I contributed to the development of the word application, which uses +200 thousand users in the Android market.",
      ],
    },
  ],
  education = [
    {
      title: "Master of Science - Product Engineering",
      company_name: "Poznan University Of Technology",
      icon: poznan,
      iconBg: "#E6DEDD",
      date: "February 2023 - July 2024",
      location: " Poznan Poland",
      points: [],
    },
    {
      title: "Full Stack Bootcamp",
      company_name: "Patika.dev",
      icon: patika,
      iconBg: "#E6DEDD",
      location: "Remote",
      date: "October 2022 - March 2023",
      points: [
        "Developing and maintaining web applications using React.js and other related technologies.",
        "Collaborating with cross-functional teams including designers, product managers, and other developers to create high-quality products.",
        "Implementing responsive design and ensuring cross-browser compatibility.",
        "Participating in code reviews and providing constructive feedback to other developers.",
      ],
    },
    {
      title: "Aeronautical Engineering",
      company_name: "Erciyes University",
      icon: eru,
      location: "  Turkey",
      iconBg: "#383E56",
      date: "September 2018 - September 2022",
      points: [],
    },
  ],
  projects = [
    {
      name: "NakilPort",
      description:
        "NakilPort is a platform that connects carriers and shippers. It allows carriers to find loads and shippers to find carriers. The platform is built with Next.js and Firebase, and it features a responsive design, user authentication, and a restful API.",
      tags: [
        { name: "Next.js", color: "blue-text-gradient" },
        { name: "restFul API", color: "green-text-gradient" },
        { name: "Firebase", color: "pink-text-gradient" },
      ],
      demoLink: "https://nakilport.com/",
      image: nakilport,
      source_code_link: "https://nakilport.com/",
    },
    {
      name: "MercanSoft",
      description:
        "MercanSoft is a company website that shows the services and offers of the company. It is built css and javascript. It features a responsive design and a user-friendly interface.",
      tags: [
        { name: "HTML", color: "blue-text-gradient" },
        { name: "CSS", color: "green-text-gradient" },
        { name: "JavaScript", color: "pink-text-gradient" },
      ],
      demoLink: "https://mercansoft.vercel.app/",
      image: MercanSoft,
      source_code_link: "https://github.com/Aliozzaim/TravelExplorer",
    },
    {
      name: "3D Art Exhibition",
      description:
        "This project demonstrates my web development skills through visually appealing 3D scenes and animations. With a user-friendly interface on any device, the gallery seamlessly integrates interactive elements, showcasing the captivating potential of art and technology. ",
      tags: [
        { name: "JavaScript", color: "blue-text-gradient" },
        { name: "three.js", color: "green-text-gradient" },
        { name: "CSS", color: "pink-text-gradient" },
      ],
      demoLink: "https://3d-gallery-lime.vercel.app/",
      image: ecommerce,
      source_code_link: "https://3d-gallery-lime.vercel.app/",
    },
    {
      name: "Garden Planner",
      description:
        "AdTask is a web application that showcases a responsive image gallery with a Masonry layout. It allows users to explore a collection of images, view them in a modal, and navigate through a slideshow. The application also features a search functionality for easy image discovery.",
      tags: [
        { name: "JavaScript", color: "blue-text-gradient" },
        { name: "Masonry", color: "green-text-gradient" },
        { name: "css", color: "pink-text-gradient" },
      ],
      demoLink: "https://adtask-jet.vercel.app/",
      image: garden,
      source_code_link: "https://github.com/Aliozzaim/AdTask",
    },
    {
      name: "Trip Guide",
      description:
        "This project is a full-stack application that allows users to create, view, update, and delete places. It consists of a backend API built with Node.js, Express.js, and MongoDB, and a frontend user interface built with React.js.",
      tags: [
        { name: "react.js", color: "blue-text-gradient" },
        { name: "mongodb", color: "green-text-gradient" },
        { name: "Express.js", color: "pink-text-gradient" },
      ],
      demoLink: "https://github.com/Aliozzaim/TravelExplorer",
      image: tripguide,
      source_code_link: "https://github.com/Aliozzaim/TravelExplorer",
    },
  ],
  Navbar = () => {
    const [s, e] = reactExports.useState(""),
      [a, o] = reactExports.useState(!1),
      [c, d] = reactExports.useState(!1)
    return (
      reactExports.useEffect(() => {
        const g = () => {
          window.scrollY > 100 ? d(!0) : d(!1)
        }
        return (
          window.addEventListener("scroll", g),
          () => window.removeEventListener("scroll", g)
        )
      }, []),
      jsxRuntimeExports.jsx("nav", {
        className: `${
          styles.paddingX
        } w-full flex items-center py-5 fixed top-0 z-20 ${
          c ? "bg-primary" : "bg-transparent"
        }`,
        children: jsxRuntimeExports.jsxs("div", {
          className:
            "w-full flex justify-between items-center max-w-7xl mx-auto",
          children: [
            jsxRuntimeExports.jsx(Link, {
              to: "/",
              className: "flex items-center gap-2",
              onClick: () => {
                e(""), window.scrollTo(0, 0)
              },
              children: jsxRuntimeExports.jsxs("p", {
                className:
                  "text-white text-[18px] font-bold cursor-pointer flex ",
                children: [
                  "Ali Ozzaim ",
                  jsxRuntimeExports.jsx("span", {
                    className: "sm:block hidden",
                    children: " | Frontend Developer",
                  }),
                ],
              }),
            }),
            jsxRuntimeExports.jsx("ul", {
              className: "list-none hidden sm:flex flex-row gap-10",
              children: navLinks.map((g) =>
                jsxRuntimeExports.jsx(
                  "li",
                  {
                    className: `${
                      s === g.title ? "text-white" : "text-secondary"
                    } hover:text-white text-[18px] font-medium cursor-pointer`,
                    onClick: () => e(g.title),
                    children: jsxRuntimeExports.jsx("a", {
                      href: `#${g.id}`,
                      children: g.title,
                    }),
                  },
                  g.id
                )
              ),
            }),
            jsxRuntimeExports.jsxs("div", {
              className: "sm:hidden flex flex-1 justify-end items-center",
              children: [
                jsxRuntimeExports.jsx("img", {
                  src: a ? close : menu,
                  alt: "menu",
                  className: "w-[28px] h-[28px] object-contain",
                  onClick: () => o(!a),
                }),
                jsxRuntimeExports.jsx("div", {
                  className: `${
                    a ? "flex" : "hidden"
                  } p-6 black-gradient absolute top-20 right-0 mx-4 my-2 min-w-[140px] z-10 rounded-xl`,
                  children: jsxRuntimeExports.jsx("ul", {
                    className:
                      "list-none flex justify-end items-start flex-1 flex-col gap-4",
                    children: navLinks.map((g) =>
                      jsxRuntimeExports.jsx(
                        "li",
                        {
                          className: `font-poppins font-medium cursor-pointer text-[16px] ${
                            s === g.title ? "text-white" : "text-secondary"
                          }`,
                          onClick: () => {
                            o(!a), e(g.title)
                          },
                          children: jsxRuntimeExports.jsx("a", {
                            href: `#${g.id}`,
                            children: g.title,
                          }),
                        },
                        g.id
                      )
                    ),
                  }),
                }),
              ],
            }),
          ],
        }),
      })
    )
  }
var __defProp = Object.defineProperty,
  __defProps = Object.defineProperties,
  __getOwnPropDescs = Object.getOwnPropertyDescriptors,
  __getOwnPropSymbols = Object.getOwnPropertySymbols,
  __hasOwnProp = Object.prototype.hasOwnProperty,
  __propIsEnum = Object.prototype.propertyIsEnumerable,
  __defNormalProp = (s, e, a) =>
    e in s
      ? __defProp(s, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: a,
        })
      : (s[e] = a),
  __spreadValues = (s, e) => {
    for (var a in e || (e = {}))
      __hasOwnProp.call(e, a) && __defNormalProp(s, a, e[a])
    if (__getOwnPropSymbols)
      for (var a of __getOwnPropSymbols(e))
        __propIsEnum.call(e, a) && __defNormalProp(s, a, e[a])
    return s
  },
  __spreadProps = (s, e) => __defProps(s, __getOwnPropDescs(e)),
  Tilt = class extends reactExports.Component {
    constructor(s) {
      super(s), (this.ref = React.createRef()), (this.state = { style: {} })
      const e = {
        reverse: !1,
        max: 35,
        perspective: 1e3,
        easing: "cubic-bezier(.03,.98,.52,.99)",
        scale: "1.1",
        speed: "1000",
        transition: !0,
        axis: null,
        reset: !0,
      }
      ;(this.width = null),
        (this.height = null),
        (this.left = null),
        (this.top = null),
        (this.transitionTimeout = null),
        (this.updateCall = null),
        (this.element = null),
        (this.settings = Object.assign({}, e, this.props.options)),
        (this.reverse = this.settings.reverse ? -1 : 1),
        (this.onMouseEnter = this.onMouseEnter.bind(
          this,
          this.props.onMouseEnter
        )),
        (this.onMouseMove = this.onMouseMove.bind(
          this,
          this.props.onMouseMove
        )),
        (this.onMouseLeave = this.onMouseLeave.bind(
          this,
          this.props.onMouseLeave
        ))
    }
    componentDidMount() {
      ;(this.element = this.ref.current),
        setTimeout(() => {
          this.element.parentElement.querySelector(":hover") === this.element &&
            this.onMouseEnter()
        }, 0)
    }
    componentWillUnmount() {
      clearTimeout(this.transitionTimeout),
        cancelAnimationFrame(this.updateCall)
    }
    onMouseEnter(s = () => {}, e) {
      return (
        this.updateElementPosition(),
        this.setState(
          Object.assign({}, this.state, {
            style: __spreadProps(__spreadValues({}, this.state.style), {
              willChange: "transform",
            }),
          })
        ),
        this.setTransition(),
        s(e)
      )
    }
    reset() {
      window.requestAnimationFrame(() => {
        this.setState(
          Object.assign({}, this.state, {
            style: __spreadProps(__spreadValues({}, this.state.style), {
              transform: `perspective(${this.settings.perspective}px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`,
            }),
          })
        )
      })
    }
    onMouseMove(s = () => {}, e) {
      return (
        e.persist(),
        this.updateCall !== null &&
          window.cancelAnimationFrame(this.updateCall),
        (this.event = e),
        (this.updateCall = requestAnimationFrame(this.update.bind(this, e))),
        s(e)
      )
    }
    setTransition() {
      clearTimeout(this.transitionTimeout),
        this.setState(
          Object.assign({}, this.state, {
            style: __spreadProps(__spreadValues({}, this.state.style), {
              transition: `${this.settings.speed}ms ${this.settings.easing}`,
            }),
          })
        ),
        (this.transitionTimeout = setTimeout(() => {
          this.setState(
            Object.assign({}, this.state, {
              style: __spreadProps(__spreadValues({}, this.state.style), {
                transition: "",
              }),
            })
          )
        }, this.settings.speed))
    }
    onMouseLeave(s = () => {}, e) {
      return this.setTransition(), this.settings.reset && this.reset(), s(e)
    }
    getValues(s) {
      const e = (s.nativeEvent.clientX - this.left) / this.width,
        a = (s.nativeEvent.clientY - this.top) / this.height,
        o = Math.min(Math.max(e, 0), 1),
        c = Math.min(Math.max(a, 0), 1),
        d = (
          this.reverse *
          (this.settings.max / 2 - o * this.settings.max)
        ).toFixed(2),
        g = (
          this.reverse *
          (c * this.settings.max - this.settings.max / 2)
        ).toFixed(2),
        _ = o * 100,
        b = c * 100
      return { tiltX: d, tiltY: g, percentageX: _, percentageY: b }
    }
    updateElementPosition() {
      const s = this.element.getBoundingClientRect()
      ;(this.width = this.element.offsetWidth),
        (this.height = this.element.offsetHeight),
        (this.left = s.left),
        (this.top = s.top)
    }
    update(s) {
      const e = this.getValues(s)
      this.setState(
        Object.assign({}, this.state, {
          style: __spreadProps(__spreadValues({}, this.state.style), {
            transform: `perspective(${this.settings.perspective}px) rotateX(${
              this.settings.axis === "x" ? 0 : e.tiltY
            }deg) rotateY(${
              this.settings.axis === "y" ? 0 : e.tiltX
            }deg) scale3d(${this.settings.scale}, ${this.settings.scale}, ${
              this.settings.scale
            })`,
          }),
        })
      ),
        (this.updateCall = null)
    }
    render() {
      const s = Object.assign({}, this.props.style, this.state.style)
      return jsxRuntimeExports.jsx("div", {
        style: s,
        ref: this.ref,
        className: this.props.className,
        onMouseEnter: this.onMouseEnter,
        onMouseMove: this.onMouseMove,
        onMouseLeave: this.onMouseLeave,
        children: this.props.children,
      })
    }
  }
const textVariant = (s) => ({
    hidden: { y: -50, opacity: 0 },
    show: {
      y: 0,
      opacity: 1,
      transition: { type: "spring", duration: 1.25, delay: s },
    },
  }),
  fadeIn = (s, e, a, o) => ({
    hidden: {
      x: s === "left" ? 100 : s === "right" ? -100 : 0,
      y: s === "up" ? 100 : s === "down" ? -100 : 0,
      opacity: 0,
    },
    show: {
      x: 0,
      y: 0,
      opacity: 1,
      transition: { type: e, delay: a, duration: o, ease: "easeOut" },
    },
  }),
  slideIn = (s, e, a, o) => ({
    hidden: {
      x: s === "left" ? "-100%" : s === "right" ? "100%" : 0,
      y: s === "up" || s === "down" ? "100%" : 0,
    },
    show: {
      x: 0,
      y: 0,
      transition: { type: e, delay: a, duration: o, ease: "easeOut" },
    },
  }),
  staggerContainer = (s, e) => ({
    hidden: {},
    show: { transition: { staggerChildren: s, delayChildren: e || 0 } },
  }),
  StarWrapper = (s, e) =>
    function () {
      return jsxRuntimeExports.jsxs(motion.section, {
        variants: staggerContainer(),
        initial: "hidden",
        whileInView: "show",
        viewport: { once: !0, amount: 0.25 },
        className: `${styles.padding} max-w-7xl mx-auto relative z-0`,
        children: [
          jsxRuntimeExports.jsx("span", {
            className: "hash-span",
            id: e,
            children: "",
          }),
          jsxRuntimeExports.jsx(s, {}),
        ],
      })
    },
  ServiceCard = ({ index: s, title: e, icon: a }) =>
    jsxRuntimeExports.jsx(Tilt, {
      className: "xs:w-[250px] w-full",
      children: jsxRuntimeExports.jsx(motion.div, {
        variants: fadeIn("right", "spring", s * 0.5, 0.75),
        className:
          "w-full green-pink-gradient p-[1px] rounded-[20px] shadow-card",
        children: jsxRuntimeExports.jsxs("div", {
          options: { max: 45, scale: 1, speed: 450 },
          className:
            "bg-tertiary rounded-[20px] py-5 px-12 min-h-[280px] flex justify-evenly items-center flex-col",
          children: [
            jsxRuntimeExports.jsx("img", {
              src: a,
              alt: "web-development",
              className: "w-16 h-16 object-contain",
            }),
            jsxRuntimeExports.jsx("h3", {
              className: "text-white text-[20px] font-bold text-center",
              children: e,
            }),
          ],
        }),
      }),
    }),
  About = () =>
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsxs(motion.div, {
          variants: textVariant(),
          children: [
            jsxRuntimeExports.jsx("p", {
              className: styles.sectionSubText,
              children: "Introduction",
            }),
            jsxRuntimeExports.jsx("h2", {
              className: styles.sectionHeadText,
              children: "Overview.",
            }),
          ],
        }),
        jsxRuntimeExports.jsx(motion.p, {
          variants: fadeIn("", "", 0.1, 1),
          className: "mt-4 text-secondary text-[17px] max-w-3xl leading-[30px]",
          children:
            "I'm a skilled software developer with experience in TypeScript and JavaScript, and expertise in frameworks like React, Node.js, and Three.js. I'm a quick learner and collaborate closely with clients to create efficient, scalable, and user-friendly solutions that solve real-world problems. Let's work together to bring your ideas to life!",
        }),
        jsxRuntimeExports.jsx("div", {
          className: "mt-20 flex flex-wrap gap-10",
          children: services.map((s, e) =>
            jsxRuntimeExports.jsx(ServiceCard, { index: e, ...s }, s.title)
          ),
        }),
      ],
    }),
  About$1 = StarWrapper(About, "about"),
  Tech = () =>
    jsxRuntimeExports.jsx("div", {
      className: "flex flex-row flex-wrap justify-center gap-10",
      children: technologies.map((s) =>
        jsxRuntimeExports.jsx(
          "div",
          {
            className: "w-25 h-25",
            children: jsxRuntimeExports.jsx("div", {
              className: "cursor-pointer",
              children: jsxRuntimeExports.jsx(BallCanvas, { icon: s.icon }),
            }),
          },
          s.name
        )
      ),
    }),
  Tech$1 = StarWrapper(Tech, "")
var VerticalTimeline$1 = {},
  classnames = { exports: {} }
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ ;(function (s) {
  ;(function () {
    var e = {}.hasOwnProperty
    function a() {
      for (var o = [], c = 0; c < arguments.length; c++) {
        var d = arguments[c]
        if (d) {
          var g = typeof d
          if (g === "string" || g === "number") o.push(d)
          else if (Array.isArray(d)) {
            if (d.length) {
              var _ = a.apply(null, d)
              _ && o.push(_)
            }
          } else if (g === "object") {
            if (
              d.toString !== Object.prototype.toString &&
              !d.toString.toString().includes("[native code]")
            ) {
              o.push(d.toString())
              continue
            }
            for (var b in d) e.call(d, b) && d[b] && o.push(b)
          }
        }
      }
      return o.join(" ")
    }
    s.exports ? ((a.default = a), (s.exports = a)) : (window.classNames = a)
  })()
})(classnames)
var classnamesExports = classnames.exports
VerticalTimeline$1.__esModule = !0
VerticalTimeline$1.default = void 0
var _react$1 = _interopRequireDefault$1(reactExports),
  _propTypes$1 = _interopRequireDefault$1(propTypesExports),
  _classnames$1 = _interopRequireDefault$1(classnamesExports)
function _interopRequireDefault$1(s) {
  return s && s.__esModule ? s : { default: s }
}
const VerticalTimeline = ({
  animate: s = !0,
  className: e = "",
  layout: a = "2-columns",
  lineColor: o = "#FFF",
  children: c,
}) => (
  typeof window == "object" &&
    document.documentElement.style.setProperty("--line-color", o),
  _react$1.default.createElement(
    "div",
    {
      className: (0, _classnames$1.default)(e, "vertical-timeline", {
        "vertical-timeline--animate": s,
        "vertical-timeline--two-columns": a === "2-columns",
        "vertical-timeline--one-column-left":
          a === "1-column" || a === "1-column-left",
        "vertical-timeline--one-column-right": a === "1-column-right",
      }),
    },
    c
  )
)
VerticalTimeline.propTypes = {
  children: _propTypes$1.default.oneOfType([
    _propTypes$1.default.arrayOf(_propTypes$1.default.node),
    _propTypes$1.default.node,
  ]).isRequired,
  className: _propTypes$1.default.string,
  animate: _propTypes$1.default.bool,
  layout: _propTypes$1.default.oneOf([
    "1-column-left",
    "1-column",
    "2-columns",
    "1-column-right",
  ]),
  lineColor: _propTypes$1.default.string,
}
var _default$1 = VerticalTimeline
VerticalTimeline$1.default = _default$1
var VerticalTimelineElement$1 = {}
function _extends() {
  return (
    (_extends =
      Object.assign ||
      function (s) {
        for (var e = 1; e < arguments.length; e++) {
          var a = arguments[e]
          for (var o in a)
            Object.prototype.hasOwnProperty.call(a, o) && (s[o] = a[o])
        }
        return s
      }),
    _extends.apply(this, arguments)
  )
}
function _inheritsLoose(s, e) {
  ;(s.prototype = Object.create(e.prototype)),
    (s.prototype.constructor = s),
    _setPrototypeOf(s, e)
}
function _setPrototypeOf(s, e) {
  return (
    (_setPrototypeOf =
      Object.setPrototypeOf ||
      function (o, c) {
        return (o.__proto__ = c), o
      }),
    _setPrototypeOf(s, e)
  )
}
function _objectWithoutPropertiesLoose$1(s, e) {
  if (s == null) return {}
  var a = {},
    o = Object.keys(s),
    c,
    d
  for (d = 0; d < o.length; d++)
    (c = o[d]), !(e.indexOf(c) >= 0) && (a[c] = s[c])
  return a
}
var observerMap = new Map(),
  RootIds = new WeakMap(),
  rootId = 0,
  unsupportedValue = void 0
function defaultFallbackInView(s) {
  unsupportedValue = s
}
function getRootId(s) {
  return s
    ? (RootIds.has(s) || ((rootId += 1), RootIds.set(s, rootId.toString())),
      RootIds.get(s))
    : "0"
}
function optionsToId(s) {
  return Object.keys(s)
    .sort()
    .filter(function (e) {
      return s[e] !== void 0
    })
    .map(function (e) {
      return e + "_" + (e === "root" ? getRootId(s.root) : s[e])
    })
    .toString()
}
function createObserver(s) {
  var e = optionsToId(s),
    a = observerMap.get(e)
  if (!a) {
    var o = new Map(),
      c,
      d = new IntersectionObserver(function (g) {
        g.forEach(function (_) {
          var b,
            j =
              _.isIntersecting &&
              c.some(function ($) {
                return _.intersectionRatio >= $
              })
          s.trackVisibility && typeof _.isVisible > "u" && (_.isVisible = j),
            (b = o.get(_.target)) == null ||
              b.forEach(function ($) {
                $(j, _)
              })
        })
      }, s)
    ;(c =
      d.thresholds ||
      (Array.isArray(s.threshold) ? s.threshold : [s.threshold || 0])),
      (a = { id: e, observer: d, elements: o }),
      observerMap.set(e, a)
  }
  return a
}
function observe(s, e, a, o) {
  if (
    (a === void 0 && (a = {}),
    o === void 0 && (o = unsupportedValue),
    typeof window.IntersectionObserver > "u" && o !== void 0)
  ) {
    var c = s.getBoundingClientRect()
    return (
      e(o, {
        isIntersecting: o,
        target: s,
        intersectionRatio: typeof a.threshold == "number" ? a.threshold : 0,
        time: 0,
        boundingClientRect: c,
        intersectionRect: c,
        rootBounds: c,
      }),
      function () {}
    )
  }
  var d = createObserver(a),
    g = d.id,
    _ = d.observer,
    b = d.elements,
    j = b.get(s) || []
  return (
    b.has(s) || b.set(s, j),
    j.push(e),
    _.observe(s),
    function () {
      j.splice(j.indexOf(e), 1),
        j.length === 0 && (b.delete(s), _.unobserve(s)),
        b.size === 0 && (_.disconnect(), observerMap.delete(g))
    }
  )
}
var _excluded$2 = [
  "children",
  "as",
  "triggerOnce",
  "threshold",
  "root",
  "rootMargin",
  "onChange",
  "skip",
  "trackVisibility",
  "delay",
  "initialInView",
  "fallbackInView",
]
function isPlainChildren(s) {
  return typeof s.children != "function"
}
var InView = (function (s) {
  _inheritsLoose(e, s)
  function e(o) {
    var c
    return (
      (c = s.call(this, o) || this),
      (c.node = null),
      (c._unobserveCb = null),
      (c.handleNode = function (d) {
        c.node &&
          (c.unobserve(),
          !d &&
            !c.props.triggerOnce &&
            !c.props.skip &&
            c.setState({ inView: !!c.props.initialInView, entry: void 0 })),
          (c.node = d || null),
          c.observeNode()
      }),
      (c.handleChange = function (d, g) {
        d && c.props.triggerOnce && c.unobserve(),
          isPlainChildren(c.props) || c.setState({ inView: d, entry: g }),
          c.props.onChange && c.props.onChange(d, g)
      }),
      (c.state = { inView: !!o.initialInView, entry: void 0 }),
      c
    )
  }
  var a = e.prototype
  return (
    (a.componentDidUpdate = function (c) {
      ;(c.rootMargin !== this.props.rootMargin ||
        c.root !== this.props.root ||
        c.threshold !== this.props.threshold ||
        c.skip !== this.props.skip ||
        c.trackVisibility !== this.props.trackVisibility ||
        c.delay !== this.props.delay) &&
        (this.unobserve(), this.observeNode())
    }),
    (a.componentWillUnmount = function () {
      this.unobserve(), (this.node = null)
    }),
    (a.observeNode = function () {
      if (!(!this.node || this.props.skip)) {
        var c = this.props,
          d = c.threshold,
          g = c.root,
          _ = c.rootMargin,
          b = c.trackVisibility,
          j = c.delay,
          $ = c.fallbackInView
        this._unobserveCb = observe(
          this.node,
          this.handleChange,
          {
            threshold: d,
            root: g,
            rootMargin: _,
            trackVisibility: b,
            delay: j,
          },
          $
        )
      }
    }),
    (a.unobserve = function () {
      this._unobserveCb && (this._unobserveCb(), (this._unobserveCb = null))
    }),
    (a.render = function () {
      if (!isPlainChildren(this.props)) {
        var c = this.state,
          d = c.inView,
          g = c.entry
        return this.props.children({
          inView: d,
          entry: g,
          ref: this.handleNode,
        })
      }
      var _ = this.props,
        b = _.children,
        j = _.as,
        $ = _objectWithoutPropertiesLoose$1(_, _excluded$2)
      return reactExports.createElement(
        j || "div",
        _extends({ ref: this.handleNode }, $),
        b
      )
    }),
    e
  )
})(reactExports.Component)
InView.displayName = "InView"
InView.defaultProps = { threshold: 0, triggerOnce: !1, initialInView: !1 }
function useInView(s) {
  var e = s === void 0 ? {} : s,
    a = e.threshold,
    o = e.delay,
    c = e.trackVisibility,
    d = e.rootMargin,
    g = e.root,
    _ = e.triggerOnce,
    b = e.skip,
    j = e.initialInView,
    $ = e.fallbackInView,
    _e = reactExports.useRef(),
    tt = reactExports.useState({ inView: !!j }),
    st = tt[0],
    at = tt[1],
    ot = reactExports.useCallback(
      function (it) {
        _e.current !== void 0 && (_e.current(), (_e.current = void 0)),
          !b &&
            it &&
            (_e.current = observe(
              it,
              function (ct, lt) {
                at({ inView: ct, entry: lt }),
                  lt.isIntersecting &&
                    _ &&
                    _e.current &&
                    (_e.current(), (_e.current = void 0))
              },
              {
                root: g,
                rootMargin: d,
                threshold: a,
                trackVisibility: c,
                delay: o,
              },
              $
            ))
      },
      [Array.isArray(a) ? a.toString() : a, g, d, _, b, c, $, o]
    )
  reactExports.useEffect(function () {
    !_e.current && st.entry && !_ && !b && at({ inView: !!j })
  })
  var ut = [ot, st.inView, st.entry]
  return (ut.ref = ut[0]), (ut.inView = ut[1]), (ut.entry = ut[2]), ut
}
const reactIntersectionObserver_m = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        InView,
        default: InView,
        defaultFallbackInView,
        observe,
        useInView,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  require$$3 = getAugmentedNamespace(reactIntersectionObserver_m)
VerticalTimelineElement$1.__esModule = !0
VerticalTimelineElement$1.default = void 0
var _react = _interopRequireDefault(reactExports),
  _propTypes = _interopRequireDefault(propTypesExports),
  _classnames = _interopRequireDefault(classnamesExports),
  _reactIntersectionObserver = require$$3
function _interopRequireDefault(s) {
  return s && s.__esModule ? s : { default: s }
}
const VerticalTimelineElement = ({
  children: s = "",
  className: e = "",
  contentArrowStyle: a = null,
  contentStyle: o = null,
  date: c = "",
  dateClassName: d = "",
  icon: g = null,
  iconClassName: _ = "",
  iconOnClick: b = null,
  onTimelineElementClick: j = null,
  iconStyle: $ = null,
  id: _e = "",
  position: tt = "",
  style: st = null,
  textClassName: at = "",
  intersectionObserverProps: ot = {
    rootMargin: "0px 0px -40px 0px",
    triggerOnce: !0,
  },
  visible: ut = !1,
}) =>
  _react.default.createElement(
    _reactIntersectionObserver.InView,
    ot,
    ({ inView: it, ref: ct }) =>
      _react.default.createElement(
        "div",
        {
          ref: ct,
          id: _e,
          className: (0, _classnames.default)(e, "vertical-timeline-element", {
            "vertical-timeline-element--left": tt === "left",
            "vertical-timeline-element--right": tt === "right",
            "vertical-timeline-element--no-children": s === "",
          }),
          style: st,
        },
        _react.default.createElement(
          _react.default.Fragment,
          null,
          _react.default.createElement(
            "span",
            {
              style: $,
              onClick: b,
              className: (0, _classnames.default)(
                _,
                "vertical-timeline-element-icon",
                { "bounce-in": it || ut, "": !(it || ut) }
              ),
            },
            g
          ),
          _react.default.createElement(
            "div",
            {
              style: o,
              onClick: j,
              className: (0, _classnames.default)(
                at,
                "vertical-timeline-element-content",
                { "bounce-in": it || ut, "": !(it || ut) }
              ),
            },
            _react.default.createElement("div", {
              style: a,
              className: "vertical-timeline-element-content-arrow",
            }),
            s,
            _react.default.createElement(
              "span",
              {
                className: (0, _classnames.default)(
                  d,
                  "vertical-timeline-element-date"
                ),
              },
              c
            )
          )
        )
      )
  )
VerticalTimelineElement.propTypes = {
  children: _propTypes.default.oneOfType([
    _propTypes.default.arrayOf(_propTypes.default.node),
    _propTypes.default.node,
  ]),
  className: _propTypes.default.string,
  contentArrowStyle: _propTypes.default.shape({}),
  contentStyle: _propTypes.default.shape({}),
  date: _propTypes.default.node,
  dateClassName: _propTypes.default.string,
  icon: _propTypes.default.element,
  iconClassName: _propTypes.default.string,
  iconStyle: _propTypes.default.shape({}),
  iconOnClick: _propTypes.default.func,
  onTimelineElementClick: _propTypes.default.func,
  id: _propTypes.default.string,
  position: _propTypes.default.string,
  style: _propTypes.default.shape({}),
  textClassName: _propTypes.default.string,
  visible: _propTypes.default.bool,
  intersectionObserverProps: _propTypes.default.shape({
    root: _propTypes.default.object,
    rootMargin: _propTypes.default.string,
    threshold: _propTypes.default.number,
    triggerOnce: _propTypes.default.bool,
  }),
}
var _default = VerticalTimelineElement
VerticalTimelineElement$1.default = _default
var distEs6 = {
  VerticalTimeline: VerticalTimeline$1.default,
  VerticalTimelineElement: VerticalTimelineElement$1.default,
}
const style_min = "",
  ExperienceCard = ({ experience: s }) =>
    jsxRuntimeExports.jsxs(distEs6.VerticalTimelineElement, {
      contentStyle: { background: "#1d1836", color: "#fff" },
      contentArrowStyle: { borderRight: "15px solid  #232631" },
      date: s.date,
      location: s.location,
      iconStyle: { background: s.iconBg },
      icon: jsxRuntimeExports.jsx("div", {
        className: "flex justify-center items-center w-full h-full  ",
        children: jsxRuntimeExports.jsx("img", {
          src: s.icon,
          alt: s.company_name,
          className: "w-[100%] h-[100%] object-contain rounded-full ",
        }),
      }),
      children: [
        jsxRuntimeExports.jsxs("div", {
          children: [
            jsxRuntimeExports.jsx("h3", {
              className: "text-white text-[24px] font-bold",
              children: s.title,
            }),
            jsxRuntimeExports.jsx("p", {
              className: "text-secondary text-[16px] font-semibold",
              style: { margin: 0 },
              children: s.company_name,
            }),
          ],
        }),
        jsxRuntimeExports.jsx("ul", {
          className: "mt-5 list-disc ml-5 space-y-2",
          children: s.points.map((e, a) =>
            jsxRuntimeExports.jsx(
              "li",
              {
                className: "text-white-100 text-[14px] pl-1 tracking-wider",
                children: e,
              },
              `experience-point-${a}`
            )
          ),
        }),
      ],
    }),
  Experience = () =>
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsxs(motion.div, {
          variants: textVariant(),
          children: [
            jsxRuntimeExports.jsx("p", {
              className: `${styles.sectionSubText} text-center`,
              children: "What I have done so far",
            }),
            jsxRuntimeExports.jsx("h2", {
              className: `${styles.sectionHeadText} text-center`,
              children: "Work Experience.",
            }),
          ],
        }),
        jsxRuntimeExports.jsx("div", {
          className: "mt-20 flex flex-col",
          children: jsxRuntimeExports.jsx(distEs6.VerticalTimeline, {
            children: experiences.map((s, e) =>
              jsxRuntimeExports.jsx(
                ExperienceCard,
                { experience: s },
                `experience-${e}`
              )
            ),
          }),
        }),
      ],
    }),
  Experience$1 = StarWrapper(Experience, "work"),
  ProjectCard = ({
    index: s,
    name: e,
    description: a,
    tags: o,
    image: c,
    source_code_link: d,
    demoLink: g,
  }) =>
    jsxRuntimeExports.jsx(motion.div, {
      variants: fadeIn("up", "spring", s * 0.5, 0.75),
      children: jsxRuntimeExports.jsxs(Tilt, {
        options: { max: 45, scale: 1, speed: 450 },
        className: "bg-tertiary p-5 rounded-2xl sm:w-[360px] w-full",
        children: [
          jsxRuntimeExports.jsxs("div", {
            onClick: () => window.open(g, "_blank"),
            className: "relative w-full h-[230px]  cursor-pointer",
            children: [
              jsxRuntimeExports.jsx("img", {
                src: c,
                alt: "project_image",
                className: "w-full h-full object-cover rounded-2xl",
              }),
              jsxRuntimeExports.jsx("div", {
                className:
                  "absolute inset-0 flex justify-end m-3 card-img_hover",
                children: jsxRuntimeExports.jsx("div", {
                  onClick: () => window.open(d, "_blank"),
                  className:
                    "black-gradient w-10 h-10 rounded-full flex justify-center items-center cursor-pointer",
                  children: jsxRuntimeExports.jsx("img", {
                    src: github,
                    alt: "source code",
                    className: "w-1/2 h-1/2 object-contain",
                  }),
                }),
              }),
            ],
          }),
          jsxRuntimeExports.jsxs("div", {
            className: "mt-5",
            children: [
              jsxRuntimeExports.jsx("h3", {
                className: "text-white font-bold text-[24px]",
                children: e,
              }),
              jsxRuntimeExports.jsx("p", {
                className: "mt-2 text-secondary text-[14px]",
                children: a,
              }),
            ],
          }),
          jsxRuntimeExports.jsx("div", {
            className: "mt-4 flex flex-wrap gap-2",
            children: o.map((_) =>
              jsxRuntimeExports.jsxs(
                "p",
                {
                  className: `text-[14px] ${_.color}`,
                  children: ["#", _.name],
                },
                `${e}-${_.name}`
              )
            ),
          }),
        ],
      }),
    }),
  Works = () =>
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsxs(motion.div, {
          variants: textVariant(),
          children: [
            jsxRuntimeExports.jsx("p", {
              className: `${styles.sectionSubText} `,
              children: "My work",
            }),
            jsxRuntimeExports.jsx("h2", {
              className: `${styles.sectionHeadText}`,
              children: "Projects.",
            }),
          ],
        }),
        jsxRuntimeExports.jsx("div", {
          className: "w-full flex",
          children: jsxRuntimeExports.jsx(motion.p, {
            variants: fadeIn("", "", 0.1, 1),
            className:
              "mt-3 text-secondary text-[17px] max-w-3xl leading-[30px]",
            children:
              "Following projects showcases my skills and experience through real-world examples of my work. Each project is briefly described with links to code repositories and live demos in it. It reflects my ability to solve complex problems, work with different technologies, and manage projects effectively.",
          }),
        }),
        jsxRuntimeExports.jsx("div", {
          className: "mt-20 flex flex-wrap gap-7",
          children: projects.map((s, e) =>
            jsxRuntimeExports.jsx(
              ProjectCard,
              { index: e, ...s },
              `project-${e}`
            )
          ),
        }),
      ],
    }),
  Works$1 = StarWrapper(Works, "")
var lottie$1 = { exports: {} }
;(function (module, exports) {
  typeof navigator < "u" &&
    (function (s, e) {
      module.exports = e()
    })(commonjsGlobal, function () {
      var svgNS = "http://www.w3.org/2000/svg",
        locationHref = "",
        _useWebWorker = !1,
        initialDefaultFrame = -999999,
        setWebWorker = function (e) {
          _useWebWorker = !!e
        },
        getWebWorker = function () {
          return _useWebWorker
        },
        setLocationHref = function (e) {
          locationHref = e
        },
        getLocationHref = function () {
          return locationHref
        }
      function createTag(s) {
        return document.createElement(s)
      }
      function extendPrototype(s, e) {
        var a,
          o = s.length,
          c
        for (a = 0; a < o; a += 1) {
          c = s[a].prototype
          for (var d in c)
            Object.prototype.hasOwnProperty.call(c, d) &&
              (e.prototype[d] = c[d])
        }
      }
      function getDescriptor(s, e) {
        return Object.getOwnPropertyDescriptor(s, e)
      }
      function createProxyFunction(s) {
        function e() {}
        return (e.prototype = s), e
      }
      var audioControllerFactory = (function () {
          function s(e) {
            ;(this.audios = []),
              (this.audioFactory = e),
              (this._volume = 1),
              (this._isMuted = !1)
          }
          return (
            (s.prototype = {
              addAudio: function (a) {
                this.audios.push(a)
              },
              pause: function () {
                var a,
                  o = this.audios.length
                for (a = 0; a < o; a += 1) this.audios[a].pause()
              },
              resume: function () {
                var a,
                  o = this.audios.length
                for (a = 0; a < o; a += 1) this.audios[a].resume()
              },
              setRate: function (a) {
                var o,
                  c = this.audios.length
                for (o = 0; o < c; o += 1) this.audios[o].setRate(a)
              },
              createAudio: function (a) {
                return this.audioFactory
                  ? this.audioFactory(a)
                  : window.Howl
                  ? new window.Howl({ src: [a] })
                  : {
                      isPlaying: !1,
                      play: function () {
                        this.isPlaying = !0
                      },
                      seek: function () {
                        this.isPlaying = !1
                      },
                      playing: function () {},
                      rate: function () {},
                      setVolume: function () {},
                    }
              },
              setAudioFactory: function (a) {
                this.audioFactory = a
              },
              setVolume: function (a) {
                ;(this._volume = a), this._updateVolume()
              },
              mute: function () {
                ;(this._isMuted = !0), this._updateVolume()
              },
              unmute: function () {
                ;(this._isMuted = !1), this._updateVolume()
              },
              getVolume: function () {
                return this._volume
              },
              _updateVolume: function () {
                var a,
                  o = this.audios.length
                for (a = 0; a < o; a += 1)
                  this.audios[a].volume(this._volume * (this._isMuted ? 0 : 1))
              },
            }),
            function () {
              return new s()
            }
          )
        })(),
        createTypedArray = (function () {
          function s(a, o) {
            var c = 0,
              d = [],
              g
            switch (a) {
              case "int16":
              case "uint8c":
                g = 1
                break
              default:
                g = 1.1
                break
            }
            for (c = 0; c < o; c += 1) d.push(g)
            return d
          }
          function e(a, o) {
            return a === "float32"
              ? new Float32Array(o)
              : a === "int16"
              ? new Int16Array(o)
              : a === "uint8c"
              ? new Uint8ClampedArray(o)
              : s(a, o)
          }
          return typeof Uint8ClampedArray == "function" &&
            typeof Float32Array == "function"
            ? e
            : s
        })()
      function createSizedArray(s) {
        return Array.apply(null, { length: s })
      }
      function _typeof$6(s) {
        "@babel/helpers - typeof"
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$6 = function (a) {
                return typeof a
              })
            : (_typeof$6 = function (a) {
                return a &&
                  typeof Symbol == "function" &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a
              }),
          _typeof$6(s)
        )
      }
      var subframeEnabled = !0,
        expressionsPlugin = null,
        expressionsInterfaces = null,
        idPrefix$1 = "",
        isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
        bmPow = Math.pow,
        bmSqrt = Math.sqrt,
        bmFloor = Math.floor,
        bmMax = Math.max,
        bmMin = Math.min,
        BMMath = {}
      ;(function () {
        var s = [
            "abs",
            "acos",
            "acosh",
            "asin",
            "asinh",
            "atan",
            "atanh",
            "atan2",
            "ceil",
            "cbrt",
            "expm1",
            "clz32",
            "cos",
            "cosh",
            "exp",
            "floor",
            "fround",
            "hypot",
            "imul",
            "log",
            "log1p",
            "log2",
            "log10",
            "max",
            "min",
            "pow",
            "random",
            "round",
            "sign",
            "sin",
            "sinh",
            "sqrt",
            "tan",
            "tanh",
            "trunc",
            "E",
            "LN10",
            "LN2",
            "LOG10E",
            "LOG2E",
            "PI",
            "SQRT1_2",
            "SQRT2",
          ],
          e,
          a = s.length
        for (e = 0; e < a; e += 1) BMMath[s[e]] = Math[s[e]]
      })(),
        (BMMath.random = Math.random),
        (BMMath.abs = function (s) {
          var e = _typeof$6(s)
          if (e === "object" && s.length) {
            var a = createSizedArray(s.length),
              o,
              c = s.length
            for (o = 0; o < c; o += 1) a[o] = Math.abs(s[o])
            return a
          }
          return Math.abs(s)
        })
      var defaultCurveSegments = 150,
        degToRads = Math.PI / 180,
        roundCorner = 0.5519
      function styleDiv(s) {
        ;(s.style.position = "absolute"),
          (s.style.top = 0),
          (s.style.left = 0),
          (s.style.display = "block"),
          (s.style.transformOrigin = "0 0"),
          (s.style.webkitTransformOrigin = "0 0"),
          (s.style.backfaceVisibility = "visible"),
          (s.style.webkitBackfaceVisibility = "visible"),
          (s.style.transformStyle = "preserve-3d"),
          (s.style.webkitTransformStyle = "preserve-3d"),
          (s.style.mozTransformStyle = "preserve-3d")
      }
      function BMEnterFrameEvent(s, e, a, o) {
        ;(this.type = s),
          (this.currentTime = e),
          (this.totalTime = a),
          (this.direction = o < 0 ? -1 : 1)
      }
      function BMCompleteEvent(s, e) {
        ;(this.type = s), (this.direction = e < 0 ? -1 : 1)
      }
      function BMCompleteLoopEvent(s, e, a, o) {
        ;(this.type = s),
          (this.currentLoop = a),
          (this.totalLoops = e),
          (this.direction = o < 0 ? -1 : 1)
      }
      function BMSegmentStartEvent(s, e, a) {
        ;(this.type = s), (this.firstFrame = e), (this.totalFrames = a)
      }
      function BMDestroyEvent(s, e) {
        ;(this.type = s), (this.target = e)
      }
      function BMRenderFrameErrorEvent(s, e) {
        ;(this.type = "renderFrameError"),
          (this.nativeError = s),
          (this.currentTime = e)
      }
      function BMConfigErrorEvent(s) {
        ;(this.type = "configError"), (this.nativeError = s)
      }
      var createElementID = (function () {
        var s = 0
        return function () {
          return (s += 1), idPrefix$1 + "__lottie_element_" + s
        }
      })()
      function HSVtoRGB(s, e, a) {
        var o, c, d, g, _, b, j, $
        switch (
          ((g = Math.floor(s * 6)),
          (_ = s * 6 - g),
          (b = a * (1 - e)),
          (j = a * (1 - _ * e)),
          ($ = a * (1 - (1 - _) * e)),
          g % 6)
        ) {
          case 0:
            ;(o = a), (c = $), (d = b)
            break
          case 1:
            ;(o = j), (c = a), (d = b)
            break
          case 2:
            ;(o = b), (c = a), (d = $)
            break
          case 3:
            ;(o = b), (c = j), (d = a)
            break
          case 4:
            ;(o = $), (c = b), (d = a)
            break
          case 5:
            ;(o = a), (c = b), (d = j)
            break
        }
        return [o, c, d]
      }
      function RGBtoHSV(s, e, a) {
        var o = Math.max(s, e, a),
          c = Math.min(s, e, a),
          d = o - c,
          g,
          _ = o === 0 ? 0 : d / o,
          b = o / 255
        switch (o) {
          case c:
            g = 0
            break
          case s:
            ;(g = e - a + d * (e < a ? 6 : 0)), (g /= 6 * d)
            break
          case e:
            ;(g = a - s + d * 2), (g /= 6 * d)
            break
          case a:
            ;(g = s - e + d * 4), (g /= 6 * d)
            break
        }
        return [g, _, b]
      }
      function addSaturationToRGB(s, e) {
        var a = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255)
        return (
          (a[1] += e),
          a[1] > 1 ? (a[1] = 1) : a[1] <= 0 && (a[1] = 0),
          HSVtoRGB(a[0], a[1], a[2])
        )
      }
      function addBrightnessToRGB(s, e) {
        var a = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255)
        return (
          (a[2] += e),
          a[2] > 1 ? (a[2] = 1) : a[2] < 0 && (a[2] = 0),
          HSVtoRGB(a[0], a[1], a[2])
        )
      }
      function addHueToRGB(s, e) {
        var a = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255)
        return (
          (a[0] += e / 360),
          a[0] > 1 ? (a[0] -= 1) : a[0] < 0 && (a[0] += 1),
          HSVtoRGB(a[0], a[1], a[2])
        )
      }
      var rgbToHex = (function () {
          var s = [],
            e,
            a
          for (e = 0; e < 256; e += 1)
            (a = e.toString(16)), (s[e] = a.length === 1 ? "0" + a : a)
          return function (o, c, d) {
            return (
              o < 0 && (o = 0),
              c < 0 && (c = 0),
              d < 0 && (d = 0),
              "#" + s[o] + s[c] + s[d]
            )
          }
        })(),
        setSubframeEnabled = function (e) {
          subframeEnabled = !!e
        },
        getSubframeEnabled = function () {
          return subframeEnabled
        },
        setExpressionsPlugin = function (e) {
          expressionsPlugin = e
        },
        getExpressionsPlugin = function () {
          return expressionsPlugin
        },
        setExpressionInterfaces = function (e) {
          expressionsInterfaces = e
        },
        getExpressionInterfaces = function () {
          return expressionsInterfaces
        },
        setDefaultCurveSegments = function (e) {
          defaultCurveSegments = e
        },
        getDefaultCurveSegments = function () {
          return defaultCurveSegments
        },
        setIdPrefix = function (e) {
          idPrefix$1 = e
        }
      function createNS(s) {
        return document.createElementNS(svgNS, s)
      }
      function _typeof$5(s) {
        "@babel/helpers - typeof"
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$5 = function (a) {
                return typeof a
              })
            : (_typeof$5 = function (a) {
                return a &&
                  typeof Symbol == "function" &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a
              }),
          _typeof$5(s)
        )
      }
      var dataManager = (function () {
          var s = 1,
            e = [],
            a,
            o,
            c = {
              onmessage: function () {},
              postMessage: function (st) {
                a({ data: st })
              },
            },
            d = {
              postMessage: function (st) {
                c.onmessage({ data: st })
              },
            }
          function g(tt) {
            if (window.Worker && window.Blob && getWebWorker()) {
              var st = new Blob(
                  ["var _workerSelf = self; self.onmessage = ", tt.toString()],
                  { type: "text/javascript" }
                ),
                at = URL.createObjectURL(st)
              return new Worker(at)
            }
            return (a = tt), c
          }
          function _() {
            o ||
              ((o = g(function (st) {
                function at() {
                  function ut(Dt, Mt) {
                    var wt,
                      gt,
                      At = Dt.length,
                      bt,
                      Tt,
                      It,
                      $t
                    for (gt = 0; gt < At; gt += 1)
                      if (((wt = Dt[gt]), "ks" in wt && !wt.completed)) {
                        if (((wt.completed = !0), wt.hasMask)) {
                          var Xt = wt.masksProperties
                          for (Tt = Xt.length, bt = 0; bt < Tt; bt += 1)
                            if (Xt[bt].pt.k.i) dt(Xt[bt].pt.k)
                            else
                              for (
                                $t = Xt[bt].pt.k.length, It = 0;
                                It < $t;
                                It += 1
                              )
                                Xt[bt].pt.k[It].s && dt(Xt[bt].pt.k[It].s[0]),
                                  Xt[bt].pt.k[It].e && dt(Xt[bt].pt.k[It].e[0])
                        }
                        wt.ty === 0
                          ? ((wt.layers = lt(wt.refId, Mt)), ut(wt.layers, Mt))
                          : wt.ty === 4
                          ? ht(wt.shapes)
                          : wt.ty === 5 && kt(wt)
                      }
                  }
                  function it(Dt, Mt) {
                    if (Dt) {
                      var wt = 0,
                        gt = Dt.length
                      for (wt = 0; wt < gt; wt += 1)
                        Dt[wt].t === 1 &&
                          ((Dt[wt].data.layers = lt(Dt[wt].data.refId, Mt)),
                          ut(Dt[wt].data.layers, Mt))
                    }
                  }
                  function ct(Dt, Mt) {
                    for (var wt = 0, gt = Mt.length; wt < gt; ) {
                      if (Mt[wt].id === Dt) return Mt[wt]
                      wt += 1
                    }
                    return null
                  }
                  function lt(Dt, Mt) {
                    var wt = ct(Dt, Mt)
                    return wt
                      ? wt.layers.__used
                        ? JSON.parse(JSON.stringify(wt.layers))
                        : ((wt.layers.__used = !0), wt.layers)
                      : null
                  }
                  function ht(Dt) {
                    var Mt,
                      wt = Dt.length,
                      gt,
                      At
                    for (Mt = wt - 1; Mt >= 0; Mt -= 1)
                      if (Dt[Mt].ty === "sh")
                        if (Dt[Mt].ks.k.i) dt(Dt[Mt].ks.k)
                        else
                          for (
                            At = Dt[Mt].ks.k.length, gt = 0;
                            gt < At;
                            gt += 1
                          )
                            Dt[Mt].ks.k[gt].s && dt(Dt[Mt].ks.k[gt].s[0]),
                              Dt[Mt].ks.k[gt].e && dt(Dt[Mt].ks.k[gt].e[0])
                      else Dt[Mt].ty === "gr" && ht(Dt[Mt].it)
                  }
                  function dt(Dt) {
                    var Mt,
                      wt = Dt.i.length
                    for (Mt = 0; Mt < wt; Mt += 1)
                      (Dt.i[Mt][0] += Dt.v[Mt][0]),
                        (Dt.i[Mt][1] += Dt.v[Mt][1]),
                        (Dt.o[Mt][0] += Dt.v[Mt][0]),
                        (Dt.o[Mt][1] += Dt.v[Mt][1])
                  }
                  function pt(Dt, Mt) {
                    var wt = Mt ? Mt.split(".") : [100, 100, 100]
                    return Dt[0] > wt[0]
                      ? !0
                      : wt[0] > Dt[0]
                      ? !1
                      : Dt[1] > wt[1]
                      ? !0
                      : wt[1] > Dt[1]
                      ? !1
                      : Dt[2] > wt[2]
                      ? !0
                      : wt[2] > Dt[2]
                      ? !1
                      : null
                  }
                  var vt = (function () {
                      var Dt = [4, 4, 14]
                      function Mt(gt) {
                        var At = gt.t.d
                        gt.t.d = { k: [{ s: At, t: 0 }] }
                      }
                      function wt(gt) {
                        var At,
                          bt = gt.length
                        for (At = 0; At < bt; At += 1)
                          gt[At].ty === 5 && Mt(gt[At])
                      }
                      return function (gt) {
                        if (pt(Dt, gt.v) && (wt(gt.layers), gt.assets)) {
                          var At,
                            bt = gt.assets.length
                          for (At = 0; At < bt; At += 1)
                            gt.assets[At].layers && wt(gt.assets[At].layers)
                        }
                      }
                    })(),
                    _t = (function () {
                      var Dt = [4, 7, 99]
                      return function (Mt) {
                        if (Mt.chars && !pt(Dt, Mt.v)) {
                          var wt,
                            gt = Mt.chars.length
                          for (wt = 0; wt < gt; wt += 1) {
                            var At = Mt.chars[wt]
                            At.data &&
                              At.data.shapes &&
                              (ht(At.data.shapes),
                              (At.data.ip = 0),
                              (At.data.op = 99999),
                              (At.data.st = 0),
                              (At.data.sr = 1),
                              (At.data.ks = {
                                p: { k: [0, 0], a: 0 },
                                s: { k: [100, 100], a: 0 },
                                a: { k: [0, 0], a: 0 },
                                r: { k: 0, a: 0 },
                                o: { k: 100, a: 0 },
                              }),
                              Mt.chars[wt].t ||
                                (At.data.shapes.push({ ty: "no" }),
                                At.data.shapes[0].it.push({
                                  p: { k: [0, 0], a: 0 },
                                  s: { k: [100, 100], a: 0 },
                                  a: { k: [0, 0], a: 0 },
                                  r: { k: 0, a: 0 },
                                  o: { k: 100, a: 0 },
                                  sk: { k: 0, a: 0 },
                                  sa: { k: 0, a: 0 },
                                  ty: "tr",
                                })))
                          }
                        }
                      }
                    })(),
                    yt = (function () {
                      var Dt = [5, 7, 15]
                      function Mt(gt) {
                        var At = gt.t.p
                        typeof At.a == "number" && (At.a = { a: 0, k: At.a }),
                          typeof At.p == "number" && (At.p = { a: 0, k: At.p }),
                          typeof At.r == "number" && (At.r = { a: 0, k: At.r })
                      }
                      function wt(gt) {
                        var At,
                          bt = gt.length
                        for (At = 0; At < bt; At += 1)
                          gt[At].ty === 5 && Mt(gt[At])
                      }
                      return function (gt) {
                        if (pt(Dt, gt.v) && (wt(gt.layers), gt.assets)) {
                          var At,
                            bt = gt.assets.length
                          for (At = 0; At < bt; At += 1)
                            gt.assets[At].layers && wt(gt.assets[At].layers)
                        }
                      }
                    })(),
                    Et = (function () {
                      var Dt = [4, 1, 9]
                      function Mt(gt) {
                        var At,
                          bt = gt.length,
                          Tt,
                          It
                        for (At = 0; At < bt; At += 1)
                          if (gt[At].ty === "gr") Mt(gt[At].it)
                          else if (gt[At].ty === "fl" || gt[At].ty === "st")
                            if (gt[At].c.k && gt[At].c.k[0].i)
                              for (
                                It = gt[At].c.k.length, Tt = 0;
                                Tt < It;
                                Tt += 1
                              )
                                gt[At].c.k[Tt].s &&
                                  ((gt[At].c.k[Tt].s[0] /= 255),
                                  (gt[At].c.k[Tt].s[1] /= 255),
                                  (gt[At].c.k[Tt].s[2] /= 255),
                                  (gt[At].c.k[Tt].s[3] /= 255)),
                                  gt[At].c.k[Tt].e &&
                                    ((gt[At].c.k[Tt].e[0] /= 255),
                                    (gt[At].c.k[Tt].e[1] /= 255),
                                    (gt[At].c.k[Tt].e[2] /= 255),
                                    (gt[At].c.k[Tt].e[3] /= 255))
                            else
                              (gt[At].c.k[0] /= 255),
                                (gt[At].c.k[1] /= 255),
                                (gt[At].c.k[2] /= 255),
                                (gt[At].c.k[3] /= 255)
                      }
                      function wt(gt) {
                        var At,
                          bt = gt.length
                        for (At = 0; At < bt; At += 1)
                          gt[At].ty === 4 && Mt(gt[At].shapes)
                      }
                      return function (gt) {
                        if (pt(Dt, gt.v) && (wt(gt.layers), gt.assets)) {
                          var At,
                            bt = gt.assets.length
                          for (At = 0; At < bt; At += 1)
                            gt.assets[At].layers && wt(gt.assets[At].layers)
                        }
                      }
                    })(),
                    Rt = (function () {
                      var Dt = [4, 4, 18]
                      function Mt(gt) {
                        var At,
                          bt = gt.length,
                          Tt,
                          It
                        for (At = bt - 1; At >= 0; At -= 1)
                          if (gt[At].ty === "sh")
                            if (gt[At].ks.k.i) gt[At].ks.k.c = gt[At].closed
                            else
                              for (
                                It = gt[At].ks.k.length, Tt = 0;
                                Tt < It;
                                Tt += 1
                              )
                                gt[At].ks.k[Tt].s &&
                                  (gt[At].ks.k[Tt].s[0].c = gt[At].closed),
                                  gt[At].ks.k[Tt].e &&
                                    (gt[At].ks.k[Tt].e[0].c = gt[At].closed)
                          else gt[At].ty === "gr" && Mt(gt[At].it)
                      }
                      function wt(gt) {
                        var At,
                          bt,
                          Tt = gt.length,
                          It,
                          $t,
                          Xt,
                          qt
                        for (bt = 0; bt < Tt; bt += 1) {
                          if (((At = gt[bt]), At.hasMask)) {
                            var en = At.masksProperties
                            for ($t = en.length, It = 0; It < $t; It += 1)
                              if (en[It].pt.k.i) en[It].pt.k.c = en[It].cl
                              else
                                for (
                                  qt = en[It].pt.k.length, Xt = 0;
                                  Xt < qt;
                                  Xt += 1
                                )
                                  en[It].pt.k[Xt].s &&
                                    (en[It].pt.k[Xt].s[0].c = en[It].cl),
                                    en[It].pt.k[Xt].e &&
                                      (en[It].pt.k[Xt].e[0].c = en[It].cl)
                          }
                          At.ty === 4 && Mt(At.shapes)
                        }
                      }
                      return function (gt) {
                        if (pt(Dt, gt.v) && (wt(gt.layers), gt.assets)) {
                          var At,
                            bt = gt.assets.length
                          for (At = 0; At < bt; At += 1)
                            gt.assets[At].layers && wt(gt.assets[At].layers)
                        }
                      }
                    })()
                  function Ft(Dt) {
                    Dt.__complete ||
                      (Et(Dt),
                      vt(Dt),
                      _t(Dt),
                      yt(Dt),
                      Rt(Dt),
                      ut(Dt.layers, Dt.assets),
                      it(Dt.chars, Dt.assets),
                      (Dt.__complete = !0))
                  }
                  function kt(Dt) {
                    Dt.t.a.length === 0 && "m" in Dt.t.p
                  }
                  var Nt = {}
                  return (
                    (Nt.completeData = Ft),
                    (Nt.checkColors = Et),
                    (Nt.checkChars = _t),
                    (Nt.checkPathProperties = yt),
                    (Nt.checkShapes = Rt),
                    (Nt.completeLayers = ut),
                    Nt
                  )
                }
                if (
                  (d.dataManager || (d.dataManager = at()),
                  d.assetLoader ||
                    (d.assetLoader = (function () {
                      function ut(ct) {
                        var lt = ct.getResponseHeader("content-type")
                        return (lt &&
                          ct.responseType === "json" &&
                          lt.indexOf("json") !== -1) ||
                          (ct.response && _typeof$5(ct.response) === "object")
                          ? ct.response
                          : ct.response && typeof ct.response == "string"
                          ? JSON.parse(ct.response)
                          : ct.responseText
                          ? JSON.parse(ct.responseText)
                          : null
                      }
                      function it(ct, lt, ht, dt) {
                        var pt,
                          vt = new XMLHttpRequest()
                        try {
                          vt.responseType = "json"
                        } catch {}
                        vt.onreadystatechange = function () {
                          if (vt.readyState === 4)
                            if (vt.status === 200) (pt = ut(vt)), ht(pt)
                            else
                              try {
                                ;(pt = ut(vt)), ht(pt)
                              } catch (_t) {
                                dt && dt(_t)
                              }
                        }
                        try {
                          vt.open(["G", "E", "T"].join(""), ct, !0)
                        } catch {
                          vt.open(["G", "E", "T"].join(""), lt + "/" + ct, !0)
                        }
                        vt.send()
                      }
                      return { load: it }
                    })()),
                  st.data.type === "loadAnimation")
                )
                  d.assetLoader.load(
                    st.data.path,
                    st.data.fullPath,
                    function (ut) {
                      d.dataManager.completeData(ut),
                        d.postMessage({
                          id: st.data.id,
                          payload: ut,
                          status: "success",
                        })
                    },
                    function () {
                      d.postMessage({ id: st.data.id, status: "error" })
                    }
                  )
                else if (st.data.type === "complete") {
                  var ot = st.data.animation
                  d.dataManager.completeData(ot),
                    d.postMessage({
                      id: st.data.id,
                      payload: ot,
                      status: "success",
                    })
                } else
                  st.data.type === "loadData" &&
                    d.assetLoader.load(
                      st.data.path,
                      st.data.fullPath,
                      function (ut) {
                        d.postMessage({
                          id: st.data.id,
                          payload: ut,
                          status: "success",
                        })
                      },
                      function () {
                        d.postMessage({ id: st.data.id, status: "error" })
                      }
                    )
              })),
              (o.onmessage = function (tt) {
                var st = tt.data,
                  at = st.id,
                  ot = e[at]
                ;(e[at] = null),
                  st.status === "success"
                    ? ot.onComplete(st.payload)
                    : ot.onError && ot.onError()
              }))
          }
          function b(tt, st) {
            s += 1
            var at = "processId_" + s
            return (e[at] = { onComplete: tt, onError: st }), at
          }
          function j(tt, st, at) {
            _()
            var ot = b(st, at)
            o.postMessage({
              type: "loadAnimation",
              path: tt,
              fullPath: window.location.origin + window.location.pathname,
              id: ot,
            })
          }
          function $(tt, st, at) {
            _()
            var ot = b(st, at)
            o.postMessage({
              type: "loadData",
              path: tt,
              fullPath: window.location.origin + window.location.pathname,
              id: ot,
            })
          }
          function _e(tt, st, at) {
            _()
            var ot = b(st, at)
            o.postMessage({ type: "complete", animation: tt, id: ot })
          }
          return { loadAnimation: j, loadData: $, completeAnimation: _e }
        })(),
        ImagePreloader = (function () {
          var s = (function () {
            var it = createTag("canvas")
            ;(it.width = 1), (it.height = 1)
            var ct = it.getContext("2d")
            return (ct.fillStyle = "rgba(0,0,0,0)"), ct.fillRect(0, 0, 1, 1), it
          })()
          function e() {
            ;(this.loadedAssets += 1),
              this.loadedAssets === this.totalImages &&
                this.loadedFootagesCount === this.totalFootages &&
                this.imagesLoadedCb &&
                this.imagesLoadedCb(null)
          }
          function a() {
            ;(this.loadedFootagesCount += 1),
              this.loadedAssets === this.totalImages &&
                this.loadedFootagesCount === this.totalFootages &&
                this.imagesLoadedCb &&
                this.imagesLoadedCb(null)
          }
          function o(it, ct, lt) {
            var ht = ""
            if (it.e) ht = it.p
            else if (ct) {
              var dt = it.p
              dt.indexOf("images/") !== -1 && (dt = dt.split("/")[1]),
                (ht = ct + dt)
            } else (ht = lt), (ht += it.u ? it.u : ""), (ht += it.p)
            return ht
          }
          function c(it) {
            var ct = 0,
              lt = setInterval(
                function () {
                  var ht = it.getBBox()
                  ;(ht.width || ct > 500) &&
                    (this._imageLoaded(), clearInterval(lt)),
                    (ct += 1)
                }.bind(this),
                50
              )
          }
          function d(it) {
            var ct = o(it, this.assetsPath, this.path),
              lt = createNS("image")
            isSafari
              ? this.testImageLoaded(lt)
              : lt.addEventListener("load", this._imageLoaded, !1),
              lt.addEventListener(
                "error",
                function () {
                  ;(ht.img = s), this._imageLoaded()
                }.bind(this),
                !1
              ),
              lt.setAttributeNS("http://www.w3.org/1999/xlink", "href", ct),
              this._elementHelper.append
                ? this._elementHelper.append(lt)
                : this._elementHelper.appendChild(lt)
            var ht = { img: lt, assetData: it }
            return ht
          }
          function g(it) {
            var ct = o(it, this.assetsPath, this.path),
              lt = createTag("img")
            ;(lt.crossOrigin = "anonymous"),
              lt.addEventListener("load", this._imageLoaded, !1),
              lt.addEventListener(
                "error",
                function () {
                  ;(ht.img = s), this._imageLoaded()
                }.bind(this),
                !1
              ),
              (lt.src = ct)
            var ht = { img: lt, assetData: it }
            return ht
          }
          function _(it) {
            var ct = { assetData: it },
              lt = o(it, this.assetsPath, this.path)
            return (
              dataManager.loadData(
                lt,
                function (ht) {
                  ;(ct.img = ht), this._footageLoaded()
                }.bind(this),
                function () {
                  ;(ct.img = {}), this._footageLoaded()
                }.bind(this)
              ),
              ct
            )
          }
          function b(it, ct) {
            this.imagesLoadedCb = ct
            var lt,
              ht = it.length
            for (lt = 0; lt < ht; lt += 1)
              it[lt].layers ||
                (!it[lt].t || it[lt].t === "seq"
                  ? ((this.totalImages += 1),
                    this.images.push(this._createImageData(it[lt])))
                  : it[lt].t === 3 &&
                    ((this.totalFootages += 1),
                    this.images.push(this.createFootageData(it[lt]))))
          }
          function j(it) {
            this.path = it || ""
          }
          function $(it) {
            this.assetsPath = it || ""
          }
          function _e(it) {
            for (var ct = 0, lt = this.images.length; ct < lt; ) {
              if (this.images[ct].assetData === it) return this.images[ct].img
              ct += 1
            }
            return null
          }
          function tt() {
            ;(this.imagesLoadedCb = null), (this.images.length = 0)
          }
          function st() {
            return this.totalImages === this.loadedAssets
          }
          function at() {
            return this.totalFootages === this.loadedFootagesCount
          }
          function ot(it, ct) {
            it === "svg"
              ? ((this._elementHelper = ct),
                (this._createImageData = this.createImageData.bind(this)))
              : (this._createImageData = this.createImgData.bind(this))
          }
          function ut() {
            ;(this._imageLoaded = e.bind(this)),
              (this._footageLoaded = a.bind(this)),
              (this.testImageLoaded = c.bind(this)),
              (this.createFootageData = _.bind(this)),
              (this.assetsPath = ""),
              (this.path = ""),
              (this.totalImages = 0),
              (this.totalFootages = 0),
              (this.loadedAssets = 0),
              (this.loadedFootagesCount = 0),
              (this.imagesLoadedCb = null),
              (this.images = [])
          }
          return (
            (ut.prototype = {
              loadAssets: b,
              setAssetsPath: $,
              setPath: j,
              loadedImages: st,
              loadedFootages: at,
              destroy: tt,
              getAsset: _e,
              createImgData: g,
              createImageData: d,
              imageLoaded: e,
              footageLoaded: a,
              setCacheType: ot,
            }),
            ut
          )
        })()
      function BaseEvent() {}
      BaseEvent.prototype = {
        triggerEvent: function (e, a) {
          if (this._cbs[e])
            for (var o = this._cbs[e], c = 0; c < o.length; c += 1) o[c](a)
        },
        addEventListener: function (e, a) {
          return (
            this._cbs[e] || (this._cbs[e] = []),
            this._cbs[e].push(a),
            function () {
              this.removeEventListener(e, a)
            }.bind(this)
          )
        },
        removeEventListener: function (e, a) {
          if (!a) this._cbs[e] = null
          else if (this._cbs[e]) {
            for (var o = 0, c = this._cbs[e].length; o < c; )
              this._cbs[e][o] === a &&
                (this._cbs[e].splice(o, 1), (o -= 1), (c -= 1)),
                (o += 1)
            this._cbs[e].length || (this._cbs[e] = null)
          }
        },
      }
      var markerParser = (function () {
          function s(e) {
            for (
              var a = e.split(`\r
`),
                o = {},
                c,
                d = 0,
                g = 0;
              g < a.length;
              g += 1
            )
              (c = a[g].split(":")),
                c.length === 2 && ((o[c[0]] = c[1].trim()), (d += 1))
            if (d === 0) throw new Error()
            return o
          }
          return function (e) {
            for (var a = [], o = 0; o < e.length; o += 1) {
              var c = e[o],
                d = { time: c.tm, duration: c.dr }
              try {
                d.payload = JSON.parse(e[o].cm)
              } catch {
                try {
                  d.payload = s(e[o].cm)
                } catch {
                  d.payload = { name: e[o].cm }
                }
              }
              a.push(d)
            }
            return a
          }
        })(),
        ProjectInterface = (function () {
          function s(e) {
            this.compositions.push(e)
          }
          return function () {
            function e(a) {
              for (var o = 0, c = this.compositions.length; o < c; ) {
                if (
                  this.compositions[o].data &&
                  this.compositions[o].data.nm === a
                )
                  return (
                    this.compositions[o].prepareFrame &&
                      this.compositions[o].data.xt &&
                      this.compositions[o].prepareFrame(this.currentFrame),
                    this.compositions[o].compInterface
                  )
                o += 1
              }
              return null
            }
            return (
              (e.compositions = []),
              (e.currentFrame = 0),
              (e.registerComposition = s),
              e
            )
          }
        })(),
        renderers = {},
        registerRenderer = function (e, a) {
          renderers[e] = a
        }
      function getRenderer(s) {
        return renderers[s]
      }
      function getRegisteredRenderer() {
        if (renderers.canvas) return "canvas"
        for (var s in renderers) if (renderers[s]) return s
        return ""
      }
      function _typeof$4(s) {
        "@babel/helpers - typeof"
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$4 = function (a) {
                return typeof a
              })
            : (_typeof$4 = function (a) {
                return a &&
                  typeof Symbol == "function" &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a
              }),
          _typeof$4(s)
        )
      }
      var AnimationItem = function () {
        ;(this._cbs = []),
          (this.name = ""),
          (this.path = ""),
          (this.isLoaded = !1),
          (this.currentFrame = 0),
          (this.currentRawFrame = 0),
          (this.firstFrame = 0),
          (this.totalFrames = 0),
          (this.frameRate = 0),
          (this.frameMult = 0),
          (this.playSpeed = 1),
          (this.playDirection = 1),
          (this.playCount = 0),
          (this.animationData = {}),
          (this.assets = []),
          (this.isPaused = !0),
          (this.autoplay = !1),
          (this.loop = !0),
          (this.renderer = null),
          (this.animationID = createElementID()),
          (this.assetsPath = ""),
          (this.timeCompleted = 0),
          (this.segmentPos = 0),
          (this.isSubframeEnabled = getSubframeEnabled()),
          (this.segments = []),
          (this._idle = !0),
          (this._completedLoop = !1),
          (this.projectInterface = ProjectInterface()),
          (this.imagePreloader = new ImagePreloader()),
          (this.audioController = audioControllerFactory()),
          (this.markers = []),
          (this.configAnimation = this.configAnimation.bind(this)),
          (this.onSetupError = this.onSetupError.bind(this)),
          (this.onSegmentComplete = this.onSegmentComplete.bind(this)),
          (this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0)),
          (this.expressionsPlugin = getExpressionsPlugin())
      }
      extendPrototype([BaseEvent], AnimationItem),
        (AnimationItem.prototype.setParams = function (s) {
          ;(s.wrapper || s.container) &&
            (this.wrapper = s.wrapper || s.container)
          var e = "svg"
          s.animType ? (e = s.animType) : s.renderer && (e = s.renderer)
          var a = getRenderer(e)
          ;(this.renderer = new a(this, s.rendererSettings)),
            this.imagePreloader.setCacheType(e, this.renderer.globalData.defs),
            this.renderer.setProjectInterface(this.projectInterface),
            (this.animType = e),
            s.loop === "" ||
            s.loop === null ||
            s.loop === void 0 ||
            s.loop === !0
              ? (this.loop = !0)
              : s.loop === !1
              ? (this.loop = !1)
              : (this.loop = parseInt(s.loop, 10)),
            (this.autoplay = "autoplay" in s ? s.autoplay : !0),
            (this.name = s.name ? s.name : ""),
            (this.autoloadSegments = Object.prototype.hasOwnProperty.call(
              s,
              "autoloadSegments"
            )
              ? s.autoloadSegments
              : !0),
            (this.assetsPath = s.assetsPath),
            (this.initialSegment = s.initialSegment),
            s.audioFactory &&
              this.audioController.setAudioFactory(s.audioFactory),
            s.animationData
              ? this.setupAnimation(s.animationData)
              : s.path &&
                (s.path.lastIndexOf("\\") !== -1
                  ? (this.path = s.path.substr(0, s.path.lastIndexOf("\\") + 1))
                  : (this.path = s.path.substr(0, s.path.lastIndexOf("/") + 1)),
                (this.fileName = s.path.substr(s.path.lastIndexOf("/") + 1)),
                (this.fileName = this.fileName.substr(
                  0,
                  this.fileName.lastIndexOf(".json")
                )),
                dataManager.loadAnimation(
                  s.path,
                  this.configAnimation,
                  this.onSetupError
                ))
        }),
        (AnimationItem.prototype.onSetupError = function () {
          this.trigger("data_failed")
        }),
        (AnimationItem.prototype.setupAnimation = function (s) {
          dataManager.completeAnimation(s, this.configAnimation)
        }),
        (AnimationItem.prototype.setData = function (s, e) {
          e && _typeof$4(e) !== "object" && (e = JSON.parse(e))
          var a = { wrapper: s, animationData: e },
            o = s.attributes
          ;(a.path = o.getNamedItem("data-animation-path")
            ? o.getNamedItem("data-animation-path").value
            : o.getNamedItem("data-bm-path")
            ? o.getNamedItem("data-bm-path").value
            : o.getNamedItem("bm-path")
            ? o.getNamedItem("bm-path").value
            : ""),
            (a.animType = o.getNamedItem("data-anim-type")
              ? o.getNamedItem("data-anim-type").value
              : o.getNamedItem("data-bm-type")
              ? o.getNamedItem("data-bm-type").value
              : o.getNamedItem("bm-type")
              ? o.getNamedItem("bm-type").value
              : o.getNamedItem("data-bm-renderer")
              ? o.getNamedItem("data-bm-renderer").value
              : o.getNamedItem("bm-renderer")
              ? o.getNamedItem("bm-renderer").value
              : getRegisteredRenderer() || "canvas")
          var c = o.getNamedItem("data-anim-loop")
            ? o.getNamedItem("data-anim-loop").value
            : o.getNamedItem("data-bm-loop")
            ? o.getNamedItem("data-bm-loop").value
            : o.getNamedItem("bm-loop")
            ? o.getNamedItem("bm-loop").value
            : ""
          c === "false"
            ? (a.loop = !1)
            : c === "true"
            ? (a.loop = !0)
            : c !== "" && (a.loop = parseInt(c, 10))
          var d = o.getNamedItem("data-anim-autoplay")
            ? o.getNamedItem("data-anim-autoplay").value
            : o.getNamedItem("data-bm-autoplay")
            ? o.getNamedItem("data-bm-autoplay").value
            : o.getNamedItem("bm-autoplay")
            ? o.getNamedItem("bm-autoplay").value
            : !0
          ;(a.autoplay = d !== "false"),
            (a.name = o.getNamedItem("data-name")
              ? o.getNamedItem("data-name").value
              : o.getNamedItem("data-bm-name")
              ? o.getNamedItem("data-bm-name").value
              : o.getNamedItem("bm-name")
              ? o.getNamedItem("bm-name").value
              : "")
          var g = o.getNamedItem("data-anim-prerender")
            ? o.getNamedItem("data-anim-prerender").value
            : o.getNamedItem("data-bm-prerender")
            ? o.getNamedItem("data-bm-prerender").value
            : o.getNamedItem("bm-prerender")
            ? o.getNamedItem("bm-prerender").value
            : ""
          g === "false" && (a.prerender = !1),
            a.path ? this.setParams(a) : this.trigger("destroy")
        }),
        (AnimationItem.prototype.includeLayers = function (s) {
          s.op > this.animationData.op &&
            ((this.animationData.op = s.op),
            (this.totalFrames = Math.floor(s.op - this.animationData.ip)))
          var e = this.animationData.layers,
            a,
            o = e.length,
            c = s.layers,
            d,
            g = c.length
          for (d = 0; d < g; d += 1)
            for (a = 0; a < o; ) {
              if (e[a].id === c[d].id) {
                e[a] = c[d]
                break
              }
              a += 1
            }
          if (
            ((s.chars || s.fonts) &&
              (this.renderer.globalData.fontManager.addChars(s.chars),
              this.renderer.globalData.fontManager.addFonts(
                s.fonts,
                this.renderer.globalData.defs
              )),
            s.assets)
          )
            for (o = s.assets.length, a = 0; a < o; a += 1)
              this.animationData.assets.push(s.assets[a])
          ;(this.animationData.__complete = !1),
            dataManager.completeAnimation(
              this.animationData,
              this.onSegmentComplete
            )
        }),
        (AnimationItem.prototype.onSegmentComplete = function (s) {
          this.animationData = s
          var e = getExpressionsPlugin()
          e && e.initExpressions(this), this.loadNextSegment()
        }),
        (AnimationItem.prototype.loadNextSegment = function () {
          var s = this.animationData.segments
          if (!s || s.length === 0 || !this.autoloadSegments) {
            this.trigger("data_ready"), (this.timeCompleted = this.totalFrames)
            return
          }
          var e = s.shift()
          this.timeCompleted = e.time * this.frameRate
          var a = this.path + this.fileName + "_" + this.segmentPos + ".json"
          ;(this.segmentPos += 1),
            dataManager.loadData(
              a,
              this.includeLayers.bind(this),
              function () {
                this.trigger("data_failed")
              }.bind(this)
            )
        }),
        (AnimationItem.prototype.loadSegments = function () {
          var s = this.animationData.segments
          s || (this.timeCompleted = this.totalFrames), this.loadNextSegment()
        }),
        (AnimationItem.prototype.imagesLoaded = function () {
          this.trigger("loaded_images"), this.checkLoaded()
        }),
        (AnimationItem.prototype.preloadImages = function () {
          this.imagePreloader.setAssetsPath(this.assetsPath),
            this.imagePreloader.setPath(this.path),
            this.imagePreloader.loadAssets(
              this.animationData.assets,
              this.imagesLoaded.bind(this)
            )
        }),
        (AnimationItem.prototype.configAnimation = function (s) {
          if (this.renderer)
            try {
              ;(this.animationData = s),
                this.initialSegment
                  ? ((this.totalFrames = Math.floor(
                      this.initialSegment[1] - this.initialSegment[0]
                    )),
                    (this.firstFrame = Math.round(this.initialSegment[0])))
                  : ((this.totalFrames = Math.floor(
                      this.animationData.op - this.animationData.ip
                    )),
                    (this.firstFrame = Math.round(this.animationData.ip))),
                this.renderer.configAnimation(s),
                s.assets || (s.assets = []),
                (this.assets = this.animationData.assets),
                (this.frameRate = this.animationData.fr),
                (this.frameMult = this.animationData.fr / 1e3),
                this.renderer.searchExtraCompositions(s.assets),
                (this.markers = markerParser(s.markers || [])),
                this.trigger("config_ready"),
                this.preloadImages(),
                this.loadSegments(),
                this.updaFrameModifier(),
                this.waitForFontsLoaded(),
                this.isPaused && this.audioController.pause()
            } catch (e) {
              this.triggerConfigError(e)
            }
        }),
        (AnimationItem.prototype.waitForFontsLoaded = function () {
          this.renderer &&
            (this.renderer.globalData.fontManager.isLoaded
              ? this.checkLoaded()
              : setTimeout(this.waitForFontsLoaded.bind(this), 20))
        }),
        (AnimationItem.prototype.checkLoaded = function () {
          if (
            !this.isLoaded &&
            this.renderer.globalData.fontManager.isLoaded &&
            (this.imagePreloader.loadedImages() ||
              this.renderer.rendererType !== "canvas") &&
            this.imagePreloader.loadedFootages()
          ) {
            this.isLoaded = !0
            var s = getExpressionsPlugin()
            s && s.initExpressions(this),
              this.renderer.initItems(),
              setTimeout(
                function () {
                  this.trigger("DOMLoaded")
                }.bind(this),
                0
              ),
              this.gotoFrame(),
              this.autoplay && this.play()
          }
        }),
        (AnimationItem.prototype.resize = function (s, e) {
          var a = typeof s == "number" ? s : void 0,
            o = typeof e == "number" ? e : void 0
          this.renderer.updateContainerSize(a, o)
        }),
        (AnimationItem.prototype.setSubframe = function (s) {
          this.isSubframeEnabled = !!s
        }),
        (AnimationItem.prototype.gotoFrame = function () {
          ;(this.currentFrame = this.isSubframeEnabled
            ? this.currentRawFrame
            : ~~this.currentRawFrame),
            this.timeCompleted !== this.totalFrames &&
              this.currentFrame > this.timeCompleted &&
              (this.currentFrame = this.timeCompleted),
            this.trigger("enterFrame"),
            this.renderFrame(),
            this.trigger("drawnFrame")
        }),
        (AnimationItem.prototype.renderFrame = function () {
          if (!(this.isLoaded === !1 || !this.renderer))
            try {
              this.expressionsPlugin && this.expressionsPlugin.resetFrame(),
                this.renderer.renderFrame(this.currentFrame + this.firstFrame)
            } catch (s) {
              this.triggerRenderFrameError(s)
            }
        }),
        (AnimationItem.prototype.play = function (s) {
          ;(s && this.name !== s) ||
            (this.isPaused === !0 &&
              ((this.isPaused = !1),
              this.trigger("_play"),
              this.audioController.resume(),
              this._idle && ((this._idle = !1), this.trigger("_active"))))
        }),
        (AnimationItem.prototype.pause = function (s) {
          ;(s && this.name !== s) ||
            (this.isPaused === !1 &&
              ((this.isPaused = !0),
              this.trigger("_pause"),
              (this._idle = !0),
              this.trigger("_idle"),
              this.audioController.pause()))
        }),
        (AnimationItem.prototype.togglePause = function (s) {
          ;(s && this.name !== s) ||
            (this.isPaused === !0 ? this.play() : this.pause())
        }),
        (AnimationItem.prototype.stop = function (s) {
          ;(s && this.name !== s) ||
            (this.pause(),
            (this.playCount = 0),
            (this._completedLoop = !1),
            this.setCurrentRawFrameValue(0))
        }),
        (AnimationItem.prototype.getMarkerData = function (s) {
          for (var e, a = 0; a < this.markers.length; a += 1)
            if (((e = this.markers[a]), e.payload && e.payload.name === s))
              return e
          return null
        }),
        (AnimationItem.prototype.goToAndStop = function (s, e, a) {
          if (!(a && this.name !== a)) {
            var o = Number(s)
            if (isNaN(o)) {
              var c = this.getMarkerData(s)
              c && this.goToAndStop(c.time, !0)
            } else
              e
                ? this.setCurrentRawFrameValue(s)
                : this.setCurrentRawFrameValue(s * this.frameModifier)
            this.pause()
          }
        }),
        (AnimationItem.prototype.goToAndPlay = function (s, e, a) {
          if (!(a && this.name !== a)) {
            var o = Number(s)
            if (isNaN(o)) {
              var c = this.getMarkerData(s)
              c &&
                (c.duration
                  ? this.playSegments([c.time, c.time + c.duration], !0)
                  : this.goToAndStop(c.time, !0))
            } else this.goToAndStop(o, e, a)
            this.play()
          }
        }),
        (AnimationItem.prototype.advanceTime = function (s) {
          if (!(this.isPaused === !0 || this.isLoaded === !1)) {
            var e = this.currentRawFrame + s * this.frameModifier,
              a = !1
            e >= this.totalFrames - 1 && this.frameModifier > 0
              ? !this.loop || this.playCount === this.loop
                ? this.checkSegments(
                    e > this.totalFrames ? e % this.totalFrames : 0
                  ) || ((a = !0), (e = this.totalFrames - 1))
                : e >= this.totalFrames
                ? ((this.playCount += 1),
                  this.checkSegments(e % this.totalFrames) ||
                    (this.setCurrentRawFrameValue(e % this.totalFrames),
                    (this._completedLoop = !0),
                    this.trigger("loopComplete")))
                : this.setCurrentRawFrameValue(e)
              : e < 0
              ? this.checkSegments(e % this.totalFrames) ||
                (this.loop && !(this.playCount-- <= 0 && this.loop !== !0)
                  ? (this.setCurrentRawFrameValue(
                      this.totalFrames + (e % this.totalFrames)
                    ),
                    this._completedLoop
                      ? this.trigger("loopComplete")
                      : (this._completedLoop = !0))
                  : ((a = !0), (e = 0)))
              : this.setCurrentRawFrameValue(e),
              a &&
                (this.setCurrentRawFrameValue(e),
                this.pause(),
                this.trigger("complete"))
          }
        }),
        (AnimationItem.prototype.adjustSegment = function (s, e) {
          ;(this.playCount = 0),
            s[1] < s[0]
              ? (this.frameModifier > 0 &&
                  (this.playSpeed < 0
                    ? this.setSpeed(-this.playSpeed)
                    : this.setDirection(-1)),
                (this.totalFrames = s[0] - s[1]),
                (this.timeCompleted = this.totalFrames),
                (this.firstFrame = s[1]),
                this.setCurrentRawFrameValue(this.totalFrames - 0.001 - e))
              : s[1] > s[0] &&
                (this.frameModifier < 0 &&
                  (this.playSpeed < 0
                    ? this.setSpeed(-this.playSpeed)
                    : this.setDirection(1)),
                (this.totalFrames = s[1] - s[0]),
                (this.timeCompleted = this.totalFrames),
                (this.firstFrame = s[0]),
                this.setCurrentRawFrameValue(0.001 + e)),
            this.trigger("segmentStart")
        }),
        (AnimationItem.prototype.setSegment = function (s, e) {
          var a = -1
          this.isPaused &&
            (this.currentRawFrame + this.firstFrame < s
              ? (a = s)
              : this.currentRawFrame + this.firstFrame > e && (a = e - s)),
            (this.firstFrame = s),
            (this.totalFrames = e - s),
            (this.timeCompleted = this.totalFrames),
            a !== -1 && this.goToAndStop(a, !0)
        }),
        (AnimationItem.prototype.playSegments = function (s, e) {
          if ((e && (this.segments.length = 0), _typeof$4(s[0]) === "object")) {
            var a,
              o = s.length
            for (a = 0; a < o; a += 1) this.segments.push(s[a])
          } else this.segments.push(s)
          this.segments.length &&
            e &&
            this.adjustSegment(this.segments.shift(), 0),
            this.isPaused && this.play()
        }),
        (AnimationItem.prototype.resetSegments = function (s) {
          ;(this.segments.length = 0),
            this.segments.push([this.animationData.ip, this.animationData.op]),
            s && this.checkSegments(0)
        }),
        (AnimationItem.prototype.checkSegments = function (s) {
          return this.segments.length
            ? (this.adjustSegment(this.segments.shift(), s), !0)
            : !1
        }),
        (AnimationItem.prototype.destroy = function (s) {
          ;(s && this.name !== s) ||
            !this.renderer ||
            (this.renderer.destroy(),
            this.imagePreloader.destroy(),
            this.trigger("destroy"),
            (this._cbs = null),
            (this.onEnterFrame = null),
            (this.onLoopComplete = null),
            (this.onComplete = null),
            (this.onSegmentStart = null),
            (this.onDestroy = null),
            (this.renderer = null),
            (this.expressionsPlugin = null),
            (this.imagePreloader = null),
            (this.projectInterface = null))
        }),
        (AnimationItem.prototype.setCurrentRawFrameValue = function (s) {
          ;(this.currentRawFrame = s), this.gotoFrame()
        }),
        (AnimationItem.prototype.setSpeed = function (s) {
          ;(this.playSpeed = s), this.updaFrameModifier()
        }),
        (AnimationItem.prototype.setDirection = function (s) {
          ;(this.playDirection = s < 0 ? -1 : 1), this.updaFrameModifier()
        }),
        (AnimationItem.prototype.setLoop = function (s) {
          this.loop = s
        }),
        (AnimationItem.prototype.setVolume = function (s, e) {
          ;(e && this.name !== e) || this.audioController.setVolume(s)
        }),
        (AnimationItem.prototype.getVolume = function () {
          return this.audioController.getVolume()
        }),
        (AnimationItem.prototype.mute = function (s) {
          ;(s && this.name !== s) || this.audioController.mute()
        }),
        (AnimationItem.prototype.unmute = function (s) {
          ;(s && this.name !== s) || this.audioController.unmute()
        }),
        (AnimationItem.prototype.updaFrameModifier = function () {
          ;(this.frameModifier =
            this.frameMult * this.playSpeed * this.playDirection),
            this.audioController.setRate(this.playSpeed * this.playDirection)
        }),
        (AnimationItem.prototype.getPath = function () {
          return this.path
        }),
        (AnimationItem.prototype.getAssetsPath = function (s) {
          var e = ""
          if (s.e) e = s.p
          else if (this.assetsPath) {
            var a = s.p
            a.indexOf("images/") !== -1 && (a = a.split("/")[1]),
              (e = this.assetsPath + a)
          } else (e = this.path), (e += s.u ? s.u : ""), (e += s.p)
          return e
        }),
        (AnimationItem.prototype.getAssetData = function (s) {
          for (var e = 0, a = this.assets.length; e < a; ) {
            if (s === this.assets[e].id) return this.assets[e]
            e += 1
          }
          return null
        }),
        (AnimationItem.prototype.hide = function () {
          this.renderer.hide()
        }),
        (AnimationItem.prototype.show = function () {
          this.renderer.show()
        }),
        (AnimationItem.prototype.getDuration = function (s) {
          return s ? this.totalFrames : this.totalFrames / this.frameRate
        }),
        (AnimationItem.prototype.updateDocumentData = function (s, e, a) {
          try {
            var o = this.renderer.getElementByPath(s)
            o.updateDocumentData(e, a)
          } catch {}
        }),
        (AnimationItem.prototype.trigger = function (s) {
          if (this._cbs && this._cbs[s])
            switch (s) {
              case "enterFrame":
                this.triggerEvent(
                  s,
                  new BMEnterFrameEvent(
                    s,
                    this.currentFrame,
                    this.totalFrames,
                    this.frameModifier
                  )
                )
                break
              case "drawnFrame":
                ;(this.drawnFrameEvent.currentTime = this.currentFrame),
                  (this.drawnFrameEvent.totalTime = this.totalFrames),
                  (this.drawnFrameEvent.direction = this.frameModifier),
                  this.triggerEvent(s, this.drawnFrameEvent)
                break
              case "loopComplete":
                this.triggerEvent(
                  s,
                  new BMCompleteLoopEvent(
                    s,
                    this.loop,
                    this.playCount,
                    this.frameMult
                  )
                )
                break
              case "complete":
                this.triggerEvent(s, new BMCompleteEvent(s, this.frameMult))
                break
              case "segmentStart":
                this.triggerEvent(
                  s,
                  new BMSegmentStartEvent(s, this.firstFrame, this.totalFrames)
                )
                break
              case "destroy":
                this.triggerEvent(s, new BMDestroyEvent(s, this))
                break
              default:
                this.triggerEvent(s)
            }
          s === "enterFrame" &&
            this.onEnterFrame &&
            this.onEnterFrame.call(
              this,
              new BMEnterFrameEvent(
                s,
                this.currentFrame,
                this.totalFrames,
                this.frameMult
              )
            ),
            s === "loopComplete" &&
              this.onLoopComplete &&
              this.onLoopComplete.call(
                this,
                new BMCompleteLoopEvent(
                  s,
                  this.loop,
                  this.playCount,
                  this.frameMult
                )
              ),
            s === "complete" &&
              this.onComplete &&
              this.onComplete.call(
                this,
                new BMCompleteEvent(s, this.frameMult)
              ),
            s === "segmentStart" &&
              this.onSegmentStart &&
              this.onSegmentStart.call(
                this,
                new BMSegmentStartEvent(s, this.firstFrame, this.totalFrames)
              ),
            s === "destroy" &&
              this.onDestroy &&
              this.onDestroy.call(this, new BMDestroyEvent(s, this))
        }),
        (AnimationItem.prototype.triggerRenderFrameError = function (s) {
          var e = new BMRenderFrameErrorEvent(s, this.currentFrame)
          this.triggerEvent("error", e),
            this.onError && this.onError.call(this, e)
        }),
        (AnimationItem.prototype.triggerConfigError = function (s) {
          var e = new BMConfigErrorEvent(s, this.currentFrame)
          this.triggerEvent("error", e),
            this.onError && this.onError.call(this, e)
        })
      var animationManager = (function () {
          var s = {},
            e = [],
            a = 0,
            o = 0,
            c = 0,
            d = !0,
            g = !1
          function _(Mt) {
            for (var wt = 0, gt = Mt.target; wt < o; )
              e[wt].animation === gt &&
                (e.splice(wt, 1), (wt -= 1), (o -= 1), gt.isPaused || _e()),
                (wt += 1)
          }
          function b(Mt, wt) {
            if (!Mt) return null
            for (var gt = 0; gt < o; ) {
              if (e[gt].elem === Mt && e[gt].elem !== null)
                return e[gt].animation
              gt += 1
            }
            var At = new AnimationItem()
            return tt(At, Mt), At.setData(Mt, wt), At
          }
          function j() {
            var Mt,
              wt = e.length,
              gt = []
            for (Mt = 0; Mt < wt; Mt += 1) gt.push(e[Mt].animation)
            return gt
          }
          function $() {
            ;(c += 1), Et()
          }
          function _e() {
            c -= 1
          }
          function tt(Mt, wt) {
            Mt.addEventListener("destroy", _),
              Mt.addEventListener("_active", $),
              Mt.addEventListener("_idle", _e),
              e.push({ elem: wt, animation: Mt }),
              (o += 1)
          }
          function st(Mt) {
            var wt = new AnimationItem()
            return tt(wt, null), wt.setParams(Mt), wt
          }
          function at(Mt, wt) {
            var gt
            for (gt = 0; gt < o; gt += 1) e[gt].animation.setSpeed(Mt, wt)
          }
          function ot(Mt, wt) {
            var gt
            for (gt = 0; gt < o; gt += 1) e[gt].animation.setDirection(Mt, wt)
          }
          function ut(Mt) {
            var wt
            for (wt = 0; wt < o; wt += 1) e[wt].animation.play(Mt)
          }
          function it(Mt) {
            var wt = Mt - a,
              gt
            for (gt = 0; gt < o; gt += 1) e[gt].animation.advanceTime(wt)
            ;(a = Mt), c && !g ? window.requestAnimationFrame(it) : (d = !0)
          }
          function ct(Mt) {
            ;(a = Mt), window.requestAnimationFrame(it)
          }
          function lt(Mt) {
            var wt
            for (wt = 0; wt < o; wt += 1) e[wt].animation.pause(Mt)
          }
          function ht(Mt, wt, gt) {
            var At
            for (At = 0; At < o; At += 1)
              e[At].animation.goToAndStop(Mt, wt, gt)
          }
          function dt(Mt) {
            var wt
            for (wt = 0; wt < o; wt += 1) e[wt].animation.stop(Mt)
          }
          function pt(Mt) {
            var wt
            for (wt = 0; wt < o; wt += 1) e[wt].animation.togglePause(Mt)
          }
          function vt(Mt) {
            var wt
            for (wt = o - 1; wt >= 0; wt -= 1) e[wt].animation.destroy(Mt)
          }
          function _t(Mt, wt, gt) {
            var At = [].concat(
                [].slice.call(document.getElementsByClassName("lottie")),
                [].slice.call(document.getElementsByClassName("bodymovin"))
              ),
              bt,
              Tt = At.length
            for (bt = 0; bt < Tt; bt += 1)
              gt && At[bt].setAttribute("data-bm-type", gt), b(At[bt], Mt)
            if (wt && Tt === 0) {
              gt || (gt = "svg")
              var It = document.getElementsByTagName("body")[0]
              It.innerText = ""
              var $t = createTag("div")
              ;($t.style.width = "100%"),
                ($t.style.height = "100%"),
                $t.setAttribute("data-bm-type", gt),
                It.appendChild($t),
                b($t, Mt)
            }
          }
          function yt() {
            var Mt
            for (Mt = 0; Mt < o; Mt += 1) e[Mt].animation.resize()
          }
          function Et() {
            !g && c && d && (window.requestAnimationFrame(ct), (d = !1))
          }
          function Rt() {
            g = !0
          }
          function Ft() {
            ;(g = !1), Et()
          }
          function kt(Mt, wt) {
            var gt
            for (gt = 0; gt < o; gt += 1) e[gt].animation.setVolume(Mt, wt)
          }
          function Nt(Mt) {
            var wt
            for (wt = 0; wt < o; wt += 1) e[wt].animation.mute(Mt)
          }
          function Dt(Mt) {
            var wt
            for (wt = 0; wt < o; wt += 1) e[wt].animation.unmute(Mt)
          }
          return (
            (s.registerAnimation = b),
            (s.loadAnimation = st),
            (s.setSpeed = at),
            (s.setDirection = ot),
            (s.play = ut),
            (s.pause = lt),
            (s.stop = dt),
            (s.togglePause = pt),
            (s.searchAnimations = _t),
            (s.resize = yt),
            (s.goToAndStop = ht),
            (s.destroy = vt),
            (s.freeze = Rt),
            (s.unfreeze = Ft),
            (s.setVolume = kt),
            (s.mute = Nt),
            (s.unmute = Dt),
            (s.getRegisteredAnimations = j),
            s
          )
        })(),
        BezierFactory = (function () {
          var s = {}
          s.getBezierEasing = a
          var e = {}
          function a(ct, lt, ht, dt, pt) {
            var vt =
              pt ||
              ("bez_" + ct + "_" + lt + "_" + ht + "_" + dt).replace(/\./g, "p")
            if (e[vt]) return e[vt]
            var _t = new it([ct, lt, ht, dt])
            return (e[vt] = _t), _t
          }
          var o = 4,
            c = 0.001,
            d = 1e-7,
            g = 10,
            _ = 11,
            b = 1 / (_ - 1),
            j = typeof Float32Array == "function"
          function $(ct, lt) {
            return 1 - 3 * lt + 3 * ct
          }
          function _e(ct, lt) {
            return 3 * lt - 6 * ct
          }
          function tt(ct) {
            return 3 * ct
          }
          function st(ct, lt, ht) {
            return (($(lt, ht) * ct + _e(lt, ht)) * ct + tt(lt)) * ct
          }
          function at(ct, lt, ht) {
            return 3 * $(lt, ht) * ct * ct + 2 * _e(lt, ht) * ct + tt(lt)
          }
          function ot(ct, lt, ht, dt, pt) {
            var vt,
              _t,
              yt = 0
            do
              (_t = lt + (ht - lt) / 2),
                (vt = st(_t, dt, pt) - ct),
                vt > 0 ? (ht = _t) : (lt = _t)
            while (Math.abs(vt) > d && ++yt < g)
            return _t
          }
          function ut(ct, lt, ht, dt) {
            for (var pt = 0; pt < o; ++pt) {
              var vt = at(lt, ht, dt)
              if (vt === 0) return lt
              var _t = st(lt, ht, dt) - ct
              lt -= _t / vt
            }
            return lt
          }
          function it(ct) {
            ;(this._p = ct),
              (this._mSampleValues = j ? new Float32Array(_) : new Array(_)),
              (this._precomputed = !1),
              (this.get = this.get.bind(this))
          }
          return (
            (it.prototype = {
              get: function (lt) {
                var ht = this._p[0],
                  dt = this._p[1],
                  pt = this._p[2],
                  vt = this._p[3]
                return (
                  this._precomputed || this._precompute(),
                  ht === dt && pt === vt
                    ? lt
                    : lt === 0
                    ? 0
                    : lt === 1
                    ? 1
                    : st(this._getTForX(lt), dt, vt)
                )
              },
              _precompute: function () {
                var lt = this._p[0],
                  ht = this._p[1],
                  dt = this._p[2],
                  pt = this._p[3]
                ;(this._precomputed = !0),
                  (lt !== ht || dt !== pt) && this._calcSampleValues()
              },
              _calcSampleValues: function () {
                for (var lt = this._p[0], ht = this._p[2], dt = 0; dt < _; ++dt)
                  this._mSampleValues[dt] = st(dt * b, lt, ht)
              },
              _getTForX: function (lt) {
                for (
                  var ht = this._p[0],
                    dt = this._p[2],
                    pt = this._mSampleValues,
                    vt = 0,
                    _t = 1,
                    yt = _ - 1;
                  _t !== yt && pt[_t] <= lt;
                  ++_t
                )
                  vt += b
                --_t
                var Et = (lt - pt[_t]) / (pt[_t + 1] - pt[_t]),
                  Rt = vt + Et * b,
                  Ft = at(Rt, ht, dt)
                return Ft >= c
                  ? ut(lt, Rt, ht, dt)
                  : Ft === 0
                  ? Rt
                  : ot(lt, vt, vt + b, ht, dt)
              },
            }),
            s
          )
        })(),
        pooling = (function () {
          function s(e) {
            return e.concat(createSizedArray(e.length))
          }
          return { double: s }
        })(),
        poolFactory = (function () {
          return function (s, e, a) {
            var o = 0,
              c = s,
              d = createSizedArray(c),
              g = { newElement: _, release: b }
            function _() {
              var j
              return o ? ((o -= 1), (j = d[o])) : (j = e()), j
            }
            function b(j) {
              o === c && ((d = pooling.double(d)), (c *= 2)),
                a && a(j),
                (d[o] = j),
                (o += 1)
            }
            return g
          }
        })(),
        bezierLengthPool = (function () {
          function s() {
            return {
              addedLength: 0,
              percents: createTypedArray("float32", getDefaultCurveSegments()),
              lengths: createTypedArray("float32", getDefaultCurveSegments()),
            }
          }
          return poolFactory(8, s)
        })(),
        segmentsLengthPool = (function () {
          function s() {
            return { lengths: [], totalLength: 0 }
          }
          function e(a) {
            var o,
              c = a.lengths.length
            for (o = 0; o < c; o += 1) bezierLengthPool.release(a.lengths[o])
            a.lengths.length = 0
          }
          return poolFactory(8, s, e)
        })()
      function bezFunction() {
        var s = Math
        function e(tt, st, at, ot, ut, it) {
          var ct = tt * ot + st * ut + at * it - ut * ot - it * tt - at * st
          return ct > -0.001 && ct < 0.001
        }
        function a(tt, st, at, ot, ut, it, ct, lt, ht) {
          if (at === 0 && it === 0 && ht === 0) return e(tt, st, ot, ut, ct, lt)
          var dt = s.sqrt(
              s.pow(ot - tt, 2) + s.pow(ut - st, 2) + s.pow(it - at, 2)
            ),
            pt = s.sqrt(
              s.pow(ct - tt, 2) + s.pow(lt - st, 2) + s.pow(ht - at, 2)
            ),
            vt = s.sqrt(
              s.pow(ct - ot, 2) + s.pow(lt - ut, 2) + s.pow(ht - it, 2)
            ),
            _t
          return (
            dt > pt
              ? dt > vt
                ? (_t = dt - pt - vt)
                : (_t = vt - pt - dt)
              : vt > pt
              ? (_t = vt - pt - dt)
              : (_t = pt - dt - vt),
            _t > -1e-4 && _t < 1e-4
          )
        }
        var o = (function () {
          return function (tt, st, at, ot) {
            var ut = getDefaultCurveSegments(),
              it,
              ct,
              lt,
              ht,
              dt,
              pt = 0,
              vt,
              _t = [],
              yt = [],
              Et = bezierLengthPool.newElement()
            for (lt = at.length, it = 0; it < ut; it += 1) {
              for (dt = it / (ut - 1), vt = 0, ct = 0; ct < lt; ct += 1)
                (ht =
                  bmPow(1 - dt, 3) * tt[ct] +
                  3 * bmPow(1 - dt, 2) * dt * at[ct] +
                  3 * (1 - dt) * bmPow(dt, 2) * ot[ct] +
                  bmPow(dt, 3) * st[ct]),
                  (_t[ct] = ht),
                  yt[ct] !== null && (vt += bmPow(_t[ct] - yt[ct], 2)),
                  (yt[ct] = _t[ct])
              vt && ((vt = bmSqrt(vt)), (pt += vt)),
                (Et.percents[it] = dt),
                (Et.lengths[it] = pt)
            }
            return (Et.addedLength = pt), Et
          }
        })()
        function c(tt) {
          var st = segmentsLengthPool.newElement(),
            at = tt.c,
            ot = tt.v,
            ut = tt.o,
            it = tt.i,
            ct,
            lt = tt._length,
            ht = st.lengths,
            dt = 0
          for (ct = 0; ct < lt - 1; ct += 1)
            (ht[ct] = o(ot[ct], ot[ct + 1], ut[ct], it[ct + 1])),
              (dt += ht[ct].addedLength)
          return (
            at &&
              lt &&
              ((ht[ct] = o(ot[ct], ot[0], ut[ct], it[0])),
              (dt += ht[ct].addedLength)),
            (st.totalLength = dt),
            st
          )
        }
        function d(tt) {
          ;(this.segmentLength = 0), (this.points = new Array(tt))
        }
        function g(tt, st) {
          ;(this.partialLength = tt), (this.point = st)
        }
        var _ = (function () {
          var tt = {}
          return function (st, at, ot, ut) {
            var it = (
              st[0] +
              "_" +
              st[1] +
              "_" +
              at[0] +
              "_" +
              at[1] +
              "_" +
              ot[0] +
              "_" +
              ot[1] +
              "_" +
              ut[0] +
              "_" +
              ut[1]
            ).replace(/\./g, "p")
            if (!tt[it]) {
              var ct = getDefaultCurveSegments(),
                lt,
                ht,
                dt,
                pt,
                vt,
                _t = 0,
                yt,
                Et,
                Rt = null
              st.length === 2 &&
                (st[0] !== at[0] || st[1] !== at[1]) &&
                e(st[0], st[1], at[0], at[1], st[0] + ot[0], st[1] + ot[1]) &&
                e(st[0], st[1], at[0], at[1], at[0] + ut[0], at[1] + ut[1]) &&
                (ct = 2)
              var Ft = new d(ct)
              for (dt = ot.length, lt = 0; lt < ct; lt += 1) {
                for (
                  Et = createSizedArray(dt), vt = lt / (ct - 1), yt = 0, ht = 0;
                  ht < dt;
                  ht += 1
                )
                  (pt =
                    bmPow(1 - vt, 3) * st[ht] +
                    3 * bmPow(1 - vt, 2) * vt * (st[ht] + ot[ht]) +
                    3 * (1 - vt) * bmPow(vt, 2) * (at[ht] + ut[ht]) +
                    bmPow(vt, 3) * at[ht]),
                    (Et[ht] = pt),
                    Rt !== null && (yt += bmPow(Et[ht] - Rt[ht], 2))
                ;(yt = bmSqrt(yt)),
                  (_t += yt),
                  (Ft.points[lt] = new g(yt, Et)),
                  (Rt = Et)
              }
              ;(Ft.segmentLength = _t), (tt[it] = Ft)
            }
            return tt[it]
          }
        })()
        function b(tt, st) {
          var at = st.percents,
            ot = st.lengths,
            ut = at.length,
            it = bmFloor((ut - 1) * tt),
            ct = tt * st.addedLength,
            lt = 0
          if (it === ut - 1 || it === 0 || ct === ot[it]) return at[it]
          for (var ht = ot[it] > ct ? -1 : 1, dt = !0; dt; )
            if (
              (ot[it] <= ct && ot[it + 1] > ct
                ? ((lt = (ct - ot[it]) / (ot[it + 1] - ot[it])), (dt = !1))
                : (it += ht),
              it < 0 || it >= ut - 1)
            ) {
              if (it === ut - 1) return at[it]
              dt = !1
            }
          return at[it] + (at[it + 1] - at[it]) * lt
        }
        function j(tt, st, at, ot, ut, it) {
          var ct = b(ut, it),
            lt = 1 - ct,
            ht =
              s.round(
                (lt * lt * lt * tt[0] +
                  (ct * lt * lt + lt * ct * lt + lt * lt * ct) * at[0] +
                  (ct * ct * lt + lt * ct * ct + ct * lt * ct) * ot[0] +
                  ct * ct * ct * st[0]) *
                  1e3
              ) / 1e3,
            dt =
              s.round(
                (lt * lt * lt * tt[1] +
                  (ct * lt * lt + lt * ct * lt + lt * lt * ct) * at[1] +
                  (ct * ct * lt + lt * ct * ct + ct * lt * ct) * ot[1] +
                  ct * ct * ct * st[1]) *
                  1e3
              ) / 1e3
          return [ht, dt]
        }
        var $ = createTypedArray("float32", 8)
        function _e(tt, st, at, ot, ut, it, ct) {
          ut < 0 ? (ut = 0) : ut > 1 && (ut = 1)
          var lt = b(ut, ct)
          it = it > 1 ? 1 : it
          var ht = b(it, ct),
            dt,
            pt = tt.length,
            vt = 1 - lt,
            _t = 1 - ht,
            yt = vt * vt * vt,
            Et = lt * vt * vt * 3,
            Rt = lt * lt * vt * 3,
            Ft = lt * lt * lt,
            kt = vt * vt * _t,
            Nt = lt * vt * _t + vt * lt * _t + vt * vt * ht,
            Dt = lt * lt * _t + vt * lt * ht + lt * vt * ht,
            Mt = lt * lt * ht,
            wt = vt * _t * _t,
            gt = lt * _t * _t + vt * ht * _t + vt * _t * ht,
            At = lt * ht * _t + vt * ht * ht + lt * _t * ht,
            bt = lt * ht * ht,
            Tt = _t * _t * _t,
            It = ht * _t * _t + _t * ht * _t + _t * _t * ht,
            $t = ht * ht * _t + _t * ht * ht + ht * _t * ht,
            Xt = ht * ht * ht
          for (dt = 0; dt < pt; dt += 1)
            ($[dt * 4] =
              s.round(
                (yt * tt[dt] + Et * at[dt] + Rt * ot[dt] + Ft * st[dt]) * 1e3
              ) / 1e3),
              ($[dt * 4 + 1] =
                s.round(
                  (kt * tt[dt] + Nt * at[dt] + Dt * ot[dt] + Mt * st[dt]) * 1e3
                ) / 1e3),
              ($[dt * 4 + 2] =
                s.round(
                  (wt * tt[dt] + gt * at[dt] + At * ot[dt] + bt * st[dt]) * 1e3
                ) / 1e3),
              ($[dt * 4 + 3] =
                s.round(
                  (Tt * tt[dt] + It * at[dt] + $t * ot[dt] + Xt * st[dt]) * 1e3
                ) / 1e3)
          return $
        }
        return {
          getSegmentsLength: c,
          getNewSegment: _e,
          getPointInSegment: j,
          buildBezierData: _,
          pointOnLine2D: e,
          pointOnLine3D: a,
        }
      }
      var bez = bezFunction(),
        initFrame = initialDefaultFrame,
        mathAbs = Math.abs
      function interpolateValue(s, e) {
        var a = this.offsetTime,
          o
        this.propType === "multidimensional" &&
          (o = createTypedArray("float32", this.pv.length))
        for (
          var c = e.lastIndex,
            d = c,
            g = this.keyframes.length - 1,
            _ = !0,
            b,
            j,
            $;
          _;

        ) {
          if (
            ((b = this.keyframes[d]),
            (j = this.keyframes[d + 1]),
            d === g - 1 && s >= j.t - a)
          ) {
            b.h && (b = j), (c = 0)
            break
          }
          if (j.t - a > s) {
            c = d
            break
          }
          d < g - 1 ? (d += 1) : ((c = 0), (_ = !1))
        }
        $ = this.keyframesMetadata[d] || {}
        var _e,
          tt,
          st,
          at,
          ot,
          ut,
          it = j.t - a,
          ct = b.t - a,
          lt
        if (b.to) {
          $.bezierData ||
            ($.bezierData = bez.buildBezierData(b.s, j.s || b.e, b.to, b.ti))
          var ht = $.bezierData
          if (s >= it || s < ct) {
            var dt = s >= it ? ht.points.length - 1 : 0
            for (tt = ht.points[dt].point.length, _e = 0; _e < tt; _e += 1)
              o[_e] = ht.points[dt].point[_e]
          } else {
            $.__fnct
              ? (ut = $.__fnct)
              : ((ut = BezierFactory.getBezierEasing(
                  b.o.x,
                  b.o.y,
                  b.i.x,
                  b.i.y,
                  b.n
                ).get),
                ($.__fnct = ut)),
              (st = ut((s - ct) / (it - ct)))
            var pt = ht.segmentLength * st,
              vt,
              _t =
                e.lastFrame < s && e._lastKeyframeIndex === d
                  ? e._lastAddedLength
                  : 0
            for (
              ot =
                e.lastFrame < s && e._lastKeyframeIndex === d
                  ? e._lastPoint
                  : 0,
                _ = !0,
                at = ht.points.length;
              _;

            ) {
              if (
                ((_t += ht.points[ot].partialLength),
                pt === 0 || st === 0 || ot === ht.points.length - 1)
              ) {
                for (tt = ht.points[ot].point.length, _e = 0; _e < tt; _e += 1)
                  o[_e] = ht.points[ot].point[_e]
                break
              } else if (
                pt >= _t &&
                pt < _t + ht.points[ot + 1].partialLength
              ) {
                for (
                  vt = (pt - _t) / ht.points[ot + 1].partialLength,
                    tt = ht.points[ot].point.length,
                    _e = 0;
                  _e < tt;
                  _e += 1
                )
                  o[_e] =
                    ht.points[ot].point[_e] +
                    (ht.points[ot + 1].point[_e] - ht.points[ot].point[_e]) * vt
                break
              }
              ot < at - 1 ? (ot += 1) : (_ = !1)
            }
            ;(e._lastPoint = ot),
              (e._lastAddedLength = _t - ht.points[ot].partialLength),
              (e._lastKeyframeIndex = d)
          }
        } else {
          var yt, Et, Rt, Ft, kt
          if (((g = b.s.length), (lt = j.s || b.e), this.sh && b.h !== 1))
            if (s >= it) (o[0] = lt[0]), (o[1] = lt[1]), (o[2] = lt[2])
            else if (s <= ct) (o[0] = b.s[0]), (o[1] = b.s[1]), (o[2] = b.s[2])
            else {
              var Nt = createQuaternion(b.s),
                Dt = createQuaternion(lt),
                Mt = (s - ct) / (it - ct)
              quaternionToEuler(o, slerp(Nt, Dt, Mt))
            }
          else
            for (d = 0; d < g; d += 1)
              b.h !== 1 &&
                (s >= it
                  ? (st = 1)
                  : s < ct
                  ? (st = 0)
                  : (b.o.x.constructor === Array
                      ? ($.__fnct || ($.__fnct = []),
                        $.__fnct[d]
                          ? (ut = $.__fnct[d])
                          : ((yt = b.o.x[d] === void 0 ? b.o.x[0] : b.o.x[d]),
                            (Et = b.o.y[d] === void 0 ? b.o.y[0] : b.o.y[d]),
                            (Rt = b.i.x[d] === void 0 ? b.i.x[0] : b.i.x[d]),
                            (Ft = b.i.y[d] === void 0 ? b.i.y[0] : b.i.y[d]),
                            (ut = BezierFactory.getBezierEasing(
                              yt,
                              Et,
                              Rt,
                              Ft
                            ).get),
                            ($.__fnct[d] = ut)))
                      : $.__fnct
                      ? (ut = $.__fnct)
                      : ((yt = b.o.x),
                        (Et = b.o.y),
                        (Rt = b.i.x),
                        (Ft = b.i.y),
                        (ut = BezierFactory.getBezierEasing(
                          yt,
                          Et,
                          Rt,
                          Ft
                        ).get),
                        (b.keyframeMetadata = ut)),
                    (st = ut((s - ct) / (it - ct))))),
                (lt = j.s || b.e),
                (kt = b.h === 1 ? b.s[d] : b.s[d] + (lt[d] - b.s[d]) * st),
                this.propType === "multidimensional" ? (o[d] = kt) : (o = kt)
        }
        return (e.lastIndex = c), o
      }
      function slerp(s, e, a) {
        var o = [],
          c = s[0],
          d = s[1],
          g = s[2],
          _ = s[3],
          b = e[0],
          j = e[1],
          $ = e[2],
          _e = e[3],
          tt,
          st,
          at,
          ot,
          ut
        return (
          (st = c * b + d * j + g * $ + _ * _e),
          st < 0 && ((st = -st), (b = -b), (j = -j), ($ = -$), (_e = -_e)),
          1 - st > 1e-6
            ? ((tt = Math.acos(st)),
              (at = Math.sin(tt)),
              (ot = Math.sin((1 - a) * tt) / at),
              (ut = Math.sin(a * tt) / at))
            : ((ot = 1 - a), (ut = a)),
          (o[0] = ot * c + ut * b),
          (o[1] = ot * d + ut * j),
          (o[2] = ot * g + ut * $),
          (o[3] = ot * _ + ut * _e),
          o
        )
      }
      function quaternionToEuler(s, e) {
        var a = e[0],
          o = e[1],
          c = e[2],
          d = e[3],
          g = Math.atan2(2 * o * d - 2 * a * c, 1 - 2 * o * o - 2 * c * c),
          _ = Math.asin(2 * a * o + 2 * c * d),
          b = Math.atan2(2 * a * d - 2 * o * c, 1 - 2 * a * a - 2 * c * c)
        ;(s[0] = g / degToRads), (s[1] = _ / degToRads), (s[2] = b / degToRads)
      }
      function createQuaternion(s) {
        var e = s[0] * degToRads,
          a = s[1] * degToRads,
          o = s[2] * degToRads,
          c = Math.cos(e / 2),
          d = Math.cos(a / 2),
          g = Math.cos(o / 2),
          _ = Math.sin(e / 2),
          b = Math.sin(a / 2),
          j = Math.sin(o / 2),
          $ = c * d * g - _ * b * j,
          _e = _ * b * g + c * d * j,
          tt = _ * d * g + c * b * j,
          st = c * b * g - _ * d * j
        return [_e, tt, st, $]
      }
      function getValueAtCurrentTime() {
        var s = this.comp.renderedFrame - this.offsetTime,
          e = this.keyframes[0].t - this.offsetTime,
          a = this.keyframes[this.keyframes.length - 1].t - this.offsetTime
        if (
          !(
            s === this._caching.lastFrame ||
            (this._caching.lastFrame !== initFrame &&
              ((this._caching.lastFrame >= a && s >= a) ||
                (this._caching.lastFrame < e && s < e)))
          )
        ) {
          this._caching.lastFrame >= s &&
            ((this._caching._lastKeyframeIndex = -1),
            (this._caching.lastIndex = 0))
          var o = this.interpolateValue(s, this._caching)
          this.pv = o
        }
        return (this._caching.lastFrame = s), this.pv
      }
      function setVValue(s) {
        var e
        if (this.propType === "unidimensional")
          (e = s * this.mult),
            mathAbs(this.v - e) > 1e-5 && ((this.v = e), (this._mdf = !0))
        else
          for (var a = 0, o = this.v.length; a < o; )
            (e = s[a] * this.mult),
              mathAbs(this.v[a] - e) > 1e-5 &&
                ((this.v[a] = e), (this._mdf = !0)),
              (a += 1)
      }
      function processEffectsSequence() {
        if (
          !(
            this.elem.globalData.frameId === this.frameId ||
            !this.effectsSequence.length
          )
        ) {
          if (this.lock) {
            this.setVValue(this.pv)
            return
          }
          ;(this.lock = !0), (this._mdf = this._isFirstFrame)
          var s,
            e = this.effectsSequence.length,
            a = this.kf ? this.pv : this.data.k
          for (s = 0; s < e; s += 1) a = this.effectsSequence[s](a)
          this.setVValue(a),
            (this._isFirstFrame = !1),
            (this.lock = !1),
            (this.frameId = this.elem.globalData.frameId)
        }
      }
      function addEffect(s) {
        this.effectsSequence.push(s), this.container.addDynamicProperty(this)
      }
      function ValueProperty(s, e, a, o) {
        ;(this.propType = "unidimensional"),
          (this.mult = a || 1),
          (this.data = e),
          (this.v = a ? e.k * a : e.k),
          (this.pv = e.k),
          (this._mdf = !1),
          (this.elem = s),
          (this.container = o),
          (this.comp = s.comp),
          (this.k = !1),
          (this.kf = !1),
          (this.vel = 0),
          (this.effectsSequence = []),
          (this._isFirstFrame = !0),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.addEffect = addEffect)
      }
      function MultiDimensionalProperty(s, e, a, o) {
        ;(this.propType = "multidimensional"),
          (this.mult = a || 1),
          (this.data = e),
          (this._mdf = !1),
          (this.elem = s),
          (this.container = o),
          (this.comp = s.comp),
          (this.k = !1),
          (this.kf = !1),
          (this.frameId = -1)
        var c,
          d = e.k.length
        for (
          this.v = createTypedArray("float32", d),
            this.pv = createTypedArray("float32", d),
            this.vel = createTypedArray("float32", d),
            c = 0;
          c < d;
          c += 1
        )
          (this.v[c] = e.k[c] * this.mult), (this.pv[c] = e.k[c])
        ;(this._isFirstFrame = !0),
          (this.effectsSequence = []),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.addEffect = addEffect)
      }
      function KeyframedValueProperty(s, e, a, o) {
        ;(this.propType = "unidimensional"),
          (this.keyframes = e.k),
          (this.keyframesMetadata = []),
          (this.offsetTime = s.data.st),
          (this.frameId = -1),
          (this._caching = {
            lastFrame: initFrame,
            lastIndex: 0,
            value: 0,
            _lastKeyframeIndex: -1,
          }),
          (this.k = !0),
          (this.kf = !0),
          (this.data = e),
          (this.mult = a || 1),
          (this.elem = s),
          (this.container = o),
          (this.comp = s.comp),
          (this.v = initFrame),
          (this.pv = initFrame),
          (this._isFirstFrame = !0),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.interpolateValue = interpolateValue),
          (this.effectsSequence = [getValueAtCurrentTime.bind(this)]),
          (this.addEffect = addEffect)
      }
      function KeyframedMultidimensionalProperty(s, e, a, o) {
        this.propType = "multidimensional"
        var c,
          d = e.k.length,
          g,
          _,
          b,
          j
        for (c = 0; c < d - 1; c += 1)
          e.k[c].to &&
            e.k[c].s &&
            e.k[c + 1] &&
            e.k[c + 1].s &&
            ((g = e.k[c].s),
            (_ = e.k[c + 1].s),
            (b = e.k[c].to),
            (j = e.k[c].ti),
            ((g.length === 2 &&
              !(g[0] === _[0] && g[1] === _[1]) &&
              bez.pointOnLine2D(
                g[0],
                g[1],
                _[0],
                _[1],
                g[0] + b[0],
                g[1] + b[1]
              ) &&
              bez.pointOnLine2D(
                g[0],
                g[1],
                _[0],
                _[1],
                _[0] + j[0],
                _[1] + j[1]
              )) ||
              (g.length === 3 &&
                !(g[0] === _[0] && g[1] === _[1] && g[2] === _[2]) &&
                bez.pointOnLine3D(
                  g[0],
                  g[1],
                  g[2],
                  _[0],
                  _[1],
                  _[2],
                  g[0] + b[0],
                  g[1] + b[1],
                  g[2] + b[2]
                ) &&
                bez.pointOnLine3D(
                  g[0],
                  g[1],
                  g[2],
                  _[0],
                  _[1],
                  _[2],
                  _[0] + j[0],
                  _[1] + j[1],
                  _[2] + j[2]
                ))) &&
              ((e.k[c].to = null), (e.k[c].ti = null)),
            g[0] === _[0] &&
              g[1] === _[1] &&
              b[0] === 0 &&
              b[1] === 0 &&
              j[0] === 0 &&
              j[1] === 0 &&
              (g.length === 2 || (g[2] === _[2] && b[2] === 0 && j[2] === 0)) &&
              ((e.k[c].to = null), (e.k[c].ti = null)))
        ;(this.effectsSequence = [getValueAtCurrentTime.bind(this)]),
          (this.data = e),
          (this.keyframes = e.k),
          (this.keyframesMetadata = []),
          (this.offsetTime = s.data.st),
          (this.k = !0),
          (this.kf = !0),
          (this._isFirstFrame = !0),
          (this.mult = a || 1),
          (this.elem = s),
          (this.container = o),
          (this.comp = s.comp),
          (this.getValue = processEffectsSequence),
          (this.setVValue = setVValue),
          (this.interpolateValue = interpolateValue),
          (this.frameId = -1)
        var $ = e.k[0].s.length
        for (
          this.v = createTypedArray("float32", $),
            this.pv = createTypedArray("float32", $),
            c = 0;
          c < $;
          c += 1
        )
          (this.v[c] = initFrame), (this.pv[c] = initFrame)
        ;(this._caching = {
          lastFrame: initFrame,
          lastIndex: 0,
          value: createTypedArray("float32", $),
        }),
          (this.addEffect = addEffect)
      }
      var PropertyFactory = (function () {
        function s(a, o, c, d, g) {
          o.sid && (o = a.globalData.slotManager.getProp(o))
          var _
          if (!o.k.length) _ = new ValueProperty(a, o, d, g)
          else if (typeof o.k[0] == "number")
            _ = new MultiDimensionalProperty(a, o, d, g)
          else
            switch (c) {
              case 0:
                _ = new KeyframedValueProperty(a, o, d, g)
                break
              case 1:
                _ = new KeyframedMultidimensionalProperty(a, o, d, g)
                break
            }
          return _.effectsSequence.length && g.addDynamicProperty(_), _
        }
        var e = { getProp: s }
        return e
      })()
      function DynamicPropertyContainer() {}
      DynamicPropertyContainer.prototype = {
        addDynamicProperty: function (e) {
          this.dynamicProperties.indexOf(e) === -1 &&
            (this.dynamicProperties.push(e),
            this.container.addDynamicProperty(this),
            (this._isAnimated = !0))
        },
        iterateDynamicProperties: function () {
          this._mdf = !1
          var e,
            a = this.dynamicProperties.length
          for (e = 0; e < a; e += 1)
            this.dynamicProperties[e].getValue(),
              this.dynamicProperties[e]._mdf && (this._mdf = !0)
        },
        initDynamicPropertyContainer: function (e) {
          ;(this.container = e),
            (this.dynamicProperties = []),
            (this._mdf = !1),
            (this._isAnimated = !1)
        },
      }
      var pointPool = (function () {
        function s() {
          return createTypedArray("float32", 2)
        }
        return poolFactory(8, s)
      })()
      function ShapePath() {
        ;(this.c = !1),
          (this._length = 0),
          (this._maxLength = 8),
          (this.v = createSizedArray(this._maxLength)),
          (this.o = createSizedArray(this._maxLength)),
          (this.i = createSizedArray(this._maxLength))
      }
      ;(ShapePath.prototype.setPathData = function (s, e) {
        ;(this.c = s), this.setLength(e)
        for (var a = 0; a < e; )
          (this.v[a] = pointPool.newElement()),
            (this.o[a] = pointPool.newElement()),
            (this.i[a] = pointPool.newElement()),
            (a += 1)
      }),
        (ShapePath.prototype.setLength = function (s) {
          for (; this._maxLength < s; ) this.doubleArrayLength()
          this._length = s
        }),
        (ShapePath.prototype.doubleArrayLength = function () {
          ;(this.v = this.v.concat(createSizedArray(this._maxLength))),
            (this.i = this.i.concat(createSizedArray(this._maxLength))),
            (this.o = this.o.concat(createSizedArray(this._maxLength))),
            (this._maxLength *= 2)
        }),
        (ShapePath.prototype.setXYAt = function (s, e, a, o, c) {
          var d
          switch (
            ((this._length = Math.max(this._length, o + 1)),
            this._length >= this._maxLength && this.doubleArrayLength(),
            a)
          ) {
            case "v":
              d = this.v
              break
            case "i":
              d = this.i
              break
            case "o":
              d = this.o
              break
            default:
              d = []
              break
          }
          ;(!d[o] || (d[o] && !c)) && (d[o] = pointPool.newElement()),
            (d[o][0] = s),
            (d[o][1] = e)
        }),
        (ShapePath.prototype.setTripleAt = function (s, e, a, o, c, d, g, _) {
          this.setXYAt(s, e, "v", g, _),
            this.setXYAt(a, o, "o", g, _),
            this.setXYAt(c, d, "i", g, _)
        }),
        (ShapePath.prototype.reverse = function () {
          var s = new ShapePath()
          s.setPathData(this.c, this._length)
          var e = this.v,
            a = this.o,
            o = this.i,
            c = 0
          this.c &&
            (s.setTripleAt(
              e[0][0],
              e[0][1],
              o[0][0],
              o[0][1],
              a[0][0],
              a[0][1],
              0,
              !1
            ),
            (c = 1))
          var d = this._length - 1,
            g = this._length,
            _
          for (_ = c; _ < g; _ += 1)
            s.setTripleAt(
              e[d][0],
              e[d][1],
              o[d][0],
              o[d][1],
              a[d][0],
              a[d][1],
              _,
              !1
            ),
              (d -= 1)
          return s
        }),
        (ShapePath.prototype.length = function () {
          return this._length
        })
      var shapePool = (function () {
        function s() {
          return new ShapePath()
        }
        function e(c) {
          var d = c._length,
            g
          for (g = 0; g < d; g += 1)
            pointPool.release(c.v[g]),
              pointPool.release(c.i[g]),
              pointPool.release(c.o[g]),
              (c.v[g] = null),
              (c.i[g] = null),
              (c.o[g] = null)
          ;(c._length = 0), (c.c = !1)
        }
        function a(c) {
          var d = o.newElement(),
            g,
            _ = c._length === void 0 ? c.v.length : c._length
          for (d.setLength(_), d.c = c.c, g = 0; g < _; g += 1)
            d.setTripleAt(
              c.v[g][0],
              c.v[g][1],
              c.o[g][0],
              c.o[g][1],
              c.i[g][0],
              c.i[g][1],
              g
            )
          return d
        }
        var o = poolFactory(4, s, e)
        return (o.clone = a), o
      })()
      function ShapeCollection() {
        ;(this._length = 0),
          (this._maxLength = 4),
          (this.shapes = createSizedArray(this._maxLength))
      }
      ;(ShapeCollection.prototype.addShape = function (s) {
        this._length === this._maxLength &&
          ((this.shapes = this.shapes.concat(
            createSizedArray(this._maxLength)
          )),
          (this._maxLength *= 2)),
          (this.shapes[this._length] = s),
          (this._length += 1)
      }),
        (ShapeCollection.prototype.releaseShapes = function () {
          var s
          for (s = 0; s < this._length; s += 1)
            shapePool.release(this.shapes[s])
          this._length = 0
        })
      var shapeCollectionPool = (function () {
          var s = { newShapeCollection: c, release: d },
            e = 0,
            a = 4,
            o = createSizedArray(a)
          function c() {
            var g
            return e ? ((e -= 1), (g = o[e])) : (g = new ShapeCollection()), g
          }
          function d(g) {
            var _,
              b = g._length
            for (_ = 0; _ < b; _ += 1) shapePool.release(g.shapes[_])
            ;(g._length = 0),
              e === a && ((o = pooling.double(o)), (a *= 2)),
              (o[e] = g),
              (e += 1)
          }
          return s
        })(),
        ShapePropertyFactory = (function () {
          var s = -999999
          function e(it, ct, lt) {
            var ht = lt.lastIndex,
              dt,
              pt,
              vt,
              _t,
              yt,
              Et,
              Rt,
              Ft,
              kt,
              Nt = this.keyframes
            if (it < Nt[0].t - this.offsetTime)
              (dt = Nt[0].s[0]), (vt = !0), (ht = 0)
            else if (it >= Nt[Nt.length - 1].t - this.offsetTime)
              (dt = Nt[Nt.length - 1].s
                ? Nt[Nt.length - 1].s[0]
                : Nt[Nt.length - 2].e[0]),
                (vt = !0)
            else {
              for (
                var Dt = ht, Mt = Nt.length - 1, wt = !0, gt, At, bt;
                wt &&
                ((gt = Nt[Dt]),
                (At = Nt[Dt + 1]),
                !(At.t - this.offsetTime > it));

              )
                Dt < Mt - 1 ? (Dt += 1) : (wt = !1)
              if (
                ((bt = this.keyframesMetadata[Dt] || {}),
                (vt = gt.h === 1),
                (ht = Dt),
                !vt)
              ) {
                if (it >= At.t - this.offsetTime) Ft = 1
                else if (it < gt.t - this.offsetTime) Ft = 0
                else {
                  var Tt
                  bt.__fnct
                    ? (Tt = bt.__fnct)
                    : ((Tt = BezierFactory.getBezierEasing(
                        gt.o.x,
                        gt.o.y,
                        gt.i.x,
                        gt.i.y
                      ).get),
                      (bt.__fnct = Tt)),
                    (Ft = Tt(
                      (it - (gt.t - this.offsetTime)) /
                        (At.t - this.offsetTime - (gt.t - this.offsetTime))
                    ))
                }
                pt = At.s ? At.s[0] : gt.e[0]
              }
              dt = gt.s[0]
            }
            for (
              Et = ct._length, Rt = dt.i[0].length, lt.lastIndex = ht, _t = 0;
              _t < Et;
              _t += 1
            )
              for (yt = 0; yt < Rt; yt += 1)
                (kt = vt
                  ? dt.i[_t][yt]
                  : dt.i[_t][yt] + (pt.i[_t][yt] - dt.i[_t][yt]) * Ft),
                  (ct.i[_t][yt] = kt),
                  (kt = vt
                    ? dt.o[_t][yt]
                    : dt.o[_t][yt] + (pt.o[_t][yt] - dt.o[_t][yt]) * Ft),
                  (ct.o[_t][yt] = kt),
                  (kt = vt
                    ? dt.v[_t][yt]
                    : dt.v[_t][yt] + (pt.v[_t][yt] - dt.v[_t][yt]) * Ft),
                  (ct.v[_t][yt] = kt)
          }
          function a() {
            var it = this.comp.renderedFrame - this.offsetTime,
              ct = this.keyframes[0].t - this.offsetTime,
              lt =
                this.keyframes[this.keyframes.length - 1].t - this.offsetTime,
              ht = this._caching.lastFrame
            return (
              (ht !== s && ((ht < ct && it < ct) || (ht > lt && it > lt))) ||
                ((this._caching.lastIndex =
                  ht < it ? this._caching.lastIndex : 0),
                this.interpolateShape(it, this.pv, this._caching)),
              (this._caching.lastFrame = it),
              this.pv
            )
          }
          function o() {
            this.paths = this.localShapeCollection
          }
          function c(it, ct) {
            if (it._length !== ct._length || it.c !== ct.c) return !1
            var lt,
              ht = it._length
            for (lt = 0; lt < ht; lt += 1)
              if (
                it.v[lt][0] !== ct.v[lt][0] ||
                it.v[lt][1] !== ct.v[lt][1] ||
                it.o[lt][0] !== ct.o[lt][0] ||
                it.o[lt][1] !== ct.o[lt][1] ||
                it.i[lt][0] !== ct.i[lt][0] ||
                it.i[lt][1] !== ct.i[lt][1]
              )
                return !1
            return !0
          }
          function d(it) {
            c(this.v, it) ||
              ((this.v = shapePool.clone(it)),
              this.localShapeCollection.releaseShapes(),
              this.localShapeCollection.addShape(this.v),
              (this._mdf = !0),
              (this.paths = this.localShapeCollection))
          }
          function g() {
            if (this.elem.globalData.frameId !== this.frameId) {
              if (!this.effectsSequence.length) {
                this._mdf = !1
                return
              }
              if (this.lock) {
                this.setVValue(this.pv)
                return
              }
              ;(this.lock = !0), (this._mdf = !1)
              var it
              this.kf
                ? (it = this.pv)
                : this.data.ks
                ? (it = this.data.ks.k)
                : (it = this.data.pt.k)
              var ct,
                lt = this.effectsSequence.length
              for (ct = 0; ct < lt; ct += 1) it = this.effectsSequence[ct](it)
              this.setVValue(it),
                (this.lock = !1),
                (this.frameId = this.elem.globalData.frameId)
            }
          }
          function _(it, ct, lt) {
            ;(this.propType = "shape"),
              (this.comp = it.comp),
              (this.container = it),
              (this.elem = it),
              (this.data = ct),
              (this.k = !1),
              (this.kf = !1),
              (this._mdf = !1)
            var ht = lt === 3 ? ct.pt.k : ct.ks.k
            ;(this.v = shapePool.clone(ht)),
              (this.pv = shapePool.clone(this.v)),
              (this.localShapeCollection =
                shapeCollectionPool.newShapeCollection()),
              (this.paths = this.localShapeCollection),
              this.paths.addShape(this.v),
              (this.reset = o),
              (this.effectsSequence = [])
          }
          function b(it) {
            this.effectsSequence.push(it),
              this.container.addDynamicProperty(this)
          }
          ;(_.prototype.interpolateShape = e),
            (_.prototype.getValue = g),
            (_.prototype.setVValue = d),
            (_.prototype.addEffect = b)
          function j(it, ct, lt) {
            ;(this.propType = "shape"),
              (this.comp = it.comp),
              (this.elem = it),
              (this.container = it),
              (this.offsetTime = it.data.st),
              (this.keyframes = lt === 3 ? ct.pt.k : ct.ks.k),
              (this.keyframesMetadata = []),
              (this.k = !0),
              (this.kf = !0)
            var ht = this.keyframes[0].s[0].i.length
            ;(this.v = shapePool.newElement()),
              this.v.setPathData(this.keyframes[0].s[0].c, ht),
              (this.pv = shapePool.clone(this.v)),
              (this.localShapeCollection =
                shapeCollectionPool.newShapeCollection()),
              (this.paths = this.localShapeCollection),
              this.paths.addShape(this.v),
              (this.lastFrame = s),
              (this.reset = o),
              (this._caching = { lastFrame: s, lastIndex: 0 }),
              (this.effectsSequence = [a.bind(this)])
          }
          ;(j.prototype.getValue = g),
            (j.prototype.interpolateShape = e),
            (j.prototype.setVValue = d),
            (j.prototype.addEffect = b)
          var $ = (function () {
              var it = roundCorner
              function ct(lt, ht) {
                ;(this.v = shapePool.newElement()),
                  this.v.setPathData(!0, 4),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  (this.paths = this.localShapeCollection),
                  this.localShapeCollection.addShape(this.v),
                  (this.d = ht.d),
                  (this.elem = lt),
                  (this.comp = lt.comp),
                  (this.frameId = -1),
                  this.initDynamicPropertyContainer(lt),
                  (this.p = PropertyFactory.getProp(lt, ht.p, 1, 0, this)),
                  (this.s = PropertyFactory.getProp(lt, ht.s, 1, 0, this)),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertEllToPath())
              }
              return (
                (ct.prototype = {
                  reset: o,
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertEllToPath())
                  },
                  convertEllToPath: function () {
                    var ht = this.p.v[0],
                      dt = this.p.v[1],
                      pt = this.s.v[0] / 2,
                      vt = this.s.v[1] / 2,
                      _t = this.d !== 3,
                      yt = this.v
                    ;(yt.v[0][0] = ht),
                      (yt.v[0][1] = dt - vt),
                      (yt.v[1][0] = _t ? ht + pt : ht - pt),
                      (yt.v[1][1] = dt),
                      (yt.v[2][0] = ht),
                      (yt.v[2][1] = dt + vt),
                      (yt.v[3][0] = _t ? ht - pt : ht + pt),
                      (yt.v[3][1] = dt),
                      (yt.i[0][0] = _t ? ht - pt * it : ht + pt * it),
                      (yt.i[0][1] = dt - vt),
                      (yt.i[1][0] = _t ? ht + pt : ht - pt),
                      (yt.i[1][1] = dt - vt * it),
                      (yt.i[2][0] = _t ? ht + pt * it : ht - pt * it),
                      (yt.i[2][1] = dt + vt),
                      (yt.i[3][0] = _t ? ht - pt : ht + pt),
                      (yt.i[3][1] = dt + vt * it),
                      (yt.o[0][0] = _t ? ht + pt * it : ht - pt * it),
                      (yt.o[0][1] = dt - vt),
                      (yt.o[1][0] = _t ? ht + pt : ht - pt),
                      (yt.o[1][1] = dt + vt * it),
                      (yt.o[2][0] = _t ? ht - pt * it : ht + pt * it),
                      (yt.o[2][1] = dt + vt),
                      (yt.o[3][0] = _t ? ht - pt : ht + pt),
                      (yt.o[3][1] = dt - vt * it)
                  },
                }),
                extendPrototype([DynamicPropertyContainer], ct),
                ct
              )
            })(),
            _e = (function () {
              function it(ct, lt) {
                ;(this.v = shapePool.newElement()),
                  this.v.setPathData(!0, 0),
                  (this.elem = ct),
                  (this.comp = ct.comp),
                  (this.data = lt),
                  (this.frameId = -1),
                  (this.d = lt.d),
                  this.initDynamicPropertyContainer(ct),
                  lt.sy === 1
                    ? ((this.ir = PropertyFactory.getProp(
                        ct,
                        lt.ir,
                        0,
                        0,
                        this
                      )),
                      (this.is = PropertyFactory.getProp(
                        ct,
                        lt.is,
                        0,
                        0.01,
                        this
                      )),
                      (this.convertToPath = this.convertStarToPath))
                    : (this.convertToPath = this.convertPolygonToPath),
                  (this.pt = PropertyFactory.getProp(ct, lt.pt, 0, 0, this)),
                  (this.p = PropertyFactory.getProp(ct, lt.p, 1, 0, this)),
                  (this.r = PropertyFactory.getProp(
                    ct,
                    lt.r,
                    0,
                    degToRads,
                    this
                  )),
                  (this.or = PropertyFactory.getProp(ct, lt.or, 0, 0, this)),
                  (this.os = PropertyFactory.getProp(ct, lt.os, 0, 0.01, this)),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  this.localShapeCollection.addShape(this.v),
                  (this.paths = this.localShapeCollection),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertToPath())
              }
              return (
                (it.prototype = {
                  reset: o,
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertToPath())
                  },
                  convertStarToPath: function () {
                    var lt = Math.floor(this.pt.v) * 2,
                      ht = (Math.PI * 2) / lt,
                      dt = !0,
                      pt = this.or.v,
                      vt = this.ir.v,
                      _t = this.os.v,
                      yt = this.is.v,
                      Et = (2 * Math.PI * pt) / (lt * 2),
                      Rt = (2 * Math.PI * vt) / (lt * 2),
                      Ft,
                      kt,
                      Nt,
                      Dt,
                      Mt = -Math.PI / 2
                    Mt += this.r.v
                    var wt = this.data.d === 3 ? -1 : 1
                    for (this.v._length = 0, Ft = 0; Ft < lt; Ft += 1) {
                      ;(kt = dt ? pt : vt),
                        (Nt = dt ? _t : yt),
                        (Dt = dt ? Et : Rt)
                      var gt = kt * Math.cos(Mt),
                        At = kt * Math.sin(Mt),
                        bt =
                          gt === 0 && At === 0
                            ? 0
                            : At / Math.sqrt(gt * gt + At * At),
                        Tt =
                          gt === 0 && At === 0
                            ? 0
                            : -gt / Math.sqrt(gt * gt + At * At)
                      ;(gt += +this.p.v[0]),
                        (At += +this.p.v[1]),
                        this.v.setTripleAt(
                          gt,
                          At,
                          gt - bt * Dt * Nt * wt,
                          At - Tt * Dt * Nt * wt,
                          gt + bt * Dt * Nt * wt,
                          At + Tt * Dt * Nt * wt,
                          Ft,
                          !0
                        ),
                        (dt = !dt),
                        (Mt += ht * wt)
                    }
                  },
                  convertPolygonToPath: function () {
                    var lt = Math.floor(this.pt.v),
                      ht = (Math.PI * 2) / lt,
                      dt = this.or.v,
                      pt = this.os.v,
                      vt = (2 * Math.PI * dt) / (lt * 4),
                      _t,
                      yt = -Math.PI * 0.5,
                      Et = this.data.d === 3 ? -1 : 1
                    for (
                      yt += this.r.v, this.v._length = 0, _t = 0;
                      _t < lt;
                      _t += 1
                    ) {
                      var Rt = dt * Math.cos(yt),
                        Ft = dt * Math.sin(yt),
                        kt =
                          Rt === 0 && Ft === 0
                            ? 0
                            : Ft / Math.sqrt(Rt * Rt + Ft * Ft),
                        Nt =
                          Rt === 0 && Ft === 0
                            ? 0
                            : -Rt / Math.sqrt(Rt * Rt + Ft * Ft)
                      ;(Rt += +this.p.v[0]),
                        (Ft += +this.p.v[1]),
                        this.v.setTripleAt(
                          Rt,
                          Ft,
                          Rt - kt * vt * pt * Et,
                          Ft - Nt * vt * pt * Et,
                          Rt + kt * vt * pt * Et,
                          Ft + Nt * vt * pt * Et,
                          _t,
                          !0
                        ),
                        (yt += ht * Et)
                    }
                    ;(this.paths.length = 0), (this.paths[0] = this.v)
                  },
                }),
                extendPrototype([DynamicPropertyContainer], it),
                it
              )
            })(),
            tt = (function () {
              function it(ct, lt) {
                ;(this.v = shapePool.newElement()),
                  (this.v.c = !0),
                  (this.localShapeCollection =
                    shapeCollectionPool.newShapeCollection()),
                  this.localShapeCollection.addShape(this.v),
                  (this.paths = this.localShapeCollection),
                  (this.elem = ct),
                  (this.comp = ct.comp),
                  (this.frameId = -1),
                  (this.d = lt.d),
                  this.initDynamicPropertyContainer(ct),
                  (this.p = PropertyFactory.getProp(ct, lt.p, 1, 0, this)),
                  (this.s = PropertyFactory.getProp(ct, lt.s, 1, 0, this)),
                  (this.r = PropertyFactory.getProp(ct, lt.r, 0, 0, this)),
                  this.dynamicProperties.length
                    ? (this.k = !0)
                    : ((this.k = !1), this.convertRectToPath())
              }
              return (
                (it.prototype = {
                  convertRectToPath: function () {
                    var lt = this.p.v[0],
                      ht = this.p.v[1],
                      dt = this.s.v[0] / 2,
                      pt = this.s.v[1] / 2,
                      vt = bmMin(dt, pt, this.r.v),
                      _t = vt * (1 - roundCorner)
                    ;(this.v._length = 0),
                      this.d === 2 || this.d === 1
                        ? (this.v.setTripleAt(
                            lt + dt,
                            ht - pt + vt,
                            lt + dt,
                            ht - pt + vt,
                            lt + dt,
                            ht - pt + _t,
                            0,
                            !0
                          ),
                          this.v.setTripleAt(
                            lt + dt,
                            ht + pt - vt,
                            lt + dt,
                            ht + pt - _t,
                            lt + dt,
                            ht + pt - vt,
                            1,
                            !0
                          ),
                          vt !== 0
                            ? (this.v.setTripleAt(
                                lt + dt - vt,
                                ht + pt,
                                lt + dt - vt,
                                ht + pt,
                                lt + dt - _t,
                                ht + pt,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt - dt + vt,
                                ht + pt,
                                lt - dt + _t,
                                ht + pt,
                                lt - dt + vt,
                                ht + pt,
                                3,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt - dt,
                                ht + pt - vt,
                                lt - dt,
                                ht + pt - vt,
                                lt - dt,
                                ht + pt - _t,
                                4,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt - dt,
                                ht - pt + vt,
                                lt - dt,
                                ht - pt + _t,
                                lt - dt,
                                ht - pt + vt,
                                5,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt - dt + vt,
                                ht - pt,
                                lt - dt + vt,
                                ht - pt,
                                lt - dt + _t,
                                ht - pt,
                                6,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt + dt - vt,
                                ht - pt,
                                lt + dt - _t,
                                ht - pt,
                                lt + dt - vt,
                                ht - pt,
                                7,
                                !0
                              ))
                            : (this.v.setTripleAt(
                                lt - dt,
                                ht + pt,
                                lt - dt + _t,
                                ht + pt,
                                lt - dt,
                                ht + pt,
                                2
                              ),
                              this.v.setTripleAt(
                                lt - dt,
                                ht - pt,
                                lt - dt,
                                ht - pt + _t,
                                lt - dt,
                                ht - pt,
                                3
                              )))
                        : (this.v.setTripleAt(
                            lt + dt,
                            ht - pt + vt,
                            lt + dt,
                            ht - pt + _t,
                            lt + dt,
                            ht - pt + vt,
                            0,
                            !0
                          ),
                          vt !== 0
                            ? (this.v.setTripleAt(
                                lt + dt - vt,
                                ht - pt,
                                lt + dt - vt,
                                ht - pt,
                                lt + dt - _t,
                                ht - pt,
                                1,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt - dt + vt,
                                ht - pt,
                                lt - dt + _t,
                                ht - pt,
                                lt - dt + vt,
                                ht - pt,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt - dt,
                                ht - pt + vt,
                                lt - dt,
                                ht - pt + vt,
                                lt - dt,
                                ht - pt + _t,
                                3,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt - dt,
                                ht + pt - vt,
                                lt - dt,
                                ht + pt - _t,
                                lt - dt,
                                ht + pt - vt,
                                4,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt - dt + vt,
                                ht + pt,
                                lt - dt + vt,
                                ht + pt,
                                lt - dt + _t,
                                ht + pt,
                                5,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt + dt - vt,
                                ht + pt,
                                lt + dt - _t,
                                ht + pt,
                                lt + dt - vt,
                                ht + pt,
                                6,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt + dt,
                                ht + pt - vt,
                                lt + dt,
                                ht + pt - vt,
                                lt + dt,
                                ht + pt - _t,
                                7,
                                !0
                              ))
                            : (this.v.setTripleAt(
                                lt - dt,
                                ht - pt,
                                lt - dt + _t,
                                ht - pt,
                                lt - dt,
                                ht - pt,
                                1,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt - dt,
                                ht + pt,
                                lt - dt,
                                ht + pt - _t,
                                lt - dt,
                                ht + pt,
                                2,
                                !0
                              ),
                              this.v.setTripleAt(
                                lt + dt,
                                ht + pt,
                                lt + dt - _t,
                                ht + pt,
                                lt + dt,
                                ht + pt,
                                3,
                                !0
                              )))
                  },
                  getValue: function () {
                    this.elem.globalData.frameId !== this.frameId &&
                      ((this.frameId = this.elem.globalData.frameId),
                      this.iterateDynamicProperties(),
                      this._mdf && this.convertRectToPath())
                  },
                  reset: o,
                }),
                extendPrototype([DynamicPropertyContainer], it),
                it
              )
            })()
          function st(it, ct, lt) {
            var ht
            if (lt === 3 || lt === 4) {
              var dt = lt === 3 ? ct.pt : ct.ks,
                pt = dt.k
              pt.length ? (ht = new j(it, ct, lt)) : (ht = new _(it, ct, lt))
            } else
              lt === 5
                ? (ht = new tt(it, ct))
                : lt === 6
                ? (ht = new $(it, ct))
                : lt === 7 && (ht = new _e(it, ct))
            return ht.k && it.addDynamicProperty(ht), ht
          }
          function at() {
            return _
          }
          function ot() {
            return j
          }
          var ut = {}
          return (
            (ut.getShapeProp = st),
            (ut.getConstructorFunction = at),
            (ut.getKeyframedConstructorFunction = ot),
            ut
          )
        })()
      /*!
 Transformation Matrix v2.0
 (c) Epistemex 2014-2015
 www.epistemex.com
 By Ken Fyrstenberg
 Contributions by leeoniya.
 License: MIT, header required.
 */ var Matrix = (function () {
        var s = Math.cos,
          e = Math.sin,
          a = Math.tan,
          o = Math.round
        function c() {
          return (
            (this.props[0] = 1),
            (this.props[1] = 0),
            (this.props[2] = 0),
            (this.props[3] = 0),
            (this.props[4] = 0),
            (this.props[5] = 1),
            (this.props[6] = 0),
            (this.props[7] = 0),
            (this.props[8] = 0),
            (this.props[9] = 0),
            (this.props[10] = 1),
            (this.props[11] = 0),
            (this.props[12] = 0),
            (this.props[13] = 0),
            (this.props[14] = 0),
            (this.props[15] = 1),
            this
          )
        }
        function d(gt) {
          if (gt === 0) return this
          var At = s(gt),
            bt = e(gt)
          return this._t(At, -bt, 0, 0, bt, At, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
        }
        function g(gt) {
          if (gt === 0) return this
          var At = s(gt),
            bt = e(gt)
          return this._t(1, 0, 0, 0, 0, At, -bt, 0, 0, bt, At, 0, 0, 0, 0, 1)
        }
        function _(gt) {
          if (gt === 0) return this
          var At = s(gt),
            bt = e(gt)
          return this._t(At, 0, bt, 0, 0, 1, 0, 0, -bt, 0, At, 0, 0, 0, 0, 1)
        }
        function b(gt) {
          if (gt === 0) return this
          var At = s(gt),
            bt = e(gt)
          return this._t(At, -bt, 0, 0, bt, At, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
        }
        function j(gt, At) {
          return this._t(1, At, gt, 1, 0, 0)
        }
        function $(gt, At) {
          return this.shear(a(gt), a(At))
        }
        function _e(gt, At) {
          var bt = s(At),
            Tt = e(At)
          return this._t(bt, Tt, 0, 0, -Tt, bt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            ._t(1, 0, 0, 0, a(gt), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
            ._t(bt, -Tt, 0, 0, Tt, bt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
        }
        function tt(gt, At, bt) {
          return (
            !bt && bt !== 0 && (bt = 1),
            gt === 1 && At === 1 && bt === 1
              ? this
              : this._t(gt, 0, 0, 0, 0, At, 0, 0, 0, 0, bt, 0, 0, 0, 0, 1)
          )
        }
        function st(
          gt,
          At,
          bt,
          Tt,
          It,
          $t,
          Xt,
          qt,
          en,
          yn,
          Tn,
          $n,
          Vn,
          gn,
          Ht,
          on
        ) {
          return (
            (this.props[0] = gt),
            (this.props[1] = At),
            (this.props[2] = bt),
            (this.props[3] = Tt),
            (this.props[4] = It),
            (this.props[5] = $t),
            (this.props[6] = Xt),
            (this.props[7] = qt),
            (this.props[8] = en),
            (this.props[9] = yn),
            (this.props[10] = Tn),
            (this.props[11] = $n),
            (this.props[12] = Vn),
            (this.props[13] = gn),
            (this.props[14] = Ht),
            (this.props[15] = on),
            this
          )
        }
        function at(gt, At, bt) {
          return (
            (bt = bt || 0),
            gt !== 0 || At !== 0 || bt !== 0
              ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, gt, At, bt, 1)
              : this
          )
        }
        function ot(
          gt,
          At,
          bt,
          Tt,
          It,
          $t,
          Xt,
          qt,
          en,
          yn,
          Tn,
          $n,
          Vn,
          gn,
          Ht,
          on
        ) {
          var Yt = this.props
          if (
            gt === 1 &&
            At === 0 &&
            bt === 0 &&
            Tt === 0 &&
            It === 0 &&
            $t === 1 &&
            Xt === 0 &&
            qt === 0 &&
            en === 0 &&
            yn === 0 &&
            Tn === 1 &&
            $n === 0
          )
            return (
              (Yt[12] = Yt[12] * gt + Yt[15] * Vn),
              (Yt[13] = Yt[13] * $t + Yt[15] * gn),
              (Yt[14] = Yt[14] * Tn + Yt[15] * Ht),
              (Yt[15] *= on),
              (this._identityCalculated = !1),
              this
            )
          var _n = Yt[0],
            pn = Yt[1],
            Rn = Yt[2],
            bn = Yt[3],
            Pn = Yt[4],
            Gn = Yt[5],
            jn = Yt[6],
            ar = Yt[7],
            Vt = Yt[8],
            Lt = Yt[9],
            Zt = Yt[10],
            xn = Yt[11],
            vn = Yt[12],
            An = Yt[13],
            Nn = Yt[14],
            Sn = Yt[15]
          return (
            (Yt[0] = _n * gt + pn * It + Rn * en + bn * Vn),
            (Yt[1] = _n * At + pn * $t + Rn * yn + bn * gn),
            (Yt[2] = _n * bt + pn * Xt + Rn * Tn + bn * Ht),
            (Yt[3] = _n * Tt + pn * qt + Rn * $n + bn * on),
            (Yt[4] = Pn * gt + Gn * It + jn * en + ar * Vn),
            (Yt[5] = Pn * At + Gn * $t + jn * yn + ar * gn),
            (Yt[6] = Pn * bt + Gn * Xt + jn * Tn + ar * Ht),
            (Yt[7] = Pn * Tt + Gn * qt + jn * $n + ar * on),
            (Yt[8] = Vt * gt + Lt * It + Zt * en + xn * Vn),
            (Yt[9] = Vt * At + Lt * $t + Zt * yn + xn * gn),
            (Yt[10] = Vt * bt + Lt * Xt + Zt * Tn + xn * Ht),
            (Yt[11] = Vt * Tt + Lt * qt + Zt * $n + xn * on),
            (Yt[12] = vn * gt + An * It + Nn * en + Sn * Vn),
            (Yt[13] = vn * At + An * $t + Nn * yn + Sn * gn),
            (Yt[14] = vn * bt + An * Xt + Nn * Tn + Sn * Ht),
            (Yt[15] = vn * Tt + An * qt + Nn * $n + Sn * on),
            (this._identityCalculated = !1),
            this
          )
        }
        function ut(gt) {
          var At = gt.props
          return this.transform(
            At[0],
            At[1],
            At[2],
            At[3],
            At[4],
            At[5],
            At[6],
            At[7],
            At[8],
            At[9],
            At[10],
            At[11],
            At[12],
            At[13],
            At[14],
            At[15]
          )
        }
        function it() {
          return (
            this._identityCalculated ||
              ((this._identity = !(
                this.props[0] !== 1 ||
                this.props[1] !== 0 ||
                this.props[2] !== 0 ||
                this.props[3] !== 0 ||
                this.props[4] !== 0 ||
                this.props[5] !== 1 ||
                this.props[6] !== 0 ||
                this.props[7] !== 0 ||
                this.props[8] !== 0 ||
                this.props[9] !== 0 ||
                this.props[10] !== 1 ||
                this.props[11] !== 0 ||
                this.props[12] !== 0 ||
                this.props[13] !== 0 ||
                this.props[14] !== 0 ||
                this.props[15] !== 1
              )),
              (this._identityCalculated = !0)),
            this._identity
          )
        }
        function ct(gt) {
          for (var At = 0; At < 16; ) {
            if (gt.props[At] !== this.props[At]) return !1
            At += 1
          }
          return !0
        }
        function lt(gt) {
          var At
          for (At = 0; At < 16; At += 1) gt.props[At] = this.props[At]
          return gt
        }
        function ht(gt) {
          var At
          for (At = 0; At < 16; At += 1) this.props[At] = gt[At]
        }
        function dt(gt, At, bt) {
          return {
            x:
              gt * this.props[0] +
              At * this.props[4] +
              bt * this.props[8] +
              this.props[12],
            y:
              gt * this.props[1] +
              At * this.props[5] +
              bt * this.props[9] +
              this.props[13],
            z:
              gt * this.props[2] +
              At * this.props[6] +
              bt * this.props[10] +
              this.props[14],
          }
        }
        function pt(gt, At, bt) {
          return (
            gt * this.props[0] +
            At * this.props[4] +
            bt * this.props[8] +
            this.props[12]
          )
        }
        function vt(gt, At, bt) {
          return (
            gt * this.props[1] +
            At * this.props[5] +
            bt * this.props[9] +
            this.props[13]
          )
        }
        function _t(gt, At, bt) {
          return (
            gt * this.props[2] +
            At * this.props[6] +
            bt * this.props[10] +
            this.props[14]
          )
        }
        function yt() {
          var gt =
              this.props[0] * this.props[5] - this.props[1] * this.props[4],
            At = this.props[5] / gt,
            bt = -this.props[1] / gt,
            Tt = -this.props[4] / gt,
            It = this.props[0] / gt,
            $t =
              (this.props[4] * this.props[13] -
                this.props[5] * this.props[12]) /
              gt,
            Xt =
              -(
                this.props[0] * this.props[13] -
                this.props[1] * this.props[12]
              ) / gt,
            qt = new Matrix()
          return (
            (qt.props[0] = At),
            (qt.props[1] = bt),
            (qt.props[4] = Tt),
            (qt.props[5] = It),
            (qt.props[12] = $t),
            (qt.props[13] = Xt),
            qt
          )
        }
        function Et(gt) {
          var At = this.getInverseMatrix()
          return At.applyToPointArray(gt[0], gt[1], gt[2] || 0)
        }
        function Rt(gt) {
          var At,
            bt = gt.length,
            Tt = []
          for (At = 0; At < bt; At += 1) Tt[At] = Et(gt[At])
          return Tt
        }
        function Ft(gt, At, bt) {
          var Tt = createTypedArray("float32", 6)
          if (this.isIdentity())
            (Tt[0] = gt[0]),
              (Tt[1] = gt[1]),
              (Tt[2] = At[0]),
              (Tt[3] = At[1]),
              (Tt[4] = bt[0]),
              (Tt[5] = bt[1])
          else {
            var It = this.props[0],
              $t = this.props[1],
              Xt = this.props[4],
              qt = this.props[5],
              en = this.props[12],
              yn = this.props[13]
            ;(Tt[0] = gt[0] * It + gt[1] * Xt + en),
              (Tt[1] = gt[0] * $t + gt[1] * qt + yn),
              (Tt[2] = At[0] * It + At[1] * Xt + en),
              (Tt[3] = At[0] * $t + At[1] * qt + yn),
              (Tt[4] = bt[0] * It + bt[1] * Xt + en),
              (Tt[5] = bt[0] * $t + bt[1] * qt + yn)
          }
          return Tt
        }
        function kt(gt, At, bt) {
          var Tt
          return (
            this.isIdentity()
              ? (Tt = [gt, At, bt])
              : (Tt = [
                  gt * this.props[0] +
                    At * this.props[4] +
                    bt * this.props[8] +
                    this.props[12],
                  gt * this.props[1] +
                    At * this.props[5] +
                    bt * this.props[9] +
                    this.props[13],
                  gt * this.props[2] +
                    At * this.props[6] +
                    bt * this.props[10] +
                    this.props[14],
                ]),
            Tt
          )
        }
        function Nt(gt, At) {
          if (this.isIdentity()) return gt + "," + At
          var bt = this.props
          return (
            Math.round((gt * bt[0] + At * bt[4] + bt[12]) * 100) / 100 +
            "," +
            Math.round((gt * bt[1] + At * bt[5] + bt[13]) * 100) / 100
          )
        }
        function Dt() {
          for (
            var gt = 0, At = this.props, bt = "matrix3d(", Tt = 1e4;
            gt < 16;

          )
            (bt += o(At[gt] * Tt) / Tt),
              (bt += gt === 15 ? ")" : ","),
              (gt += 1)
          return bt
        }
        function Mt(gt) {
          var At = 1e4
          return (gt < 1e-6 && gt > 0) || (gt > -1e-6 && gt < 0)
            ? o(gt * At) / At
            : gt
        }
        function wt() {
          var gt = this.props,
            At = Mt(gt[0]),
            bt = Mt(gt[1]),
            Tt = Mt(gt[4]),
            It = Mt(gt[5]),
            $t = Mt(gt[12]),
            Xt = Mt(gt[13])
          return (
            "matrix(" +
            At +
            "," +
            bt +
            "," +
            Tt +
            "," +
            It +
            "," +
            $t +
            "," +
            Xt +
            ")"
          )
        }
        return function () {
          ;(this.reset = c),
            (this.rotate = d),
            (this.rotateX = g),
            (this.rotateY = _),
            (this.rotateZ = b),
            (this.skew = $),
            (this.skewFromAxis = _e),
            (this.shear = j),
            (this.scale = tt),
            (this.setTransform = st),
            (this.translate = at),
            (this.transform = ot),
            (this.multiply = ut),
            (this.applyToPoint = dt),
            (this.applyToX = pt),
            (this.applyToY = vt),
            (this.applyToZ = _t),
            (this.applyToPointArray = kt),
            (this.applyToTriplePoints = Ft),
            (this.applyToPointStringified = Nt),
            (this.toCSS = Dt),
            (this.to2dCSS = wt),
            (this.clone = lt),
            (this.cloneFromProps = ht),
            (this.equals = ct),
            (this.inversePoints = Rt),
            (this.inversePoint = Et),
            (this.getInverseMatrix = yt),
            (this._t = this.transform),
            (this.isIdentity = it),
            (this._identity = !0),
            (this._identityCalculated = !1),
            (this.props = createTypedArray("float32", 16)),
            this.reset()
        }
      })()
      function _typeof$3(s) {
        "@babel/helpers - typeof"
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$3 = function (a) {
                return typeof a
              })
            : (_typeof$3 = function (a) {
                return a &&
                  typeof Symbol == "function" &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a
              }),
          _typeof$3(s)
        )
      }
      var lottie = {}
      function setLocation(s) {
        setLocationHref(s)
      }
      function searchAnimations() {
        animationManager.searchAnimations()
      }
      function setSubframeRendering(s) {
        setSubframeEnabled(s)
      }
      function setPrefix(s) {
        setIdPrefix(s)
      }
      function loadAnimation(s) {
        return animationManager.loadAnimation(s)
      }
      function setQuality(s) {
        if (typeof s == "string")
          switch (s) {
            case "high":
              setDefaultCurveSegments(200)
              break
            default:
            case "medium":
              setDefaultCurveSegments(50)
              break
            case "low":
              setDefaultCurveSegments(10)
              break
          }
        else !isNaN(s) && s > 1 && setDefaultCurveSegments(s)
      }
      function inBrowser() {
        return typeof navigator < "u"
      }
      function installPlugin(s, e) {
        s === "expressions" && setExpressionsPlugin(e)
      }
      function getFactory(s) {
        switch (s) {
          case "propertyFactory":
            return PropertyFactory
          case "shapePropertyFactory":
            return ShapePropertyFactory
          case "matrix":
            return Matrix
          default:
            return null
        }
      }
      ;(lottie.play = animationManager.play),
        (lottie.pause = animationManager.pause),
        (lottie.setLocationHref = setLocation),
        (lottie.togglePause = animationManager.togglePause),
        (lottie.setSpeed = animationManager.setSpeed),
        (lottie.setDirection = animationManager.setDirection),
        (lottie.stop = animationManager.stop),
        (lottie.searchAnimations = searchAnimations),
        (lottie.registerAnimation = animationManager.registerAnimation),
        (lottie.loadAnimation = loadAnimation),
        (lottie.setSubframeRendering = setSubframeRendering),
        (lottie.resize = animationManager.resize),
        (lottie.goToAndStop = animationManager.goToAndStop),
        (lottie.destroy = animationManager.destroy),
        (lottie.setQuality = setQuality),
        (lottie.inBrowser = inBrowser),
        (lottie.installPlugin = installPlugin),
        (lottie.freeze = animationManager.freeze),
        (lottie.unfreeze = animationManager.unfreeze),
        (lottie.setVolume = animationManager.setVolume),
        (lottie.mute = animationManager.mute),
        (lottie.unmute = animationManager.unmute),
        (lottie.getRegisteredAnimations =
          animationManager.getRegisteredAnimations),
        (lottie.useWebWorker = setWebWorker),
        (lottie.setIDPrefix = setPrefix),
        (lottie.__getFactory = getFactory),
        (lottie.version = "5.12.2")
      function checkReady() {
        document.readyState === "complete" &&
          (clearInterval(readyStateCheckInterval), searchAnimations())
      }
      function getQueryVariable(s) {
        for (var e = queryString.split("&"), a = 0; a < e.length; a += 1) {
          var o = e[a].split("=")
          if (decodeURIComponent(o[0]) == s) return decodeURIComponent(o[1])
        }
        return null
      }
      var queryString = ""
      {
        var scripts = document.getElementsByTagName("script"),
          index = scripts.length - 1,
          myScript = scripts[index] || { src: "" }
        ;(queryString = myScript.src
          ? myScript.src.replace(/^[^\?]+\??/, "")
          : ""),
          getQueryVariable("renderer")
      }
      var readyStateCheckInterval = setInterval(checkReady, 100)
      try {
        _typeof$3(exports) !== "object" && (window.bodymovin = lottie)
      } catch (s) {}
      var ShapeModifiers = (function () {
        var s = {},
          e = {}
        ;(s.registerModifier = a), (s.getModifier = o)
        function a(c, d) {
          e[c] || (e[c] = d)
        }
        function o(c, d, g) {
          return new e[c](d, g)
        }
        return s
      })()
      function ShapeModifier() {}
      ;(ShapeModifier.prototype.initModifierProperties = function () {}),
        (ShapeModifier.prototype.addShapeToModifier = function () {}),
        (ShapeModifier.prototype.addShape = function (s) {
          if (!this.closed) {
            s.sh.container.addDynamicProperty(s.sh)
            var e = {
              shape: s.sh,
              data: s,
              localShapeCollection: shapeCollectionPool.newShapeCollection(),
            }
            this.shapes.push(e),
              this.addShapeToModifier(e),
              this._isAnimated && s.setAsAnimated()
          }
        }),
        (ShapeModifier.prototype.init = function (s, e) {
          ;(this.shapes = []),
            (this.elem = s),
            this.initDynamicPropertyContainer(s),
            this.initModifierProperties(s, e),
            (this.frameId = initialDefaultFrame),
            (this.closed = !1),
            (this.k = !1),
            this.dynamicProperties.length ? (this.k = !0) : this.getValue(!0)
        }),
        (ShapeModifier.prototype.processKeys = function () {
          this.elem.globalData.frameId !== this.frameId &&
            ((this.frameId = this.elem.globalData.frameId),
            this.iterateDynamicProperties())
        }),
        extendPrototype([DynamicPropertyContainer], ShapeModifier)
      function TrimModifier() {}
      extendPrototype([ShapeModifier], TrimModifier),
        (TrimModifier.prototype.initModifierProperties = function (s, e) {
          ;(this.s = PropertyFactory.getProp(s, e.s, 0, 0.01, this)),
            (this.e = PropertyFactory.getProp(s, e.e, 0, 0.01, this)),
            (this.o = PropertyFactory.getProp(s, e.o, 0, 0, this)),
            (this.sValue = 0),
            (this.eValue = 0),
            (this.getValue = this.processKeys),
            (this.m = e.m),
            (this._isAnimated =
              !!this.s.effectsSequence.length ||
              !!this.e.effectsSequence.length ||
              !!this.o.effectsSequence.length)
        }),
        (TrimModifier.prototype.addShapeToModifier = function (s) {
          s.pathsData = []
        }),
        (TrimModifier.prototype.calculateShapeEdges = function (s, e, a, o, c) {
          var d = []
          e <= 1
            ? d.push({ s, e })
            : s >= 1
            ? d.push({ s: s - 1, e: e - 1 })
            : (d.push({ s, e: 1 }), d.push({ s: 0, e: e - 1 }))
          var g = [],
            _,
            b = d.length,
            j
          for (_ = 0; _ < b; _ += 1)
            if (((j = d[_]), !(j.e * c < o || j.s * c > o + a))) {
              var $, _e
              j.s * c <= o ? ($ = 0) : ($ = (j.s * c - o) / a),
                j.e * c >= o + a ? (_e = 1) : (_e = (j.e * c - o) / a),
                g.push([$, _e])
            }
          return g.length || g.push([0, 0]), g
        }),
        (TrimModifier.prototype.releasePathsData = function (s) {
          var e,
            a = s.length
          for (e = 0; e < a; e += 1) segmentsLengthPool.release(s[e])
          return (s.length = 0), s
        }),
        (TrimModifier.prototype.processShapes = function (s) {
          var e, a
          if (this._mdf || s) {
            var o = (this.o.v % 360) / 360
            if (
              (o < 0 && (o += 1),
              this.s.v > 1
                ? (e = 1 + o)
                : this.s.v < 0
                ? (e = 0 + o)
                : (e = this.s.v + o),
              this.e.v > 1
                ? (a = 1 + o)
                : this.e.v < 0
                ? (a = 0 + o)
                : (a = this.e.v + o),
              e > a)
            ) {
              var c = e
              ;(e = a), (a = c)
            }
            ;(e = Math.round(e * 1e4) * 1e-4),
              (a = Math.round(a * 1e4) * 1e-4),
              (this.sValue = e),
              (this.eValue = a)
          } else (e = this.sValue), (a = this.eValue)
          var d,
            g,
            _ = this.shapes.length,
            b,
            j,
            $,
            _e,
            tt,
            st = 0
          if (a === e)
            for (g = 0; g < _; g += 1)
              this.shapes[g].localShapeCollection.releaseShapes(),
                (this.shapes[g].shape._mdf = !0),
                (this.shapes[g].shape.paths =
                  this.shapes[g].localShapeCollection),
                this._mdf && (this.shapes[g].pathsData.length = 0)
          else if ((a === 1 && e === 0) || (a === 0 && e === 1)) {
            if (this._mdf)
              for (g = 0; g < _; g += 1)
                (this.shapes[g].pathsData.length = 0),
                  (this.shapes[g].shape._mdf = !0)
          } else {
            var at = [],
              ot,
              ut
            for (g = 0; g < _; g += 1)
              if (
                ((ot = this.shapes[g]),
                !ot.shape._mdf && !this._mdf && !s && this.m !== 2)
              )
                ot.shape.paths = ot.localShapeCollection
              else {
                if (
                  ((d = ot.shape.paths),
                  (j = d._length),
                  (tt = 0),
                  !ot.shape._mdf && ot.pathsData.length)
                )
                  tt = ot.totalShapeLength
                else {
                  for (
                    $ = this.releasePathsData(ot.pathsData), b = 0;
                    b < j;
                    b += 1
                  )
                    (_e = bez.getSegmentsLength(d.shapes[b])),
                      $.push(_e),
                      (tt += _e.totalLength)
                  ;(ot.totalShapeLength = tt), (ot.pathsData = $)
                }
                ;(st += tt), (ot.shape._mdf = !0)
              }
            var it = e,
              ct = a,
              lt = 0,
              ht
            for (g = _ - 1; g >= 0; g -= 1)
              if (((ot = this.shapes[g]), ot.shape._mdf)) {
                for (
                  ut = ot.localShapeCollection,
                    ut.releaseShapes(),
                    this.m === 2 && _ > 1
                      ? ((ht = this.calculateShapeEdges(
                          e,
                          a,
                          ot.totalShapeLength,
                          lt,
                          st
                        )),
                        (lt += ot.totalShapeLength))
                      : (ht = [[it, ct]]),
                    j = ht.length,
                    b = 0;
                  b < j;
                  b += 1
                ) {
                  ;(it = ht[b][0]),
                    (ct = ht[b][1]),
                    (at.length = 0),
                    ct <= 1
                      ? at.push({
                          s: ot.totalShapeLength * it,
                          e: ot.totalShapeLength * ct,
                        })
                      : it >= 1
                      ? at.push({
                          s: ot.totalShapeLength * (it - 1),
                          e: ot.totalShapeLength * (ct - 1),
                        })
                      : (at.push({
                          s: ot.totalShapeLength * it,
                          e: ot.totalShapeLength,
                        }),
                        at.push({ s: 0, e: ot.totalShapeLength * (ct - 1) }))
                  var dt = this.addShapes(ot, at[0])
                  if (at[0].s !== at[0].e) {
                    if (at.length > 1) {
                      var pt = ot.shape.paths.shapes[ot.shape.paths._length - 1]
                      if (pt.c) {
                        var vt = dt.pop()
                        this.addPaths(dt, ut),
                          (dt = this.addShapes(ot, at[1], vt))
                      } else
                        this.addPaths(dt, ut), (dt = this.addShapes(ot, at[1]))
                    }
                    this.addPaths(dt, ut)
                  }
                }
                ot.shape.paths = ut
              }
          }
        }),
        (TrimModifier.prototype.addPaths = function (s, e) {
          var a,
            o = s.length
          for (a = 0; a < o; a += 1) e.addShape(s[a])
        }),
        (TrimModifier.prototype.addSegment = function (s, e, a, o, c, d, g) {
          c.setXYAt(e[0], e[1], "o", d),
            c.setXYAt(a[0], a[1], "i", d + 1),
            g && c.setXYAt(s[0], s[1], "v", d),
            c.setXYAt(o[0], o[1], "v", d + 1)
        }),
        (TrimModifier.prototype.addSegmentFromArray = function (s, e, a, o) {
          e.setXYAt(s[1], s[5], "o", a),
            e.setXYAt(s[2], s[6], "i", a + 1),
            o && e.setXYAt(s[0], s[4], "v", a),
            e.setXYAt(s[3], s[7], "v", a + 1)
        }),
        (TrimModifier.prototype.addShapes = function (s, e, a) {
          var o = s.pathsData,
            c = s.shape.paths.shapes,
            d,
            g = s.shape.paths._length,
            _,
            b,
            j = 0,
            $,
            _e,
            tt,
            st,
            at = [],
            ot,
            ut = !0
          for (
            a
              ? ((_e = a._length), (ot = a._length))
              : ((a = shapePool.newElement()), (_e = 0), (ot = 0)),
              at.push(a),
              d = 0;
            d < g;
            d += 1
          ) {
            for (
              tt = o[d].lengths,
                a.c = c[d].c,
                b = c[d].c ? tt.length : tt.length + 1,
                _ = 1;
              _ < b;
              _ += 1
            )
              if ((($ = tt[_ - 1]), j + $.addedLength < e.s))
                (j += $.addedLength), (a.c = !1)
              else if (j > e.e) {
                a.c = !1
                break
              } else
                e.s <= j && e.e >= j + $.addedLength
                  ? (this.addSegment(
                      c[d].v[_ - 1],
                      c[d].o[_ - 1],
                      c[d].i[_],
                      c[d].v[_],
                      a,
                      _e,
                      ut
                    ),
                    (ut = !1))
                  : ((st = bez.getNewSegment(
                      c[d].v[_ - 1],
                      c[d].v[_],
                      c[d].o[_ - 1],
                      c[d].i[_],
                      (e.s - j) / $.addedLength,
                      (e.e - j) / $.addedLength,
                      tt[_ - 1]
                    )),
                    this.addSegmentFromArray(st, a, _e, ut),
                    (ut = !1),
                    (a.c = !1)),
                  (j += $.addedLength),
                  (_e += 1)
            if (c[d].c && tt.length) {
              if ((($ = tt[_ - 1]), j <= e.e)) {
                var it = tt[_ - 1].addedLength
                e.s <= j && e.e >= j + it
                  ? (this.addSegment(
                      c[d].v[_ - 1],
                      c[d].o[_ - 1],
                      c[d].i[0],
                      c[d].v[0],
                      a,
                      _e,
                      ut
                    ),
                    (ut = !1))
                  : ((st = bez.getNewSegment(
                      c[d].v[_ - 1],
                      c[d].v[0],
                      c[d].o[_ - 1],
                      c[d].i[0],
                      (e.s - j) / it,
                      (e.e - j) / it,
                      tt[_ - 1]
                    )),
                    this.addSegmentFromArray(st, a, _e, ut),
                    (ut = !1),
                    (a.c = !1))
              } else a.c = !1
              ;(j += $.addedLength), (_e += 1)
            }
            if (
              (a._length &&
                (a.setXYAt(a.v[ot][0], a.v[ot][1], "i", ot),
                a.setXYAt(
                  a.v[a._length - 1][0],
                  a.v[a._length - 1][1],
                  "o",
                  a._length - 1
                )),
              j > e.e)
            )
              break
            d < g - 1 &&
              ((a = shapePool.newElement()), (ut = !0), at.push(a), (_e = 0))
          }
          return at
        })
      function PuckerAndBloatModifier() {}
      extendPrototype([ShapeModifier], PuckerAndBloatModifier),
        (PuckerAndBloatModifier.prototype.initModifierProperties = function (
          s,
          e
        ) {
          ;(this.getValue = this.processKeys),
            (this.amount = PropertyFactory.getProp(s, e.a, 0, null, this)),
            (this._isAnimated = !!this.amount.effectsSequence.length)
        }),
        (PuckerAndBloatModifier.prototype.processPath = function (s, e) {
          var a = e / 100,
            o = [0, 0],
            c = s._length,
            d = 0
          for (d = 0; d < c; d += 1) (o[0] += s.v[d][0]), (o[1] += s.v[d][1])
          ;(o[0] /= c), (o[1] /= c)
          var g = shapePool.newElement()
          g.c = s.c
          var _, b, j, $, _e, tt
          for (d = 0; d < c; d += 1)
            (_ = s.v[d][0] + (o[0] - s.v[d][0]) * a),
              (b = s.v[d][1] + (o[1] - s.v[d][1]) * a),
              (j = s.o[d][0] + (o[0] - s.o[d][0]) * -a),
              ($ = s.o[d][1] + (o[1] - s.o[d][1]) * -a),
              (_e = s.i[d][0] + (o[0] - s.i[d][0]) * -a),
              (tt = s.i[d][1] + (o[1] - s.i[d][1]) * -a),
              g.setTripleAt(_, b, j, $, _e, tt, d)
          return g
        }),
        (PuckerAndBloatModifier.prototype.processShapes = function (s) {
          var e,
            a,
            o = this.shapes.length,
            c,
            d,
            g = this.amount.v
          if (g !== 0) {
            var _, b
            for (a = 0; a < o; a += 1) {
              if (
                ((_ = this.shapes[a]),
                (b = _.localShapeCollection),
                !(!_.shape._mdf && !this._mdf && !s))
              )
                for (
                  b.releaseShapes(),
                    _.shape._mdf = !0,
                    e = _.shape.paths.shapes,
                    d = _.shape.paths._length,
                    c = 0;
                  c < d;
                  c += 1
                )
                  b.addShape(this.processPath(e[c], g))
              _.shape.paths = _.localShapeCollection
            }
          }
          this.dynamicProperties.length || (this._mdf = !1)
        })
      var TransformPropertyFactory = (function () {
        var s = [0, 0]
        function e(b) {
          var j = this._mdf
          this.iterateDynamicProperties(),
            (this._mdf = this._mdf || j),
            this.a && b.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
            this.s && b.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
            this.sk && b.skewFromAxis(-this.sk.v, this.sa.v),
            this.r
              ? b.rotate(-this.r.v)
              : b
                  .rotateZ(-this.rz.v)
                  .rotateY(this.ry.v)
                  .rotateX(this.rx.v)
                  .rotateZ(-this.or.v[2])
                  .rotateY(this.or.v[1])
                  .rotateX(this.or.v[0]),
            this.data.p.s
              ? this.data.p.z
                ? b.translate(this.px.v, this.py.v, -this.pz.v)
                : b.translate(this.px.v, this.py.v, 0)
              : b.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
        }
        function a(b) {
          if (this.elem.globalData.frameId !== this.frameId) {
            if (
              (this._isDirty &&
                (this.precalculateMatrix(), (this._isDirty = !1)),
              this.iterateDynamicProperties(),
              this._mdf || b)
            ) {
              var j
              if (
                (this.v.cloneFromProps(this.pre.props),
                this.appliedTransformations < 1 &&
                  this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
                this.appliedTransformations < 2 &&
                  this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
                this.sk &&
                  this.appliedTransformations < 3 &&
                  this.v.skewFromAxis(-this.sk.v, this.sa.v),
                this.r && this.appliedTransformations < 4
                  ? this.v.rotate(-this.r.v)
                  : !this.r &&
                    this.appliedTransformations < 4 &&
                    this.v
                      .rotateZ(-this.rz.v)
                      .rotateY(this.ry.v)
                      .rotateX(this.rx.v)
                      .rotateZ(-this.or.v[2])
                      .rotateY(this.or.v[1])
                      .rotateX(this.or.v[0]),
                this.autoOriented)
              ) {
                var $, _e
                if (
                  ((j = this.elem.globalData.frameRate),
                  this.p && this.p.keyframes && this.p.getValueAtTime)
                )
                  this.p._caching.lastFrame + this.p.offsetTime <=
                  this.p.keyframes[0].t
                    ? (($ = this.p.getValueAtTime(
                        (this.p.keyframes[0].t + 0.01) / j,
                        0
                      )),
                      (_e = this.p.getValueAtTime(
                        this.p.keyframes[0].t / j,
                        0
                      )))
                    : this.p._caching.lastFrame + this.p.offsetTime >=
                      this.p.keyframes[this.p.keyframes.length - 1].t
                    ? (($ = this.p.getValueAtTime(
                        this.p.keyframes[this.p.keyframes.length - 1].t / j,
                        0
                      )),
                      (_e = this.p.getValueAtTime(
                        (this.p.keyframes[this.p.keyframes.length - 1].t -
                          0.05) /
                          j,
                        0
                      )))
                    : (($ = this.p.pv),
                      (_e = this.p.getValueAtTime(
                        (this.p._caching.lastFrame + this.p.offsetTime - 0.01) /
                          j,
                        this.p.offsetTime
                      )))
                else if (
                  this.px &&
                  this.px.keyframes &&
                  this.py.keyframes &&
                  this.px.getValueAtTime &&
                  this.py.getValueAtTime
                ) {
                  ;($ = []), (_e = [])
                  var tt = this.px,
                    st = this.py
                  tt._caching.lastFrame + tt.offsetTime <= tt.keyframes[0].t
                    ? (($[0] = tt.getValueAtTime(
                        (tt.keyframes[0].t + 0.01) / j,
                        0
                      )),
                      ($[1] = st.getValueAtTime(
                        (st.keyframes[0].t + 0.01) / j,
                        0
                      )),
                      (_e[0] = tt.getValueAtTime(tt.keyframes[0].t / j, 0)),
                      (_e[1] = st.getValueAtTime(st.keyframes[0].t / j, 0)))
                    : tt._caching.lastFrame + tt.offsetTime >=
                      tt.keyframes[tt.keyframes.length - 1].t
                    ? (($[0] = tt.getValueAtTime(
                        tt.keyframes[tt.keyframes.length - 1].t / j,
                        0
                      )),
                      ($[1] = st.getValueAtTime(
                        st.keyframes[st.keyframes.length - 1].t / j,
                        0
                      )),
                      (_e[0] = tt.getValueAtTime(
                        (tt.keyframes[tt.keyframes.length - 1].t - 0.01) / j,
                        0
                      )),
                      (_e[1] = st.getValueAtTime(
                        (st.keyframes[st.keyframes.length - 1].t - 0.01) / j,
                        0
                      )))
                    : (($ = [tt.pv, st.pv]),
                      (_e[0] = tt.getValueAtTime(
                        (tt._caching.lastFrame + tt.offsetTime - 0.01) / j,
                        tt.offsetTime
                      )),
                      (_e[1] = st.getValueAtTime(
                        (st._caching.lastFrame + st.offsetTime - 0.01) / j,
                        st.offsetTime
                      )))
                } else (_e = s), ($ = _e)
                this.v.rotate(-Math.atan2($[1] - _e[1], $[0] - _e[0]))
              }
              this.data.p && this.data.p.s
                ? this.data.p.z
                  ? this.v.translate(this.px.v, this.py.v, -this.pz.v)
                  : this.v.translate(this.px.v, this.py.v, 0)
                : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2])
            }
            this.frameId = this.elem.globalData.frameId
          }
        }
        function o() {
          if (
            ((this.appliedTransformations = 0),
            this.pre.reset(),
            !this.a.effectsSequence.length)
          )
            this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]),
              (this.appliedTransformations = 1)
          else return
          if (!this.s.effectsSequence.length)
            this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]),
              (this.appliedTransformations = 2)
          else return
          if (this.sk)
            if (
              !this.sk.effectsSequence.length &&
              !this.sa.effectsSequence.length
            )
              this.pre.skewFromAxis(-this.sk.v, this.sa.v),
                (this.appliedTransformations = 3)
            else return
          this.r
            ? this.r.effectsSequence.length ||
              (this.pre.rotate(-this.r.v), (this.appliedTransformations = 4))
            : !this.rz.effectsSequence.length &&
              !this.ry.effectsSequence.length &&
              !this.rx.effectsSequence.length &&
              !this.or.effectsSequence.length &&
              (this.pre
                .rotateZ(-this.rz.v)
                .rotateY(this.ry.v)
                .rotateX(this.rx.v)
                .rotateZ(-this.or.v[2])
                .rotateY(this.or.v[1])
                .rotateX(this.or.v[0]),
              (this.appliedTransformations = 4))
        }
        function c() {}
        function d(b) {
          this._addDynamicProperty(b),
            this.elem.addDynamicProperty(b),
            (this._isDirty = !0)
        }
        function g(b, j, $) {
          if (
            ((this.elem = b),
            (this.frameId = -1),
            (this.propType = "transform"),
            (this.data = j),
            (this.v = new Matrix()),
            (this.pre = new Matrix()),
            (this.appliedTransformations = 0),
            this.initDynamicPropertyContainer($ || b),
            j.p && j.p.s
              ? ((this.px = PropertyFactory.getProp(b, j.p.x, 0, 0, this)),
                (this.py = PropertyFactory.getProp(b, j.p.y, 0, 0, this)),
                j.p.z &&
                  (this.pz = PropertyFactory.getProp(b, j.p.z, 0, 0, this)))
              : (this.p = PropertyFactory.getProp(
                  b,
                  j.p || { k: [0, 0, 0] },
                  1,
                  0,
                  this
                )),
            j.rx)
          ) {
            if (
              ((this.rx = PropertyFactory.getProp(b, j.rx, 0, degToRads, this)),
              (this.ry = PropertyFactory.getProp(b, j.ry, 0, degToRads, this)),
              (this.rz = PropertyFactory.getProp(b, j.rz, 0, degToRads, this)),
              j.or.k[0].ti)
            ) {
              var _e,
                tt = j.or.k.length
              for (_e = 0; _e < tt; _e += 1)
                (j.or.k[_e].to = null), (j.or.k[_e].ti = null)
            }
            ;(this.or = PropertyFactory.getProp(b, j.or, 1, degToRads, this)),
              (this.or.sh = !0)
          } else
            this.r = PropertyFactory.getProp(
              b,
              j.r || { k: 0 },
              0,
              degToRads,
              this
            )
          j.sk &&
            ((this.sk = PropertyFactory.getProp(b, j.sk, 0, degToRads, this)),
            (this.sa = PropertyFactory.getProp(b, j.sa, 0, degToRads, this))),
            (this.a = PropertyFactory.getProp(
              b,
              j.a || { k: [0, 0, 0] },
              1,
              0,
              this
            )),
            (this.s = PropertyFactory.getProp(
              b,
              j.s || { k: [100, 100, 100] },
              1,
              0.01,
              this
            )),
            j.o
              ? (this.o = PropertyFactory.getProp(b, j.o, 0, 0.01, b))
              : (this.o = { _mdf: !1, v: 1 }),
            (this._isDirty = !0),
            this.dynamicProperties.length || this.getValue(!0)
        }
        ;(g.prototype = {
          applyToMatrix: e,
          getValue: a,
          precalculateMatrix: o,
          autoOrient: c,
        }),
          extendPrototype([DynamicPropertyContainer], g),
          (g.prototype.addDynamicProperty = d),
          (g.prototype._addDynamicProperty =
            DynamicPropertyContainer.prototype.addDynamicProperty)
        function _(b, j, $) {
          return new g(b, j, $)
        }
        return { getTransformProperty: _ }
      })()
      function RepeaterModifier() {}
      extendPrototype([ShapeModifier], RepeaterModifier),
        (RepeaterModifier.prototype.initModifierProperties = function (s, e) {
          ;(this.getValue = this.processKeys),
            (this.c = PropertyFactory.getProp(s, e.c, 0, null, this)),
            (this.o = PropertyFactory.getProp(s, e.o, 0, null, this)),
            (this.tr = TransformPropertyFactory.getTransformProperty(
              s,
              e.tr,
              this
            )),
            (this.so = PropertyFactory.getProp(s, e.tr.so, 0, 0.01, this)),
            (this.eo = PropertyFactory.getProp(s, e.tr.eo, 0, 0.01, this)),
            (this.data = e),
            this.dynamicProperties.length || this.getValue(!0),
            (this._isAnimated = !!this.dynamicProperties.length),
            (this.pMatrix = new Matrix()),
            (this.rMatrix = new Matrix()),
            (this.sMatrix = new Matrix()),
            (this.tMatrix = new Matrix()),
            (this.matrix = new Matrix())
        }),
        (RepeaterModifier.prototype.applyTransforms = function (
          s,
          e,
          a,
          o,
          c,
          d
        ) {
          var g = d ? -1 : 1,
            _ = o.s.v[0] + (1 - o.s.v[0]) * (1 - c),
            b = o.s.v[1] + (1 - o.s.v[1]) * (1 - c)
          s.translate(o.p.v[0] * g * c, o.p.v[1] * g * c, o.p.v[2]),
            e.translate(-o.a.v[0], -o.a.v[1], o.a.v[2]),
            e.rotate(-o.r.v * g * c),
            e.translate(o.a.v[0], o.a.v[1], o.a.v[2]),
            a.translate(-o.a.v[0], -o.a.v[1], o.a.v[2]),
            a.scale(d ? 1 / _ : _, d ? 1 / b : b),
            a.translate(o.a.v[0], o.a.v[1], o.a.v[2])
        }),
        (RepeaterModifier.prototype.init = function (s, e, a, o) {
          for (
            this.elem = s,
              this.arr = e,
              this.pos = a,
              this.elemsData = o,
              this._currentCopies = 0,
              this._elements = [],
              this._groups = [],
              this.frameId = -1,
              this.initDynamicPropertyContainer(s),
              this.initModifierProperties(s, e[a]);
            a > 0;

          )
            (a -= 1), this._elements.unshift(e[a])
          this.dynamicProperties.length ? (this.k = !0) : this.getValue(!0)
        }),
        (RepeaterModifier.prototype.resetElements = function (s) {
          var e,
            a = s.length
          for (e = 0; e < a; e += 1)
            (s[e]._processed = !1),
              s[e].ty === "gr" && this.resetElements(s[e].it)
        }),
        (RepeaterModifier.prototype.cloneElements = function (s) {
          var e = JSON.parse(JSON.stringify(s))
          return this.resetElements(e), e
        }),
        (RepeaterModifier.prototype.changeGroupRender = function (s, e) {
          var a,
            o = s.length
          for (a = 0; a < o; a += 1)
            (s[a]._render = e),
              s[a].ty === "gr" && this.changeGroupRender(s[a].it, e)
        }),
        (RepeaterModifier.prototype.processShapes = function (s) {
          var e,
            a,
            o,
            c,
            d,
            g = !1
          if (this._mdf || s) {
            var _ = Math.ceil(this.c.v)
            if (this._groups.length < _) {
              for (; this._groups.length < _; ) {
                var b = { it: this.cloneElements(this._elements), ty: "gr" }
                b.it.push({
                  a: { a: 0, ix: 1, k: [0, 0] },
                  nm: "Transform",
                  o: { a: 0, ix: 7, k: 100 },
                  p: { a: 0, ix: 2, k: [0, 0] },
                  r: {
                    a: 1,
                    ix: 6,
                    k: [
                      { s: 0, e: 0, t: 0 },
                      { s: 0, e: 0, t: 1 },
                    ],
                  },
                  s: { a: 0, ix: 3, k: [100, 100] },
                  sa: { a: 0, ix: 5, k: 0 },
                  sk: { a: 0, ix: 4, k: 0 },
                  ty: "tr",
                }),
                  this.arr.splice(0, 0, b),
                  this._groups.splice(0, 0, b),
                  (this._currentCopies += 1)
              }
              this.elem.reloadShapes(), (g = !0)
            }
            d = 0
            var j
            for (o = 0; o <= this._groups.length - 1; o += 1) {
              if (
                ((j = d < _),
                (this._groups[o]._render = j),
                this.changeGroupRender(this._groups[o].it, j),
                !j)
              ) {
                var $ = this.elemsData[o].it,
                  _e = $[$.length - 1]
                _e.transform.op.v !== 0
                  ? ((_e.transform.op._mdf = !0), (_e.transform.op.v = 0))
                  : (_e.transform.op._mdf = !1)
              }
              d += 1
            }
            this._currentCopies = _
            var tt = this.o.v,
              st = tt % 1,
              at = tt > 0 ? Math.floor(tt) : Math.ceil(tt),
              ot = this.pMatrix.props,
              ut = this.rMatrix.props,
              it = this.sMatrix.props
            this.pMatrix.reset(),
              this.rMatrix.reset(),
              this.sMatrix.reset(),
              this.tMatrix.reset(),
              this.matrix.reset()
            var ct = 0
            if (tt > 0) {
              for (; ct < at; )
                this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  1,
                  !1
                ),
                  (ct += 1)
              st &&
                (this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  st,
                  !1
                ),
                (ct += st))
            } else if (tt < 0) {
              for (; ct > at; )
                this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  1,
                  !0
                ),
                  (ct -= 1)
              st &&
                (this.applyTransforms(
                  this.pMatrix,
                  this.rMatrix,
                  this.sMatrix,
                  this.tr,
                  -st,
                  !0
                ),
                (ct -= st))
            }
            ;(o = this.data.m === 1 ? 0 : this._currentCopies - 1),
              (c = this.data.m === 1 ? 1 : -1),
              (d = this._currentCopies)
            for (var lt, ht; d; ) {
              if (
                ((e = this.elemsData[o].it),
                (a = e[e.length - 1].transform.mProps.v.props),
                (ht = a.length),
                (e[e.length - 1].transform.mProps._mdf = !0),
                (e[e.length - 1].transform.op._mdf = !0),
                (e[e.length - 1].transform.op.v =
                  this._currentCopies === 1
                    ? this.so.v
                    : this.so.v +
                      (this.eo.v - this.so.v) *
                        (o / (this._currentCopies - 1))),
                ct !== 0)
              ) {
                for (
                  ((o !== 0 && c === 1) ||
                    (o !== this._currentCopies - 1 && c === -1)) &&
                    this.applyTransforms(
                      this.pMatrix,
                      this.rMatrix,
                      this.sMatrix,
                      this.tr,
                      1,
                      !1
                    ),
                    this.matrix.transform(
                      ut[0],
                      ut[1],
                      ut[2],
                      ut[3],
                      ut[4],
                      ut[5],
                      ut[6],
                      ut[7],
                      ut[8],
                      ut[9],
                      ut[10],
                      ut[11],
                      ut[12],
                      ut[13],
                      ut[14],
                      ut[15]
                    ),
                    this.matrix.transform(
                      it[0],
                      it[1],
                      it[2],
                      it[3],
                      it[4],
                      it[5],
                      it[6],
                      it[7],
                      it[8],
                      it[9],
                      it[10],
                      it[11],
                      it[12],
                      it[13],
                      it[14],
                      it[15]
                    ),
                    this.matrix.transform(
                      ot[0],
                      ot[1],
                      ot[2],
                      ot[3],
                      ot[4],
                      ot[5],
                      ot[6],
                      ot[7],
                      ot[8],
                      ot[9],
                      ot[10],
                      ot[11],
                      ot[12],
                      ot[13],
                      ot[14],
                      ot[15]
                    ),
                    lt = 0;
                  lt < ht;
                  lt += 1
                )
                  a[lt] = this.matrix.props[lt]
                this.matrix.reset()
              } else
                for (this.matrix.reset(), lt = 0; lt < ht; lt += 1)
                  a[lt] = this.matrix.props[lt]
              ;(ct += 1), (d -= 1), (o += c)
            }
          } else
            for (d = this._currentCopies, o = 0, c = 1; d; )
              (e = this.elemsData[o].it),
                (a = e[e.length - 1].transform.mProps.v.props),
                (e[e.length - 1].transform.mProps._mdf = !1),
                (e[e.length - 1].transform.op._mdf = !1),
                (d -= 1),
                (o += c)
          return g
        }),
        (RepeaterModifier.prototype.addShape = function () {})
      function RoundCornersModifier() {}
      extendPrototype([ShapeModifier], RoundCornersModifier),
        (RoundCornersModifier.prototype.initModifierProperties = function (
          s,
          e
        ) {
          ;(this.getValue = this.processKeys),
            (this.rd = PropertyFactory.getProp(s, e.r, 0, null, this)),
            (this._isAnimated = !!this.rd.effectsSequence.length)
        }),
        (RoundCornersModifier.prototype.processPath = function (s, e) {
          var a = shapePool.newElement()
          a.c = s.c
          var o,
            c = s._length,
            d,
            g,
            _,
            b,
            j,
            $,
            _e = 0,
            tt,
            st,
            at,
            ot,
            ut,
            it
          for (o = 0; o < c; o += 1)
            (d = s.v[o]),
              (_ = s.o[o]),
              (g = s.i[o]),
              d[0] === _[0] && d[1] === _[1] && d[0] === g[0] && d[1] === g[1]
                ? (o === 0 || o === c - 1) && !s.c
                  ? (a.setTripleAt(d[0], d[1], _[0], _[1], g[0], g[1], _e),
                    (_e += 1))
                  : (o === 0 ? (b = s.v[c - 1]) : (b = s.v[o - 1]),
                    (j = Math.sqrt(
                      Math.pow(d[0] - b[0], 2) + Math.pow(d[1] - b[1], 2)
                    )),
                    ($ = j ? Math.min(j / 2, e) / j : 0),
                    (ut = d[0] + (b[0] - d[0]) * $),
                    (tt = ut),
                    (it = d[1] - (d[1] - b[1]) * $),
                    (st = it),
                    (at = tt - (tt - d[0]) * roundCorner),
                    (ot = st - (st - d[1]) * roundCorner),
                    a.setTripleAt(tt, st, at, ot, ut, it, _e),
                    (_e += 1),
                    o === c - 1 ? (b = s.v[0]) : (b = s.v[o + 1]),
                    (j = Math.sqrt(
                      Math.pow(d[0] - b[0], 2) + Math.pow(d[1] - b[1], 2)
                    )),
                    ($ = j ? Math.min(j / 2, e) / j : 0),
                    (at = d[0] + (b[0] - d[0]) * $),
                    (tt = at),
                    (ot = d[1] + (b[1] - d[1]) * $),
                    (st = ot),
                    (ut = tt - (tt - d[0]) * roundCorner),
                    (it = st - (st - d[1]) * roundCorner),
                    a.setTripleAt(tt, st, at, ot, ut, it, _e),
                    (_e += 1))
                : (a.setTripleAt(
                    s.v[o][0],
                    s.v[o][1],
                    s.o[o][0],
                    s.o[o][1],
                    s.i[o][0],
                    s.i[o][1],
                    _e
                  ),
                  (_e += 1))
          return a
        }),
        (RoundCornersModifier.prototype.processShapes = function (s) {
          var e,
            a,
            o = this.shapes.length,
            c,
            d,
            g = this.rd.v
          if (g !== 0) {
            var _, b
            for (a = 0; a < o; a += 1) {
              if (
                ((_ = this.shapes[a]),
                (b = _.localShapeCollection),
                !(!_.shape._mdf && !this._mdf && !s))
              )
                for (
                  b.releaseShapes(),
                    _.shape._mdf = !0,
                    e = _.shape.paths.shapes,
                    d = _.shape.paths._length,
                    c = 0;
                  c < d;
                  c += 1
                )
                  b.addShape(this.processPath(e[c], g))
              _.shape.paths = _.localShapeCollection
            }
          }
          this.dynamicProperties.length || (this._mdf = !1)
        })
      function floatEqual(s, e) {
        return Math.abs(s - e) * 1e5 <= Math.min(Math.abs(s), Math.abs(e))
      }
      function floatZero(s) {
        return Math.abs(s) <= 1e-5
      }
      function lerp(s, e, a) {
        return s * (1 - a) + e * a
      }
      function lerpPoint(s, e, a) {
        return [lerp(s[0], e[0], a), lerp(s[1], e[1], a)]
      }
      function quadRoots(s, e, a) {
        if (s === 0) return []
        var o = e * e - 4 * s * a
        if (o < 0) return []
        var c = -e / (2 * s)
        if (o === 0) return [c]
        var d = Math.sqrt(o) / (2 * s)
        return [c - d, c + d]
      }
      function polynomialCoefficients(s, e, a, o) {
        return [
          -s + 3 * e - 3 * a + o,
          3 * s - 6 * e + 3 * a,
          -3 * s + 3 * e,
          s,
        ]
      }
      function singlePoint(s) {
        return new PolynomialBezier(s, s, s, s, !1)
      }
      function PolynomialBezier(s, e, a, o, c) {
        c && pointEqual(s, e) && (e = lerpPoint(s, o, 1 / 3)),
          c && pointEqual(a, o) && (a = lerpPoint(s, o, 2 / 3))
        var d = polynomialCoefficients(s[0], e[0], a[0], o[0]),
          g = polynomialCoefficients(s[1], e[1], a[1], o[1])
        ;(this.a = [d[0], g[0]]),
          (this.b = [d[1], g[1]]),
          (this.c = [d[2], g[2]]),
          (this.d = [d[3], g[3]]),
          (this.points = [s, e, a, o])
      }
      ;(PolynomialBezier.prototype.point = function (s) {
        return [
          ((this.a[0] * s + this.b[0]) * s + this.c[0]) * s + this.d[0],
          ((this.a[1] * s + this.b[1]) * s + this.c[1]) * s + this.d[1],
        ]
      }),
        (PolynomialBezier.prototype.derivative = function (s) {
          return [
            (3 * s * this.a[0] + 2 * this.b[0]) * s + this.c[0],
            (3 * s * this.a[1] + 2 * this.b[1]) * s + this.c[1],
          ]
        }),
        (PolynomialBezier.prototype.tangentAngle = function (s) {
          var e = this.derivative(s)
          return Math.atan2(e[1], e[0])
        }),
        (PolynomialBezier.prototype.normalAngle = function (s) {
          var e = this.derivative(s)
          return Math.atan2(e[0], e[1])
        }),
        (PolynomialBezier.prototype.inflectionPoints = function () {
          var s = this.a[1] * this.b[0] - this.a[0] * this.b[1]
          if (floatZero(s)) return []
          var e = (-0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1])) / s,
            a =
              e * e -
              ((1 / 3) * (this.b[1] * this.c[0] - this.b[0] * this.c[1])) / s
          if (a < 0) return []
          var o = Math.sqrt(a)
          return floatZero(o)
            ? o > 0 && o < 1
              ? [e]
              : []
            : [e - o, e + o].filter(function (c) {
                return c > 0 && c < 1
              })
        }),
        (PolynomialBezier.prototype.split = function (s) {
          if (s <= 0) return [singlePoint(this.points[0]), this]
          if (s >= 1)
            return [this, singlePoint(this.points[this.points.length - 1])]
          var e = lerpPoint(this.points[0], this.points[1], s),
            a = lerpPoint(this.points[1], this.points[2], s),
            o = lerpPoint(this.points[2], this.points[3], s),
            c = lerpPoint(e, a, s),
            d = lerpPoint(a, o, s),
            g = lerpPoint(c, d, s)
          return [
            new PolynomialBezier(this.points[0], e, c, g, !0),
            new PolynomialBezier(g, d, o, this.points[3], !0),
          ]
        })
      function extrema(s, e) {
        var a = s.points[0][e],
          o = s.points[s.points.length - 1][e]
        if (a > o) {
          var c = o
          ;(o = a), (a = c)
        }
        for (
          var d = quadRoots(3 * s.a[e], 2 * s.b[e], s.c[e]), g = 0;
          g < d.length;
          g += 1
        )
          if (d[g] > 0 && d[g] < 1) {
            var _ = s.point(d[g])[e]
            _ < a ? (a = _) : _ > o && (o = _)
          }
        return { min: a, max: o }
      }
      ;(PolynomialBezier.prototype.bounds = function () {
        return { x: extrema(this, 0), y: extrema(this, 1) }
      }),
        (PolynomialBezier.prototype.boundingBox = function () {
          var s = this.bounds()
          return {
            left: s.x.min,
            right: s.x.max,
            top: s.y.min,
            bottom: s.y.max,
            width: s.x.max - s.x.min,
            height: s.y.max - s.y.min,
            cx: (s.x.max + s.x.min) / 2,
            cy: (s.y.max + s.y.min) / 2,
          }
        })
      function intersectData(s, e, a) {
        var o = s.boundingBox()
        return {
          cx: o.cx,
          cy: o.cy,
          width: o.width,
          height: o.height,
          bez: s,
          t: (e + a) / 2,
          t1: e,
          t2: a,
        }
      }
      function splitData(s) {
        var e = s.bez.split(0.5)
        return [intersectData(e[0], s.t1, s.t), intersectData(e[1], s.t, s.t2)]
      }
      function boxIntersect(s, e) {
        return (
          Math.abs(s.cx - e.cx) * 2 < s.width + e.width &&
          Math.abs(s.cy - e.cy) * 2 < s.height + e.height
        )
      }
      function intersectsImpl(s, e, a, o, c, d) {
        if (boxIntersect(s, e)) {
          if (
            a >= d ||
            (s.width <= o && s.height <= o && e.width <= o && e.height <= o)
          ) {
            c.push([s.t, e.t])
            return
          }
          var g = splitData(s),
            _ = splitData(e)
          intersectsImpl(g[0], _[0], a + 1, o, c, d),
            intersectsImpl(g[0], _[1], a + 1, o, c, d),
            intersectsImpl(g[1], _[0], a + 1, o, c, d),
            intersectsImpl(g[1], _[1], a + 1, o, c, d)
        }
      }
      ;(PolynomialBezier.prototype.intersections = function (s, e, a) {
        e === void 0 && (e = 2), a === void 0 && (a = 7)
        var o = []
        return (
          intersectsImpl(
            intersectData(this, 0, 1),
            intersectData(s, 0, 1),
            0,
            e,
            o,
            a
          ),
          o
        )
      }),
        (PolynomialBezier.shapeSegment = function (s, e) {
          var a = (e + 1) % s.length()
          return new PolynomialBezier(s.v[e], s.o[e], s.i[a], s.v[a], !0)
        }),
        (PolynomialBezier.shapeSegmentInverted = function (s, e) {
          var a = (e + 1) % s.length()
          return new PolynomialBezier(s.v[a], s.i[a], s.o[e], s.v[e], !0)
        })
      function crossProduct(s, e) {
        return [
          s[1] * e[2] - s[2] * e[1],
          s[2] * e[0] - s[0] * e[2],
          s[0] * e[1] - s[1] * e[0],
        ]
      }
      function lineIntersection(s, e, a, o) {
        var c = [s[0], s[1], 1],
          d = [e[0], e[1], 1],
          g = [a[0], a[1], 1],
          _ = [o[0], o[1], 1],
          b = crossProduct(crossProduct(c, d), crossProduct(g, _))
        return floatZero(b[2]) ? null : [b[0] / b[2], b[1] / b[2]]
      }
      function polarOffset(s, e, a) {
        return [s[0] + Math.cos(e) * a, s[1] - Math.sin(e) * a]
      }
      function pointDistance(s, e) {
        return Math.hypot(s[0] - e[0], s[1] - e[1])
      }
      function pointEqual(s, e) {
        return floatEqual(s[0], e[0]) && floatEqual(s[1], e[1])
      }
      function ZigZagModifier() {}
      extendPrototype([ShapeModifier], ZigZagModifier),
        (ZigZagModifier.prototype.initModifierProperties = function (s, e) {
          ;(this.getValue = this.processKeys),
            (this.amplitude = PropertyFactory.getProp(s, e.s, 0, null, this)),
            (this.frequency = PropertyFactory.getProp(s, e.r, 0, null, this)),
            (this.pointsType = PropertyFactory.getProp(s, e.pt, 0, null, this)),
            (this._isAnimated =
              this.amplitude.effectsSequence.length !== 0 ||
              this.frequency.effectsSequence.length !== 0 ||
              this.pointsType.effectsSequence.length !== 0)
        })
      function setPoint(s, e, a, o, c, d, g) {
        var _ = a - Math.PI / 2,
          b = a + Math.PI / 2,
          j = e[0] + Math.cos(a) * o * c,
          $ = e[1] - Math.sin(a) * o * c
        s.setTripleAt(
          j,
          $,
          j + Math.cos(_) * d,
          $ - Math.sin(_) * d,
          j + Math.cos(b) * g,
          $ - Math.sin(b) * g,
          s.length()
        )
      }
      function getPerpendicularVector(s, e) {
        var a = [e[0] - s[0], e[1] - s[1]],
          o = -Math.PI * 0.5,
          c = [
            Math.cos(o) * a[0] - Math.sin(o) * a[1],
            Math.sin(o) * a[0] + Math.cos(o) * a[1],
          ]
        return c
      }
      function getProjectingAngle(s, e) {
        var a = e === 0 ? s.length() - 1 : e - 1,
          o = (e + 1) % s.length(),
          c = s.v[a],
          d = s.v[o],
          g = getPerpendicularVector(c, d)
        return Math.atan2(0, 1) - Math.atan2(g[1], g[0])
      }
      function zigZagCorner(s, e, a, o, c, d, g) {
        var _ = getProjectingAngle(e, a),
          b = e.v[a % e._length],
          j = e.v[a === 0 ? e._length - 1 : a - 1],
          $ = e.v[(a + 1) % e._length],
          _e =
            d === 2
              ? Math.sqrt(Math.pow(b[0] - j[0], 2) + Math.pow(b[1] - j[1], 2))
              : 0,
          tt =
            d === 2
              ? Math.sqrt(Math.pow(b[0] - $[0], 2) + Math.pow(b[1] - $[1], 2))
              : 0
        setPoint(
          s,
          e.v[a % e._length],
          _,
          g,
          o,
          tt / ((c + 1) * 2),
          _e / ((c + 1) * 2)
        )
      }
      function zigZagSegment(s, e, a, o, c, d) {
        for (var g = 0; g < o; g += 1) {
          var _ = (g + 1) / (o + 1),
            b =
              c === 2
                ? Math.sqrt(
                    Math.pow(e.points[3][0] - e.points[0][0], 2) +
                      Math.pow(e.points[3][1] - e.points[0][1], 2)
                  )
                : 0,
            j = e.normalAngle(_),
            $ = e.point(_)
          setPoint(s, $, j, d, a, b / ((o + 1) * 2), b / ((o + 1) * 2)),
            (d = -d)
        }
        return d
      }
      ;(ZigZagModifier.prototype.processPath = function (s, e, a, o) {
        var c = s._length,
          d = shapePool.newElement()
        if (((d.c = s.c), s.c || (c -= 1), c === 0)) return d
        var g = -1,
          _ = PolynomialBezier.shapeSegment(s, 0)
        zigZagCorner(d, s, 0, e, a, o, g)
        for (var b = 0; b < c; b += 1)
          (g = zigZagSegment(d, _, e, a, o, -g)),
            b === c - 1 && !s.c
              ? (_ = null)
              : (_ = PolynomialBezier.shapeSegment(s, (b + 1) % c)),
            zigZagCorner(d, s, b + 1, e, a, o, g)
        return d
      }),
        (ZigZagModifier.prototype.processShapes = function (s) {
          var e,
            a,
            o = this.shapes.length,
            c,
            d,
            g = this.amplitude.v,
            _ = Math.max(0, Math.round(this.frequency.v)),
            b = this.pointsType.v
          if (g !== 0) {
            var j, $
            for (a = 0; a < o; a += 1) {
              if (
                ((j = this.shapes[a]),
                ($ = j.localShapeCollection),
                !(!j.shape._mdf && !this._mdf && !s))
              )
                for (
                  $.releaseShapes(),
                    j.shape._mdf = !0,
                    e = j.shape.paths.shapes,
                    d = j.shape.paths._length,
                    c = 0;
                  c < d;
                  c += 1
                )
                  $.addShape(this.processPath(e[c], g, _, b))
              j.shape.paths = j.localShapeCollection
            }
          }
          this.dynamicProperties.length || (this._mdf = !1)
        })
      function linearOffset(s, e, a) {
        var o = Math.atan2(e[0] - s[0], e[1] - s[1])
        return [polarOffset(s, o, a), polarOffset(e, o, a)]
      }
      function offsetSegment(s, e) {
        var a, o, c, d, g, _, b
        ;(b = linearOffset(s.points[0], s.points[1], e)),
          (a = b[0]),
          (o = b[1]),
          (b = linearOffset(s.points[1], s.points[2], e)),
          (c = b[0]),
          (d = b[1]),
          (b = linearOffset(s.points[2], s.points[3], e)),
          (g = b[0]),
          (_ = b[1])
        var j = lineIntersection(a, o, c, d)
        j === null && (j = o)
        var $ = lineIntersection(g, _, c, d)
        return $ === null && ($ = g), new PolynomialBezier(a, j, $, _)
      }
      function joinLines(s, e, a, o, c) {
        var d = e.points[3],
          g = a.points[0]
        if (o === 3 || pointEqual(d, g)) return d
        if (o === 2) {
          var _ = -e.tangentAngle(1),
            b = -a.tangentAngle(0) + Math.PI,
            j = lineIntersection(
              d,
              polarOffset(d, _ + Math.PI / 2, 100),
              g,
              polarOffset(g, _ + Math.PI / 2, 100)
            ),
            $ = j ? pointDistance(j, d) : pointDistance(d, g) / 2,
            _e = polarOffset(d, _, 2 * $ * roundCorner)
          return (
            s.setXYAt(_e[0], _e[1], "o", s.length() - 1),
            (_e = polarOffset(g, b, 2 * $ * roundCorner)),
            s.setTripleAt(g[0], g[1], g[0], g[1], _e[0], _e[1], s.length()),
            g
          )
        }
        var tt = pointEqual(d, e.points[2]) ? e.points[0] : e.points[2],
          st = pointEqual(g, a.points[1]) ? a.points[3] : a.points[1],
          at = lineIntersection(tt, d, g, st)
        return at && pointDistance(at, d) < c
          ? (s.setTripleAt(
              at[0],
              at[1],
              at[0],
              at[1],
              at[0],
              at[1],
              s.length()
            ),
            at)
          : d
      }
      function getIntersection(s, e) {
        var a = s.intersections(e)
        return (
          a.length && floatEqual(a[0][0], 1) && a.shift(),
          a.length ? a[0] : null
        )
      }
      function pruneSegmentIntersection(s, e) {
        var a = s.slice(),
          o = e.slice(),
          c = getIntersection(s[s.length - 1], e[0])
        return (
          c &&
            ((a[s.length - 1] = s[s.length - 1].split(c[0])[0]),
            (o[0] = e[0].split(c[1])[1])),
          s.length > 1 &&
          e.length > 1 &&
          ((c = getIntersection(s[0], e[e.length - 1])), c)
            ? [[s[0].split(c[0])[0]], [e[e.length - 1].split(c[1])[1]]]
            : [a, o]
        )
      }
      function pruneIntersections(s) {
        for (var e, a = 1; a < s.length; a += 1)
          (e = pruneSegmentIntersection(s[a - 1], s[a])),
            (s[a - 1] = e[0]),
            (s[a] = e[1])
        return (
          s.length > 1 &&
            ((e = pruneSegmentIntersection(s[s.length - 1], s[0])),
            (s[s.length - 1] = e[0]),
            (s[0] = e[1])),
          s
        )
      }
      function offsetSegmentSplit(s, e) {
        var a = s.inflectionPoints(),
          o,
          c,
          d,
          g
        if (a.length === 0) return [offsetSegment(s, e)]
        if (a.length === 1 || floatEqual(a[1], 1))
          return (
            (d = s.split(a[0])),
            (o = d[0]),
            (c = d[1]),
            [offsetSegment(o, e), offsetSegment(c, e)]
          )
        ;(d = s.split(a[0])), (o = d[0])
        var _ = (a[1] - a[0]) / (1 - a[0])
        return (
          (d = d[1].split(_)),
          (g = d[0]),
          (c = d[1]),
          [offsetSegment(o, e), offsetSegment(g, e), offsetSegment(c, e)]
        )
      }
      function OffsetPathModifier() {}
      extendPrototype([ShapeModifier], OffsetPathModifier),
        (OffsetPathModifier.prototype.initModifierProperties = function (s, e) {
          ;(this.getValue = this.processKeys),
            (this.amount = PropertyFactory.getProp(s, e.a, 0, null, this)),
            (this.miterLimit = PropertyFactory.getProp(s, e.ml, 0, null, this)),
            (this.lineJoin = e.lj),
            (this._isAnimated = this.amount.effectsSequence.length !== 0)
        }),
        (OffsetPathModifier.prototype.processPath = function (s, e, a, o) {
          var c = shapePool.newElement()
          c.c = s.c
          var d = s.length()
          s.c || (d -= 1)
          var g,
            _,
            b,
            j = []
          for (g = 0; g < d; g += 1)
            (b = PolynomialBezier.shapeSegment(s, g)),
              j.push(offsetSegmentSplit(b, e))
          if (!s.c)
            for (g = d - 1; g >= 0; g -= 1)
              (b = PolynomialBezier.shapeSegmentInverted(s, g)),
                j.push(offsetSegmentSplit(b, e))
          j = pruneIntersections(j)
          var $ = null,
            _e = null
          for (g = 0; g < j.length; g += 1) {
            var tt = j[g]
            for (
              _e && ($ = joinLines(c, _e, tt[0], a, o)),
                _e = tt[tt.length - 1],
                _ = 0;
              _ < tt.length;
              _ += 1
            )
              (b = tt[_]),
                $ && pointEqual(b.points[0], $)
                  ? c.setXYAt(
                      b.points[1][0],
                      b.points[1][1],
                      "o",
                      c.length() - 1
                    )
                  : c.setTripleAt(
                      b.points[0][0],
                      b.points[0][1],
                      b.points[1][0],
                      b.points[1][1],
                      b.points[0][0],
                      b.points[0][1],
                      c.length()
                    ),
                c.setTripleAt(
                  b.points[3][0],
                  b.points[3][1],
                  b.points[3][0],
                  b.points[3][1],
                  b.points[2][0],
                  b.points[2][1],
                  c.length()
                ),
                ($ = b.points[3])
          }
          return j.length && joinLines(c, _e, j[0][0], a, o), c
        }),
        (OffsetPathModifier.prototype.processShapes = function (s) {
          var e,
            a,
            o = this.shapes.length,
            c,
            d,
            g = this.amount.v,
            _ = this.miterLimit.v,
            b = this.lineJoin
          if (g !== 0) {
            var j, $
            for (a = 0; a < o; a += 1) {
              if (
                ((j = this.shapes[a]),
                ($ = j.localShapeCollection),
                !(!j.shape._mdf && !this._mdf && !s))
              )
                for (
                  $.releaseShapes(),
                    j.shape._mdf = !0,
                    e = j.shape.paths.shapes,
                    d = j.shape.paths._length,
                    c = 0;
                  c < d;
                  c += 1
                )
                  $.addShape(this.processPath(e[c], g, b, _))
              j.shape.paths = j.localShapeCollection
            }
          }
          this.dynamicProperties.length || (this._mdf = !1)
        })
      function getFontProperties(s) {
        for (
          var e = s.fStyle ? s.fStyle.split(" ") : [],
            a = "normal",
            o = "normal",
            c = e.length,
            d,
            g = 0;
          g < c;
          g += 1
        )
          switch (((d = e[g].toLowerCase()), d)) {
            case "italic":
              o = "italic"
              break
            case "bold":
              a = "700"
              break
            case "black":
              a = "900"
              break
            case "medium":
              a = "500"
              break
            case "regular":
            case "normal":
              a = "400"
              break
            case "light":
            case "thin":
              a = "200"
              break
          }
        return { style: o, weight: s.fWeight || a }
      }
      var FontManager = (function () {
        var s = 5e3,
          e = { w: 0, size: 0, shapes: [], data: { shapes: [] } },
          a = []
        a = a.concat([
          2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368,
          2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379,
          2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403,
        ])
        var o = 127988,
          c = 917631,
          d = 917601,
          g = 917626,
          _ = 65039,
          b = 8205,
          j = 127462,
          $ = 127487,
          _e = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"]
        function tt(Mt) {
          var wt = Mt.split(","),
            gt,
            At = wt.length,
            bt = []
          for (gt = 0; gt < At; gt += 1)
            wt[gt] !== "sans-serif" && wt[gt] !== "monospace" && bt.push(wt[gt])
          return bt.join(",")
        }
        function st(Mt, wt) {
          var gt = createTag("span")
          gt.setAttribute("aria-hidden", !0), (gt.style.fontFamily = wt)
          var At = createTag("span")
          ;(At.innerText = "giItT1WQy@!-/#"),
            (gt.style.position = "absolute"),
            (gt.style.left = "-10000px"),
            (gt.style.top = "-10000px"),
            (gt.style.fontSize = "300px"),
            (gt.style.fontVariant = "normal"),
            (gt.style.fontStyle = "normal"),
            (gt.style.fontWeight = "normal"),
            (gt.style.letterSpacing = "0"),
            gt.appendChild(At),
            document.body.appendChild(gt)
          var bt = At.offsetWidth
          return (
            (At.style.fontFamily = tt(Mt) + ", " + wt),
            { node: At, w: bt, parent: gt }
          )
        }
        function at() {
          var Mt,
            wt = this.fonts.length,
            gt,
            At,
            bt = wt
          for (Mt = 0; Mt < wt; Mt += 1)
            this.fonts[Mt].loaded
              ? (bt -= 1)
              : this.fonts[Mt].fOrigin === "n" || this.fonts[Mt].origin === 0
              ? (this.fonts[Mt].loaded = !0)
              : ((gt = this.fonts[Mt].monoCase.node),
                (At = this.fonts[Mt].monoCase.w),
                gt.offsetWidth !== At
                  ? ((bt -= 1), (this.fonts[Mt].loaded = !0))
                  : ((gt = this.fonts[Mt].sansCase.node),
                    (At = this.fonts[Mt].sansCase.w),
                    gt.offsetWidth !== At &&
                      ((bt -= 1), (this.fonts[Mt].loaded = !0))),
                this.fonts[Mt].loaded &&
                  (this.fonts[Mt].sansCase.parent.parentNode.removeChild(
                    this.fonts[Mt].sansCase.parent
                  ),
                  this.fonts[Mt].monoCase.parent.parentNode.removeChild(
                    this.fonts[Mt].monoCase.parent
                  )))
          bt !== 0 && Date.now() - this.initTime < s
            ? setTimeout(this.checkLoadedFontsBinded, 20)
            : setTimeout(this.setIsLoadedBinded, 10)
        }
        function ot(Mt, wt) {
          var gt = document.body && wt ? "svg" : "canvas",
            At,
            bt = getFontProperties(Mt)
          if (gt === "svg") {
            var Tt = createNS("text")
            ;(Tt.style.fontSize = "100px"),
              Tt.setAttribute("font-family", Mt.fFamily),
              Tt.setAttribute("font-style", bt.style),
              Tt.setAttribute("font-weight", bt.weight),
              (Tt.textContent = "1"),
              Mt.fClass
                ? ((Tt.style.fontFamily = "inherit"),
                  Tt.setAttribute("class", Mt.fClass))
                : (Tt.style.fontFamily = Mt.fFamily),
              wt.appendChild(Tt),
              (At = Tt)
          } else {
            var It = new OffscreenCanvas(500, 500).getContext("2d")
            ;(It.font = bt.style + " " + bt.weight + " 100px " + Mt.fFamily),
              (At = It)
          }
          function $t(Xt) {
            return gt === "svg"
              ? ((At.textContent = Xt), At.getComputedTextLength())
              : At.measureText(Xt).width
          }
          return { measureText: $t }
        }
        function ut(Mt, wt) {
          if (!Mt) {
            this.isLoaded = !0
            return
          }
          if (this.chars) {
            ;(this.isLoaded = !0), (this.fonts = Mt.list)
            return
          }
          if (!document.body) {
            ;(this.isLoaded = !0),
              Mt.list.forEach(function (Tn) {
                ;(Tn.helper = ot(Tn)), (Tn.cache = {})
              }),
              (this.fonts = Mt.list)
            return
          }
          var gt = Mt.list,
            At,
            bt = gt.length,
            Tt = bt
          for (At = 0; At < bt; At += 1) {
            var It = !0,
              $t,
              Xt
            if (
              ((gt[At].loaded = !1),
              (gt[At].monoCase = st(gt[At].fFamily, "monospace")),
              (gt[At].sansCase = st(gt[At].fFamily, "sans-serif")),
              !gt[At].fPath)
            )
              (gt[At].loaded = !0), (Tt -= 1)
            else if (gt[At].fOrigin === "p" || gt[At].origin === 3) {
              if (
                (($t = document.querySelectorAll(
                  'style[f-forigin="p"][f-family="' +
                    gt[At].fFamily +
                    '"], style[f-origin="3"][f-family="' +
                    gt[At].fFamily +
                    '"]'
                )),
                $t.length > 0 && (It = !1),
                It)
              ) {
                var qt = createTag("style")
                qt.setAttribute("f-forigin", gt[At].fOrigin),
                  qt.setAttribute("f-origin", gt[At].origin),
                  qt.setAttribute("f-family", gt[At].fFamily),
                  (qt.type = "text/css"),
                  (qt.innerText =
                    "@font-face {font-family: " +
                    gt[At].fFamily +
                    "; font-style: normal; src: url('" +
                    gt[At].fPath +
                    "');}"),
                  wt.appendChild(qt)
              }
            } else if (gt[At].fOrigin === "g" || gt[At].origin === 1) {
              for (
                $t = document.querySelectorAll(
                  'link[f-forigin="g"], link[f-origin="1"]'
                ),
                  Xt = 0;
                Xt < $t.length;
                Xt += 1
              )
                $t[Xt].href.indexOf(gt[At].fPath) !== -1 && (It = !1)
              if (It) {
                var en = createTag("link")
                en.setAttribute("f-forigin", gt[At].fOrigin),
                  en.setAttribute("f-origin", gt[At].origin),
                  (en.type = "text/css"),
                  (en.rel = "stylesheet"),
                  (en.href = gt[At].fPath),
                  document.body.appendChild(en)
              }
            } else if (gt[At].fOrigin === "t" || gt[At].origin === 2) {
              for (
                $t = document.querySelectorAll(
                  'script[f-forigin="t"], script[f-origin="2"]'
                ),
                  Xt = 0;
                Xt < $t.length;
                Xt += 1
              )
                gt[At].fPath === $t[Xt].src && (It = !1)
              if (It) {
                var yn = createTag("link")
                yn.setAttribute("f-forigin", gt[At].fOrigin),
                  yn.setAttribute("f-origin", gt[At].origin),
                  yn.setAttribute("rel", "stylesheet"),
                  yn.setAttribute("href", gt[At].fPath),
                  wt.appendChild(yn)
              }
            }
            ;(gt[At].helper = ot(gt[At], wt)),
              (gt[At].cache = {}),
              this.fonts.push(gt[At])
          }
          Tt === 0
            ? (this.isLoaded = !0)
            : setTimeout(this.checkLoadedFonts.bind(this), 100)
        }
        function it(Mt) {
          if (Mt) {
            this.chars || (this.chars = [])
            var wt,
              gt = Mt.length,
              At,
              bt = this.chars.length,
              Tt
            for (wt = 0; wt < gt; wt += 1) {
              for (At = 0, Tt = !1; At < bt; )
                this.chars[At].style === Mt[wt].style &&
                  this.chars[At].fFamily === Mt[wt].fFamily &&
                  this.chars[At].ch === Mt[wt].ch &&
                  (Tt = !0),
                  (At += 1)
              Tt || (this.chars.push(Mt[wt]), (bt += 1))
            }
          }
        }
        function ct(Mt, wt, gt) {
          for (var At = 0, bt = this.chars.length; At < bt; ) {
            if (
              this.chars[At].ch === Mt &&
              this.chars[At].style === wt &&
              this.chars[At].fFamily === gt
            )
              return this.chars[At]
            At += 1
          }
          return (
            ((typeof Mt == "string" && Mt.charCodeAt(0) !== 13) || !Mt) &&
              console &&
              console.warn &&
              !this._warned &&
              ((this._warned = !0),
              console.warn(
                "Missing character from exported characters list: ",
                Mt,
                wt,
                gt
              )),
            e
          )
        }
        function lt(Mt, wt, gt) {
          var At = this.getFontByName(wt),
            bt = Mt
          if (!At.cache[bt]) {
            var Tt = At.helper
            if (Mt === " ") {
              var It = Tt.measureText("|" + Mt + "|"),
                $t = Tt.measureText("||")
              At.cache[bt] = (It - $t) / 100
            } else At.cache[bt] = Tt.measureText(Mt) / 100
          }
          return At.cache[bt] * gt
        }
        function ht(Mt) {
          for (var wt = 0, gt = this.fonts.length; wt < gt; ) {
            if (this.fonts[wt].fName === Mt) return this.fonts[wt]
            wt += 1
          }
          return this.fonts[0]
        }
        function dt(Mt) {
          var wt = 0,
            gt = Mt.charCodeAt(0)
          if (gt >= 55296 && gt <= 56319) {
            var At = Mt.charCodeAt(1)
            At >= 56320 &&
              At <= 57343 &&
              (wt = (gt - 55296) * 1024 + At - 56320 + 65536)
          }
          return wt
        }
        function pt(Mt, wt) {
          var gt = Mt.toString(16) + wt.toString(16)
          return _e.indexOf(gt) !== -1
        }
        function vt(Mt) {
          return Mt === b
        }
        function _t(Mt) {
          return Mt === _
        }
        function yt(Mt) {
          var wt = dt(Mt)
          return wt >= j && wt <= $
        }
        function Et(Mt) {
          return yt(Mt.substr(0, 2)) && yt(Mt.substr(2, 2))
        }
        function Rt(Mt) {
          return a.indexOf(Mt) !== -1
        }
        function Ft(Mt, wt) {
          var gt = dt(Mt.substr(wt, 2))
          if (gt !== o) return !1
          var At = 0
          for (wt += 2; At < 5; ) {
            if (((gt = dt(Mt.substr(wt, 2))), gt < d || gt > g)) return !1
            ;(At += 1), (wt += 2)
          }
          return dt(Mt.substr(wt, 2)) === c
        }
        function kt() {
          this.isLoaded = !0
        }
        var Nt = function () {
          ;(this.fonts = []),
            (this.chars = null),
            (this.typekitLoaded = 0),
            (this.isLoaded = !1),
            (this._warned = !1),
            (this.initTime = Date.now()),
            (this.setIsLoadedBinded = this.setIsLoaded.bind(this)),
            (this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this))
        }
        ;(Nt.isModifier = pt),
          (Nt.isZeroWidthJoiner = vt),
          (Nt.isFlagEmoji = Et),
          (Nt.isRegionalCode = yt),
          (Nt.isCombinedCharacter = Rt),
          (Nt.isRegionalFlag = Ft),
          (Nt.isVariationSelector = _t),
          (Nt.BLACK_FLAG_CODE_POINT = o)
        var Dt = {
          addChars: it,
          addFonts: ut,
          getCharData: ct,
          getFontByName: ht,
          measureText: lt,
          checkLoadedFonts: at,
          setIsLoaded: kt,
        }
        return (Nt.prototype = Dt), Nt
      })()
      function SlotManager(s) {
        this.animationData = s
      }
      SlotManager.prototype.getProp = function (s) {
        return this.animationData.slots && this.animationData.slots[s.sid]
          ? Object.assign(s, this.animationData.slots[s.sid].p)
          : s
      }
      function slotFactory(s) {
        return new SlotManager(s)
      }
      function RenderableElement() {}
      RenderableElement.prototype = {
        initRenderable: function () {
          ;(this.isInRange = !1),
            (this.hidden = !1),
            (this.isTransparent = !1),
            (this.renderableComponents = [])
        },
        addRenderableComponent: function (e) {
          this.renderableComponents.indexOf(e) === -1 &&
            this.renderableComponents.push(e)
        },
        removeRenderableComponent: function (e) {
          this.renderableComponents.indexOf(e) !== -1 &&
            this.renderableComponents.splice(
              this.renderableComponents.indexOf(e),
              1
            )
        },
        prepareRenderableFrame: function (e) {
          this.checkLayerLimits(e)
        },
        checkTransparency: function () {
          this.finalTransform.mProp.o.v <= 0
            ? !this.isTransparent &&
              this.globalData.renderConfig.hideOnTransparent &&
              ((this.isTransparent = !0), this.hide())
            : this.isTransparent && ((this.isTransparent = !1), this.show())
        },
        checkLayerLimits: function (e) {
          this.data.ip - this.data.st <= e && this.data.op - this.data.st > e
            ? this.isInRange !== !0 &&
              ((this.globalData._mdf = !0),
              (this._mdf = !0),
              (this.isInRange = !0),
              this.show())
            : this.isInRange !== !1 &&
              ((this.globalData._mdf = !0), (this.isInRange = !1), this.hide())
        },
        renderRenderable: function () {
          var e,
            a = this.renderableComponents.length
          for (e = 0; e < a; e += 1)
            this.renderableComponents[e].renderFrame(this._isFirstFrame)
        },
        sourceRectAtTime: function () {
          return { top: 0, left: 0, width: 100, height: 100 }
        },
        getLayerSize: function () {
          return this.data.ty === 5
            ? { w: this.data.textData.width, h: this.data.textData.height }
            : { w: this.data.width, h: this.data.height }
        },
      }
      var getBlendMode = (function () {
        var s = {
          0: "source-over",
          1: "multiply",
          2: "screen",
          3: "overlay",
          4: "darken",
          5: "lighten",
          6: "color-dodge",
          7: "color-burn",
          8: "hard-light",
          9: "soft-light",
          10: "difference",
          11: "exclusion",
          12: "hue",
          13: "saturation",
          14: "color",
          15: "luminosity",
        }
        return function (e) {
          return s[e] || ""
        }
      })()
      function SliderEffect(s, e, a) {
        this.p = PropertyFactory.getProp(e, s.v, 0, 0, a)
      }
      function AngleEffect(s, e, a) {
        this.p = PropertyFactory.getProp(e, s.v, 0, 0, a)
      }
      function ColorEffect(s, e, a) {
        this.p = PropertyFactory.getProp(e, s.v, 1, 0, a)
      }
      function PointEffect(s, e, a) {
        this.p = PropertyFactory.getProp(e, s.v, 1, 0, a)
      }
      function LayerIndexEffect(s, e, a) {
        this.p = PropertyFactory.getProp(e, s.v, 0, 0, a)
      }
      function MaskIndexEffect(s, e, a) {
        this.p = PropertyFactory.getProp(e, s.v, 0, 0, a)
      }
      function CheckboxEffect(s, e, a) {
        this.p = PropertyFactory.getProp(e, s.v, 0, 0, a)
      }
      function NoValueEffect() {
        this.p = {}
      }
      function EffectsManager(s, e) {
        var a = s.ef || []
        this.effectElements = []
        var o,
          c = a.length,
          d
        for (o = 0; o < c; o += 1)
          (d = new GroupEffect(a[o], e)), this.effectElements.push(d)
      }
      function GroupEffect(s, e) {
        this.init(s, e)
      }
      extendPrototype([DynamicPropertyContainer], GroupEffect),
        (GroupEffect.prototype.getValue =
          GroupEffect.prototype.iterateDynamicProperties),
        (GroupEffect.prototype.init = function (s, e) {
          ;(this.data = s),
            (this.effectElements = []),
            this.initDynamicPropertyContainer(e)
          var a,
            o = this.data.ef.length,
            c,
            d = this.data.ef
          for (a = 0; a < o; a += 1) {
            switch (((c = null), d[a].ty)) {
              case 0:
                c = new SliderEffect(d[a], e, this)
                break
              case 1:
                c = new AngleEffect(d[a], e, this)
                break
              case 2:
                c = new ColorEffect(d[a], e, this)
                break
              case 3:
                c = new PointEffect(d[a], e, this)
                break
              case 4:
              case 7:
                c = new CheckboxEffect(d[a], e, this)
                break
              case 10:
                c = new LayerIndexEffect(d[a], e, this)
                break
              case 11:
                c = new MaskIndexEffect(d[a], e, this)
                break
              case 5:
                c = new EffectsManager(d[a], e)
                break
              default:
                c = new NoValueEffect(d[a])
                break
            }
            c && this.effectElements.push(c)
          }
        })
      function BaseElement() {}
      BaseElement.prototype = {
        checkMasks: function () {
          if (!this.data.hasMask) return !1
          for (var e = 0, a = this.data.masksProperties.length; e < a; ) {
            if (
              this.data.masksProperties[e].mode !== "n" &&
              this.data.masksProperties[e].cl !== !1
            )
              return !0
            e += 1
          }
          return !1
        },
        initExpressions: function () {
          var e = getExpressionInterfaces()
          if (e) {
            var a = e("layer"),
              o = e("effects"),
              c = e("shape"),
              d = e("text"),
              g = e("comp")
            ;(this.layerInterface = a(this)),
              this.data.hasMask &&
                this.maskManager &&
                this.layerInterface.registerMaskInterface(this.maskManager)
            var _ = o.createEffectsInterface(this, this.layerInterface)
            this.layerInterface.registerEffectsInterface(_),
              this.data.ty === 0 || this.data.xt
                ? (this.compInterface = g(this))
                : this.data.ty === 4
                ? ((this.layerInterface.shapeInterface = c(
                    this.shapesData,
                    this.itemsData,
                    this.layerInterface
                  )),
                  (this.layerInterface.content =
                    this.layerInterface.shapeInterface))
                : this.data.ty === 5 &&
                  ((this.layerInterface.textInterface = d(this)),
                  (this.layerInterface.text =
                    this.layerInterface.textInterface))
          }
        },
        setBlendMode: function () {
          var e = getBlendMode(this.data.bm),
            a = this.baseElement || this.layerElement
          a.style["mix-blend-mode"] = e
        },
        initBaseData: function (e, a, o) {
          ;(this.globalData = a),
            (this.comp = o),
            (this.data = e),
            (this.layerId = createElementID()),
            this.data.sr || (this.data.sr = 1),
            (this.effectsManager = new EffectsManager(
              this.data,
              this,
              this.dynamicProperties
            ))
        },
        getType: function () {
          return this.type
        },
        sourceRectAtTime: function () {},
      }
      function FrameElement() {}
      FrameElement.prototype = {
        initFrame: function () {
          ;(this._isFirstFrame = !1),
            (this.dynamicProperties = []),
            (this._mdf = !1)
        },
        prepareProperties: function (e, a) {
          var o,
            c = this.dynamicProperties.length
          for (o = 0; o < c; o += 1)
            (a ||
              (this._isParent &&
                this.dynamicProperties[o].propType === "transform")) &&
              (this.dynamicProperties[o].getValue(),
              this.dynamicProperties[o]._mdf &&
                ((this.globalData._mdf = !0), (this._mdf = !0)))
        },
        addDynamicProperty: function (e) {
          this.dynamicProperties.indexOf(e) === -1 &&
            this.dynamicProperties.push(e)
        },
      }
      function FootageElement(s, e, a) {
        this.initFrame(),
          this.initRenderable(),
          (this.assetData = e.getAssetData(s.refId)),
          (this.footageData = e.imageLoader.getAsset(this.assetData)),
          this.initBaseData(s, e, a)
      }
      ;(FootageElement.prototype.prepareFrame = function () {}),
        extendPrototype(
          [RenderableElement, BaseElement, FrameElement],
          FootageElement
        ),
        (FootageElement.prototype.getBaseElement = function () {
          return null
        }),
        (FootageElement.prototype.renderFrame = function () {}),
        (FootageElement.prototype.destroy = function () {}),
        (FootageElement.prototype.initExpressions = function () {
          var s = getExpressionInterfaces()
          if (s) {
            var e = s("footage")
            this.layerInterface = e(this)
          }
        }),
        (FootageElement.prototype.getFootageData = function () {
          return this.footageData
        })
      function AudioElement(s, e, a) {
        this.initFrame(),
          this.initRenderable(),
          (this.assetData = e.getAssetData(s.refId)),
          this.initBaseData(s, e, a),
          (this._isPlaying = !1),
          (this._canPlay = !1)
        var o = this.globalData.getAssetsPath(this.assetData)
        ;(this.audio = this.globalData.audioController.createAudio(o)),
          (this._currentTime = 0),
          this.globalData.audioController.addAudio(this),
          (this._volumeMultiplier = 1),
          (this._volume = 1),
          (this._previousVolume = null),
          (this.tm = s.tm
            ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this)
            : { _placeholder: !0 }),
          (this.lv = PropertyFactory.getProp(
            this,
            s.au && s.au.lv ? s.au.lv : { k: [100] },
            1,
            0.01,
            this
          ))
      }
      ;(AudioElement.prototype.prepareFrame = function (s) {
        if (
          (this.prepareRenderableFrame(s, !0),
          this.prepareProperties(s, !0),
          this.tm._placeholder)
        )
          this._currentTime = s / this.data.sr
        else {
          var e = this.tm.v
          this._currentTime = e
        }
        this._volume = this.lv.v[0]
        var a = this._volume * this._volumeMultiplier
        this._previousVolume !== a &&
          ((this._previousVolume = a), this.audio.volume(a))
      }),
        extendPrototype(
          [RenderableElement, BaseElement, FrameElement],
          AudioElement
        ),
        (AudioElement.prototype.renderFrame = function () {
          this.isInRange &&
            this._canPlay &&
            (this._isPlaying
              ? (!this.audio.playing() ||
                  Math.abs(
                    this._currentTime / this.globalData.frameRate -
                      this.audio.seek()
                  ) > 0.1) &&
                this.audio.seek(this._currentTime / this.globalData.frameRate)
              : (this.audio.play(),
                this.audio.seek(this._currentTime / this.globalData.frameRate),
                (this._isPlaying = !0)))
        }),
        (AudioElement.prototype.show = function () {}),
        (AudioElement.prototype.hide = function () {
          this.audio.pause(), (this._isPlaying = !1)
        }),
        (AudioElement.prototype.pause = function () {
          this.audio.pause(), (this._isPlaying = !1), (this._canPlay = !1)
        }),
        (AudioElement.prototype.resume = function () {
          this._canPlay = !0
        }),
        (AudioElement.prototype.setRate = function (s) {
          this.audio.rate(s)
        }),
        (AudioElement.prototype.volume = function (s) {
          ;(this._volumeMultiplier = s),
            (this._previousVolume = s * this._volume),
            this.audio.volume(this._previousVolume)
        }),
        (AudioElement.prototype.getBaseElement = function () {
          return null
        }),
        (AudioElement.prototype.destroy = function () {}),
        (AudioElement.prototype.sourceRectAtTime = function () {}),
        (AudioElement.prototype.initExpressions = function () {})
      function BaseRenderer() {}
      ;(BaseRenderer.prototype.checkLayers = function (s) {
        var e,
          a = this.layers.length,
          o
        for (this.completeLayers = !0, e = a - 1; e >= 0; e -= 1)
          this.elements[e] ||
            ((o = this.layers[e]),
            o.ip - o.st <= s - this.layers[e].st &&
              o.op - o.st > s - this.layers[e].st &&
              this.buildItem(e)),
            (this.completeLayers = this.elements[e] ? this.completeLayers : !1)
        this.checkPendingElements()
      }),
        (BaseRenderer.prototype.createItem = function (s) {
          switch (s.ty) {
            case 2:
              return this.createImage(s)
            case 0:
              return this.createComp(s)
            case 1:
              return this.createSolid(s)
            case 3:
              return this.createNull(s)
            case 4:
              return this.createShape(s)
            case 5:
              return this.createText(s)
            case 6:
              return this.createAudio(s)
            case 13:
              return this.createCamera(s)
            case 15:
              return this.createFootage(s)
            default:
              return this.createNull(s)
          }
        }),
        (BaseRenderer.prototype.createCamera = function () {
          throw new Error("You're using a 3d camera. Try the html renderer.")
        }),
        (BaseRenderer.prototype.createAudio = function (s) {
          return new AudioElement(s, this.globalData, this)
        }),
        (BaseRenderer.prototype.createFootage = function (s) {
          return new FootageElement(s, this.globalData, this)
        }),
        (BaseRenderer.prototype.buildAllItems = function () {
          var s,
            e = this.layers.length
          for (s = 0; s < e; s += 1) this.buildItem(s)
          this.checkPendingElements()
        }),
        (BaseRenderer.prototype.includeLayers = function (s) {
          this.completeLayers = !1
          var e,
            a = s.length,
            o,
            c = this.layers.length
          for (e = 0; e < a; e += 1)
            for (o = 0; o < c; ) {
              if (this.layers[o].id === s[e].id) {
                this.layers[o] = s[e]
                break
              }
              o += 1
            }
        }),
        (BaseRenderer.prototype.setProjectInterface = function (s) {
          this.globalData.projectInterface = s
        }),
        (BaseRenderer.prototype.initItems = function () {
          this.globalData.progressiveLoad || this.buildAllItems()
        }),
        (BaseRenderer.prototype.buildElementParenting = function (s, e, a) {
          for (
            var o = this.elements, c = this.layers, d = 0, g = c.length;
            d < g;

          )
            c[d].ind == e &&
              (!o[d] || o[d] === !0
                ? (this.buildItem(d), this.addPendingElement(s))
                : (a.push(o[d]),
                  o[d].setAsParent(),
                  c[d].parent !== void 0
                    ? this.buildElementParenting(s, c[d].parent, a)
                    : s.setHierarchy(a))),
              (d += 1)
        }),
        (BaseRenderer.prototype.addPendingElement = function (s) {
          this.pendingElements.push(s)
        }),
        (BaseRenderer.prototype.searchExtraCompositions = function (s) {
          var e,
            a = s.length
          for (e = 0; e < a; e += 1)
            if (s[e].xt) {
              var o = this.createComp(s[e])
              o.initExpressions(),
                this.globalData.projectInterface.registerComposition(o)
            }
        }),
        (BaseRenderer.prototype.getElementById = function (s) {
          var e,
            a = this.elements.length
          for (e = 0; e < a; e += 1)
            if (this.elements[e].data.ind === s) return this.elements[e]
          return null
        }),
        (BaseRenderer.prototype.getElementByPath = function (s) {
          var e = s.shift(),
            a
          if (typeof e == "number") a = this.elements[e]
          else {
            var o,
              c = this.elements.length
            for (o = 0; o < c; o += 1)
              if (this.elements[o].data.nm === e) {
                a = this.elements[o]
                break
              }
          }
          return s.length === 0 ? a : a.getElementByPath(s)
        }),
        (BaseRenderer.prototype.setupGlobalData = function (s, e) {
          ;(this.globalData.fontManager = new FontManager()),
            (this.globalData.slotManager = slotFactory(s)),
            this.globalData.fontManager.addChars(s.chars),
            this.globalData.fontManager.addFonts(s.fonts, e),
            (this.globalData.getAssetData =
              this.animationItem.getAssetData.bind(this.animationItem)),
            (this.globalData.getAssetsPath =
              this.animationItem.getAssetsPath.bind(this.animationItem)),
            (this.globalData.imageLoader = this.animationItem.imagePreloader),
            (this.globalData.audioController =
              this.animationItem.audioController),
            (this.globalData.frameId = 0),
            (this.globalData.frameRate = s.fr),
            (this.globalData.nm = s.nm),
            (this.globalData.compSize = { w: s.w, h: s.h })
        })
      var effectTypes = { TRANSFORM_EFFECT: "transformEFfect" }
      function TransformElement() {}
      TransformElement.prototype = {
        initTransform: function () {
          var e = new Matrix()
          ;(this.finalTransform = {
            mProp: this.data.ks
              ? TransformPropertyFactory.getTransformProperty(
                  this,
                  this.data.ks,
                  this
                )
              : { o: 0 },
            _matMdf: !1,
            _localMatMdf: !1,
            _opMdf: !1,
            mat: e,
            localMat: e,
            localOpacity: 1,
          }),
            this.data.ao && (this.finalTransform.mProp.autoOriented = !0),
            this.data.ty
        },
        renderTransform: function () {
          if (
            ((this.finalTransform._opMdf =
              this.finalTransform.mProp.o._mdf || this._isFirstFrame),
            (this.finalTransform._matMdf =
              this.finalTransform.mProp._mdf || this._isFirstFrame),
            this.hierarchy)
          ) {
            var e,
              a = this.finalTransform.mat,
              o = 0,
              c = this.hierarchy.length
            if (!this.finalTransform._matMdf)
              for (; o < c; ) {
                if (this.hierarchy[o].finalTransform.mProp._mdf) {
                  this.finalTransform._matMdf = !0
                  break
                }
                o += 1
              }
            if (this.finalTransform._matMdf)
              for (
                e = this.finalTransform.mProp.v.props,
                  a.cloneFromProps(e),
                  o = 0;
                o < c;
                o += 1
              )
                a.multiply(this.hierarchy[o].finalTransform.mProp.v)
          }
          this.finalTransform._matMdf &&
            (this.finalTransform._localMatMdf = this.finalTransform._matMdf),
            this.finalTransform._opMdf &&
              (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v)
        },
        renderLocalTransform: function () {
          if (this.localTransforms) {
            var e = 0,
              a = this.localTransforms.length
            if (
              ((this.finalTransform._localMatMdf = this.finalTransform._matMdf),
              !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
            )
              for (; e < a; )
                this.localTransforms[e]._mdf &&
                  (this.finalTransform._localMatMdf = !0),
                  this.localTransforms[e]._opMdf &&
                    !this.finalTransform._opMdf &&
                    ((this.finalTransform.localOpacity =
                      this.finalTransform.mProp.o.v),
                    (this.finalTransform._opMdf = !0)),
                  (e += 1)
            if (this.finalTransform._localMatMdf) {
              var o = this.finalTransform.localMat
              for (
                this.localTransforms[0].matrix.clone(o), e = 1;
                e < a;
                e += 1
              ) {
                var c = this.localTransforms[e].matrix
                o.multiply(c)
              }
              o.multiply(this.finalTransform.mat)
            }
            if (this.finalTransform._opMdf) {
              var d = this.finalTransform.localOpacity
              for (e = 0; e < a; e += 1)
                d *= this.localTransforms[e].opacity * 0.01
              this.finalTransform.localOpacity = d
            }
          }
        },
        searchEffectTransforms: function () {
          if (this.renderableEffectsManager) {
            var e = this.renderableEffectsManager.getEffects(
              effectTypes.TRANSFORM_EFFECT
            )
            if (e.length) {
              ;(this.localTransforms = []),
                (this.finalTransform.localMat = new Matrix())
              var a = 0,
                o = e.length
              for (a = 0; a < o; a += 1) this.localTransforms.push(e[a])
            }
          }
        },
        globalToLocal: function (e) {
          var a = []
          a.push(this.finalTransform)
          for (var o = !0, c = this.comp; o; )
            c.finalTransform
              ? (c.data.hasMask && a.splice(0, 0, c.finalTransform),
                (c = c.comp))
              : (o = !1)
          var d,
            g = a.length,
            _
          for (d = 0; d < g; d += 1)
            (_ = a[d].mat.applyToPointArray(0, 0, 0)),
              (e = [e[0] - _[0], e[1] - _[1], 0])
          return e
        },
        mHelper: new Matrix(),
      }
      function MaskElement(s, e, a) {
        ;(this.data = s),
          (this.element = e),
          (this.globalData = a),
          (this.storedData = []),
          (this.masksProperties = this.data.masksProperties || []),
          (this.maskElement = null)
        var o = this.globalData.defs,
          c,
          d = this.masksProperties ? this.masksProperties.length : 0
        ;(this.viewData = createSizedArray(d)), (this.solidPath = "")
        var g,
          _ = this.masksProperties,
          b = 0,
          j = [],
          $,
          _e,
          tt = createElementID(),
          st,
          at,
          ot,
          ut,
          it = "clipPath",
          ct = "clip-path"
        for (c = 0; c < d; c += 1)
          if (
            (((_[c].mode !== "a" && _[c].mode !== "n") ||
              _[c].inv ||
              _[c].o.k !== 100 ||
              _[c].o.x) &&
              ((it = "mask"), (ct = "mask")),
            (_[c].mode === "s" || _[c].mode === "i") && b === 0
              ? ((st = createNS("rect")),
                st.setAttribute("fill", "#ffffff"),
                st.setAttribute("width", this.element.comp.data.w || 0),
                st.setAttribute("height", this.element.comp.data.h || 0),
                j.push(st))
              : (st = null),
            (g = createNS("path")),
            _[c].mode === "n")
          )
            (this.viewData[c] = {
              op: PropertyFactory.getProp(
                this.element,
                _[c].o,
                0,
                0.01,
                this.element
              ),
              prop: ShapePropertyFactory.getShapeProp(this.element, _[c], 3),
              elem: g,
              lastPath: "",
            }),
              o.appendChild(g)
          else {
            ;(b += 1),
              g.setAttribute("fill", _[c].mode === "s" ? "#000000" : "#ffffff"),
              g.setAttribute("clip-rule", "nonzero")
            var lt
            if (
              (_[c].x.k !== 0
                ? ((it = "mask"),
                  (ct = "mask"),
                  (ut = PropertyFactory.getProp(
                    this.element,
                    _[c].x,
                    0,
                    null,
                    this.element
                  )),
                  (lt = createElementID()),
                  (at = createNS("filter")),
                  at.setAttribute("id", lt),
                  (ot = createNS("feMorphology")),
                  ot.setAttribute("operator", "erode"),
                  ot.setAttribute("in", "SourceGraphic"),
                  ot.setAttribute("radius", "0"),
                  at.appendChild(ot),
                  o.appendChild(at),
                  g.setAttribute(
                    "stroke",
                    _[c].mode === "s" ? "#000000" : "#ffffff"
                  ))
                : ((ot = null), (ut = null)),
              (this.storedData[c] = {
                elem: g,
                x: ut,
                expan: ot,
                lastPath: "",
                lastOperator: "",
                filterId: lt,
                lastRadius: 0,
              }),
              _[c].mode === "i")
            ) {
              _e = j.length
              var ht = createNS("g")
              for ($ = 0; $ < _e; $ += 1) ht.appendChild(j[$])
              var dt = createNS("mask")
              dt.setAttribute("mask-type", "alpha"),
                dt.setAttribute("id", tt + "_" + b),
                dt.appendChild(g),
                o.appendChild(dt),
                ht.setAttribute(
                  "mask",
                  "url(" + getLocationHref() + "#" + tt + "_" + b + ")"
                ),
                (j.length = 0),
                j.push(ht)
            } else j.push(g)
            _[c].inv &&
              !this.solidPath &&
              (this.solidPath = this.createLayerSolidPath()),
              (this.viewData[c] = {
                elem: g,
                lastPath: "",
                op: PropertyFactory.getProp(
                  this.element,
                  _[c].o,
                  0,
                  0.01,
                  this.element
                ),
                prop: ShapePropertyFactory.getShapeProp(this.element, _[c], 3),
                invRect: st,
              }),
              this.viewData[c].prop.k ||
                this.drawPath(_[c], this.viewData[c].prop.v, this.viewData[c])
          }
        for (
          this.maskElement = createNS(it), d = j.length, c = 0;
          c < d;
          c += 1
        )
          this.maskElement.appendChild(j[c])
        b > 0 &&
          (this.maskElement.setAttribute("id", tt),
          this.element.maskedElement.setAttribute(
            ct,
            "url(" + getLocationHref() + "#" + tt + ")"
          ),
          o.appendChild(this.maskElement)),
          this.viewData.length && this.element.addRenderableComponent(this)
      }
      ;(MaskElement.prototype.getMaskProperty = function (s) {
        return this.viewData[s].prop
      }),
        (MaskElement.prototype.renderFrame = function (s) {
          var e = this.element.finalTransform.mat,
            a,
            o = this.masksProperties.length
          for (a = 0; a < o; a += 1)
            if (
              ((this.viewData[a].prop._mdf || s) &&
                this.drawPath(
                  this.masksProperties[a],
                  this.viewData[a].prop.v,
                  this.viewData[a]
                ),
              (this.viewData[a].op._mdf || s) &&
                this.viewData[a].elem.setAttribute(
                  "fill-opacity",
                  this.viewData[a].op.v
                ),
              this.masksProperties[a].mode !== "n" &&
                (this.viewData[a].invRect &&
                  (this.element.finalTransform.mProp._mdf || s) &&
                  this.viewData[a].invRect.setAttribute(
                    "transform",
                    e.getInverseMatrix().to2dCSS()
                  ),
                this.storedData[a].x && (this.storedData[a].x._mdf || s)))
            ) {
              var c = this.storedData[a].expan
              this.storedData[a].x.v < 0
                ? (this.storedData[a].lastOperator !== "erode" &&
                    ((this.storedData[a].lastOperator = "erode"),
                    this.storedData[a].elem.setAttribute(
                      "filter",
                      "url(" +
                        getLocationHref() +
                        "#" +
                        this.storedData[a].filterId +
                        ")"
                    )),
                  c.setAttribute("radius", -this.storedData[a].x.v))
                : (this.storedData[a].lastOperator !== "dilate" &&
                    ((this.storedData[a].lastOperator = "dilate"),
                    this.storedData[a].elem.setAttribute("filter", null)),
                  this.storedData[a].elem.setAttribute(
                    "stroke-width",
                    this.storedData[a].x.v * 2
                  ))
            }
        }),
        (MaskElement.prototype.getMaskelement = function () {
          return this.maskElement
        }),
        (MaskElement.prototype.createLayerSolidPath = function () {
          var s = "M0,0 "
          return (
            (s += " h" + this.globalData.compSize.w),
            (s += " v" + this.globalData.compSize.h),
            (s += " h-" + this.globalData.compSize.w),
            (s += " v-" + this.globalData.compSize.h + " "),
            s
          )
        }),
        (MaskElement.prototype.drawPath = function (s, e, a) {
          var o = " M" + e.v[0][0] + "," + e.v[0][1],
            c,
            d
          for (d = e._length, c = 1; c < d; c += 1)
            o +=
              " C" +
              e.o[c - 1][0] +
              "," +
              e.o[c - 1][1] +
              " " +
              e.i[c][0] +
              "," +
              e.i[c][1] +
              " " +
              e.v[c][0] +
              "," +
              e.v[c][1]
          if (
            (e.c &&
              d > 1 &&
              (o +=
                " C" +
                e.o[c - 1][0] +
                "," +
                e.o[c - 1][1] +
                " " +
                e.i[0][0] +
                "," +
                e.i[0][1] +
                " " +
                e.v[0][0] +
                "," +
                e.v[0][1]),
            a.lastPath !== o)
          ) {
            var g = ""
            a.elem &&
              (e.c && (g = s.inv ? this.solidPath + o : o),
              a.elem.setAttribute("d", g)),
              (a.lastPath = o)
          }
        }),
        (MaskElement.prototype.destroy = function () {
          ;(this.element = null),
            (this.globalData = null),
            (this.maskElement = null),
            (this.data = null),
            (this.masksProperties = null)
        })
      var filtersFactory = (function () {
          var s = {}
          ;(s.createFilter = e), (s.createAlphaToLuminanceFilter = a)
          function e(o, c) {
            var d = createNS("filter")
            return (
              d.setAttribute("id", o),
              c !== !0 &&
                (d.setAttribute("filterUnits", "objectBoundingBox"),
                d.setAttribute("x", "0%"),
                d.setAttribute("y", "0%"),
                d.setAttribute("width", "100%"),
                d.setAttribute("height", "100%")),
              d
            )
          }
          function a() {
            var o = createNS("feColorMatrix")
            return (
              o.setAttribute("type", "matrix"),
              o.setAttribute("color-interpolation-filters", "sRGB"),
              o.setAttribute(
                "values",
                "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"
              ),
              o
            )
          }
          return s
        })(),
        featureSupport = (function () {
          var s = {
            maskType: !0,
            svgLumaHidden: !0,
            offscreenCanvas: typeof OffscreenCanvas < "u",
          }
          return (
            (/MSIE 10/i.test(navigator.userAgent) ||
              /MSIE 9/i.test(navigator.userAgent) ||
              /rv:11.0/i.test(navigator.userAgent) ||
              /Edge\/\d./i.test(navigator.userAgent)) &&
              (s.maskType = !1),
            /firefox/i.test(navigator.userAgent) && (s.svgLumaHidden = !1),
            s
          )
        })(),
        registeredEffects$1 = {},
        idPrefix = "filter_result_"
      function SVGEffects(s) {
        var e,
          a = "SourceGraphic",
          o = s.data.ef ? s.data.ef.length : 0,
          c = createElementID(),
          d = filtersFactory.createFilter(c, !0),
          g = 0
        this.filters = []
        var _
        for (e = 0; e < o; e += 1) {
          _ = null
          var b = s.data.ef[e].ty
          if (registeredEffects$1[b]) {
            var j = registeredEffects$1[b].effect
            ;(_ = new j(
              d,
              s.effectsManager.effectElements[e],
              s,
              idPrefix + g,
              a
            )),
              (a = idPrefix + g),
              registeredEffects$1[b].countsAsEffect && (g += 1)
          }
          _ && this.filters.push(_)
        }
        g &&
          (s.globalData.defs.appendChild(d),
          s.layerElement.setAttribute(
            "filter",
            "url(" + getLocationHref() + "#" + c + ")"
          )),
          this.filters.length && s.addRenderableComponent(this)
      }
      ;(SVGEffects.prototype.renderFrame = function (s) {
        var e,
          a = this.filters.length
        for (e = 0; e < a; e += 1) this.filters[e].renderFrame(s)
      }),
        (SVGEffects.prototype.getEffects = function (s) {
          var e,
            a = this.filters.length,
            o = []
          for (e = 0; e < a; e += 1)
            this.filters[e].type === s && o.push(this.filters[e])
          return o
        })
      function registerEffect$1(s, e, a) {
        registeredEffects$1[s] = { effect: e, countsAsEffect: a }
      }
      function SVGBaseElement() {}
      SVGBaseElement.prototype = {
        initRendererElement: function () {
          this.layerElement = createNS("g")
        },
        createContainerElements: function () {
          ;(this.matteElement = createNS("g")),
            (this.transformedElement = this.layerElement),
            (this.maskedElement = this.layerElement),
            (this._sizeChanged = !1)
          var e = null
          if (this.data.td) {
            this.matteMasks = {}
            var a = createNS("g")
            a.setAttribute("id", this.layerId),
              a.appendChild(this.layerElement),
              (e = a),
              this.globalData.defs.appendChild(a)
          } else
            this.data.tt
              ? (this.matteElement.appendChild(this.layerElement),
                (e = this.matteElement),
                (this.baseElement = this.matteElement))
              : (this.baseElement = this.layerElement)
          if (
            (this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
            this.data.cl &&
              this.layerElement.setAttribute("class", this.data.cl),
            this.data.ty === 0 && !this.data.hd)
          ) {
            var o = createNS("clipPath"),
              c = createNS("path")
            c.setAttribute(
              "d",
              "M0,0 L" +
                this.data.w +
                ",0 L" +
                this.data.w +
                "," +
                this.data.h +
                " L0," +
                this.data.h +
                "z"
            )
            var d = createElementID()
            if (
              (o.setAttribute("id", d),
              o.appendChild(c),
              this.globalData.defs.appendChild(o),
              this.checkMasks())
            ) {
              var g = createNS("g")
              g.setAttribute(
                "clip-path",
                "url(" + getLocationHref() + "#" + d + ")"
              ),
                g.appendChild(this.layerElement),
                (this.transformedElement = g),
                e
                  ? e.appendChild(this.transformedElement)
                  : (this.baseElement = this.transformedElement)
            } else
              this.layerElement.setAttribute(
                "clip-path",
                "url(" + getLocationHref() + "#" + d + ")"
              )
          }
          this.data.bm !== 0 && this.setBlendMode()
        },
        renderElement: function () {
          this.finalTransform._localMatMdf &&
            this.transformedElement.setAttribute(
              "transform",
              this.finalTransform.localMat.to2dCSS()
            ),
            this.finalTransform._opMdf &&
              this.transformedElement.setAttribute(
                "opacity",
                this.finalTransform.localOpacity
              )
        },
        destroyBaseElement: function () {
          ;(this.layerElement = null),
            (this.matteElement = null),
            this.maskManager.destroy()
        },
        getBaseElement: function () {
          return this.data.hd ? null : this.baseElement
        },
        createRenderableComponents: function () {
          ;(this.maskManager = new MaskElement(
            this.data,
            this,
            this.globalData
          )),
            (this.renderableEffectsManager = new SVGEffects(this)),
            this.searchEffectTransforms()
        },
        getMatte: function (e) {
          if (
            (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[e])
          ) {
            var a = this.layerId + "_" + e,
              o,
              c,
              d,
              g
            if (e === 1 || e === 3) {
              var _ = createNS("mask")
              _.setAttribute("id", a),
                _.setAttribute("mask-type", e === 3 ? "luminance" : "alpha"),
                (d = createNS("use")),
                d.setAttributeNS(
                  "http://www.w3.org/1999/xlink",
                  "href",
                  "#" + this.layerId
                ),
                _.appendChild(d),
                this.globalData.defs.appendChild(_),
                !featureSupport.maskType &&
                  e === 1 &&
                  (_.setAttribute("mask-type", "luminance"),
                  (o = createElementID()),
                  (c = filtersFactory.createFilter(o)),
                  this.globalData.defs.appendChild(c),
                  c.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                  (g = createNS("g")),
                  g.appendChild(d),
                  _.appendChild(g),
                  g.setAttribute(
                    "filter",
                    "url(" + getLocationHref() + "#" + o + ")"
                  ))
            } else if (e === 2) {
              var b = createNS("mask")
              b.setAttribute("id", a), b.setAttribute("mask-type", "alpha")
              var j = createNS("g")
              b.appendChild(j),
                (o = createElementID()),
                (c = filtersFactory.createFilter(o))
              var $ = createNS("feComponentTransfer")
              $.setAttribute("in", "SourceGraphic"), c.appendChild($)
              var _e = createNS("feFuncA")
              _e.setAttribute("type", "table"),
                _e.setAttribute("tableValues", "1.0 0.0"),
                $.appendChild(_e),
                this.globalData.defs.appendChild(c)
              var tt = createNS("rect")
              tt.setAttribute("width", this.comp.data.w),
                tt.setAttribute("height", this.comp.data.h),
                tt.setAttribute("x", "0"),
                tt.setAttribute("y", "0"),
                tt.setAttribute("fill", "#ffffff"),
                tt.setAttribute("opacity", "0"),
                j.setAttribute(
                  "filter",
                  "url(" + getLocationHref() + "#" + o + ")"
                ),
                j.appendChild(tt),
                (d = createNS("use")),
                d.setAttributeNS(
                  "http://www.w3.org/1999/xlink",
                  "href",
                  "#" + this.layerId
                ),
                j.appendChild(d),
                featureSupport.maskType ||
                  (b.setAttribute("mask-type", "luminance"),
                  c.appendChild(filtersFactory.createAlphaToLuminanceFilter()),
                  (g = createNS("g")),
                  j.appendChild(tt),
                  g.appendChild(this.layerElement),
                  j.appendChild(g)),
                this.globalData.defs.appendChild(b)
            }
            this.matteMasks[e] = a
          }
          return this.matteMasks[e]
        },
        setMatte: function (e) {
          this.matteElement &&
            this.matteElement.setAttribute(
              "mask",
              "url(" + getLocationHref() + "#" + e + ")"
            )
        },
      }
      function HierarchyElement() {}
      HierarchyElement.prototype = {
        initHierarchy: function () {
          ;(this.hierarchy = []), (this._isParent = !1), this.checkParenting()
        },
        setHierarchy: function (e) {
          this.hierarchy = e
        },
        setAsParent: function () {
          this._isParent = !0
        },
        checkParenting: function () {
          this.data.parent !== void 0 &&
            this.comp.buildElementParenting(this, this.data.parent, [])
        },
      }
      function RenderableDOMElement() {}
      ;(function () {
        var s = {
          initElement: function (a, o, c) {
            this.initFrame(),
              this.initBaseData(a, o, c),
              this.initTransform(a, o, c),
              this.initHierarchy(),
              this.initRenderable(),
              this.initRendererElement(),
              this.createContainerElements(),
              this.createRenderableComponents(),
              this.createContent(),
              this.hide()
          },
          hide: function () {
            if (!this.hidden && (!this.isInRange || this.isTransparent)) {
              var a = this.baseElement || this.layerElement
              ;(a.style.display = "none"), (this.hidden = !0)
            }
          },
          show: function () {
            if (this.isInRange && !this.isTransparent) {
              if (!this.data.hd) {
                var a = this.baseElement || this.layerElement
                a.style.display = "block"
              }
              ;(this.hidden = !1), (this._isFirstFrame = !0)
            }
          },
          renderFrame: function () {
            this.data.hd ||
              this.hidden ||
              (this.renderTransform(),
              this.renderRenderable(),
              this.renderLocalTransform(),
              this.renderElement(),
              this.renderInnerContent(),
              this._isFirstFrame && (this._isFirstFrame = !1))
          },
          renderInnerContent: function () {},
          prepareFrame: function (a) {
            ;(this._mdf = !1),
              this.prepareRenderableFrame(a),
              this.prepareProperties(a, this.isInRange),
              this.checkTransparency()
          },
          destroy: function () {
            ;(this.innerElem = null), this.destroyBaseElement()
          },
        }
        extendPrototype(
          [RenderableElement, createProxyFunction(s)],
          RenderableDOMElement
        )
      })()
      function IImageElement(s, e, a) {
        ;(this.assetData = e.getAssetData(s.refId)),
          this.assetData &&
            this.assetData.sid &&
            (this.assetData = e.slotManager.getProp(this.assetData)),
          this.initElement(s, e, a),
          (this.sourceRect = {
            top: 0,
            left: 0,
            width: this.assetData.w,
            height: this.assetData.h,
          })
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        IImageElement
      ),
        (IImageElement.prototype.createContent = function () {
          var s = this.globalData.getAssetsPath(this.assetData)
          ;(this.innerElem = createNS("image")),
            this.innerElem.setAttribute("width", this.assetData.w + "px"),
            this.innerElem.setAttribute("height", this.assetData.h + "px"),
            this.innerElem.setAttribute(
              "preserveAspectRatio",
              this.assetData.pr ||
                this.globalData.renderConfig.imagePreserveAspectRatio
            ),
            this.innerElem.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "href",
              s
            ),
            this.layerElement.appendChild(this.innerElem)
        }),
        (IImageElement.prototype.sourceRectAtTime = function () {
          return this.sourceRect
        })
      function ProcessedElement(s, e) {
        ;(this.elem = s), (this.pos = e)
      }
      function IShapeElement() {}
      IShapeElement.prototype = {
        addShapeToModifiers: function (e) {
          var a,
            o = this.shapeModifiers.length
          for (a = 0; a < o; a += 1) this.shapeModifiers[a].addShape(e)
        },
        isShapeInAnimatedModifiers: function (e) {
          for (var a = 0, o = this.shapeModifiers.length; a < o; )
            if (this.shapeModifiers[a].isAnimatedWithShape(e)) return !0
          return !1
        },
        renderModifiers: function () {
          if (this.shapeModifiers.length) {
            var e,
              a = this.shapes.length
            for (e = 0; e < a; e += 1) this.shapes[e].sh.reset()
            a = this.shapeModifiers.length
            var o
            for (
              e = a - 1;
              e >= 0 &&
              ((o = this.shapeModifiers[e].processShapes(this._isFirstFrame)),
              !o);
              e -= 1
            );
          }
        },
        searchProcessedElement: function (e) {
          for (var a = this.processedElements, o = 0, c = a.length; o < c; ) {
            if (a[o].elem === e) return a[o].pos
            o += 1
          }
          return 0
        },
        addProcessedElement: function (e, a) {
          for (var o = this.processedElements, c = o.length; c; )
            if (((c -= 1), o[c].elem === e)) {
              o[c].pos = a
              return
            }
          o.push(new ProcessedElement(e, a))
        },
        prepareFrame: function (e) {
          this.prepareRenderableFrame(e),
            this.prepareProperties(e, this.isInRange)
        },
      }
      var lineCapEnum = { 1: "butt", 2: "round", 3: "square" },
        lineJoinEnum = { 1: "miter", 2: "round", 3: "bevel" }
      function SVGShapeData(s, e, a) {
        ;(this.caches = []),
          (this.styles = []),
          (this.transformers = s),
          (this.lStr = ""),
          (this.sh = a),
          (this.lvl = e),
          (this._isAnimated = !!a.k)
        for (var o = 0, c = s.length; o < c; ) {
          if (s[o].mProps.dynamicProperties.length) {
            this._isAnimated = !0
            break
          }
          o += 1
        }
      }
      SVGShapeData.prototype.setAsAnimated = function () {
        this._isAnimated = !0
      }
      function SVGStyleData(s, e) {
        ;(this.data = s),
          (this.type = s.ty),
          (this.d = ""),
          (this.lvl = e),
          (this._mdf = !1),
          (this.closed = s.hd === !0),
          (this.pElem = createNS("path")),
          (this.msElem = null)
      }
      SVGStyleData.prototype.reset = function () {
        ;(this.d = ""), (this._mdf = !1)
      }
      function DashProperty(s, e, a, o) {
        ;(this.elem = s),
          (this.frameId = -1),
          (this.dataProps = createSizedArray(e.length)),
          (this.renderer = a),
          (this.k = !1),
          (this.dashStr = ""),
          (this.dashArray = createTypedArray(
            "float32",
            e.length ? e.length - 1 : 0
          )),
          (this.dashoffset = createTypedArray("float32", 1)),
          this.initDynamicPropertyContainer(o)
        var c,
          d = e.length || 0,
          g
        for (c = 0; c < d; c += 1)
          (g = PropertyFactory.getProp(s, e[c].v, 0, 0, this)),
            (this.k = g.k || this.k),
            (this.dataProps[c] = { n: e[c].n, p: g })
        this.k || this.getValue(!0), (this._isAnimated = this.k)
      }
      ;(DashProperty.prototype.getValue = function (s) {
        if (
          !(this.elem.globalData.frameId === this.frameId && !s) &&
          ((this.frameId = this.elem.globalData.frameId),
          this.iterateDynamicProperties(),
          (this._mdf = this._mdf || s),
          this._mdf)
        ) {
          var e = 0,
            a = this.dataProps.length
          for (
            this.renderer === "svg" && (this.dashStr = ""), e = 0;
            e < a;
            e += 1
          )
            this.dataProps[e].n !== "o"
              ? this.renderer === "svg"
                ? (this.dashStr += " " + this.dataProps[e].p.v)
                : (this.dashArray[e] = this.dataProps[e].p.v)
              : (this.dashoffset[0] = this.dataProps[e].p.v)
        }
      }),
        extendPrototype([DynamicPropertyContainer], DashProperty)
      function SVGStrokeStyleData(s, e, a) {
        this.initDynamicPropertyContainer(s),
          (this.getValue = this.iterateDynamicProperties),
          (this.o = PropertyFactory.getProp(s, e.o, 0, 0.01, this)),
          (this.w = PropertyFactory.getProp(s, e.w, 0, null, this)),
          (this.d = new DashProperty(s, e.d || {}, "svg", this)),
          (this.c = PropertyFactory.getProp(s, e.c, 1, 255, this)),
          (this.style = a),
          (this._isAnimated = !!this._isAnimated)
      }
      extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData)
      function SVGFillStyleData(s, e, a) {
        this.initDynamicPropertyContainer(s),
          (this.getValue = this.iterateDynamicProperties),
          (this.o = PropertyFactory.getProp(s, e.o, 0, 0.01, this)),
          (this.c = PropertyFactory.getProp(s, e.c, 1, 255, this)),
          (this.style = a)
      }
      extendPrototype([DynamicPropertyContainer], SVGFillStyleData)
      function SVGNoStyleData(s, e, a) {
        this.initDynamicPropertyContainer(s),
          (this.getValue = this.iterateDynamicProperties),
          (this.style = a)
      }
      extendPrototype([DynamicPropertyContainer], SVGNoStyleData)
      function GradientProperty(s, e, a) {
        ;(this.data = e), (this.c = createTypedArray("uint8c", e.p * 4))
        var o = e.k.k[0].s
          ? e.k.k[0].s.length - e.p * 4
          : e.k.k.length - e.p * 4
        ;(this.o = createTypedArray("float32", o)),
          (this._cmdf = !1),
          (this._omdf = !1),
          (this._collapsable = this.checkCollapsable()),
          (this._hasOpacity = o),
          this.initDynamicPropertyContainer(a),
          (this.prop = PropertyFactory.getProp(s, e.k, 1, null, this)),
          (this.k = this.prop.k),
          this.getValue(!0)
      }
      ;(GradientProperty.prototype.comparePoints = function (s, e) {
        for (var a = 0, o = this.o.length / 2, c; a < o; ) {
          if (((c = Math.abs(s[a * 4] - s[e * 4 + a * 2])), c > 0.01)) return !1
          a += 1
        }
        return !0
      }),
        (GradientProperty.prototype.checkCollapsable = function () {
          if (this.o.length / 2 !== this.c.length / 4) return !1
          if (this.data.k.k[0].s)
            for (var s = 0, e = this.data.k.k.length; s < e; ) {
              if (!this.comparePoints(this.data.k.k[s].s, this.data.p))
                return !1
              s += 1
            }
          else if (!this.comparePoints(this.data.k.k, this.data.p)) return !1
          return !0
        }),
        (GradientProperty.prototype.getValue = function (s) {
          if (
            (this.prop.getValue(),
            (this._mdf = !1),
            (this._cmdf = !1),
            (this._omdf = !1),
            this.prop._mdf || s)
          ) {
            var e,
              a = this.data.p * 4,
              o,
              c
            for (e = 0; e < a; e += 1)
              (o = e % 4 === 0 ? 100 : 255),
                (c = Math.round(this.prop.v[e] * o)),
                this.c[e] !== c && ((this.c[e] = c), (this._cmdf = !s))
            if (this.o.length)
              for (a = this.prop.v.length, e = this.data.p * 4; e < a; e += 1)
                (o = e % 2 === 0 ? 100 : 1),
                  (c =
                    e % 2 === 0
                      ? Math.round(this.prop.v[e] * 100)
                      : this.prop.v[e]),
                  this.o[e - this.data.p * 4] !== c &&
                    ((this.o[e - this.data.p * 4] = c), (this._omdf = !s))
            this._mdf = !s
          }
        }),
        extendPrototype([DynamicPropertyContainer], GradientProperty)
      function SVGGradientFillStyleData(s, e, a) {
        this.initDynamicPropertyContainer(s),
          (this.getValue = this.iterateDynamicProperties),
          this.initGradientData(s, e, a)
      }
      ;(SVGGradientFillStyleData.prototype.initGradientData = function (
        s,
        e,
        a
      ) {
        ;(this.o = PropertyFactory.getProp(s, e.o, 0, 0.01, this)),
          (this.s = PropertyFactory.getProp(s, e.s, 1, null, this)),
          (this.e = PropertyFactory.getProp(s, e.e, 1, null, this)),
          (this.h = PropertyFactory.getProp(s, e.h || { k: 0 }, 0, 0.01, this)),
          (this.a = PropertyFactory.getProp(
            s,
            e.a || { k: 0 },
            0,
            degToRads,
            this
          )),
          (this.g = new GradientProperty(s, e.g, this)),
          (this.style = a),
          (this.stops = []),
          this.setGradientData(a.pElem, e),
          this.setGradientOpacity(e, a),
          (this._isAnimated = !!this._isAnimated)
      }),
        (SVGGradientFillStyleData.prototype.setGradientData = function (s, e) {
          var a = createElementID(),
            o = createNS(e.t === 1 ? "linearGradient" : "radialGradient")
          o.setAttribute("id", a),
            o.setAttribute("spreadMethod", "pad"),
            o.setAttribute("gradientUnits", "userSpaceOnUse")
          var c = [],
            d,
            g,
            _
          for (_ = e.g.p * 4, g = 0; g < _; g += 4)
            (d = createNS("stop")), o.appendChild(d), c.push(d)
          s.setAttribute(
            e.ty === "gf" ? "fill" : "stroke",
            "url(" + getLocationHref() + "#" + a + ")"
          ),
            (this.gf = o),
            (this.cst = c)
        }),
        (SVGGradientFillStyleData.prototype.setGradientOpacity = function (
          s,
          e
        ) {
          if (this.g._hasOpacity && !this.g._collapsable) {
            var a,
              o,
              c,
              d = createNS("mask"),
              g = createNS("path")
            d.appendChild(g)
            var _ = createElementID(),
              b = createElementID()
            d.setAttribute("id", b)
            var j = createNS(s.t === 1 ? "linearGradient" : "radialGradient")
            j.setAttribute("id", _),
              j.setAttribute("spreadMethod", "pad"),
              j.setAttribute("gradientUnits", "userSpaceOnUse"),
              (c = s.g.k.k[0].s ? s.g.k.k[0].s.length : s.g.k.k.length)
            var $ = this.stops
            for (o = s.g.p * 4; o < c; o += 2)
              (a = createNS("stop")),
                a.setAttribute("stop-color", "rgb(255,255,255)"),
                j.appendChild(a),
                $.push(a)
            g.setAttribute(
              s.ty === "gf" ? "fill" : "stroke",
              "url(" + getLocationHref() + "#" + _ + ")"
            ),
              s.ty === "gs" &&
                (g.setAttribute("stroke-linecap", lineCapEnum[s.lc || 2]),
                g.setAttribute("stroke-linejoin", lineJoinEnum[s.lj || 2]),
                s.lj === 1 && g.setAttribute("stroke-miterlimit", s.ml)),
              (this.of = j),
              (this.ms = d),
              (this.ost = $),
              (this.maskId = b),
              (e.msElem = g)
          }
        }),
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData)
      function SVGGradientStrokeStyleData(s, e, a) {
        this.initDynamicPropertyContainer(s),
          (this.getValue = this.iterateDynamicProperties),
          (this.w = PropertyFactory.getProp(s, e.w, 0, null, this)),
          (this.d = new DashProperty(s, e.d || {}, "svg", this)),
          this.initGradientData(s, e, a),
          (this._isAnimated = !!this._isAnimated)
      }
      extendPrototype(
        [SVGGradientFillStyleData, DynamicPropertyContainer],
        SVGGradientStrokeStyleData
      )
      function ShapeGroupData() {
        ;(this.it = []), (this.prevViewData = []), (this.gr = createNS("g"))
      }
      function SVGTransformData(s, e, a) {
        ;(this.transform = { mProps: s, op: e, container: a }),
          (this.elements = []),
          (this._isAnimated =
            this.transform.mProps.dynamicProperties.length ||
            this.transform.op.effectsSequence.length)
      }
      var buildShapeString = function (e, a, o, c) {
          if (a === 0) return ""
          var d = e.o,
            g = e.i,
            _ = e.v,
            b,
            j = " M" + c.applyToPointStringified(_[0][0], _[0][1])
          for (b = 1; b < a; b += 1)
            j +=
              " C" +
              c.applyToPointStringified(d[b - 1][0], d[b - 1][1]) +
              " " +
              c.applyToPointStringified(g[b][0], g[b][1]) +
              " " +
              c.applyToPointStringified(_[b][0], _[b][1])
          return (
            o &&
              a &&
              ((j +=
                " C" +
                c.applyToPointStringified(d[b - 1][0], d[b - 1][1]) +
                " " +
                c.applyToPointStringified(g[0][0], g[0][1]) +
                " " +
                c.applyToPointStringified(_[0][0], _[0][1])),
              (j += "z")),
            j
          )
        },
        SVGElementsRenderer = (function () {
          var s = new Matrix(),
            e = new Matrix(),
            a = { createRenderFunction: o }
          function o(_e) {
            switch (_e.ty) {
              case "fl":
                return _
              case "gf":
                return j
              case "gs":
                return b
              case "st":
                return $
              case "sh":
              case "el":
              case "rc":
              case "sr":
                return g
              case "tr":
                return c
              case "no":
                return d
              default:
                return null
            }
          }
          function c(_e, tt, st) {
            ;(st || tt.transform.op._mdf) &&
              tt.transform.container.setAttribute("opacity", tt.transform.op.v),
              (st || tt.transform.mProps._mdf) &&
                tt.transform.container.setAttribute(
                  "transform",
                  tt.transform.mProps.v.to2dCSS()
                )
          }
          function d() {}
          function g(_e, tt, st) {
            var at,
              ot,
              ut,
              it,
              ct,
              lt,
              ht = tt.styles.length,
              dt = tt.lvl,
              pt,
              vt,
              _t,
              yt
            for (lt = 0; lt < ht; lt += 1) {
              if (((it = tt.sh._mdf || st), tt.styles[lt].lvl < dt)) {
                for (
                  vt = e.reset(),
                    _t = dt - tt.styles[lt].lvl,
                    yt = tt.transformers.length - 1;
                  !it && _t > 0;

                )
                  (it = tt.transformers[yt].mProps._mdf || it),
                    (_t -= 1),
                    (yt -= 1)
                if (it)
                  for (
                    _t = dt - tt.styles[lt].lvl,
                      yt = tt.transformers.length - 1;
                    _t > 0;

                  )
                    vt.multiply(tt.transformers[yt].mProps.v),
                      (_t -= 1),
                      (yt -= 1)
              } else vt = s
              if (((pt = tt.sh.paths), (ot = pt._length), it)) {
                for (ut = "", at = 0; at < ot; at += 1)
                  (ct = pt.shapes[at]),
                    ct &&
                      ct._length &&
                      (ut += buildShapeString(ct, ct._length, ct.c, vt))
                tt.caches[lt] = ut
              } else ut = tt.caches[lt]
              ;(tt.styles[lt].d += _e.hd === !0 ? "" : ut),
                (tt.styles[lt]._mdf = it || tt.styles[lt]._mdf)
            }
          }
          function _(_e, tt, st) {
            var at = tt.style
            ;(tt.c._mdf || st) &&
              at.pElem.setAttribute(
                "fill",
                "rgb(" +
                  bmFloor(tt.c.v[0]) +
                  "," +
                  bmFloor(tt.c.v[1]) +
                  "," +
                  bmFloor(tt.c.v[2]) +
                  ")"
              ),
              (tt.o._mdf || st) && at.pElem.setAttribute("fill-opacity", tt.o.v)
          }
          function b(_e, tt, st) {
            j(_e, tt, st), $(_e, tt, st)
          }
          function j(_e, tt, st) {
            var at = tt.gf,
              ot = tt.g._hasOpacity,
              ut = tt.s.v,
              it = tt.e.v
            if (tt.o._mdf || st) {
              var ct = _e.ty === "gf" ? "fill-opacity" : "stroke-opacity"
              tt.style.pElem.setAttribute(ct, tt.o.v)
            }
            if (tt.s._mdf || st) {
              var lt = _e.t === 1 ? "x1" : "cx",
                ht = lt === "x1" ? "y1" : "cy"
              at.setAttribute(lt, ut[0]),
                at.setAttribute(ht, ut[1]),
                ot &&
                  !tt.g._collapsable &&
                  (tt.of.setAttribute(lt, ut[0]), tt.of.setAttribute(ht, ut[1]))
            }
            var dt, pt, vt, _t
            if (tt.g._cmdf || st) {
              dt = tt.cst
              var yt = tt.g.c
              for (vt = dt.length, pt = 0; pt < vt; pt += 1)
                (_t = dt[pt]),
                  _t.setAttribute("offset", yt[pt * 4] + "%"),
                  _t.setAttribute(
                    "stop-color",
                    "rgb(" +
                      yt[pt * 4 + 1] +
                      "," +
                      yt[pt * 4 + 2] +
                      "," +
                      yt[pt * 4 + 3] +
                      ")"
                  )
            }
            if (ot && (tt.g._omdf || st)) {
              var Et = tt.g.o
              for (
                tt.g._collapsable ? (dt = tt.cst) : (dt = tt.ost),
                  vt = dt.length,
                  pt = 0;
                pt < vt;
                pt += 1
              )
                (_t = dt[pt]),
                  tt.g._collapsable ||
                    _t.setAttribute("offset", Et[pt * 2] + "%"),
                  _t.setAttribute("stop-opacity", Et[pt * 2 + 1])
            }
            if (_e.t === 1)
              (tt.e._mdf || st) &&
                (at.setAttribute("x2", it[0]),
                at.setAttribute("y2", it[1]),
                ot &&
                  !tt.g._collapsable &&
                  (tt.of.setAttribute("x2", it[0]),
                  tt.of.setAttribute("y2", it[1])))
            else {
              var Rt
              if (
                ((tt.s._mdf || tt.e._mdf || st) &&
                  ((Rt = Math.sqrt(
                    Math.pow(ut[0] - it[0], 2) + Math.pow(ut[1] - it[1], 2)
                  )),
                  at.setAttribute("r", Rt),
                  ot && !tt.g._collapsable && tt.of.setAttribute("r", Rt)),
                tt.e._mdf || tt.h._mdf || tt.a._mdf || st)
              ) {
                Rt ||
                  (Rt = Math.sqrt(
                    Math.pow(ut[0] - it[0], 2) + Math.pow(ut[1] - it[1], 2)
                  ))
                var Ft = Math.atan2(it[1] - ut[1], it[0] - ut[0]),
                  kt = tt.h.v
                kt >= 1 ? (kt = 0.99) : kt <= -1 && (kt = -0.99)
                var Nt = Rt * kt,
                  Dt = Math.cos(Ft + tt.a.v) * Nt + ut[0],
                  Mt = Math.sin(Ft + tt.a.v) * Nt + ut[1]
                at.setAttribute("fx", Dt),
                  at.setAttribute("fy", Mt),
                  ot &&
                    !tt.g._collapsable &&
                    (tt.of.setAttribute("fx", Dt), tt.of.setAttribute("fy", Mt))
              }
            }
          }
          function $(_e, tt, st) {
            var at = tt.style,
              ot = tt.d
            ot &&
              (ot._mdf || st) &&
              ot.dashStr &&
              (at.pElem.setAttribute("stroke-dasharray", ot.dashStr),
              at.pElem.setAttribute("stroke-dashoffset", ot.dashoffset[0])),
              tt.c &&
                (tt.c._mdf || st) &&
                at.pElem.setAttribute(
                  "stroke",
                  "rgb(" +
                    bmFloor(tt.c.v[0]) +
                    "," +
                    bmFloor(tt.c.v[1]) +
                    "," +
                    bmFloor(tt.c.v[2]) +
                    ")"
                ),
              (tt.o._mdf || st) &&
                at.pElem.setAttribute("stroke-opacity", tt.o.v),
              (tt.w._mdf || st) &&
                (at.pElem.setAttribute("stroke-width", tt.w.v),
                at.msElem && at.msElem.setAttribute("stroke-width", tt.w.v))
          }
          return a
        })()
      function SVGShapeElement(s, e, a) {
        ;(this.shapes = []),
          (this.shapesData = s.shapes),
          (this.stylesList = []),
          (this.shapeModifiers = []),
          (this.itemsData = []),
          (this.processedElements = []),
          (this.animatedContents = []),
          this.initElement(s, e, a),
          (this.prevViewData = [])
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          IShapeElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        SVGShapeElement
      ),
        (SVGShapeElement.prototype.initSecondaryElement = function () {}),
        (SVGShapeElement.prototype.identityMatrix = new Matrix()),
        (SVGShapeElement.prototype.buildExpressionInterface = function () {}),
        (SVGShapeElement.prototype.createContent = function () {
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            this.layerElement,
            0,
            [],
            !0
          ),
            this.filterUniqueShapes()
        }),
        (SVGShapeElement.prototype.filterUniqueShapes = function () {
          var s,
            e = this.shapes.length,
            a,
            o,
            c = this.stylesList.length,
            d,
            g = [],
            _ = !1
          for (o = 0; o < c; o += 1) {
            for (
              d = this.stylesList[o], _ = !1, g.length = 0, s = 0;
              s < e;
              s += 1
            )
              (a = this.shapes[s]),
                a.styles.indexOf(d) !== -1 &&
                  (g.push(a), (_ = a._isAnimated || _))
            g.length > 1 && _ && this.setShapesAsAnimated(g)
          }
        }),
        (SVGShapeElement.prototype.setShapesAsAnimated = function (s) {
          var e,
            a = s.length
          for (e = 0; e < a; e += 1) s[e].setAsAnimated()
        }),
        (SVGShapeElement.prototype.createStyleElement = function (s, e) {
          var a,
            o = new SVGStyleData(s, e),
            c = o.pElem
          if (s.ty === "st") a = new SVGStrokeStyleData(this, s, o)
          else if (s.ty === "fl") a = new SVGFillStyleData(this, s, o)
          else if (s.ty === "gf" || s.ty === "gs") {
            var d =
              s.ty === "gf"
                ? SVGGradientFillStyleData
                : SVGGradientStrokeStyleData
            ;(a = new d(this, s, o)),
              this.globalData.defs.appendChild(a.gf),
              a.maskId &&
                (this.globalData.defs.appendChild(a.ms),
                this.globalData.defs.appendChild(a.of),
                c.setAttribute(
                  "mask",
                  "url(" + getLocationHref() + "#" + a.maskId + ")"
                ))
          } else s.ty === "no" && (a = new SVGNoStyleData(this, s, o))
          return (
            (s.ty === "st" || s.ty === "gs") &&
              (c.setAttribute("stroke-linecap", lineCapEnum[s.lc || 2]),
              c.setAttribute("stroke-linejoin", lineJoinEnum[s.lj || 2]),
              c.setAttribute("fill-opacity", "0"),
              s.lj === 1 && c.setAttribute("stroke-miterlimit", s.ml)),
            s.r === 2 && c.setAttribute("fill-rule", "evenodd"),
            s.ln && c.setAttribute("id", s.ln),
            s.cl && c.setAttribute("class", s.cl),
            s.bm && (c.style["mix-blend-mode"] = getBlendMode(s.bm)),
            this.stylesList.push(o),
            this.addToAnimatedContents(s, a),
            a
          )
        }),
        (SVGShapeElement.prototype.createGroupElement = function (s) {
          var e = new ShapeGroupData()
          return (
            s.ln && e.gr.setAttribute("id", s.ln),
            s.cl && e.gr.setAttribute("class", s.cl),
            s.bm && (e.gr.style["mix-blend-mode"] = getBlendMode(s.bm)),
            e
          )
        }),
        (SVGShapeElement.prototype.createTransformElement = function (s, e) {
          var a = TransformPropertyFactory.getTransformProperty(this, s, this),
            o = new SVGTransformData(a, a.o, e)
          return this.addToAnimatedContents(s, o), o
        }),
        (SVGShapeElement.prototype.createShapeElement = function (s, e, a) {
          var o = 4
          s.ty === "rc"
            ? (o = 5)
            : s.ty === "el"
            ? (o = 6)
            : s.ty === "sr" && (o = 7)
          var c = ShapePropertyFactory.getShapeProp(this, s, o, this),
            d = new SVGShapeData(e, a, c)
          return (
            this.shapes.push(d),
            this.addShapeToModifiers(d),
            this.addToAnimatedContents(s, d),
            d
          )
        }),
        (SVGShapeElement.prototype.addToAnimatedContents = function (s, e) {
          for (var a = 0, o = this.animatedContents.length; a < o; ) {
            if (this.animatedContents[a].element === e) return
            a += 1
          }
          this.animatedContents.push({
            fn: SVGElementsRenderer.createRenderFunction(s),
            element: e,
            data: s,
          })
        }),
        (SVGShapeElement.prototype.setElementStyles = function (s) {
          var e = s.styles,
            a,
            o = this.stylesList.length
          for (a = 0; a < o; a += 1)
            this.stylesList[a].closed || e.push(this.stylesList[a])
        }),
        (SVGShapeElement.prototype.reloadShapes = function () {
          this._isFirstFrame = !0
          var s,
            e = this.itemsData.length
          for (s = 0; s < e; s += 1) this.prevViewData[s] = this.itemsData[s]
          for (
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              this.layerElement,
              0,
              [],
              !0
            ),
              this.filterUniqueShapes(),
              e = this.dynamicProperties.length,
              s = 0;
            s < e;
            s += 1
          )
            this.dynamicProperties[s].getValue()
          this.renderModifiers()
        }),
        (SVGShapeElement.prototype.searchShapes = function (
          s,
          e,
          a,
          o,
          c,
          d,
          g
        ) {
          var _ = [].concat(d),
            b,
            j = s.length - 1,
            $,
            _e,
            tt = [],
            st = [],
            at,
            ot,
            ut
          for (b = j; b >= 0; b -= 1) {
            if (
              ((ut = this.searchProcessedElement(s[b])),
              ut ? (e[b] = a[ut - 1]) : (s[b]._render = g),
              s[b].ty === "fl" ||
                s[b].ty === "st" ||
                s[b].ty === "gf" ||
                s[b].ty === "gs" ||
                s[b].ty === "no")
            )
              ut
                ? (e[b].style.closed = !1)
                : (e[b] = this.createStyleElement(s[b], c)),
                s[b]._render &&
                  e[b].style.pElem.parentNode !== o &&
                  o.appendChild(e[b].style.pElem),
                tt.push(e[b].style)
            else if (s[b].ty === "gr") {
              if (!ut) e[b] = this.createGroupElement(s[b])
              else
                for (_e = e[b].it.length, $ = 0; $ < _e; $ += 1)
                  e[b].prevViewData[$] = e[b].it[$]
              this.searchShapes(
                s[b].it,
                e[b].it,
                e[b].prevViewData,
                e[b].gr,
                c + 1,
                _,
                g
              ),
                s[b]._render &&
                  e[b].gr.parentNode !== o &&
                  o.appendChild(e[b].gr)
            } else
              s[b].ty === "tr"
                ? (ut || (e[b] = this.createTransformElement(s[b], o)),
                  (at = e[b].transform),
                  _.push(at))
                : s[b].ty === "sh" ||
                  s[b].ty === "rc" ||
                  s[b].ty === "el" ||
                  s[b].ty === "sr"
                ? (ut || (e[b] = this.createShapeElement(s[b], _, c)),
                  this.setElementStyles(e[b]))
                : s[b].ty === "tm" ||
                  s[b].ty === "rd" ||
                  s[b].ty === "ms" ||
                  s[b].ty === "pb" ||
                  s[b].ty === "zz" ||
                  s[b].ty === "op"
                ? (ut
                    ? ((ot = e[b]), (ot.closed = !1))
                    : ((ot = ShapeModifiers.getModifier(s[b].ty)),
                      ot.init(this, s[b]),
                      (e[b] = ot),
                      this.shapeModifiers.push(ot)),
                  st.push(ot))
                : s[b].ty === "rp" &&
                  (ut
                    ? ((ot = e[b]), (ot.closed = !0))
                    : ((ot = ShapeModifiers.getModifier(s[b].ty)),
                      (e[b] = ot),
                      ot.init(this, s, b, e),
                      this.shapeModifiers.push(ot),
                      (g = !1)),
                  st.push(ot))
            this.addProcessedElement(s[b], b + 1)
          }
          for (j = tt.length, b = 0; b < j; b += 1) tt[b].closed = !0
          for (j = st.length, b = 0; b < j; b += 1) st[b].closed = !0
        }),
        (SVGShapeElement.prototype.renderInnerContent = function () {
          this.renderModifiers()
          var s,
            e = this.stylesList.length
          for (s = 0; s < e; s += 1) this.stylesList[s].reset()
          for (this.renderShape(), s = 0; s < e; s += 1)
            (this.stylesList[s]._mdf || this._isFirstFrame) &&
              (this.stylesList[s].msElem &&
                (this.stylesList[s].msElem.setAttribute(
                  "d",
                  this.stylesList[s].d
                ),
                (this.stylesList[s].d = "M0 0" + this.stylesList[s].d)),
              this.stylesList[s].pElem.setAttribute(
                "d",
                this.stylesList[s].d || "M0 0"
              ))
        }),
        (SVGShapeElement.prototype.renderShape = function () {
          var s,
            e = this.animatedContents.length,
            a
          for (s = 0; s < e; s += 1)
            (a = this.animatedContents[s]),
              (this._isFirstFrame || a.element._isAnimated) &&
                a.data !== !0 &&
                a.fn(a.data, a.element, this._isFirstFrame)
        }),
        (SVGShapeElement.prototype.destroy = function () {
          this.destroyBaseElement(),
            (this.shapesData = null),
            (this.itemsData = null)
        })
      function LetterProps(s, e, a, o, c, d) {
        ;(this.o = s),
          (this.sw = e),
          (this.sc = a),
          (this.fc = o),
          (this.m = c),
          (this.p = d),
          (this._mdf = { o: !0, sw: !!e, sc: !!a, fc: !!o, m: !0, p: !0 })
      }
      LetterProps.prototype.update = function (s, e, a, o, c, d) {
        ;(this._mdf.o = !1),
          (this._mdf.sw = !1),
          (this._mdf.sc = !1),
          (this._mdf.fc = !1),
          (this._mdf.m = !1),
          (this._mdf.p = !1)
        var g = !1
        return (
          this.o !== s && ((this.o = s), (this._mdf.o = !0), (g = !0)),
          this.sw !== e && ((this.sw = e), (this._mdf.sw = !0), (g = !0)),
          this.sc !== a && ((this.sc = a), (this._mdf.sc = !0), (g = !0)),
          this.fc !== o && ((this.fc = o), (this._mdf.fc = !0), (g = !0)),
          this.m !== c && ((this.m = c), (this._mdf.m = !0), (g = !0)),
          d.length &&
            (this.p[0] !== d[0] ||
              this.p[1] !== d[1] ||
              this.p[4] !== d[4] ||
              this.p[5] !== d[5] ||
              this.p[12] !== d[12] ||
              this.p[13] !== d[13]) &&
            ((this.p = d), (this._mdf.p = !0), (g = !0)),
          g
        )
      }
      function TextProperty(s, e) {
        ;(this._frameId = initialDefaultFrame),
          (this.pv = ""),
          (this.v = ""),
          (this.kf = !1),
          (this._isFirstFrame = !0),
          (this._mdf = !1),
          e.d && e.d.sid && (e.d = s.globalData.slotManager.getProp(e.d)),
          (this.data = e),
          (this.elem = s),
          (this.comp = this.elem.comp),
          (this.keysIndex = 0),
          (this.canResize = !1),
          (this.minimumFontSize = 1),
          (this.effectsSequence = []),
          (this.currentData = {
            ascent: 0,
            boxWidth: this.defaultBoxWidth,
            f: "",
            fStyle: "",
            fWeight: "",
            fc: "",
            j: "",
            justifyOffset: "",
            l: [],
            lh: 0,
            lineWidths: [],
            ls: "",
            of: "",
            s: "",
            sc: "",
            sw: 0,
            t: 0,
            tr: 0,
            sz: 0,
            ps: null,
            fillColorAnim: !1,
            strokeColorAnim: !1,
            strokeWidthAnim: !1,
            yOffset: 0,
            finalSize: 0,
            finalText: [],
            finalLineHeight: 0,
            __complete: !1,
          }),
          this.copyData(this.currentData, this.data.d.k[0].s),
          this.searchProperty() || this.completeTextData(this.currentData)
      }
      ;(TextProperty.prototype.defaultBoxWidth = [0, 0]),
        (TextProperty.prototype.copyData = function (s, e) {
          for (var a in e)
            Object.prototype.hasOwnProperty.call(e, a) && (s[a] = e[a])
          return s
        }),
        (TextProperty.prototype.setCurrentData = function (s) {
          s.__complete || this.completeTextData(s),
            (this.currentData = s),
            (this.currentData.boxWidth =
              this.currentData.boxWidth || this.defaultBoxWidth),
            (this._mdf = !0)
        }),
        (TextProperty.prototype.searchProperty = function () {
          return this.searchKeyframes()
        }),
        (TextProperty.prototype.searchKeyframes = function () {
          return (
            (this.kf = this.data.d.k.length > 1),
            this.kf && this.addEffect(this.getKeyframeValue.bind(this)),
            this.kf
          )
        }),
        (TextProperty.prototype.addEffect = function (s) {
          this.effectsSequence.push(s), this.elem.addDynamicProperty(this)
        }),
        (TextProperty.prototype.getValue = function (s) {
          if (
            !(
              (this.elem.globalData.frameId === this.frameId ||
                !this.effectsSequence.length) &&
              !s
            )
          ) {
            this.currentData.t = this.data.d.k[this.keysIndex].s.t
            var e = this.currentData,
              a = this.keysIndex
            if (this.lock) {
              this.setCurrentData(this.currentData)
              return
            }
            ;(this.lock = !0), (this._mdf = !1)
            var o,
              c = this.effectsSequence.length,
              d = s || this.data.d.k[this.keysIndex].s
            for (o = 0; o < c; o += 1)
              a !== this.keysIndex
                ? (d = this.effectsSequence[o](d, d.t))
                : (d = this.effectsSequence[o](this.currentData, d.t))
            e !== d && this.setCurrentData(d),
              (this.v = this.currentData),
              (this.pv = this.v),
              (this.lock = !1),
              (this.frameId = this.elem.globalData.frameId)
          }
        }),
        (TextProperty.prototype.getKeyframeValue = function () {
          for (
            var s = this.data.d.k,
              e = this.elem.comp.renderedFrame,
              a = 0,
              o = s.length;
            a <= o - 1 && !(a === o - 1 || s[a + 1].t > e);

          )
            a += 1
          return (
            this.keysIndex !== a && (this.keysIndex = a),
            this.data.d.k[this.keysIndex].s
          )
        }),
        (TextProperty.prototype.buildFinalText = function (s) {
          for (
            var e = [], a = 0, o = s.length, c, d, g = !1, _ = !1, b = "";
            a < o;

          )
            (g = _),
              (_ = !1),
              (c = s.charCodeAt(a)),
              (b = s.charAt(a)),
              FontManager.isCombinedCharacter(c)
                ? (g = !0)
                : c >= 55296 && c <= 56319
                ? FontManager.isRegionalFlag(s, a)
                  ? (b = s.substr(a, 14))
                  : ((d = s.charCodeAt(a + 1)),
                    d >= 56320 &&
                      d <= 57343 &&
                      (FontManager.isModifier(c, d)
                        ? ((b = s.substr(a, 2)), (g = !0))
                        : FontManager.isFlagEmoji(s.substr(a, 4))
                        ? (b = s.substr(a, 4))
                        : (b = s.substr(a, 2))))
                : c > 56319
                ? ((d = s.charCodeAt(a + 1)),
                  FontManager.isVariationSelector(c) && (g = !0))
                : FontManager.isZeroWidthJoiner(c) && ((g = !0), (_ = !0)),
              g ? ((e[e.length - 1] += b), (g = !1)) : e.push(b),
              (a += b.length)
          return e
        }),
        (TextProperty.prototype.completeTextData = function (s) {
          s.__complete = !0
          var e = this.elem.globalData.fontManager,
            a = this.data,
            o = [],
            c,
            d,
            g,
            _ = 0,
            b,
            j = a.m.g,
            $ = 0,
            _e = 0,
            tt = 0,
            st = [],
            at = 0,
            ot = 0,
            ut,
            it,
            ct = e.getFontByName(s.f),
            lt,
            ht = 0,
            dt = getFontProperties(ct)
          ;(s.fWeight = dt.weight),
            (s.fStyle = dt.style),
            (s.finalSize = s.s),
            (s.finalText = this.buildFinalText(s.t)),
            (d = s.finalText.length),
            (s.finalLineHeight = s.lh)
          var pt = (s.tr / 1e3) * s.finalSize,
            vt
          if (s.sz)
            for (var _t = !0, yt = s.sz[0], Et = s.sz[1], Rt, Ft; _t; ) {
              ;(Ft = this.buildFinalText(s.t)),
                (Rt = 0),
                (at = 0),
                (d = Ft.length),
                (pt = (s.tr / 1e3) * s.finalSize)
              var kt = -1
              for (c = 0; c < d; c += 1)
                (vt = Ft[c].charCodeAt(0)),
                  (g = !1),
                  Ft[c] === " "
                    ? (kt = c)
                    : (vt === 13 || vt === 3) &&
                      ((at = 0),
                      (g = !0),
                      (Rt += s.finalLineHeight || s.finalSize * 1.2)),
                  e.chars
                    ? ((lt = e.getCharData(Ft[c], ct.fStyle, ct.fFamily)),
                      (ht = g ? 0 : (lt.w * s.finalSize) / 100))
                    : (ht = e.measureText(Ft[c], s.f, s.finalSize)),
                  at + ht > yt && Ft[c] !== " "
                    ? (kt === -1 ? (d += 1) : (c = kt),
                      (Rt += s.finalLineHeight || s.finalSize * 1.2),
                      Ft.splice(c, kt === c ? 1 : 0, "\r"),
                      (kt = -1),
                      (at = 0))
                    : ((at += ht), (at += pt))
              ;(Rt += (ct.ascent * s.finalSize) / 100),
                this.canResize && s.finalSize > this.minimumFontSize && Et < Rt
                  ? ((s.finalSize -= 1),
                    (s.finalLineHeight = (s.finalSize * s.lh) / s.s))
                  : ((s.finalText = Ft), (d = s.finalText.length), (_t = !1))
            }
          ;(at = -pt), (ht = 0)
          var Nt = 0,
            Dt
          for (c = 0; c < d; c += 1)
            if (
              ((g = !1),
              (Dt = s.finalText[c]),
              (vt = Dt.charCodeAt(0)),
              vt === 13 || vt === 3
                ? ((Nt = 0),
                  st.push(at),
                  (ot = at > ot ? at : ot),
                  (at = -2 * pt),
                  (b = ""),
                  (g = !0),
                  (tt += 1))
                : (b = Dt),
              e.chars
                ? ((lt = e.getCharData(
                    Dt,
                    ct.fStyle,
                    e.getFontByName(s.f).fFamily
                  )),
                  (ht = g ? 0 : (lt.w * s.finalSize) / 100))
                : (ht = e.measureText(b, s.f, s.finalSize)),
              Dt === " " ? (Nt += ht + pt) : ((at += ht + pt + Nt), (Nt = 0)),
              o.push({
                l: ht,
                an: ht,
                add: $,
                n: g,
                anIndexes: [],
                val: b,
                line: tt,
                animatorJustifyOffset: 0,
              }),
              j == 2)
            ) {
              if ((($ += ht), b === "" || b === " " || c === d - 1)) {
                for ((b === "" || b === " ") && ($ -= ht); _e <= c; )
                  (o[_e].an = $), (o[_e].ind = _), (o[_e].extra = ht), (_e += 1)
                ;(_ += 1), ($ = 0)
              }
            } else if (j == 3) {
              if ((($ += ht), b === "" || c === d - 1)) {
                for (b === "" && ($ -= ht); _e <= c; )
                  (o[_e].an = $), (o[_e].ind = _), (o[_e].extra = ht), (_e += 1)
                ;($ = 0), (_ += 1)
              }
            } else (o[_].ind = _), (o[_].extra = 0), (_ += 1)
          if (((s.l = o), (ot = at > ot ? at : ot), st.push(at), s.sz))
            (s.boxWidth = s.sz[0]), (s.justifyOffset = 0)
          else
            switch (((s.boxWidth = ot), s.j)) {
              case 1:
                s.justifyOffset = -s.boxWidth
                break
              case 2:
                s.justifyOffset = -s.boxWidth / 2
                break
              default:
                s.justifyOffset = 0
            }
          s.lineWidths = st
          var Mt = a.a,
            wt,
            gt
          it = Mt.length
          var At,
            bt,
            Tt = []
          for (ut = 0; ut < it; ut += 1) {
            for (
              wt = Mt[ut],
                wt.a.sc && (s.strokeColorAnim = !0),
                wt.a.sw && (s.strokeWidthAnim = !0),
                (wt.a.fc || wt.a.fh || wt.a.fs || wt.a.fb) &&
                  (s.fillColorAnim = !0),
                bt = 0,
                At = wt.s.b,
                c = 0;
              c < d;
              c += 1
            )
              (gt = o[c]),
                (gt.anIndexes[ut] = bt),
                ((At == 1 && gt.val !== "") ||
                  (At == 2 && gt.val !== "" && gt.val !== " ") ||
                  (At == 3 && (gt.n || gt.val == " " || c == d - 1)) ||
                  (At == 4 && (gt.n || c == d - 1))) &&
                  (wt.s.rn === 1 && Tt.push(bt), (bt += 1))
            a.a[ut].s.totalChars = bt
            var It = -1,
              $t
            if (wt.s.rn === 1)
              for (c = 0; c < d; c += 1)
                (gt = o[c]),
                  It != gt.anIndexes[ut] &&
                    ((It = gt.anIndexes[ut]),
                    ($t = Tt.splice(
                      Math.floor(Math.random() * Tt.length),
                      1
                    )[0])),
                  (gt.anIndexes[ut] = $t)
          }
          ;(s.yOffset = s.finalLineHeight || s.finalSize * 1.2),
            (s.ls = s.ls || 0),
            (s.ascent = (ct.ascent * s.finalSize) / 100)
        }),
        (TextProperty.prototype.updateDocumentData = function (s, e) {
          e = e === void 0 ? this.keysIndex : e
          var a = this.copyData({}, this.data.d.k[e].s)
          ;(a = this.copyData(a, s)),
            (this.data.d.k[e].s = a),
            this.recalculate(e),
            this.setCurrentData(a),
            this.elem.addDynamicProperty(this)
        }),
        (TextProperty.prototype.recalculate = function (s) {
          var e = this.data.d.k[s].s
          ;(e.__complete = !1),
            (this.keysIndex = 0),
            (this._isFirstFrame = !0),
            this.getValue(e)
        }),
        (TextProperty.prototype.canResizeFont = function (s) {
          ;(this.canResize = s),
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this)
        }),
        (TextProperty.prototype.setMinimumFontSize = function (s) {
          ;(this.minimumFontSize = Math.floor(s) || 1),
            this.recalculate(this.keysIndex),
            this.elem.addDynamicProperty(this)
        })
      var TextSelectorProp = (function () {
        var s = Math.max,
          e = Math.min,
          a = Math.floor
        function o(d, g) {
          ;(this._currentTextLength = -1),
            (this.k = !1),
            (this.data = g),
            (this.elem = d),
            (this.comp = d.comp),
            (this.finalS = 0),
            (this.finalE = 0),
            this.initDynamicPropertyContainer(d),
            (this.s = PropertyFactory.getProp(d, g.s || { k: 0 }, 0, 0, this)),
            "e" in g
              ? (this.e = PropertyFactory.getProp(d, g.e, 0, 0, this))
              : (this.e = { v: 100 }),
            (this.o = PropertyFactory.getProp(d, g.o || { k: 0 }, 0, 0, this)),
            (this.xe = PropertyFactory.getProp(
              d,
              g.xe || { k: 0 },
              0,
              0,
              this
            )),
            (this.ne = PropertyFactory.getProp(
              d,
              g.ne || { k: 0 },
              0,
              0,
              this
            )),
            (this.sm = PropertyFactory.getProp(
              d,
              g.sm || { k: 100 },
              0,
              0,
              this
            )),
            (this.a = PropertyFactory.getProp(d, g.a, 0, 0.01, this)),
            this.dynamicProperties.length || this.getValue()
        }
        ;(o.prototype = {
          getMult: function (g) {
            this._currentTextLength !==
              this.elem.textProperty.currentData.l.length && this.getValue()
            var _ = 0,
              b = 0,
              j = 1,
              $ = 1
            this.ne.v > 0 ? (_ = this.ne.v / 100) : (b = -this.ne.v / 100),
              this.xe.v > 0
                ? (j = 1 - this.xe.v / 100)
                : ($ = 1 + this.xe.v / 100)
            var _e = BezierFactory.getBezierEasing(_, b, j, $).get,
              tt = 0,
              st = this.finalS,
              at = this.finalE,
              ot = this.data.sh
            if (ot === 2)
              at === st
                ? (tt = g >= at ? 1 : 0)
                : (tt = s(0, e(0.5 / (at - st) + (g - st) / (at - st), 1))),
                (tt = _e(tt))
            else if (ot === 3)
              at === st
                ? (tt = g >= at ? 0 : 1)
                : (tt = 1 - s(0, e(0.5 / (at - st) + (g - st) / (at - st), 1))),
                (tt = _e(tt))
            else if (ot === 4)
              at === st
                ? (tt = 0)
                : ((tt = s(0, e(0.5 / (at - st) + (g - st) / (at - st), 1))),
                  tt < 0.5 ? (tt *= 2) : (tt = 1 - 2 * (tt - 0.5))),
                (tt = _e(tt))
            else if (ot === 5) {
              if (at === st) tt = 0
              else {
                var ut = at - st
                g = e(s(0, g + 0.5 - st), at - st)
                var it = -ut / 2 + g,
                  ct = ut / 2
                tt = Math.sqrt(1 - (it * it) / (ct * ct))
              }
              tt = _e(tt)
            } else
              ot === 6
                ? (at === st
                    ? (tt = 0)
                    : ((g = e(s(0, g + 0.5 - st), at - st)),
                      (tt =
                        (1 +
                          Math.cos(Math.PI + (Math.PI * 2 * g) / (at - st))) /
                        2)),
                  (tt = _e(tt)))
                : (g >= a(st) &&
                    (g - st < 0
                      ? (tt = s(0, e(e(at, 1) - (st - g), 1)))
                      : (tt = s(0, e(at - g, 1)))),
                  (tt = _e(tt)))
            if (this.sm.v !== 100) {
              var lt = this.sm.v * 0.01
              lt === 0 && (lt = 1e-8)
              var ht = 0.5 - lt * 0.5
              tt < ht ? (tt = 0) : ((tt = (tt - ht) / lt), tt > 1 && (tt = 1))
            }
            return tt * this.a.v
          },
          getValue: function (g) {
            this.iterateDynamicProperties(),
              (this._mdf = g || this._mdf),
              (this._currentTextLength =
                this.elem.textProperty.currentData.l.length || 0),
              g && this.data.r === 2 && (this.e.v = this._currentTextLength)
            var _ = this.data.r === 2 ? 1 : 100 / this.data.totalChars,
              b = this.o.v / _,
              j = this.s.v / _ + b,
              $ = this.e.v / _ + b
            if (j > $) {
              var _e = j
              ;(j = $), ($ = _e)
            }
            ;(this.finalS = j), (this.finalE = $)
          },
        }),
          extendPrototype([DynamicPropertyContainer], o)
        function c(d, g, _) {
          return new o(d, g)
        }
        return { getTextSelectorProp: c }
      })()
      function TextAnimatorDataProperty(s, e, a) {
        var o = { propType: !1 },
          c = PropertyFactory.getProp,
          d = e.a
        ;(this.a = {
          r: d.r ? c(s, d.r, 0, degToRads, a) : o,
          rx: d.rx ? c(s, d.rx, 0, degToRads, a) : o,
          ry: d.ry ? c(s, d.ry, 0, degToRads, a) : o,
          sk: d.sk ? c(s, d.sk, 0, degToRads, a) : o,
          sa: d.sa ? c(s, d.sa, 0, degToRads, a) : o,
          s: d.s ? c(s, d.s, 1, 0.01, a) : o,
          a: d.a ? c(s, d.a, 1, 0, a) : o,
          o: d.o ? c(s, d.o, 0, 0.01, a) : o,
          p: d.p ? c(s, d.p, 1, 0, a) : o,
          sw: d.sw ? c(s, d.sw, 0, 0, a) : o,
          sc: d.sc ? c(s, d.sc, 1, 0, a) : o,
          fc: d.fc ? c(s, d.fc, 1, 0, a) : o,
          fh: d.fh ? c(s, d.fh, 0, 0, a) : o,
          fs: d.fs ? c(s, d.fs, 0, 0.01, a) : o,
          fb: d.fb ? c(s, d.fb, 0, 0.01, a) : o,
          t: d.t ? c(s, d.t, 0, 0, a) : o,
        }),
          (this.s = TextSelectorProp.getTextSelectorProp(s, e.s, a)),
          (this.s.t = e.s.t)
      }
      function TextAnimatorProperty(s, e, a) {
        ;(this._isFirstFrame = !0),
          (this._hasMaskedPath = !1),
          (this._frameId = -1),
          (this._textData = s),
          (this._renderType = e),
          (this._elem = a),
          (this._animatorsData = createSizedArray(this._textData.a.length)),
          (this._pathData = {}),
          (this._moreOptions = { alignment: {} }),
          (this.renderedLetters = []),
          (this.lettersChangedFlag = !1),
          this.initDynamicPropertyContainer(a)
      }
      ;(TextAnimatorProperty.prototype.searchProperties = function () {
        var s,
          e = this._textData.a.length,
          a,
          o = PropertyFactory.getProp
        for (s = 0; s < e; s += 1)
          (a = this._textData.a[s]),
            (this._animatorsData[s] = new TextAnimatorDataProperty(
              this._elem,
              a,
              this
            ))
        this._textData.p && "m" in this._textData.p
          ? ((this._pathData = {
              a: o(this._elem, this._textData.p.a, 0, 0, this),
              f: o(this._elem, this._textData.p.f, 0, 0, this),
              l: o(this._elem, this._textData.p.l, 0, 0, this),
              r: o(this._elem, this._textData.p.r, 0, 0, this),
              p: o(this._elem, this._textData.p.p, 0, 0, this),
              m: this._elem.maskManager.getMaskProperty(this._textData.p.m),
            }),
            (this._hasMaskedPath = !0))
          : (this._hasMaskedPath = !1),
          (this._moreOptions.alignment = o(
            this._elem,
            this._textData.m.a,
            1,
            0,
            this
          ))
      }),
        (TextAnimatorProperty.prototype.getMeasures = function (s, e) {
          if (
            ((this.lettersChangedFlag = e),
            !(
              !this._mdf &&
              !this._isFirstFrame &&
              !e &&
              (!this._hasMaskedPath || !this._pathData.m._mdf)
            ))
          ) {
            this._isFirstFrame = !1
            var a = this._moreOptions.alignment.v,
              o = this._animatorsData,
              c = this._textData,
              d = this.mHelper,
              g = this._renderType,
              _ = this.renderedLetters.length,
              b,
              j,
              $,
              _e,
              tt = s.l,
              st,
              at,
              ot,
              ut,
              it,
              ct,
              lt,
              ht,
              dt,
              pt,
              vt,
              _t,
              yt,
              Et,
              Rt
            if (this._hasMaskedPath) {
              if (
                ((Rt = this._pathData.m),
                !this._pathData.n || this._pathData._mdf)
              ) {
                var Ft = Rt.v
                this._pathData.r.v && (Ft = Ft.reverse()),
                  (st = { tLength: 0, segments: [] }),
                  (_e = Ft._length - 1)
                var kt
                for (_t = 0, $ = 0; $ < _e; $ += 1)
                  (kt = bez.buildBezierData(
                    Ft.v[$],
                    Ft.v[$ + 1],
                    [Ft.o[$][0] - Ft.v[$][0], Ft.o[$][1] - Ft.v[$][1]],
                    [
                      Ft.i[$ + 1][0] - Ft.v[$ + 1][0],
                      Ft.i[$ + 1][1] - Ft.v[$ + 1][1],
                    ]
                  )),
                    (st.tLength += kt.segmentLength),
                    st.segments.push(kt),
                    (_t += kt.segmentLength)
                ;($ = _e),
                  Rt.v.c &&
                    ((kt = bez.buildBezierData(
                      Ft.v[$],
                      Ft.v[0],
                      [Ft.o[$][0] - Ft.v[$][0], Ft.o[$][1] - Ft.v[$][1]],
                      [Ft.i[0][0] - Ft.v[0][0], Ft.i[0][1] - Ft.v[0][1]]
                    )),
                    (st.tLength += kt.segmentLength),
                    st.segments.push(kt),
                    (_t += kt.segmentLength)),
                  (this._pathData.pi = st)
              }
              if (
                ((st = this._pathData.pi),
                (at = this._pathData.f.v),
                (lt = 0),
                (ct = 1),
                (ut = 0),
                (it = !0),
                (pt = st.segments),
                at < 0 && Rt.v.c)
              )
                for (
                  st.tLength < Math.abs(at) &&
                    (at = -Math.abs(at) % st.tLength),
                    lt = pt.length - 1,
                    dt = pt[lt].points,
                    ct = dt.length - 1;
                  at < 0;

                )
                  (at += dt[ct].partialLength),
                    (ct -= 1),
                    ct < 0 &&
                      ((lt -= 1), (dt = pt[lt].points), (ct = dt.length - 1))
              ;(dt = pt[lt].points),
                (ht = dt[ct - 1]),
                (ot = dt[ct]),
                (vt = ot.partialLength)
            }
            ;(_e = tt.length), (b = 0), (j = 0)
            var Nt = s.finalSize * 1.2 * 0.714,
              Dt = !0,
              Mt,
              wt,
              gt,
              At,
              bt
            At = o.length
            var Tt,
              It = -1,
              $t,
              Xt,
              qt,
              en = at,
              yn = lt,
              Tn = ct,
              $n = -1,
              Vn,
              gn,
              Ht,
              on,
              Yt,
              _n,
              pn,
              Rn,
              bn = "",
              Pn = this.defaultPropsArray,
              Gn
            if (s.j === 2 || s.j === 1) {
              var jn = 0,
                ar = 0,
                Vt = s.j === 2 ? -0.5 : -1,
                Lt = 0,
                Zt = !0
              for ($ = 0; $ < _e; $ += 1)
                if (tt[$].n) {
                  for (jn && (jn += ar); Lt < $; )
                    (tt[Lt].animatorJustifyOffset = jn), (Lt += 1)
                  ;(jn = 0), (Zt = !0)
                } else {
                  for (gt = 0; gt < At; gt += 1)
                    (Mt = o[gt].a),
                      Mt.t.propType &&
                        (Zt && s.j === 2 && (ar += Mt.t.v * Vt),
                        (wt = o[gt].s),
                        (Tt = wt.getMult(
                          tt[$].anIndexes[gt],
                          c.a[gt].s.totalChars
                        )),
                        Tt.length
                          ? (jn += Mt.t.v * Tt[0] * Vt)
                          : (jn += Mt.t.v * Tt * Vt))
                  Zt = !1
                }
              for (jn && (jn += ar); Lt < $; )
                (tt[Lt].animatorJustifyOffset = jn), (Lt += 1)
            }
            for ($ = 0; $ < _e; $ += 1) {
              if ((d.reset(), (Vn = 1), tt[$].n))
                (b = 0),
                  (j += s.yOffset),
                  (j += Dt ? 1 : 0),
                  (at = en),
                  (Dt = !1),
                  this._hasMaskedPath &&
                    ((lt = yn),
                    (ct = Tn),
                    (dt = pt[lt].points),
                    (ht = dt[ct - 1]),
                    (ot = dt[ct]),
                    (vt = ot.partialLength),
                    (ut = 0)),
                  (bn = ""),
                  (Rn = ""),
                  (_n = ""),
                  (Gn = ""),
                  (Pn = this.defaultPropsArray)
              else {
                if (this._hasMaskedPath) {
                  if ($n !== tt[$].line) {
                    switch (s.j) {
                      case 1:
                        at += _t - s.lineWidths[tt[$].line]
                        break
                      case 2:
                        at += (_t - s.lineWidths[tt[$].line]) / 2
                        break
                    }
                    $n = tt[$].line
                  }
                  It !== tt[$].ind &&
                    (tt[It] && (at += tt[It].extra),
                    (at += tt[$].an / 2),
                    (It = tt[$].ind)),
                    (at += a[0] * tt[$].an * 0.005)
                  var xn = 0
                  for (gt = 0; gt < At; gt += 1)
                    (Mt = o[gt].a),
                      Mt.p.propType &&
                        ((wt = o[gt].s),
                        (Tt = wt.getMult(
                          tt[$].anIndexes[gt],
                          c.a[gt].s.totalChars
                        )),
                        Tt.length
                          ? (xn += Mt.p.v[0] * Tt[0])
                          : (xn += Mt.p.v[0] * Tt)),
                      Mt.a.propType &&
                        ((wt = o[gt].s),
                        (Tt = wt.getMult(
                          tt[$].anIndexes[gt],
                          c.a[gt].s.totalChars
                        )),
                        Tt.length
                          ? (xn += Mt.a.v[0] * Tt[0])
                          : (xn += Mt.a.v[0] * Tt))
                  for (
                    it = !0,
                      this._pathData.a.v &&
                        ((at =
                          tt[0].an * 0.5 +
                          ((_t -
                            this._pathData.f.v -
                            tt[0].an * 0.5 -
                            tt[tt.length - 1].an * 0.5) *
                            It) /
                            (_e - 1)),
                        (at += this._pathData.f.v));
                    it;

                  )
                    ut + vt >= at + xn || !dt
                      ? ((yt = (at + xn - ut) / ot.partialLength),
                        (Xt = ht.point[0] + (ot.point[0] - ht.point[0]) * yt),
                        (qt = ht.point[1] + (ot.point[1] - ht.point[1]) * yt),
                        d.translate(
                          -a[0] * tt[$].an * 0.005,
                          -(a[1] * Nt) * 0.01
                        ),
                        (it = !1))
                      : dt &&
                        ((ut += ot.partialLength),
                        (ct += 1),
                        ct >= dt.length &&
                          ((ct = 0),
                          (lt += 1),
                          pt[lt]
                            ? (dt = pt[lt].points)
                            : Rt.v.c
                            ? ((ct = 0), (lt = 0), (dt = pt[lt].points))
                            : ((ut -= ot.partialLength), (dt = null))),
                        dt &&
                          ((ht = ot), (ot = dt[ct]), (vt = ot.partialLength)))
                  ;($t = tt[$].an / 2 - tt[$].add), d.translate(-$t, 0, 0)
                } else
                  ($t = tt[$].an / 2 - tt[$].add),
                    d.translate(-$t, 0, 0),
                    d.translate(-a[0] * tt[$].an * 0.005, -a[1] * Nt * 0.01, 0)
                for (gt = 0; gt < At; gt += 1)
                  (Mt = o[gt].a),
                    Mt.t.propType &&
                      ((wt = o[gt].s),
                      (Tt = wt.getMult(
                        tt[$].anIndexes[gt],
                        c.a[gt].s.totalChars
                      )),
                      (b !== 0 || s.j !== 0) &&
                        (this._hasMaskedPath
                          ? Tt.length
                            ? (at += Mt.t.v * Tt[0])
                            : (at += Mt.t.v * Tt)
                          : Tt.length
                          ? (b += Mt.t.v * Tt[0])
                          : (b += Mt.t.v * Tt)))
                for (
                  s.strokeWidthAnim && (Ht = s.sw || 0),
                    s.strokeColorAnim &&
                      (s.sc
                        ? (gn = [s.sc[0], s.sc[1], s.sc[2]])
                        : (gn = [0, 0, 0])),
                    s.fillColorAnim &&
                      s.fc &&
                      (on = [s.fc[0], s.fc[1], s.fc[2]]),
                    gt = 0;
                  gt < At;
                  gt += 1
                )
                  (Mt = o[gt].a),
                    Mt.a.propType &&
                      ((wt = o[gt].s),
                      (Tt = wt.getMult(
                        tt[$].anIndexes[gt],
                        c.a[gt].s.totalChars
                      )),
                      Tt.length
                        ? d.translate(
                            -Mt.a.v[0] * Tt[0],
                            -Mt.a.v[1] * Tt[1],
                            Mt.a.v[2] * Tt[2]
                          )
                        : d.translate(
                            -Mt.a.v[0] * Tt,
                            -Mt.a.v[1] * Tt,
                            Mt.a.v[2] * Tt
                          ))
                for (gt = 0; gt < At; gt += 1)
                  (Mt = o[gt].a),
                    Mt.s.propType &&
                      ((wt = o[gt].s),
                      (Tt = wt.getMult(
                        tt[$].anIndexes[gt],
                        c.a[gt].s.totalChars
                      )),
                      Tt.length
                        ? d.scale(
                            1 + (Mt.s.v[0] - 1) * Tt[0],
                            1 + (Mt.s.v[1] - 1) * Tt[1],
                            1
                          )
                        : d.scale(
                            1 + (Mt.s.v[0] - 1) * Tt,
                            1 + (Mt.s.v[1] - 1) * Tt,
                            1
                          ))
                for (gt = 0; gt < At; gt += 1) {
                  if (
                    ((Mt = o[gt].a),
                    (wt = o[gt].s),
                    (Tt = wt.getMult(
                      tt[$].anIndexes[gt],
                      c.a[gt].s.totalChars
                    )),
                    Mt.sk.propType &&
                      (Tt.length
                        ? d.skewFromAxis(-Mt.sk.v * Tt[0], Mt.sa.v * Tt[1])
                        : d.skewFromAxis(-Mt.sk.v * Tt, Mt.sa.v * Tt)),
                    Mt.r.propType &&
                      (Tt.length
                        ? d.rotateZ(-Mt.r.v * Tt[2])
                        : d.rotateZ(-Mt.r.v * Tt)),
                    Mt.ry.propType &&
                      (Tt.length
                        ? d.rotateY(Mt.ry.v * Tt[1])
                        : d.rotateY(Mt.ry.v * Tt)),
                    Mt.rx.propType &&
                      (Tt.length
                        ? d.rotateX(Mt.rx.v * Tt[0])
                        : d.rotateX(Mt.rx.v * Tt)),
                    Mt.o.propType &&
                      (Tt.length
                        ? (Vn += (Mt.o.v * Tt[0] - Vn) * Tt[0])
                        : (Vn += (Mt.o.v * Tt - Vn) * Tt)),
                    s.strokeWidthAnim &&
                      Mt.sw.propType &&
                      (Tt.length
                        ? (Ht += Mt.sw.v * Tt[0])
                        : (Ht += Mt.sw.v * Tt)),
                    s.strokeColorAnim && Mt.sc.propType)
                  )
                    for (Yt = 0; Yt < 3; Yt += 1)
                      Tt.length
                        ? (gn[Yt] += (Mt.sc.v[Yt] - gn[Yt]) * Tt[0])
                        : (gn[Yt] += (Mt.sc.v[Yt] - gn[Yt]) * Tt)
                  if (s.fillColorAnim && s.fc) {
                    if (Mt.fc.propType)
                      for (Yt = 0; Yt < 3; Yt += 1)
                        Tt.length
                          ? (on[Yt] += (Mt.fc.v[Yt] - on[Yt]) * Tt[0])
                          : (on[Yt] += (Mt.fc.v[Yt] - on[Yt]) * Tt)
                    Mt.fh.propType &&
                      (Tt.length
                        ? (on = addHueToRGB(on, Mt.fh.v * Tt[0]))
                        : (on = addHueToRGB(on, Mt.fh.v * Tt))),
                      Mt.fs.propType &&
                        (Tt.length
                          ? (on = addSaturationToRGB(on, Mt.fs.v * Tt[0]))
                          : (on = addSaturationToRGB(on, Mt.fs.v * Tt))),
                      Mt.fb.propType &&
                        (Tt.length
                          ? (on = addBrightnessToRGB(on, Mt.fb.v * Tt[0]))
                          : (on = addBrightnessToRGB(on, Mt.fb.v * Tt)))
                  }
                }
                for (gt = 0; gt < At; gt += 1)
                  (Mt = o[gt].a),
                    Mt.p.propType &&
                      ((wt = o[gt].s),
                      (Tt = wt.getMult(
                        tt[$].anIndexes[gt],
                        c.a[gt].s.totalChars
                      )),
                      this._hasMaskedPath
                        ? Tt.length
                          ? d.translate(
                              0,
                              Mt.p.v[1] * Tt[0],
                              -Mt.p.v[2] * Tt[1]
                            )
                          : d.translate(0, Mt.p.v[1] * Tt, -Mt.p.v[2] * Tt)
                        : Tt.length
                        ? d.translate(
                            Mt.p.v[0] * Tt[0],
                            Mt.p.v[1] * Tt[1],
                            -Mt.p.v[2] * Tt[2]
                          )
                        : d.translate(
                            Mt.p.v[0] * Tt,
                            Mt.p.v[1] * Tt,
                            -Mt.p.v[2] * Tt
                          ))
                if (
                  (s.strokeWidthAnim && (_n = Ht < 0 ? 0 : Ht),
                  s.strokeColorAnim &&
                    (pn =
                      "rgb(" +
                      Math.round(gn[0] * 255) +
                      "," +
                      Math.round(gn[1] * 255) +
                      "," +
                      Math.round(gn[2] * 255) +
                      ")"),
                  s.fillColorAnim &&
                    s.fc &&
                    (Rn =
                      "rgb(" +
                      Math.round(on[0] * 255) +
                      "," +
                      Math.round(on[1] * 255) +
                      "," +
                      Math.round(on[2] * 255) +
                      ")"),
                  this._hasMaskedPath)
                ) {
                  if (
                    (d.translate(0, -s.ls),
                    d.translate(0, a[1] * Nt * 0.01 + j, 0),
                    this._pathData.p.v)
                  ) {
                    Et =
                      (ot.point[1] - ht.point[1]) / (ot.point[0] - ht.point[0])
                    var vn = (Math.atan(Et) * 180) / Math.PI
                    ot.point[0] < ht.point[0] && (vn += 180),
                      d.rotate((-vn * Math.PI) / 180)
                  }
                  d.translate(Xt, qt, 0),
                    (at -= a[0] * tt[$].an * 0.005),
                    tt[$ + 1] &&
                      It !== tt[$ + 1].ind &&
                      ((at += tt[$].an / 2), (at += s.tr * 0.001 * s.finalSize))
                } else {
                  switch (
                    (d.translate(b, j, 0),
                    s.ps && d.translate(s.ps[0], s.ps[1] + s.ascent, 0),
                    s.j)
                  ) {
                    case 1:
                      d.translate(
                        tt[$].animatorJustifyOffset +
                          s.justifyOffset +
                          (s.boxWidth - s.lineWidths[tt[$].line]),
                        0,
                        0
                      )
                      break
                    case 2:
                      d.translate(
                        tt[$].animatorJustifyOffset +
                          s.justifyOffset +
                          (s.boxWidth - s.lineWidths[tt[$].line]) / 2,
                        0,
                        0
                      )
                      break
                  }
                  d.translate(0, -s.ls),
                    d.translate($t, 0, 0),
                    d.translate(a[0] * tt[$].an * 0.005, a[1] * Nt * 0.01, 0),
                    (b += tt[$].l + s.tr * 0.001 * s.finalSize)
                }
                g === "html"
                  ? (bn = d.toCSS())
                  : g === "svg"
                  ? (bn = d.to2dCSS())
                  : (Pn = [
                      d.props[0],
                      d.props[1],
                      d.props[2],
                      d.props[3],
                      d.props[4],
                      d.props[5],
                      d.props[6],
                      d.props[7],
                      d.props[8],
                      d.props[9],
                      d.props[10],
                      d.props[11],
                      d.props[12],
                      d.props[13],
                      d.props[14],
                      d.props[15],
                    ]),
                  (Gn = Vn)
              }
              _ <= $
                ? ((bt = new LetterProps(Gn, _n, pn, Rn, bn, Pn)),
                  this.renderedLetters.push(bt),
                  (_ += 1),
                  (this.lettersChangedFlag = !0))
                : ((bt = this.renderedLetters[$]),
                  (this.lettersChangedFlag =
                    bt.update(Gn, _n, pn, Rn, bn, Pn) ||
                    this.lettersChangedFlag))
            }
          }
        }),
        (TextAnimatorProperty.prototype.getValue = function () {
          this._elem.globalData.frameId !== this._frameId &&
            ((this._frameId = this._elem.globalData.frameId),
            this.iterateDynamicProperties())
        }),
        (TextAnimatorProperty.prototype.mHelper = new Matrix()),
        (TextAnimatorProperty.prototype.defaultPropsArray = []),
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty)
      function ITextElement() {}
      ;(ITextElement.prototype.initElement = function (s, e, a) {
        ;(this.lettersChangedFlag = !0),
          this.initFrame(),
          this.initBaseData(s, e, a),
          (this.textProperty = new TextProperty(
            this,
            s.t,
            this.dynamicProperties
          )),
          (this.textAnimator = new TextAnimatorProperty(
            s.t,
            this.renderType,
            this
          )),
          this.initTransform(s, e, a),
          this.initHierarchy(),
          this.initRenderable(),
          this.initRendererElement(),
          this.createContainerElements(),
          this.createRenderableComponents(),
          this.createContent(),
          this.hide(),
          this.textAnimator.searchProperties(this.dynamicProperties)
      }),
        (ITextElement.prototype.prepareFrame = function (s) {
          ;(this._mdf = !1),
            this.prepareRenderableFrame(s),
            this.prepareProperties(s, this.isInRange)
        }),
        (ITextElement.prototype.createPathShape = function (s, e) {
          var a,
            o = e.length,
            c,
            d = ""
          for (a = 0; a < o; a += 1)
            e[a].ty === "sh" &&
              ((c = e[a].ks.k), (d += buildShapeString(c, c.i.length, !0, s)))
          return d
        }),
        (ITextElement.prototype.updateDocumentData = function (s, e) {
          this.textProperty.updateDocumentData(s, e)
        }),
        (ITextElement.prototype.canResizeFont = function (s) {
          this.textProperty.canResizeFont(s)
        }),
        (ITextElement.prototype.setMinimumFontSize = function (s) {
          this.textProperty.setMinimumFontSize(s)
        }),
        (ITextElement.prototype.applyTextPropertiesToMatrix = function (
          s,
          e,
          a,
          o,
          c
        ) {
          switch (
            (s.ps && e.translate(s.ps[0], s.ps[1] + s.ascent, 0),
            e.translate(0, -s.ls, 0),
            s.j)
          ) {
            case 1:
              e.translate(
                s.justifyOffset + (s.boxWidth - s.lineWidths[a]),
                0,
                0
              )
              break
            case 2:
              e.translate(
                s.justifyOffset + (s.boxWidth - s.lineWidths[a]) / 2,
                0,
                0
              )
              break
          }
          e.translate(o, c, 0)
        }),
        (ITextElement.prototype.buildColor = function (s) {
          return (
            "rgb(" +
            Math.round(s[0] * 255) +
            "," +
            Math.round(s[1] * 255) +
            "," +
            Math.round(s[2] * 255) +
            ")"
          )
        }),
        (ITextElement.prototype.emptyProp = new LetterProps()),
        (ITextElement.prototype.destroy = function () {}),
        (ITextElement.prototype.validateText = function () {
          ;(this.textProperty._mdf || this.textProperty._isFirstFrame) &&
            (this.buildNewText(),
            (this.textProperty._isFirstFrame = !1),
            (this.textProperty._mdf = !1))
        })
      var emptyShapeData = { shapes: [] }
      function SVGTextLottieElement(s, e, a) {
        ;(this.textSpans = []),
          (this.renderType = "svg"),
          this.initElement(s, e, a)
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          SVGBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
          ITextElement,
        ],
        SVGTextLottieElement
      ),
        (SVGTextLottieElement.prototype.createContent = function () {
          this.data.singleShape &&
            !this.globalData.fontManager.chars &&
            (this.textContainer = createNS("text"))
        }),
        (SVGTextLottieElement.prototype.buildTextContents = function (s) {
          for (var e = 0, a = s.length, o = [], c = ""; e < a; )
            s[e] === String.fromCharCode(13) || s[e] === String.fromCharCode(3)
              ? (o.push(c), (c = ""))
              : (c += s[e]),
              (e += 1)
          return o.push(c), o
        }),
        (SVGTextLottieElement.prototype.buildShapeData = function (s, e) {
          if (s.shapes && s.shapes.length) {
            var a = s.shapes[0]
            if (a.it) {
              var o = a.it[a.it.length - 1]
              o.s && ((o.s.k[0] = e), (o.s.k[1] = e))
            }
          }
          return s
        }),
        (SVGTextLottieElement.prototype.buildNewText = function () {
          this.addDynamicProperty(this)
          var s,
            e,
            a = this.textProperty.currentData
          ;(this.renderedLetters = createSizedArray(a ? a.l.length : 0)),
            a.fc
              ? this.layerElement.setAttribute("fill", this.buildColor(a.fc))
              : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"),
            a.sc &&
              (this.layerElement.setAttribute("stroke", this.buildColor(a.sc)),
              this.layerElement.setAttribute("stroke-width", a.sw)),
            this.layerElement.setAttribute("font-size", a.finalSize)
          var o = this.globalData.fontManager.getFontByName(a.f)
          if (o.fClass) this.layerElement.setAttribute("class", o.fClass)
          else {
            this.layerElement.setAttribute("font-family", o.fFamily)
            var c = a.fWeight,
              d = a.fStyle
            this.layerElement.setAttribute("font-style", d),
              this.layerElement.setAttribute("font-weight", c)
          }
          this.layerElement.setAttribute("aria-label", a.t)
          var g = a.l || [],
            _ = !!this.globalData.fontManager.chars
          e = g.length
          var b,
            j = this.mHelper,
            $ = "",
            _e = this.data.singleShape,
            tt = 0,
            st = 0,
            at = !0,
            ot = a.tr * 0.001 * a.finalSize
          if (_e && !_ && !a.sz) {
            var ut = this.textContainer,
              it = "start"
            switch (a.j) {
              case 1:
                it = "end"
                break
              case 2:
                it = "middle"
                break
              default:
                it = "start"
                break
            }
            ut.setAttribute("text-anchor", it),
              ut.setAttribute("letter-spacing", ot)
            var ct = this.buildTextContents(a.finalText)
            for (
              e = ct.length, st = a.ps ? a.ps[1] + a.ascent : 0, s = 0;
              s < e;
              s += 1
            )
              (b = this.textSpans[s].span || createNS("tspan")),
                (b.textContent = ct[s]),
                b.setAttribute("x", 0),
                b.setAttribute("y", st),
                (b.style.display = "inherit"),
                ut.appendChild(b),
                this.textSpans[s] ||
                  (this.textSpans[s] = { span: null, glyph: null }),
                (this.textSpans[s].span = b),
                (st += a.finalLineHeight)
            this.layerElement.appendChild(ut)
          } else {
            var lt = this.textSpans.length,
              ht
            for (s = 0; s < e; s += 1) {
              if (
                (this.textSpans[s] ||
                  (this.textSpans[s] = {
                    span: null,
                    childSpan: null,
                    glyph: null,
                  }),
                !_ || !_e || s === 0)
              ) {
                if (
                  ((b =
                    lt > s
                      ? this.textSpans[s].span
                      : createNS(_ ? "g" : "text")),
                  lt <= s)
                ) {
                  if (
                    (b.setAttribute("stroke-linecap", "butt"),
                    b.setAttribute("stroke-linejoin", "round"),
                    b.setAttribute("stroke-miterlimit", "4"),
                    (this.textSpans[s].span = b),
                    _)
                  ) {
                    var dt = createNS("g")
                    b.appendChild(dt), (this.textSpans[s].childSpan = dt)
                  }
                  ;(this.textSpans[s].span = b),
                    this.layerElement.appendChild(b)
                }
                b.style.display = "inherit"
              }
              if (
                (j.reset(),
                _e &&
                  (g[s].n &&
                    ((tt = -ot),
                    (st += a.yOffset),
                    (st += at ? 1 : 0),
                    (at = !1)),
                  this.applyTextPropertiesToMatrix(a, j, g[s].line, tt, st),
                  (tt += g[s].l || 0),
                  (tt += ot)),
                _)
              ) {
                ht = this.globalData.fontManager.getCharData(
                  a.finalText[s],
                  o.fStyle,
                  this.globalData.fontManager.getFontByName(a.f).fFamily
                )
                var pt
                if (ht.t === 1)
                  pt = new SVGCompElement(ht.data, this.globalData, this)
                else {
                  var vt = emptyShapeData
                  ht.data &&
                    ht.data.shapes &&
                    (vt = this.buildShapeData(ht.data, a.finalSize)),
                    (pt = new SVGShapeElement(vt, this.globalData, this))
                }
                if (this.textSpans[s].glyph) {
                  var _t = this.textSpans[s].glyph
                  this.textSpans[s].childSpan.removeChild(_t.layerElement),
                    _t.destroy()
                }
                ;(this.textSpans[s].glyph = pt),
                  (pt._debug = !0),
                  pt.prepareFrame(0),
                  pt.renderFrame(),
                  this.textSpans[s].childSpan.appendChild(pt.layerElement),
                  ht.t === 1 &&
                    this.textSpans[s].childSpan.setAttribute(
                      "transform",
                      "scale(" +
                        a.finalSize / 100 +
                        "," +
                        a.finalSize / 100 +
                        ")"
                    )
              } else
                _e &&
                  b.setAttribute(
                    "transform",
                    "translate(" + j.props[12] + "," + j.props[13] + ")"
                  ),
                  (b.textContent = g[s].val),
                  b.setAttributeNS(
                    "http://www.w3.org/XML/1998/namespace",
                    "xml:space",
                    "preserve"
                  )
            }
            _e && b && b.setAttribute("d", $)
          }
          for (; s < this.textSpans.length; )
            (this.textSpans[s].span.style.display = "none"), (s += 1)
          this._sizeChanged = !0
        }),
        (SVGTextLottieElement.prototype.sourceRectAtTime = function () {
          if (
            (this.prepareFrame(this.comp.renderedFrame - this.data.st),
            this.renderInnerContent(),
            this._sizeChanged)
          ) {
            this._sizeChanged = !1
            var s = this.layerElement.getBBox()
            this.bbox = {
              top: s.y,
              left: s.x,
              width: s.width,
              height: s.height,
            }
          }
          return this.bbox
        }),
        (SVGTextLottieElement.prototype.getValue = function () {
          var s,
            e = this.textSpans.length,
            a
          for (
            this.renderedFrame = this.comp.renderedFrame, s = 0;
            s < e;
            s += 1
          )
            (a = this.textSpans[s].glyph),
              a &&
                (a.prepareFrame(this.comp.renderedFrame - this.data.st),
                a._mdf && (this._mdf = !0))
        }),
        (SVGTextLottieElement.prototype.renderInnerContent = function () {
          if (
            (this.validateText(),
            (!this.data.singleShape || this._mdf) &&
              (this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              ),
              this.lettersChangedFlag || this.textAnimator.lettersChangedFlag))
          ) {
            this._sizeChanged = !0
            var s,
              e,
              a = this.textAnimator.renderedLetters,
              o = this.textProperty.currentData.l
            e = o.length
            var c, d, g
            for (s = 0; s < e; s += 1)
              o[s].n ||
                ((c = a[s]),
                (d = this.textSpans[s].span),
                (g = this.textSpans[s].glyph),
                g && g.renderFrame(),
                c._mdf.m && d.setAttribute("transform", c.m),
                c._mdf.o && d.setAttribute("opacity", c.o),
                c._mdf.sw && d.setAttribute("stroke-width", c.sw),
                c._mdf.sc && d.setAttribute("stroke", c.sc),
                c._mdf.fc && d.setAttribute("fill", c.fc))
          }
        })
      function ISolidElement(s, e, a) {
        this.initElement(s, e, a)
      }
      extendPrototype([IImageElement], ISolidElement),
        (ISolidElement.prototype.createContent = function () {
          var s = createNS("rect")
          s.setAttribute("width", this.data.sw),
            s.setAttribute("height", this.data.sh),
            s.setAttribute("fill", this.data.sc),
            this.layerElement.appendChild(s)
        })
      function NullElement(s, e, a) {
        this.initFrame(),
          this.initBaseData(s, e, a),
          this.initFrame(),
          this.initTransform(s, e, a),
          this.initHierarchy()
      }
      ;(NullElement.prototype.prepareFrame = function (s) {
        this.prepareProperties(s, !0)
      }),
        (NullElement.prototype.renderFrame = function () {}),
        (NullElement.prototype.getBaseElement = function () {
          return null
        }),
        (NullElement.prototype.destroy = function () {}),
        (NullElement.prototype.sourceRectAtTime = function () {}),
        (NullElement.prototype.hide = function () {}),
        extendPrototype(
          [BaseElement, TransformElement, HierarchyElement, FrameElement],
          NullElement
        )
      function SVGRendererBase() {}
      extendPrototype([BaseRenderer], SVGRendererBase),
        (SVGRendererBase.prototype.createNull = function (s) {
          return new NullElement(s, this.globalData, this)
        }),
        (SVGRendererBase.prototype.createShape = function (s) {
          return new SVGShapeElement(s, this.globalData, this)
        }),
        (SVGRendererBase.prototype.createText = function (s) {
          return new SVGTextLottieElement(s, this.globalData, this)
        }),
        (SVGRendererBase.prototype.createImage = function (s) {
          return new IImageElement(s, this.globalData, this)
        }),
        (SVGRendererBase.prototype.createSolid = function (s) {
          return new ISolidElement(s, this.globalData, this)
        }),
        (SVGRendererBase.prototype.configAnimation = function (s) {
          this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
            this.svgElement.setAttribute(
              "xmlns:xlink",
              "http://www.w3.org/1999/xlink"
            ),
            this.renderConfig.viewBoxSize
              ? this.svgElement.setAttribute(
                  "viewBox",
                  this.renderConfig.viewBoxSize
                )
              : this.svgElement.setAttribute(
                  "viewBox",
                  "0 0 " + s.w + " " + s.h
                ),
            this.renderConfig.viewBoxOnly ||
              (this.svgElement.setAttribute("width", s.w),
              this.svgElement.setAttribute("height", s.h),
              (this.svgElement.style.width = "100%"),
              (this.svgElement.style.height = "100%"),
              (this.svgElement.style.transform = "translate3d(0,0,0)"),
              (this.svgElement.style.contentVisibility =
                this.renderConfig.contentVisibility)),
            this.renderConfig.width &&
              this.svgElement.setAttribute("width", this.renderConfig.width),
            this.renderConfig.height &&
              this.svgElement.setAttribute("height", this.renderConfig.height),
            this.renderConfig.className &&
              this.svgElement.setAttribute(
                "class",
                this.renderConfig.className
              ),
            this.renderConfig.id &&
              this.svgElement.setAttribute("id", this.renderConfig.id),
            this.renderConfig.focusable !== void 0 &&
              this.svgElement.setAttribute(
                "focusable",
                this.renderConfig.focusable
              ),
            this.svgElement.setAttribute(
              "preserveAspectRatio",
              this.renderConfig.preserveAspectRatio
            ),
            this.animationItem.wrapper.appendChild(this.svgElement)
          var e = this.globalData.defs
          this.setupGlobalData(s, e),
            (this.globalData.progressiveLoad =
              this.renderConfig.progressiveLoad),
            (this.data = s)
          var a = createNS("clipPath"),
            o = createNS("rect")
          o.setAttribute("width", s.w),
            o.setAttribute("height", s.h),
            o.setAttribute("x", 0),
            o.setAttribute("y", 0)
          var c = createElementID()
          a.setAttribute("id", c),
            a.appendChild(o),
            this.layerElement.setAttribute(
              "clip-path",
              "url(" + getLocationHref() + "#" + c + ")"
            ),
            e.appendChild(a),
            (this.layers = s.layers),
            (this.elements = createSizedArray(s.layers.length))
        }),
        (SVGRendererBase.prototype.destroy = function () {
          this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = ""),
            (this.layerElement = null),
            (this.globalData.defs = null)
          var s,
            e = this.layers ? this.layers.length : 0
          for (s = 0; s < e; s += 1)
            this.elements[s] &&
              this.elements[s].destroy &&
              this.elements[s].destroy()
          ;(this.elements.length = 0),
            (this.destroyed = !0),
            (this.animationItem = null)
        }),
        (SVGRendererBase.prototype.updateContainerSize = function () {}),
        (SVGRendererBase.prototype.findIndexByInd = function (s) {
          var e = 0,
            a = this.layers.length
          for (e = 0; e < a; e += 1) if (this.layers[e].ind === s) return e
          return -1
        }),
        (SVGRendererBase.prototype.buildItem = function (s) {
          var e = this.elements
          if (!(e[s] || this.layers[s].ty === 99)) {
            e[s] = !0
            var a = this.createItem(this.layers[s])
            if (
              ((e[s] = a),
              getExpressionsPlugin() &&
                (this.layers[s].ty === 0 &&
                  this.globalData.projectInterface.registerComposition(a),
                a.initExpressions()),
              this.appendElementInPos(a, s),
              this.layers[s].tt)
            ) {
              var o =
                "tp" in this.layers[s]
                  ? this.findIndexByInd(this.layers[s].tp)
                  : s - 1
              if (o === -1) return
              if (!this.elements[o] || this.elements[o] === !0)
                this.buildItem(o), this.addPendingElement(a)
              else {
                var c = e[o],
                  d = c.getMatte(this.layers[s].tt)
                a.setMatte(d)
              }
            }
          }
        }),
        (SVGRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var s = this.pendingElements.pop()
            if ((s.checkParenting(), s.data.tt))
              for (var e = 0, a = this.elements.length; e < a; ) {
                if (this.elements[e] === s) {
                  var o =
                      "tp" in s.data ? this.findIndexByInd(s.data.tp) : e - 1,
                    c = this.elements[o],
                    d = c.getMatte(this.layers[e].tt)
                  s.setMatte(d)
                  break
                }
                e += 1
              }
          }
        }),
        (SVGRendererBase.prototype.renderFrame = function (s) {
          if (!(this.renderedFrame === s || this.destroyed)) {
            s === null ? (s = this.renderedFrame) : (this.renderedFrame = s),
              (this.globalData.frameNum = s),
              (this.globalData.frameId += 1),
              (this.globalData.projectInterface.currentFrame = s),
              (this.globalData._mdf = !1)
            var e,
              a = this.layers.length
            for (
              this.completeLayers || this.checkLayers(s), e = a - 1;
              e >= 0;
              e -= 1
            )
              (this.completeLayers || this.elements[e]) &&
                this.elements[e].prepareFrame(s - this.layers[e].st)
            if (this.globalData._mdf)
              for (e = 0; e < a; e += 1)
                (this.completeLayers || this.elements[e]) &&
                  this.elements[e].renderFrame()
          }
        }),
        (SVGRendererBase.prototype.appendElementInPos = function (s, e) {
          var a = s.getBaseElement()
          if (a) {
            for (var o = 0, c; o < e; )
              this.elements[o] &&
                this.elements[o] !== !0 &&
                this.elements[o].getBaseElement() &&
                (c = this.elements[o].getBaseElement()),
                (o += 1)
            c
              ? this.layerElement.insertBefore(a, c)
              : this.layerElement.appendChild(a)
          }
        }),
        (SVGRendererBase.prototype.hide = function () {
          this.layerElement.style.display = "none"
        }),
        (SVGRendererBase.prototype.show = function () {
          this.layerElement.style.display = "block"
        })
      function ICompElement() {}
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        ICompElement
      ),
        (ICompElement.prototype.initElement = function (s, e, a) {
          this.initFrame(),
            this.initBaseData(s, e, a),
            this.initTransform(s, e, a),
            this.initRenderable(),
            this.initHierarchy(),
            this.initRendererElement(),
            this.createContainerElements(),
            this.createRenderableComponents(),
            (this.data.xt || !e.progressiveLoad) && this.buildAllItems(),
            this.hide()
        }),
        (ICompElement.prototype.prepareFrame = function (s) {
          if (
            ((this._mdf = !1),
            this.prepareRenderableFrame(s),
            this.prepareProperties(s, this.isInRange),
            !(!this.isInRange && !this.data.xt))
          ) {
            if (this.tm._placeholder) this.renderedFrame = s / this.data.sr
            else {
              var e = this.tm.v
              e === this.data.op && (e = this.data.op - 1),
                (this.renderedFrame = e)
            }
            var a,
              o = this.elements.length
            for (
              this.completeLayers || this.checkLayers(this.renderedFrame),
                a = o - 1;
              a >= 0;
              a -= 1
            )
              (this.completeLayers || this.elements[a]) &&
                (this.elements[a].prepareFrame(
                  this.renderedFrame - this.layers[a].st
                ),
                this.elements[a]._mdf && (this._mdf = !0))
          }
        }),
        (ICompElement.prototype.renderInnerContent = function () {
          var s,
            e = this.layers.length
          for (s = 0; s < e; s += 1)
            (this.completeLayers || this.elements[s]) &&
              this.elements[s].renderFrame()
        }),
        (ICompElement.prototype.setElements = function (s) {
          this.elements = s
        }),
        (ICompElement.prototype.getElements = function () {
          return this.elements
        }),
        (ICompElement.prototype.destroyElements = function () {
          var s,
            e = this.layers.length
          for (s = 0; s < e; s += 1)
            this.elements[s] && this.elements[s].destroy()
        }),
        (ICompElement.prototype.destroy = function () {
          this.destroyElements(), this.destroyBaseElement()
        })
      function SVGCompElement(s, e, a) {
        ;(this.layers = s.layers),
          (this.supports3d = !0),
          (this.completeLayers = !1),
          (this.pendingElements = []),
          (this.elements = this.layers
            ? createSizedArray(this.layers.length)
            : []),
          this.initElement(s, e, a),
          (this.tm = s.tm
            ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this)
            : { _placeholder: !0 })
      }
      extendPrototype(
        [SVGRendererBase, ICompElement, SVGBaseElement],
        SVGCompElement
      ),
        (SVGCompElement.prototype.createComp = function (s) {
          return new SVGCompElement(s, this.globalData, this)
        })
      function SVGRenderer(s, e) {
        ;(this.animationItem = s),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.svgElement = createNS("svg"))
        var a = ""
        if (e && e.title) {
          var o = createNS("title"),
            c = createElementID()
          o.setAttribute("id", c),
            (o.textContent = e.title),
            this.svgElement.appendChild(o),
            (a += c)
        }
        if (e && e.description) {
          var d = createNS("desc"),
            g = createElementID()
          d.setAttribute("id", g),
            (d.textContent = e.description),
            this.svgElement.appendChild(d),
            (a += " " + g)
        }
        a && this.svgElement.setAttribute("aria-labelledby", a)
        var _ = createNS("defs")
        this.svgElement.appendChild(_)
        var b = createNS("g")
        this.svgElement.appendChild(b),
          (this.layerElement = b),
          (this.renderConfig = {
            preserveAspectRatio:
              (e && e.preserveAspectRatio) || "xMidYMid meet",
            imagePreserveAspectRatio:
              (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
            contentVisibility: (e && e.contentVisibility) || "visible",
            progressiveLoad: (e && e.progressiveLoad) || !1,
            hideOnTransparent: !(e && e.hideOnTransparent === !1),
            viewBoxOnly: (e && e.viewBoxOnly) || !1,
            viewBoxSize: (e && e.viewBoxSize) || !1,
            className: (e && e.className) || "",
            id: (e && e.id) || "",
            focusable: e && e.focusable,
            filterSize: {
              width: (e && e.filterSize && e.filterSize.width) || "100%",
              height: (e && e.filterSize && e.filterSize.height) || "100%",
              x: (e && e.filterSize && e.filterSize.x) || "0%",
              y: (e && e.filterSize && e.filterSize.y) || "0%",
            },
            width: e && e.width,
            height: e && e.height,
            runExpressions:
              !e || e.runExpressions === void 0 || e.runExpressions,
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            defs: _,
            renderConfig: this.renderConfig,
          }),
          (this.elements = []),
          (this.pendingElements = []),
          (this.destroyed = !1),
          (this.rendererType = "svg")
      }
      extendPrototype([SVGRendererBase], SVGRenderer),
        (SVGRenderer.prototype.createComp = function (s) {
          return new SVGCompElement(s, this.globalData, this)
        })
      function ShapeTransformManager() {
        ;(this.sequences = {}),
          (this.sequenceList = []),
          (this.transform_key_count = 0)
      }
      ShapeTransformManager.prototype = {
        addTransformSequence: function (e) {
          var a,
            o = e.length,
            c = "_"
          for (a = 0; a < o; a += 1) c += e[a].transform.key + "_"
          var d = this.sequences[c]
          return (
            d ||
              ((d = {
                transforms: [].concat(e),
                finalTransform: new Matrix(),
                _mdf: !1,
              }),
              (this.sequences[c] = d),
              this.sequenceList.push(d)),
            d
          )
        },
        processSequence: function (e, a) {
          for (var o = 0, c = e.transforms.length, d = a; o < c && !a; ) {
            if (e.transforms[o].transform.mProps._mdf) {
              d = !0
              break
            }
            o += 1
          }
          if (d)
            for (e.finalTransform.reset(), o = c - 1; o >= 0; o -= 1)
              e.finalTransform.multiply(e.transforms[o].transform.mProps.v)
          e._mdf = d
        },
        processSequences: function (e) {
          var a,
            o = this.sequenceList.length
          for (a = 0; a < o; a += 1)
            this.processSequence(this.sequenceList[a], e)
        },
        getNewKey: function () {
          return (this.transform_key_count += 1), "_" + this.transform_key_count
        },
      }
      var lumaLoader = function () {
        var e = "__lottie_element_luma_buffer",
          a = null,
          o = null,
          c = null
        function d() {
          var b = createNS("svg"),
            j = createNS("filter"),
            $ = createNS("feColorMatrix")
          return (
            j.setAttribute("id", e),
            $.setAttribute("type", "matrix"),
            $.setAttribute("color-interpolation-filters", "sRGB"),
            $.setAttribute(
              "values",
              "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"
            ),
            j.appendChild($),
            b.appendChild(j),
            b.setAttribute("id", e + "_svg"),
            featureSupport.svgLumaHidden && (b.style.display = "none"),
            b
          )
        }
        function g() {
          a ||
            ((c = d()),
            document.body.appendChild(c),
            (a = createTag("canvas")),
            (o = a.getContext("2d")),
            (o.filter = "url(#" + e + ")"),
            (o.fillStyle = "rgba(0,0,0,0)"),
            o.fillRect(0, 0, 1, 1))
        }
        function _(b) {
          return (
            a || g(),
            (a.width = b.width),
            (a.height = b.height),
            (o.filter = "url(#" + e + ")"),
            a
          )
        }
        return { load: g, get: _ }
      }
      function createCanvas(s, e) {
        if (featureSupport.offscreenCanvas) return new OffscreenCanvas(s, e)
        var a = createTag("canvas")
        return (a.width = s), (a.height = e), a
      }
      var assetLoader = (function () {
          return {
            loadLumaCanvas: lumaLoader.load,
            getLumaCanvas: lumaLoader.get,
            createCanvas,
          }
        })(),
        registeredEffects = {}
      function CVEffects(s) {
        var e,
          a = s.data.ef ? s.data.ef.length : 0
        this.filters = []
        var o
        for (e = 0; e < a; e += 1) {
          o = null
          var c = s.data.ef[e].ty
          if (registeredEffects[c]) {
            var d = registeredEffects[c].effect
            o = new d(s.effectsManager.effectElements[e], s)
          }
          o && this.filters.push(o)
        }
        this.filters.length && s.addRenderableComponent(this)
      }
      ;(CVEffects.prototype.renderFrame = function (s) {
        var e,
          a = this.filters.length
        for (e = 0; e < a; e += 1) this.filters[e].renderFrame(s)
      }),
        (CVEffects.prototype.getEffects = function (s) {
          var e,
            a = this.filters.length,
            o = []
          for (e = 0; e < a; e += 1)
            this.filters[e].type === s && o.push(this.filters[e])
          return o
        })
      function registerEffect(s, e) {
        registeredEffects[s] = { effect: e }
      }
      function CVMaskElement(s, e) {
        ;(this.data = s),
          (this.element = e),
          (this.masksProperties = this.data.masksProperties || []),
          (this.viewData = createSizedArray(this.masksProperties.length))
        var a,
          o = this.masksProperties.length,
          c = !1
        for (a = 0; a < o; a += 1)
          this.masksProperties[a].mode !== "n" && (c = !0),
            (this.viewData[a] = ShapePropertyFactory.getShapeProp(
              this.element,
              this.masksProperties[a],
              3
            ))
        ;(this.hasMasks = c), c && this.element.addRenderableComponent(this)
      }
      ;(CVMaskElement.prototype.renderFrame = function () {
        if (this.hasMasks) {
          var s = this.element.finalTransform.mat,
            e = this.element.canvasContext,
            a,
            o = this.masksProperties.length,
            c,
            d,
            g
          for (e.beginPath(), a = 0; a < o; a += 1)
            if (this.masksProperties[a].mode !== "n") {
              this.masksProperties[a].inv &&
                (e.moveTo(0, 0),
                e.lineTo(this.element.globalData.compSize.w, 0),
                e.lineTo(
                  this.element.globalData.compSize.w,
                  this.element.globalData.compSize.h
                ),
                e.lineTo(0, this.element.globalData.compSize.h),
                e.lineTo(0, 0)),
                (g = this.viewData[a].v),
                (c = s.applyToPointArray(g.v[0][0], g.v[0][1], 0)),
                e.moveTo(c[0], c[1])
              var _,
                b = g._length
              for (_ = 1; _ < b; _ += 1)
                (d = s.applyToTriplePoints(g.o[_ - 1], g.i[_], g.v[_])),
                  e.bezierCurveTo(d[0], d[1], d[2], d[3], d[4], d[5])
              ;(d = s.applyToTriplePoints(g.o[_ - 1], g.i[0], g.v[0])),
                e.bezierCurveTo(d[0], d[1], d[2], d[3], d[4], d[5])
            }
          this.element.globalData.renderer.save(!0), e.clip()
        }
      }),
        (CVMaskElement.prototype.getMaskProperty =
          MaskElement.prototype.getMaskProperty),
        (CVMaskElement.prototype.destroy = function () {
          this.element = null
        })
      function CVBaseElement() {}
      var operationsMap = {
        1: "source-in",
        2: "source-out",
        3: "source-in",
        4: "source-out",
      }
      ;(CVBaseElement.prototype = {
        createElements: function () {},
        initRendererElement: function () {},
        createContainerElements: function () {
          if (this.data.tt >= 1) {
            this.buffers = []
            var e = this.globalData.canvasContext,
              a = assetLoader.createCanvas(e.canvas.width, e.canvas.height)
            this.buffers.push(a)
            var o = assetLoader.createCanvas(e.canvas.width, e.canvas.height)
            this.buffers.push(o),
              this.data.tt >= 3 &&
                !document._isProxy &&
                assetLoader.loadLumaCanvas()
          }
          ;(this.canvasContext = this.globalData.canvasContext),
            (this.transformCanvas = this.globalData.transformCanvas),
            (this.renderableEffectsManager = new CVEffects(this)),
            this.searchEffectTransforms()
        },
        createContent: function () {},
        setBlendMode: function () {
          var e = this.globalData
          if (e.blendMode !== this.data.bm) {
            e.blendMode = this.data.bm
            var a = getBlendMode(this.data.bm)
            e.canvasContext.globalCompositeOperation = a
          }
        },
        createRenderableComponents: function () {
          ;(this.maskManager = new CVMaskElement(this.data, this)),
            (this.transformEffects = this.renderableEffectsManager.getEffects(
              effectTypes.TRANSFORM_EFFECT
            ))
        },
        hideElement: function () {
          !this.hidden &&
            (!this.isInRange || this.isTransparent) &&
            (this.hidden = !0)
        },
        showElement: function () {
          this.isInRange &&
            !this.isTransparent &&
            ((this.hidden = !1),
            (this._isFirstFrame = !0),
            (this.maskManager._isFirstFrame = !0))
        },
        clearCanvas: function (e) {
          e.clearRect(
            this.transformCanvas.tx,
            this.transformCanvas.ty,
            this.transformCanvas.w * this.transformCanvas.sx,
            this.transformCanvas.h * this.transformCanvas.sy
          )
        },
        prepareLayer: function () {
          if (this.data.tt >= 1) {
            var e = this.buffers[0],
              a = e.getContext("2d")
            this.clearCanvas(a),
              a.drawImage(this.canvasContext.canvas, 0, 0),
              (this.currentTransform = this.canvasContext.getTransform()),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.clearCanvas(this.canvasContext),
              this.canvasContext.setTransform(this.currentTransform)
          }
        },
        exitLayer: function () {
          if (this.data.tt >= 1) {
            var e = this.buffers[1],
              a = e.getContext("2d")
            this.clearCanvas(a),
              a.drawImage(this.canvasContext.canvas, 0, 0),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.clearCanvas(this.canvasContext),
              this.canvasContext.setTransform(this.currentTransform)
            var o = this.comp.getElementById(
              "tp" in this.data ? this.data.tp : this.data.ind - 1
            )
            if (
              (o.renderFrame(!0),
              this.canvasContext.setTransform(1, 0, 0, 1, 0, 0),
              this.data.tt >= 3 && !document._isProxy)
            ) {
              var c = assetLoader.getLumaCanvas(this.canvasContext.canvas),
                d = c.getContext("2d")
              d.drawImage(this.canvasContext.canvas, 0, 0),
                this.clearCanvas(this.canvasContext),
                this.canvasContext.drawImage(c, 0, 0)
            }
            ;(this.canvasContext.globalCompositeOperation =
              operationsMap[this.data.tt]),
              this.canvasContext.drawImage(e, 0, 0),
              (this.canvasContext.globalCompositeOperation =
                "destination-over"),
              this.canvasContext.drawImage(this.buffers[0], 0, 0),
              this.canvasContext.setTransform(this.currentTransform),
              (this.canvasContext.globalCompositeOperation = "source-over")
          }
        },
        renderFrame: function (e) {
          if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !e)) {
            this.renderTransform(),
              this.renderRenderable(),
              this.renderLocalTransform(),
              this.setBlendMode()
            var a = this.data.ty === 0
            this.prepareLayer(),
              this.globalData.renderer.save(a),
              this.globalData.renderer.ctxTransform(
                this.finalTransform.localMat.props
              ),
              this.globalData.renderer.ctxOpacity(
                this.finalTransform.localOpacity
              ),
              this.renderInnerContent(),
              this.globalData.renderer.restore(a),
              this.exitLayer(),
              this.maskManager.hasMasks && this.globalData.renderer.restore(!0),
              this._isFirstFrame && (this._isFirstFrame = !1)
          }
        },
        destroy: function () {
          ;(this.canvasContext = null),
            (this.data = null),
            (this.globalData = null),
            this.maskManager.destroy()
        },
        mHelper: new Matrix(),
      }),
        (CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement),
        (CVBaseElement.prototype.show = CVBaseElement.prototype.showElement)
      function CVShapeData(s, e, a, o) {
        ;(this.styledShapes = []), (this.tr = [0, 0, 0, 0, 0, 0])
        var c = 4
        e.ty === "rc"
          ? (c = 5)
          : e.ty === "el"
          ? (c = 6)
          : e.ty === "sr" && (c = 7),
          (this.sh = ShapePropertyFactory.getShapeProp(s, e, c, s))
        var d,
          g = a.length,
          _
        for (d = 0; d < g; d += 1)
          a[d].closed ||
            ((_ = {
              transforms: o.addTransformSequence(a[d].transforms),
              trNodes: [],
            }),
            this.styledShapes.push(_),
            a[d].elements.push(_))
      }
      CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated
      function CVShapeElement(s, e, a) {
        ;(this.shapes = []),
          (this.shapesData = s.shapes),
          (this.stylesList = []),
          (this.itemsData = []),
          (this.prevViewData = []),
          (this.shapeModifiers = []),
          (this.processedElements = []),
          (this.transformsManager = new ShapeTransformManager()),
          this.initElement(s, e, a)
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          IShapeElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVShapeElement
      ),
        (CVShapeElement.prototype.initElement =
          RenderableDOMElement.prototype.initElement),
        (CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: !1 }),
        (CVShapeElement.prototype.dashResetter = []),
        (CVShapeElement.prototype.createContent = function () {
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            !0,
            []
          )
        }),
        (CVShapeElement.prototype.createStyleElement = function (s, e) {
          var a = {
              data: s,
              type: s.ty,
              preTransforms: this.transformsManager.addTransformSequence(e),
              transforms: [],
              elements: [],
              closed: s.hd === !0,
            },
            o = {}
          if (
            (s.ty === "fl" || s.ty === "st"
              ? ((o.c = PropertyFactory.getProp(this, s.c, 1, 255, this)),
                o.c.k ||
                  (a.co =
                    "rgb(" +
                    bmFloor(o.c.v[0]) +
                    "," +
                    bmFloor(o.c.v[1]) +
                    "," +
                    bmFloor(o.c.v[2]) +
                    ")"))
              : (s.ty === "gf" || s.ty === "gs") &&
                ((o.s = PropertyFactory.getProp(this, s.s, 1, null, this)),
                (o.e = PropertyFactory.getProp(this, s.e, 1, null, this)),
                (o.h = PropertyFactory.getProp(
                  this,
                  s.h || { k: 0 },
                  0,
                  0.01,
                  this
                )),
                (o.a = PropertyFactory.getProp(
                  this,
                  s.a || { k: 0 },
                  0,
                  degToRads,
                  this
                )),
                (o.g = new GradientProperty(this, s.g, this))),
            (o.o = PropertyFactory.getProp(this, s.o, 0, 0.01, this)),
            s.ty === "st" || s.ty === "gs")
          ) {
            if (
              ((a.lc = lineCapEnum[s.lc || 2]),
              (a.lj = lineJoinEnum[s.lj || 2]),
              s.lj == 1 && (a.ml = s.ml),
              (o.w = PropertyFactory.getProp(this, s.w, 0, null, this)),
              o.w.k || (a.wi = o.w.v),
              s.d)
            ) {
              var c = new DashProperty(this, s.d, "canvas", this)
              ;(o.d = c),
                o.d.k || ((a.da = o.d.dashArray), (a.do = o.d.dashoffset[0]))
            }
          } else a.r = s.r === 2 ? "evenodd" : "nonzero"
          return this.stylesList.push(a), (o.style = a), o
        }),
        (CVShapeElement.prototype.createGroupElement = function () {
          var s = { it: [], prevViewData: [] }
          return s
        }),
        (CVShapeElement.prototype.createTransformElement = function (s) {
          var e = {
            transform: {
              opacity: 1,
              _opMdf: !1,
              key: this.transformsManager.getNewKey(),
              op: PropertyFactory.getProp(this, s.o, 0, 0.01, this),
              mProps: TransformPropertyFactory.getTransformProperty(
                this,
                s,
                this
              ),
            },
          }
          return e
        }),
        (CVShapeElement.prototype.createShapeElement = function (s) {
          var e = new CVShapeData(
            this,
            s,
            this.stylesList,
            this.transformsManager
          )
          return this.shapes.push(e), this.addShapeToModifiers(e), e
        }),
        (CVShapeElement.prototype.reloadShapes = function () {
          this._isFirstFrame = !0
          var s,
            e = this.itemsData.length
          for (s = 0; s < e; s += 1) this.prevViewData[s] = this.itemsData[s]
          for (
            this.searchShapes(
              this.shapesData,
              this.itemsData,
              this.prevViewData,
              !0,
              []
            ),
              e = this.dynamicProperties.length,
              s = 0;
            s < e;
            s += 1
          )
            this.dynamicProperties[s].getValue()
          this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame)
        }),
        (CVShapeElement.prototype.addTransformToStyleList = function (s) {
          var e,
            a = this.stylesList.length
          for (e = 0; e < a; e += 1)
            this.stylesList[e].closed || this.stylesList[e].transforms.push(s)
        }),
        (CVShapeElement.prototype.removeTransformFromStyleList = function () {
          var s,
            e = this.stylesList.length
          for (s = 0; s < e; s += 1)
            this.stylesList[s].closed || this.stylesList[s].transforms.pop()
        }),
        (CVShapeElement.prototype.closeStyles = function (s) {
          var e,
            a = s.length
          for (e = 0; e < a; e += 1) s[e].closed = !0
        }),
        (CVShapeElement.prototype.searchShapes = function (s, e, a, o, c) {
          var d,
            g = s.length - 1,
            _,
            b,
            j = [],
            $ = [],
            _e,
            tt,
            st,
            at = [].concat(c)
          for (d = g; d >= 0; d -= 1) {
            if (
              ((_e = this.searchProcessedElement(s[d])),
              _e ? (e[d] = a[_e - 1]) : (s[d]._shouldRender = o),
              s[d].ty === "fl" ||
                s[d].ty === "st" ||
                s[d].ty === "gf" ||
                s[d].ty === "gs")
            )
              _e
                ? (e[d].style.closed = !1)
                : (e[d] = this.createStyleElement(s[d], at)),
                j.push(e[d].style)
            else if (s[d].ty === "gr") {
              if (!_e) e[d] = this.createGroupElement(s[d])
              else
                for (b = e[d].it.length, _ = 0; _ < b; _ += 1)
                  e[d].prevViewData[_] = e[d].it[_]
              this.searchShapes(s[d].it, e[d].it, e[d].prevViewData, o, at)
            } else
              s[d].ty === "tr"
                ? (_e ||
                    ((st = this.createTransformElement(s[d])), (e[d] = st)),
                  at.push(e[d]),
                  this.addTransformToStyleList(e[d]))
                : s[d].ty === "sh" ||
                  s[d].ty === "rc" ||
                  s[d].ty === "el" ||
                  s[d].ty === "sr"
                ? _e || (e[d] = this.createShapeElement(s[d]))
                : s[d].ty === "tm" ||
                  s[d].ty === "rd" ||
                  s[d].ty === "pb" ||
                  s[d].ty === "zz" ||
                  s[d].ty === "op"
                ? (_e
                    ? ((tt = e[d]), (tt.closed = !1))
                    : ((tt = ShapeModifiers.getModifier(s[d].ty)),
                      tt.init(this, s[d]),
                      (e[d] = tt),
                      this.shapeModifiers.push(tt)),
                  $.push(tt))
                : s[d].ty === "rp" &&
                  (_e
                    ? ((tt = e[d]), (tt.closed = !0))
                    : ((tt = ShapeModifiers.getModifier(s[d].ty)),
                      (e[d] = tt),
                      tt.init(this, s, d, e),
                      this.shapeModifiers.push(tt),
                      (o = !1)),
                  $.push(tt))
            this.addProcessedElement(s[d], d + 1)
          }
          for (
            this.removeTransformFromStyleList(),
              this.closeStyles(j),
              g = $.length,
              d = 0;
            d < g;
            d += 1
          )
            $[d].closed = !0
        }),
        (CVShapeElement.prototype.renderInnerContent = function () {
          ;(this.transformHelper.opacity = 1),
            (this.transformHelper._opMdf = !1),
            this.renderModifiers(),
            this.transformsManager.processSequences(this._isFirstFrame),
            this.renderShape(
              this.transformHelper,
              this.shapesData,
              this.itemsData,
              !0
            )
        }),
        (CVShapeElement.prototype.renderShapeTransform = function (s, e) {
          ;(s._opMdf || e.op._mdf || this._isFirstFrame) &&
            ((e.opacity = s.opacity), (e.opacity *= e.op.v), (e._opMdf = !0))
        }),
        (CVShapeElement.prototype.drawLayer = function () {
          var s,
            e = this.stylesList.length,
            a,
            o,
            c,
            d,
            g,
            _,
            b = this.globalData.renderer,
            j = this.globalData.canvasContext,
            $,
            _e
          for (s = 0; s < e; s += 1)
            if (
              ((_e = this.stylesList[s]),
              ($ = _e.type),
              !(
                (($ === "st" || $ === "gs") && _e.wi === 0) ||
                !_e.data._shouldRender ||
                _e.coOp === 0 ||
                this.globalData.currentGlobalAlpha === 0
              ))
            ) {
              for (
                b.save(),
                  g = _e.elements,
                  $ === "st" || $ === "gs"
                    ? (b.ctxStrokeStyle($ === "st" ? _e.co : _e.grd),
                      b.ctxLineWidth(_e.wi),
                      b.ctxLineCap(_e.lc),
                      b.ctxLineJoin(_e.lj),
                      b.ctxMiterLimit(_e.ml || 0))
                    : b.ctxFillStyle($ === "fl" ? _e.co : _e.grd),
                  b.ctxOpacity(_e.coOp),
                  $ !== "st" && $ !== "gs" && j.beginPath(),
                  b.ctxTransform(_e.preTransforms.finalTransform.props),
                  o = g.length,
                  a = 0;
                a < o;
                a += 1
              ) {
                for (
                  ($ === "st" || $ === "gs") &&
                    (j.beginPath(),
                    _e.da &&
                      (j.setLineDash(_e.da), (j.lineDashOffset = _e.do))),
                    _ = g[a].trNodes,
                    d = _.length,
                    c = 0;
                  c < d;
                  c += 1
                )
                  _[c].t === "m"
                    ? j.moveTo(_[c].p[0], _[c].p[1])
                    : _[c].t === "c"
                    ? j.bezierCurveTo(
                        _[c].pts[0],
                        _[c].pts[1],
                        _[c].pts[2],
                        _[c].pts[3],
                        _[c].pts[4],
                        _[c].pts[5]
                      )
                    : j.closePath()
                ;($ === "st" || $ === "gs") &&
                  (b.ctxStroke(), _e.da && j.setLineDash(this.dashResetter))
              }
              $ !== "st" &&
                $ !== "gs" &&
                this.globalData.renderer.ctxFill(_e.r),
                b.restore()
            }
        }),
        (CVShapeElement.prototype.renderShape = function (s, e, a, o) {
          var c,
            d = e.length - 1,
            g
          for (g = s, c = d; c >= 0; c -= 1)
            e[c].ty === "tr"
              ? ((g = a[c].transform), this.renderShapeTransform(s, g))
              : e[c].ty === "sh" ||
                e[c].ty === "el" ||
                e[c].ty === "rc" ||
                e[c].ty === "sr"
              ? this.renderPath(e[c], a[c])
              : e[c].ty === "fl"
              ? this.renderFill(e[c], a[c], g)
              : e[c].ty === "st"
              ? this.renderStroke(e[c], a[c], g)
              : e[c].ty === "gf" || e[c].ty === "gs"
              ? this.renderGradientFill(e[c], a[c], g)
              : e[c].ty === "gr"
              ? this.renderShape(g, e[c].it, a[c].it)
              : e[c].ty
          o && this.drawLayer()
        }),
        (CVShapeElement.prototype.renderStyledShape = function (s, e) {
          if (this._isFirstFrame || e._mdf || s.transforms._mdf) {
            var a = s.trNodes,
              o = e.paths,
              c,
              d,
              g,
              _ = o._length
            a.length = 0
            var b = s.transforms.finalTransform
            for (g = 0; g < _; g += 1) {
              var j = o.shapes[g]
              if (j && j.v) {
                for (d = j._length, c = 1; c < d; c += 1)
                  c === 1 &&
                    a.push({
                      t: "m",
                      p: b.applyToPointArray(j.v[0][0], j.v[0][1], 0),
                    }),
                    a.push({
                      t: "c",
                      pts: b.applyToTriplePoints(j.o[c - 1], j.i[c], j.v[c]),
                    })
                d === 1 &&
                  a.push({
                    t: "m",
                    p: b.applyToPointArray(j.v[0][0], j.v[0][1], 0),
                  }),
                  j.c &&
                    d &&
                    (a.push({
                      t: "c",
                      pts: b.applyToTriplePoints(j.o[c - 1], j.i[0], j.v[0]),
                    }),
                    a.push({ t: "z" }))
              }
            }
            s.trNodes = a
          }
        }),
        (CVShapeElement.prototype.renderPath = function (s, e) {
          if (s.hd !== !0 && s._shouldRender) {
            var a,
              o = e.styledShapes.length
            for (a = 0; a < o; a += 1)
              this.renderStyledShape(e.styledShapes[a], e.sh)
          }
        }),
        (CVShapeElement.prototype.renderFill = function (s, e, a) {
          var o = e.style
          ;(e.c._mdf || this._isFirstFrame) &&
            (o.co =
              "rgb(" +
              bmFloor(e.c.v[0]) +
              "," +
              bmFloor(e.c.v[1]) +
              "," +
              bmFloor(e.c.v[2]) +
              ")"),
            (e.o._mdf || a._opMdf || this._isFirstFrame) &&
              (o.coOp = e.o.v * a.opacity)
        }),
        (CVShapeElement.prototype.renderGradientFill = function (s, e, a) {
          var o = e.style,
            c
          if (
            !o.grd ||
            e.g._mdf ||
            e.s._mdf ||
            e.e._mdf ||
            (s.t !== 1 && (e.h._mdf || e.a._mdf))
          ) {
            var d = this.globalData.canvasContext,
              g = e.s.v,
              _ = e.e.v
            if (s.t === 1) c = d.createLinearGradient(g[0], g[1], _[0], _[1])
            else {
              var b = Math.sqrt(
                  Math.pow(g[0] - _[0], 2) + Math.pow(g[1] - _[1], 2)
                ),
                j = Math.atan2(_[1] - g[1], _[0] - g[0]),
                $ = e.h.v
              $ >= 1 ? ($ = 0.99) : $ <= -1 && ($ = -0.99)
              var _e = b * $,
                tt = Math.cos(j + e.a.v) * _e + g[0],
                st = Math.sin(j + e.a.v) * _e + g[1]
              c = d.createRadialGradient(tt, st, 0, g[0], g[1], b)
            }
            var at,
              ot = s.g.p,
              ut = e.g.c,
              it = 1
            for (at = 0; at < ot; at += 1)
              e.g._hasOpacity && e.g._collapsable && (it = e.g.o[at * 2 + 1]),
                c.addColorStop(
                  ut[at * 4] / 100,
                  "rgba(" +
                    ut[at * 4 + 1] +
                    "," +
                    ut[at * 4 + 2] +
                    "," +
                    ut[at * 4 + 3] +
                    "," +
                    it +
                    ")"
                )
            o.grd = c
          }
          o.coOp = e.o.v * a.opacity
        }),
        (CVShapeElement.prototype.renderStroke = function (s, e, a) {
          var o = e.style,
            c = e.d
          c &&
            (c._mdf || this._isFirstFrame) &&
            ((o.da = c.dashArray), (o.do = c.dashoffset[0])),
            (e.c._mdf || this._isFirstFrame) &&
              (o.co =
                "rgb(" +
                bmFloor(e.c.v[0]) +
                "," +
                bmFloor(e.c.v[1]) +
                "," +
                bmFloor(e.c.v[2]) +
                ")"),
            (e.o._mdf || a._opMdf || this._isFirstFrame) &&
              (o.coOp = e.o.v * a.opacity),
            (e.w._mdf || this._isFirstFrame) && (o.wi = e.w.v)
        }),
        (CVShapeElement.prototype.destroy = function () {
          ;(this.shapesData = null),
            (this.globalData = null),
            (this.canvasContext = null),
            (this.stylesList.length = 0),
            (this.itemsData.length = 0)
        })
      function CVTextElement(s, e, a) {
        ;(this.textSpans = []),
          (this.yOffset = 0),
          (this.fillColorAnim = !1),
          (this.strokeColorAnim = !1),
          (this.strokeWidthAnim = !1),
          (this.stroke = !1),
          (this.fill = !1),
          (this.justifyOffset = 0),
          (this.currentRender = null),
          (this.renderType = "canvas"),
          (this.values = {
            fill: "rgba(0,0,0,0)",
            stroke: "rgba(0,0,0,0)",
            sWidth: 0,
            fValue: "",
          }),
          this.initElement(s, e, a)
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
          ITextElement,
        ],
        CVTextElement
      ),
        (CVTextElement.prototype.tHelper =
          createTag("canvas").getContext("2d")),
        (CVTextElement.prototype.buildNewText = function () {
          var s = this.textProperty.currentData
          this.renderedLetters = createSizedArray(s.l ? s.l.length : 0)
          var e = !1
          s.fc
            ? ((e = !0), (this.values.fill = this.buildColor(s.fc)))
            : (this.values.fill = "rgba(0,0,0,0)"),
            (this.fill = e)
          var a = !1
          s.sc &&
            ((a = !0),
            (this.values.stroke = this.buildColor(s.sc)),
            (this.values.sWidth = s.sw))
          var o = this.globalData.fontManager.getFontByName(s.f),
            c,
            d,
            g = s.l,
            _ = this.mHelper
          ;(this.stroke = a),
            (this.values.fValue =
              s.finalSize +
              "px " +
              this.globalData.fontManager.getFontByName(s.f).fFamily),
            (d = s.finalText.length)
          var b,
            j,
            $,
            _e,
            tt,
            st,
            at,
            ot,
            ut,
            it,
            ct = this.data.singleShape,
            lt = s.tr * 0.001 * s.finalSize,
            ht = 0,
            dt = 0,
            pt = !0,
            vt = 0
          for (c = 0; c < d; c += 1) {
            ;(b = this.globalData.fontManager.getCharData(
              s.finalText[c],
              o.fStyle,
              this.globalData.fontManager.getFontByName(s.f).fFamily
            )),
              (j = (b && b.data) || {}),
              _.reset(),
              ct &&
                g[c].n &&
                ((ht = -lt), (dt += s.yOffset), (dt += pt ? 1 : 0), (pt = !1)),
              (tt = j.shapes ? j.shapes[0].it : []),
              (at = tt.length),
              _.scale(s.finalSize / 100, s.finalSize / 100),
              ct && this.applyTextPropertiesToMatrix(s, _, g[c].line, ht, dt),
              (ut = createSizedArray(at - 1))
            var _t = 0
            for (st = 0; st < at; st += 1)
              if (tt[st].ty === "sh") {
                for (
                  _e = tt[st].ks.k.i.length, ot = tt[st].ks.k, it = [], $ = 1;
                  $ < _e;
                  $ += 1
                )
                  $ === 1 &&
                    it.push(
                      _.applyToX(ot.v[0][0], ot.v[0][1], 0),
                      _.applyToY(ot.v[0][0], ot.v[0][1], 0)
                    ),
                    it.push(
                      _.applyToX(ot.o[$ - 1][0], ot.o[$ - 1][1], 0),
                      _.applyToY(ot.o[$ - 1][0], ot.o[$ - 1][1], 0),
                      _.applyToX(ot.i[$][0], ot.i[$][1], 0),
                      _.applyToY(ot.i[$][0], ot.i[$][1], 0),
                      _.applyToX(ot.v[$][0], ot.v[$][1], 0),
                      _.applyToY(ot.v[$][0], ot.v[$][1], 0)
                    )
                it.push(
                  _.applyToX(ot.o[$ - 1][0], ot.o[$ - 1][1], 0),
                  _.applyToY(ot.o[$ - 1][0], ot.o[$ - 1][1], 0),
                  _.applyToX(ot.i[0][0], ot.i[0][1], 0),
                  _.applyToY(ot.i[0][0], ot.i[0][1], 0),
                  _.applyToX(ot.v[0][0], ot.v[0][1], 0),
                  _.applyToY(ot.v[0][0], ot.v[0][1], 0)
                ),
                  (ut[_t] = it),
                  (_t += 1)
              }
            ct && ((ht += g[c].l), (ht += lt)),
              this.textSpans[vt]
                ? (this.textSpans[vt].elem = ut)
                : (this.textSpans[vt] = { elem: ut }),
              (vt += 1)
          }
        }),
        (CVTextElement.prototype.renderInnerContent = function () {
          this.validateText()
          var s = this.canvasContext
          ;(s.font = this.values.fValue),
            this.globalData.renderer.ctxLineCap("butt"),
            this.globalData.renderer.ctxLineJoin("miter"),
            this.globalData.renderer.ctxMiterLimit(4),
            this.data.singleShape ||
              this.textAnimator.getMeasures(
                this.textProperty.currentData,
                this.lettersChangedFlag
              )
          var e,
            a,
            o,
            c,
            d,
            g,
            _ = this.textAnimator.renderedLetters,
            b = this.textProperty.currentData.l
          a = b.length
          var j,
            $ = null,
            _e = null,
            tt = null,
            st,
            at,
            ot = this.globalData.renderer
          for (e = 0; e < a; e += 1)
            if (!b[e].n) {
              if (
                ((j = _[e]),
                j && (ot.save(), ot.ctxTransform(j.p), ot.ctxOpacity(j.o)),
                this.fill)
              ) {
                for (
                  j && j.fc
                    ? $ !== j.fc && (ot.ctxFillStyle(j.fc), ($ = j.fc))
                    : $ !== this.values.fill &&
                      (($ = this.values.fill),
                      ot.ctxFillStyle(this.values.fill)),
                    st = this.textSpans[e].elem,
                    c = st.length,
                    this.globalData.canvasContext.beginPath(),
                    o = 0;
                  o < c;
                  o += 1
                )
                  for (
                    at = st[o],
                      g = at.length,
                      this.globalData.canvasContext.moveTo(at[0], at[1]),
                      d = 2;
                    d < g;
                    d += 6
                  )
                    this.globalData.canvasContext.bezierCurveTo(
                      at[d],
                      at[d + 1],
                      at[d + 2],
                      at[d + 3],
                      at[d + 4],
                      at[d + 5]
                    )
                this.globalData.canvasContext.closePath(), ot.ctxFill()
              }
              if (this.stroke) {
                for (
                  j && j.sw
                    ? tt !== j.sw && ((tt = j.sw), ot.ctxLineWidth(j.sw))
                    : tt !== this.values.sWidth &&
                      ((tt = this.values.sWidth),
                      ot.ctxLineWidth(this.values.sWidth)),
                    j && j.sc
                      ? _e !== j.sc && ((_e = j.sc), ot.ctxStrokeStyle(j.sc))
                      : _e !== this.values.stroke &&
                        ((_e = this.values.stroke),
                        ot.ctxStrokeStyle(this.values.stroke)),
                    st = this.textSpans[e].elem,
                    c = st.length,
                    this.globalData.canvasContext.beginPath(),
                    o = 0;
                  o < c;
                  o += 1
                )
                  for (
                    at = st[o],
                      g = at.length,
                      this.globalData.canvasContext.moveTo(at[0], at[1]),
                      d = 2;
                    d < g;
                    d += 6
                  )
                    this.globalData.canvasContext.bezierCurveTo(
                      at[d],
                      at[d + 1],
                      at[d + 2],
                      at[d + 3],
                      at[d + 4],
                      at[d + 5]
                    )
                this.globalData.canvasContext.closePath(), ot.ctxStroke()
              }
              j && this.globalData.renderer.restore()
            }
        })
      function CVImageElement(s, e, a) {
        ;(this.assetData = e.getAssetData(s.refId)),
          (this.img = e.imageLoader.getAsset(this.assetData)),
          this.initElement(s, e, a)
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVImageElement
      ),
        (CVImageElement.prototype.initElement =
          SVGShapeElement.prototype.initElement),
        (CVImageElement.prototype.prepareFrame =
          IImageElement.prototype.prepareFrame),
        (CVImageElement.prototype.createContent = function () {
          if (
            this.img.width &&
            (this.assetData.w !== this.img.width ||
              this.assetData.h !== this.img.height)
          ) {
            var s = createTag("canvas")
            ;(s.width = this.assetData.w), (s.height = this.assetData.h)
            var e = s.getContext("2d"),
              a = this.img.width,
              o = this.img.height,
              c = a / o,
              d = this.assetData.w / this.assetData.h,
              g,
              _,
              b =
                this.assetData.pr ||
                this.globalData.renderConfig.imagePreserveAspectRatio
            ;(c > d && b === "xMidYMid slice") ||
            (c < d && b !== "xMidYMid slice")
              ? ((_ = o), (g = _ * d))
              : ((g = a), (_ = g / d)),
              e.drawImage(
                this.img,
                (a - g) / 2,
                (o - _) / 2,
                g,
                _,
                0,
                0,
                this.assetData.w,
                this.assetData.h
              ),
              (this.img = s)
          }
        }),
        (CVImageElement.prototype.renderInnerContent = function () {
          this.canvasContext.drawImage(this.img, 0, 0)
        }),
        (CVImageElement.prototype.destroy = function () {
          this.img = null
        })
      function CVSolidElement(s, e, a) {
        this.initElement(s, e, a)
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          CVBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        CVSolidElement
      ),
        (CVSolidElement.prototype.initElement =
          SVGShapeElement.prototype.initElement),
        (CVSolidElement.prototype.prepareFrame =
          IImageElement.prototype.prepareFrame),
        (CVSolidElement.prototype.renderInnerContent = function () {
          this.globalData.renderer.ctxFillStyle(this.data.sc),
            this.globalData.renderer.ctxFillRect(
              0,
              0,
              this.data.sw,
              this.data.sh
            )
        })
      function CanvasRendererBase() {}
      extendPrototype([BaseRenderer], CanvasRendererBase),
        (CanvasRendererBase.prototype.createShape = function (s) {
          return new CVShapeElement(s, this.globalData, this)
        }),
        (CanvasRendererBase.prototype.createText = function (s) {
          return new CVTextElement(s, this.globalData, this)
        }),
        (CanvasRendererBase.prototype.createImage = function (s) {
          return new CVImageElement(s, this.globalData, this)
        }),
        (CanvasRendererBase.prototype.createSolid = function (s) {
          return new CVSolidElement(s, this.globalData, this)
        }),
        (CanvasRendererBase.prototype.createNull =
          SVGRenderer.prototype.createNull),
        (CanvasRendererBase.prototype.ctxTransform = function (s) {
          ;(s[0] === 1 &&
            s[1] === 0 &&
            s[4] === 0 &&
            s[5] === 1 &&
            s[12] === 0 &&
            s[13] === 0) ||
            this.canvasContext.transform(s[0], s[1], s[4], s[5], s[12], s[13])
        }),
        (CanvasRendererBase.prototype.ctxOpacity = function (s) {
          this.canvasContext.globalAlpha *= s < 0 ? 0 : s
        }),
        (CanvasRendererBase.prototype.ctxFillStyle = function (s) {
          this.canvasContext.fillStyle = s
        }),
        (CanvasRendererBase.prototype.ctxStrokeStyle = function (s) {
          this.canvasContext.strokeStyle = s
        }),
        (CanvasRendererBase.prototype.ctxLineWidth = function (s) {
          this.canvasContext.lineWidth = s
        }),
        (CanvasRendererBase.prototype.ctxLineCap = function (s) {
          this.canvasContext.lineCap = s
        }),
        (CanvasRendererBase.prototype.ctxLineJoin = function (s) {
          this.canvasContext.lineJoin = s
        }),
        (CanvasRendererBase.prototype.ctxMiterLimit = function (s) {
          this.canvasContext.miterLimit = s
        }),
        (CanvasRendererBase.prototype.ctxFill = function (s) {
          this.canvasContext.fill(s)
        }),
        (CanvasRendererBase.prototype.ctxFillRect = function (s, e, a, o) {
          this.canvasContext.fillRect(s, e, a, o)
        }),
        (CanvasRendererBase.prototype.ctxStroke = function () {
          this.canvasContext.stroke()
        }),
        (CanvasRendererBase.prototype.reset = function () {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore()
            return
          }
          this.contextData.reset()
        }),
        (CanvasRendererBase.prototype.save = function () {
          this.canvasContext.save()
        }),
        (CanvasRendererBase.prototype.restore = function (s) {
          if (!this.renderConfig.clearCanvas) {
            this.canvasContext.restore()
            return
          }
          s && (this.globalData.blendMode = "source-over"),
            this.contextData.restore(s)
        }),
        (CanvasRendererBase.prototype.configAnimation = function (s) {
          if (this.animationItem.wrapper) {
            this.animationItem.container = createTag("canvas")
            var e = this.animationItem.container.style
            ;(e.width = "100%"), (e.height = "100%")
            var a = "0px 0px 0px"
            ;(e.transformOrigin = a),
              (e.mozTransformOrigin = a),
              (e.webkitTransformOrigin = a),
              (e["-webkit-transform"] = a),
              (e.contentVisibility = this.renderConfig.contentVisibility),
              this.animationItem.wrapper.appendChild(
                this.animationItem.container
              ),
              (this.canvasContext =
                this.animationItem.container.getContext("2d")),
              this.renderConfig.className &&
                this.animationItem.container.setAttribute(
                  "class",
                  this.renderConfig.className
                ),
              this.renderConfig.id &&
                this.animationItem.container.setAttribute(
                  "id",
                  this.renderConfig.id
                )
          } else this.canvasContext = this.renderConfig.context
          this.contextData.setContext(this.canvasContext),
            (this.data = s),
            (this.layers = s.layers),
            (this.transformCanvas = {
              w: s.w,
              h: s.h,
              sx: 0,
              sy: 0,
              tx: 0,
              ty: 0,
            }),
            this.setupGlobalData(s, document.body),
            (this.globalData.canvasContext = this.canvasContext),
            (this.globalData.renderer = this),
            (this.globalData.isDashed = !1),
            (this.globalData.progressiveLoad =
              this.renderConfig.progressiveLoad),
            (this.globalData.transformCanvas = this.transformCanvas),
            (this.elements = createSizedArray(s.layers.length)),
            this.updateContainerSize()
        }),
        (CanvasRendererBase.prototype.updateContainerSize = function (s, e) {
          this.reset()
          var a, o
          s
            ? ((a = s),
              (o = e),
              (this.canvasContext.canvas.width = a),
              (this.canvasContext.canvas.height = o))
            : (this.animationItem.wrapper && this.animationItem.container
                ? ((a = this.animationItem.wrapper.offsetWidth),
                  (o = this.animationItem.wrapper.offsetHeight))
                : ((a = this.canvasContext.canvas.width),
                  (o = this.canvasContext.canvas.height)),
              (this.canvasContext.canvas.width = a * this.renderConfig.dpr),
              (this.canvasContext.canvas.height = o * this.renderConfig.dpr))
          var c, d
          if (
            this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 ||
            this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1
          ) {
            var g = this.renderConfig.preserveAspectRatio.split(" "),
              _ = g[1] || "meet",
              b = g[0] || "xMidYMid",
              j = b.substr(0, 4),
              $ = b.substr(4)
            ;(c = a / o),
              (d = this.transformCanvas.w / this.transformCanvas.h),
              (d > c && _ === "meet") || (d < c && _ === "slice")
                ? ((this.transformCanvas.sx =
                    a / (this.transformCanvas.w / this.renderConfig.dpr)),
                  (this.transformCanvas.sy =
                    a / (this.transformCanvas.w / this.renderConfig.dpr)))
                : ((this.transformCanvas.sx =
                    o / (this.transformCanvas.h / this.renderConfig.dpr)),
                  (this.transformCanvas.sy =
                    o / (this.transformCanvas.h / this.renderConfig.dpr))),
              j === "xMid" &&
              ((d < c && _ === "meet") || (d > c && _ === "slice"))
                ? (this.transformCanvas.tx =
                    ((a -
                      this.transformCanvas.w * (o / this.transformCanvas.h)) /
                      2) *
                    this.renderConfig.dpr)
                : j === "xMax" &&
                  ((d < c && _ === "meet") || (d > c && _ === "slice"))
                ? (this.transformCanvas.tx =
                    (a -
                      this.transformCanvas.w * (o / this.transformCanvas.h)) *
                    this.renderConfig.dpr)
                : (this.transformCanvas.tx = 0),
              $ === "YMid" &&
              ((d > c && _ === "meet") || (d < c && _ === "slice"))
                ? (this.transformCanvas.ty =
                    ((o -
                      this.transformCanvas.h * (a / this.transformCanvas.w)) /
                      2) *
                    this.renderConfig.dpr)
                : $ === "YMax" &&
                  ((d > c && _ === "meet") || (d < c && _ === "slice"))
                ? (this.transformCanvas.ty =
                    (o -
                      this.transformCanvas.h * (a / this.transformCanvas.w)) *
                    this.renderConfig.dpr)
                : (this.transformCanvas.ty = 0)
          } else
            this.renderConfig.preserveAspectRatio === "none"
              ? ((this.transformCanvas.sx =
                  a / (this.transformCanvas.w / this.renderConfig.dpr)),
                (this.transformCanvas.sy =
                  o / (this.transformCanvas.h / this.renderConfig.dpr)),
                (this.transformCanvas.tx = 0),
                (this.transformCanvas.ty = 0))
              : ((this.transformCanvas.sx = this.renderConfig.dpr),
                (this.transformCanvas.sy = this.renderConfig.dpr),
                (this.transformCanvas.tx = 0),
                (this.transformCanvas.ty = 0))
          ;(this.transformCanvas.props = [
            this.transformCanvas.sx,
            0,
            0,
            0,
            0,
            this.transformCanvas.sy,
            0,
            0,
            0,
            0,
            1,
            0,
            this.transformCanvas.tx,
            this.transformCanvas.ty,
            0,
            1,
          ]),
            this.ctxTransform(this.transformCanvas.props),
            this.canvasContext.beginPath(),
            this.canvasContext.rect(
              0,
              0,
              this.transformCanvas.w,
              this.transformCanvas.h
            ),
            this.canvasContext.closePath(),
            this.canvasContext.clip(),
            this.renderFrame(this.renderedFrame, !0)
        }),
        (CanvasRendererBase.prototype.destroy = function () {
          this.renderConfig.clearCanvas &&
            this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = "")
          var s,
            e = this.layers ? this.layers.length : 0
          for (s = e - 1; s >= 0; s -= 1)
            this.elements[s] &&
              this.elements[s].destroy &&
              this.elements[s].destroy()
          ;(this.elements.length = 0),
            (this.globalData.canvasContext = null),
            (this.animationItem.container = null),
            (this.destroyed = !0)
        }),
        (CanvasRendererBase.prototype.renderFrame = function (s, e) {
          if (
            !(
              (this.renderedFrame === s &&
                this.renderConfig.clearCanvas === !0 &&
                !e) ||
              this.destroyed ||
              s === -1
            )
          ) {
            ;(this.renderedFrame = s),
              (this.globalData.frameNum = s - this.animationItem._isFirstFrame),
              (this.globalData.frameId += 1),
              (this.globalData._mdf = !this.renderConfig.clearCanvas || e),
              (this.globalData.projectInterface.currentFrame = s)
            var a,
              o = this.layers.length
            for (
              this.completeLayers || this.checkLayers(s), a = o - 1;
              a >= 0;
              a -= 1
            )
              (this.completeLayers || this.elements[a]) &&
                this.elements[a].prepareFrame(s - this.layers[a].st)
            if (this.globalData._mdf) {
              for (
                this.renderConfig.clearCanvas === !0
                  ? this.canvasContext.clearRect(
                      0,
                      0,
                      this.transformCanvas.w,
                      this.transformCanvas.h
                    )
                  : this.save(),
                  a = o - 1;
                a >= 0;
                a -= 1
              )
                (this.completeLayers || this.elements[a]) &&
                  this.elements[a].renderFrame()
              this.renderConfig.clearCanvas !== !0 && this.restore()
            }
          }
        }),
        (CanvasRendererBase.prototype.buildItem = function (s) {
          var e = this.elements
          if (!(e[s] || this.layers[s].ty === 99)) {
            var a = this.createItem(this.layers[s], this, this.globalData)
            ;(e[s] = a), a.initExpressions()
          }
        }),
        (CanvasRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var s = this.pendingElements.pop()
            s.checkParenting()
          }
        }),
        (CanvasRendererBase.prototype.hide = function () {
          this.animationItem.container.style.display = "none"
        }),
        (CanvasRendererBase.prototype.show = function () {
          this.animationItem.container.style.display = "block"
        })
      function CanvasContext() {
        ;(this.opacity = -1),
          (this.transform = createTypedArray("float32", 16)),
          (this.fillStyle = ""),
          (this.strokeStyle = ""),
          (this.lineWidth = ""),
          (this.lineCap = ""),
          (this.lineJoin = ""),
          (this.miterLimit = ""),
          (this.id = Math.random())
      }
      function CVContextData() {
        ;(this.stack = []), (this.cArrPos = 0), (this.cTr = new Matrix())
        var s,
          e = 15
        for (s = 0; s < e; s += 1) {
          var a = new CanvasContext()
          this.stack[s] = a
        }
        ;(this._length = e),
          (this.nativeContext = null),
          (this.transformMat = new Matrix()),
          (this.currentOpacity = 1),
          (this.currentFillStyle = ""),
          (this.appliedFillStyle = ""),
          (this.currentStrokeStyle = ""),
          (this.appliedStrokeStyle = ""),
          (this.currentLineWidth = ""),
          (this.appliedLineWidth = ""),
          (this.currentLineCap = ""),
          (this.appliedLineCap = ""),
          (this.currentLineJoin = ""),
          (this.appliedLineJoin = ""),
          (this.appliedMiterLimit = ""),
          (this.currentMiterLimit = "")
      }
      ;(CVContextData.prototype.duplicate = function () {
        var s = this._length * 2,
          e = 0
        for (e = this._length; e < s; e += 1)
          this.stack[e] = new CanvasContext()
        this._length = s
      }),
        (CVContextData.prototype.reset = function () {
          ;(this.cArrPos = 0),
            this.cTr.reset(),
            (this.stack[this.cArrPos].opacity = 1)
        }),
        (CVContextData.prototype.restore = function (s) {
          this.cArrPos -= 1
          var e = this.stack[this.cArrPos],
            a = e.transform,
            o,
            c = this.cTr.props
          for (o = 0; o < 16; o += 1) c[o] = a[o]
          if (s) {
            this.nativeContext.restore()
            var d = this.stack[this.cArrPos + 1]
            ;(this.appliedFillStyle = d.fillStyle),
              (this.appliedStrokeStyle = d.strokeStyle),
              (this.appliedLineWidth = d.lineWidth),
              (this.appliedLineCap = d.lineCap),
              (this.appliedLineJoin = d.lineJoin),
              (this.appliedMiterLimit = d.miterLimit)
          }
          this.nativeContext.setTransform(a[0], a[1], a[4], a[5], a[12], a[13]),
            (s || (e.opacity !== -1 && this.currentOpacity !== e.opacity)) &&
              ((this.nativeContext.globalAlpha = e.opacity),
              (this.currentOpacity = e.opacity)),
            (this.currentFillStyle = e.fillStyle),
            (this.currentStrokeStyle = e.strokeStyle),
            (this.currentLineWidth = e.lineWidth),
            (this.currentLineCap = e.lineCap),
            (this.currentLineJoin = e.lineJoin),
            (this.currentMiterLimit = e.miterLimit)
        }),
        (CVContextData.prototype.save = function (s) {
          s && this.nativeContext.save()
          var e = this.cTr.props
          this._length <= this.cArrPos && this.duplicate()
          var a = this.stack[this.cArrPos],
            o
          for (o = 0; o < 16; o += 1) a.transform[o] = e[o]
          this.cArrPos += 1
          var c = this.stack[this.cArrPos]
          ;(c.opacity = a.opacity),
            (c.fillStyle = a.fillStyle),
            (c.strokeStyle = a.strokeStyle),
            (c.lineWidth = a.lineWidth),
            (c.lineCap = a.lineCap),
            (c.lineJoin = a.lineJoin),
            (c.miterLimit = a.miterLimit)
        }),
        (CVContextData.prototype.setOpacity = function (s) {
          this.stack[this.cArrPos].opacity = s
        }),
        (CVContextData.prototype.setContext = function (s) {
          this.nativeContext = s
        }),
        (CVContextData.prototype.fillStyle = function (s) {
          this.stack[this.cArrPos].fillStyle !== s &&
            ((this.currentFillStyle = s),
            (this.stack[this.cArrPos].fillStyle = s))
        }),
        (CVContextData.prototype.strokeStyle = function (s) {
          this.stack[this.cArrPos].strokeStyle !== s &&
            ((this.currentStrokeStyle = s),
            (this.stack[this.cArrPos].strokeStyle = s))
        }),
        (CVContextData.prototype.lineWidth = function (s) {
          this.stack[this.cArrPos].lineWidth !== s &&
            ((this.currentLineWidth = s),
            (this.stack[this.cArrPos].lineWidth = s))
        }),
        (CVContextData.prototype.lineCap = function (s) {
          this.stack[this.cArrPos].lineCap !== s &&
            ((this.currentLineCap = s), (this.stack[this.cArrPos].lineCap = s))
        }),
        (CVContextData.prototype.lineJoin = function (s) {
          this.stack[this.cArrPos].lineJoin !== s &&
            ((this.currentLineJoin = s),
            (this.stack[this.cArrPos].lineJoin = s))
        }),
        (CVContextData.prototype.miterLimit = function (s) {
          this.stack[this.cArrPos].miterLimit !== s &&
            ((this.currentMiterLimit = s),
            (this.stack[this.cArrPos].miterLimit = s))
        }),
        (CVContextData.prototype.transform = function (s) {
          this.transformMat.cloneFromProps(s)
          var e = this.cTr
          this.transformMat.multiply(e),
            e.cloneFromProps(this.transformMat.props)
          var a = e.props
          this.nativeContext.setTransform(a[0], a[1], a[4], a[5], a[12], a[13])
        }),
        (CVContextData.prototype.opacity = function (s) {
          var e = this.stack[this.cArrPos].opacity
          ;(e *= s < 0 ? 0 : s),
            this.stack[this.cArrPos].opacity !== e &&
              (this.currentOpacity !== s &&
                ((this.nativeContext.globalAlpha = s),
                (this.currentOpacity = s)),
              (this.stack[this.cArrPos].opacity = e))
        }),
        (CVContextData.prototype.fill = function (s) {
          this.appliedFillStyle !== this.currentFillStyle &&
            ((this.appliedFillStyle = this.currentFillStyle),
            (this.nativeContext.fillStyle = this.appliedFillStyle)),
            this.nativeContext.fill(s)
        }),
        (CVContextData.prototype.fillRect = function (s, e, a, o) {
          this.appliedFillStyle !== this.currentFillStyle &&
            ((this.appliedFillStyle = this.currentFillStyle),
            (this.nativeContext.fillStyle = this.appliedFillStyle)),
            this.nativeContext.fillRect(s, e, a, o)
        }),
        (CVContextData.prototype.stroke = function () {
          this.appliedStrokeStyle !== this.currentStrokeStyle &&
            ((this.appliedStrokeStyle = this.currentStrokeStyle),
            (this.nativeContext.strokeStyle = this.appliedStrokeStyle)),
            this.appliedLineWidth !== this.currentLineWidth &&
              ((this.appliedLineWidth = this.currentLineWidth),
              (this.nativeContext.lineWidth = this.appliedLineWidth)),
            this.appliedLineCap !== this.currentLineCap &&
              ((this.appliedLineCap = this.currentLineCap),
              (this.nativeContext.lineCap = this.appliedLineCap)),
            this.appliedLineJoin !== this.currentLineJoin &&
              ((this.appliedLineJoin = this.currentLineJoin),
              (this.nativeContext.lineJoin = this.appliedLineJoin)),
            this.appliedMiterLimit !== this.currentMiterLimit &&
              ((this.appliedMiterLimit = this.currentMiterLimit),
              (this.nativeContext.miterLimit = this.appliedMiterLimit)),
            this.nativeContext.stroke()
        })
      function CVCompElement(s, e, a) {
        ;(this.completeLayers = !1),
          (this.layers = s.layers),
          (this.pendingElements = []),
          (this.elements = createSizedArray(this.layers.length)),
          this.initElement(s, e, a),
          (this.tm = s.tm
            ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this)
            : { _placeholder: !0 })
      }
      extendPrototype(
        [CanvasRendererBase, ICompElement, CVBaseElement],
        CVCompElement
      ),
        (CVCompElement.prototype.renderInnerContent = function () {
          var s = this.canvasContext
          s.beginPath(),
            s.moveTo(0, 0),
            s.lineTo(this.data.w, 0),
            s.lineTo(this.data.w, this.data.h),
            s.lineTo(0, this.data.h),
            s.lineTo(0, 0),
            s.clip()
          var e,
            a = this.layers.length
          for (e = a - 1; e >= 0; e -= 1)
            (this.completeLayers || this.elements[e]) &&
              this.elements[e].renderFrame()
        }),
        (CVCompElement.prototype.destroy = function () {
          var s,
            e = this.layers.length
          for (s = e - 1; s >= 0; s -= 1)
            this.elements[s] && this.elements[s].destroy()
          ;(this.layers = null), (this.elements = null)
        }),
        (CVCompElement.prototype.createComp = function (s) {
          return new CVCompElement(s, this.globalData, this)
        })
      function CanvasRenderer(s, e) {
        ;(this.animationItem = s),
          (this.renderConfig = {
            clearCanvas: e && e.clearCanvas !== void 0 ? e.clearCanvas : !0,
            context: (e && e.context) || null,
            progressiveLoad: (e && e.progressiveLoad) || !1,
            preserveAspectRatio:
              (e && e.preserveAspectRatio) || "xMidYMid meet",
            imagePreserveAspectRatio:
              (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
            contentVisibility: (e && e.contentVisibility) || "visible",
            className: (e && e.className) || "",
            id: (e && e.id) || "",
            runExpressions:
              !e || e.runExpressions === void 0 || e.runExpressions,
          }),
          (this.renderConfig.dpr = (e && e.dpr) || 1),
          this.animationItem.wrapper &&
            (this.renderConfig.dpr =
              (e && e.dpr) || window.devicePixelRatio || 1),
          (this.renderedFrame = -1),
          (this.globalData = {
            frameNum: -1,
            _mdf: !1,
            renderConfig: this.renderConfig,
            currentGlobalAlpha: -1,
          }),
          (this.contextData = new CVContextData()),
          (this.elements = []),
          (this.pendingElements = []),
          (this.transformMat = new Matrix()),
          (this.completeLayers = !1),
          (this.rendererType = "canvas"),
          this.renderConfig.clearCanvas &&
            ((this.ctxTransform = this.contextData.transform.bind(
              this.contextData
            )),
            (this.ctxOpacity = this.contextData.opacity.bind(this.contextData)),
            (this.ctxFillStyle = this.contextData.fillStyle.bind(
              this.contextData
            )),
            (this.ctxStrokeStyle = this.contextData.strokeStyle.bind(
              this.contextData
            )),
            (this.ctxLineWidth = this.contextData.lineWidth.bind(
              this.contextData
            )),
            (this.ctxLineCap = this.contextData.lineCap.bind(this.contextData)),
            (this.ctxLineJoin = this.contextData.lineJoin.bind(
              this.contextData
            )),
            (this.ctxMiterLimit = this.contextData.miterLimit.bind(
              this.contextData
            )),
            (this.ctxFill = this.contextData.fill.bind(this.contextData)),
            (this.ctxFillRect = this.contextData.fillRect.bind(
              this.contextData
            )),
            (this.ctxStroke = this.contextData.stroke.bind(this.contextData)),
            (this.save = this.contextData.save.bind(this.contextData)))
      }
      extendPrototype([CanvasRendererBase], CanvasRenderer),
        (CanvasRenderer.prototype.createComp = function (s) {
          return new CVCompElement(s, this.globalData, this)
        })
      function HBaseElement() {}
      ;(HBaseElement.prototype = {
        checkBlendMode: function () {},
        initRendererElement: function () {
          ;(this.baseElement = createTag(this.data.tg || "div")),
            this.data.hasMask
              ? ((this.svgElement = createNS("svg")),
                (this.layerElement = createNS("g")),
                (this.maskedElement = this.layerElement),
                this.svgElement.appendChild(this.layerElement),
                this.baseElement.appendChild(this.svgElement))
              : (this.layerElement = this.baseElement),
            styleDiv(this.baseElement)
        },
        createContainerElements: function () {
          ;(this.renderableEffectsManager = new CVEffects(this)),
            (this.transformedElement = this.baseElement),
            (this.maskedElement = this.layerElement),
            this.data.ln && this.layerElement.setAttribute("id", this.data.ln),
            this.data.cl &&
              this.layerElement.setAttribute("class", this.data.cl),
            this.data.bm !== 0 && this.setBlendMode()
        },
        renderElement: function () {
          var e = this.transformedElement ? this.transformedElement.style : {}
          if (this.finalTransform._matMdf) {
            var a = this.finalTransform.mat.toCSS()
            ;(e.transform = a), (e.webkitTransform = a)
          }
          this.finalTransform._opMdf &&
            (e.opacity = this.finalTransform.mProp.o.v)
        },
        renderFrame: function () {
          this.data.hd ||
            this.hidden ||
            (this.renderTransform(),
            this.renderRenderable(),
            this.renderElement(),
            this.renderInnerContent(),
            this._isFirstFrame && (this._isFirstFrame = !1))
        },
        destroy: function () {
          ;(this.layerElement = null),
            (this.transformedElement = null),
            this.matteElement && (this.matteElement = null),
            this.maskManager &&
              (this.maskManager.destroy(), (this.maskManager = null))
        },
        createRenderableComponents: function () {
          this.maskManager = new MaskElement(this.data, this, this.globalData)
        },
        addEffects: function () {},
        setMatte: function () {},
      }),
        (HBaseElement.prototype.getBaseElement =
          SVGBaseElement.prototype.getBaseElement),
        (HBaseElement.prototype.destroyBaseElement =
          HBaseElement.prototype.destroy),
        (HBaseElement.prototype.buildElementParenting =
          BaseRenderer.prototype.buildElementParenting)
      function HSolidElement(s, e, a) {
        this.initElement(s, e, a)
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
        ],
        HSolidElement
      ),
        (HSolidElement.prototype.createContent = function () {
          var s
          this.data.hasMask
            ? ((s = createNS("rect")),
              s.setAttribute("width", this.data.sw),
              s.setAttribute("height", this.data.sh),
              s.setAttribute("fill", this.data.sc),
              this.svgElement.setAttribute("width", this.data.sw),
              this.svgElement.setAttribute("height", this.data.sh))
            : ((s = createTag("div")),
              (s.style.width = this.data.sw + "px"),
              (s.style.height = this.data.sh + "px"),
              (s.style.backgroundColor = this.data.sc)),
            this.layerElement.appendChild(s)
        })
      function HShapeElement(s, e, a) {
        ;(this.shapes = []),
          (this.shapesData = s.shapes),
          (this.stylesList = []),
          (this.shapeModifiers = []),
          (this.itemsData = []),
          (this.processedElements = []),
          (this.animatedContents = []),
          (this.shapesContainer = createNS("g")),
          this.initElement(s, e, a),
          (this.prevViewData = []),
          (this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 })
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HSolidElement,
          SVGShapeElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        HShapeElement
      ),
        (HShapeElement.prototype._renderShapeFrame =
          HShapeElement.prototype.renderInnerContent),
        (HShapeElement.prototype.createContent = function () {
          var s
          if (((this.baseElement.style.fontSize = 0), this.data.hasMask))
            this.layerElement.appendChild(this.shapesContainer),
              (s = this.svgElement)
          else {
            s = createNS("svg")
            var e = this.comp.data ? this.comp.data : this.globalData.compSize
            s.setAttribute("width", e.w),
              s.setAttribute("height", e.h),
              s.appendChild(this.shapesContainer),
              this.layerElement.appendChild(s)
          }
          this.searchShapes(
            this.shapesData,
            this.itemsData,
            this.prevViewData,
            this.shapesContainer,
            0,
            [],
            !0
          ),
            this.filterUniqueShapes(),
            (this.shapeCont = s)
        }),
        (HShapeElement.prototype.getTransformedPoint = function (s, e) {
          var a,
            o = s.length
          for (a = 0; a < o; a += 1)
            e = s[a].mProps.v.applyToPointArray(e[0], e[1], 0)
          return e
        }),
        (HShapeElement.prototype.calculateShapeBoundingBox = function (s, e) {
          var a = s.sh.v,
            o = s.transformers,
            c,
            d = a._length,
            g,
            _,
            b,
            j
          if (!(d <= 1)) {
            for (c = 0; c < d - 1; c += 1)
              (g = this.getTransformedPoint(o, a.v[c])),
                (_ = this.getTransformedPoint(o, a.o[c])),
                (b = this.getTransformedPoint(o, a.i[c + 1])),
                (j = this.getTransformedPoint(o, a.v[c + 1])),
                this.checkBounds(g, _, b, j, e)
            a.c &&
              ((g = this.getTransformedPoint(o, a.v[c])),
              (_ = this.getTransformedPoint(o, a.o[c])),
              (b = this.getTransformedPoint(o, a.i[0])),
              (j = this.getTransformedPoint(o, a.v[0])),
              this.checkBounds(g, _, b, j, e))
          }
        }),
        (HShapeElement.prototype.checkBounds = function (s, e, a, o, c) {
          this.getBoundsOfCurve(s, e, a, o)
          var d = this.shapeBoundingBox
          ;(c.x = bmMin(d.left, c.x)),
            (c.xMax = bmMax(d.right, c.xMax)),
            (c.y = bmMin(d.top, c.y)),
            (c.yMax = bmMax(d.bottom, c.yMax))
        }),
        (HShapeElement.prototype.shapeBoundingBox = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
        }),
        (HShapeElement.prototype.tempBoundingBox = {
          x: 0,
          xMax: 0,
          y: 0,
          yMax: 0,
          width: 0,
          height: 0,
        }),
        (HShapeElement.prototype.getBoundsOfCurve = function (s, e, a, o) {
          for (
            var c = [
                [s[0], o[0]],
                [s[1], o[1]],
              ],
              d,
              g,
              _,
              b,
              j,
              $,
              _e,
              tt = 0;
            tt < 2;
            ++tt
          )
            (g = 6 * s[tt] - 12 * e[tt] + 6 * a[tt]),
              (d = -3 * s[tt] + 9 * e[tt] - 9 * a[tt] + 3 * o[tt]),
              (_ = 3 * e[tt] - 3 * s[tt]),
              (g |= 0),
              (d |= 0),
              (_ |= 0),
              (d === 0 && g === 0) ||
                (d === 0
                  ? ((b = -_ / g),
                    b > 0 &&
                      b < 1 &&
                      c[tt].push(this.calculateF(b, s, e, a, o, tt)))
                  : ((j = g * g - 4 * _ * d),
                    j >= 0 &&
                      (($ = (-g + bmSqrt(j)) / (2 * d)),
                      $ > 0 &&
                        $ < 1 &&
                        c[tt].push(this.calculateF($, s, e, a, o, tt)),
                      (_e = (-g - bmSqrt(j)) / (2 * d)),
                      _e > 0 &&
                        _e < 1 &&
                        c[tt].push(this.calculateF(_e, s, e, a, o, tt)))))
          ;(this.shapeBoundingBox.left = bmMin.apply(null, c[0])),
            (this.shapeBoundingBox.top = bmMin.apply(null, c[1])),
            (this.shapeBoundingBox.right = bmMax.apply(null, c[0])),
            (this.shapeBoundingBox.bottom = bmMax.apply(null, c[1]))
        }),
        (HShapeElement.prototype.calculateF = function (s, e, a, o, c, d) {
          return (
            bmPow(1 - s, 3) * e[d] +
            3 * bmPow(1 - s, 2) * s * a[d] +
            3 * (1 - s) * bmPow(s, 2) * o[d] +
            bmPow(s, 3) * c[d]
          )
        }),
        (HShapeElement.prototype.calculateBoundingBox = function (s, e) {
          var a,
            o = s.length
          for (a = 0; a < o; a += 1)
            s[a] && s[a].sh
              ? this.calculateShapeBoundingBox(s[a], e)
              : s[a] && s[a].it
              ? this.calculateBoundingBox(s[a].it, e)
              : s[a] &&
                s[a].style &&
                s[a].w &&
                this.expandStrokeBoundingBox(s[a].w, e)
        }),
        (HShapeElement.prototype.expandStrokeBoundingBox = function (s, e) {
          var a = 0
          if (s.keyframes) {
            for (var o = 0; o < s.keyframes.length; o += 1) {
              var c = s.keyframes[o].s
              c > a && (a = c)
            }
            a *= s.mult
          } else a = s.v * s.mult
          ;(e.x -= a), (e.xMax += a), (e.y -= a), (e.yMax += a)
        }),
        (HShapeElement.prototype.currentBoxContains = function (s) {
          return (
            this.currentBBox.x <= s.x &&
            this.currentBBox.y <= s.y &&
            this.currentBBox.width + this.currentBBox.x >= s.x + s.width &&
            this.currentBBox.height + this.currentBBox.y >= s.y + s.height
          )
        }),
        (HShapeElement.prototype.renderInnerContent = function () {
          if (
            (this._renderShapeFrame(),
            !this.hidden && (this._isFirstFrame || this._mdf))
          ) {
            var s = this.tempBoundingBox,
              e = 999999
            if (
              ((s.x = e),
              (s.xMax = -e),
              (s.y = e),
              (s.yMax = -e),
              this.calculateBoundingBox(this.itemsData, s),
              (s.width = s.xMax < s.x ? 0 : s.xMax - s.x),
              (s.height = s.yMax < s.y ? 0 : s.yMax - s.y),
              this.currentBoxContains(s))
            )
              return
            var a = !1
            if (
              (this.currentBBox.w !== s.width &&
                ((this.currentBBox.w = s.width),
                this.shapeCont.setAttribute("width", s.width),
                (a = !0)),
              this.currentBBox.h !== s.height &&
                ((this.currentBBox.h = s.height),
                this.shapeCont.setAttribute("height", s.height),
                (a = !0)),
              a || this.currentBBox.x !== s.x || this.currentBBox.y !== s.y)
            ) {
              ;(this.currentBBox.w = s.width),
                (this.currentBBox.h = s.height),
                (this.currentBBox.x = s.x),
                (this.currentBBox.y = s.y),
                this.shapeCont.setAttribute(
                  "viewBox",
                  this.currentBBox.x +
                    " " +
                    this.currentBBox.y +
                    " " +
                    this.currentBBox.w +
                    " " +
                    this.currentBBox.h
                )
              var o = this.shapeCont.style,
                c =
                  "translate(" +
                  this.currentBBox.x +
                  "px," +
                  this.currentBBox.y +
                  "px)"
              ;(o.transform = c), (o.webkitTransform = c)
            }
          }
        })
      function HTextElement(s, e, a) {
        ;(this.textSpans = []),
          (this.textPaths = []),
          (this.currentBBox = { x: 999999, y: -999999, h: 0, w: 0 }),
          (this.renderType = "svg"),
          (this.isMasked = !1),
          this.initElement(s, e, a)
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HierarchyElement,
          FrameElement,
          RenderableDOMElement,
          ITextElement,
        ],
        HTextElement
      ),
        (HTextElement.prototype.createContent = function () {
          if (((this.isMasked = this.checkMasks()), this.isMasked)) {
            ;(this.renderType = "svg"),
              (this.compW = this.comp.data.w),
              (this.compH = this.comp.data.h),
              this.svgElement.setAttribute("width", this.compW),
              this.svgElement.setAttribute("height", this.compH)
            var s = createNS("g")
            this.maskedElement.appendChild(s), (this.innerElem = s)
          } else
            (this.renderType = "html"), (this.innerElem = this.layerElement)
          this.checkParenting()
        }),
        (HTextElement.prototype.buildNewText = function () {
          var s = this.textProperty.currentData
          this.renderedLetters = createSizedArray(s.l ? s.l.length : 0)
          var e = this.innerElem.style,
            a = s.fc ? this.buildColor(s.fc) : "rgba(0,0,0,0)"
          ;(e.fill = a),
            (e.color = a),
            s.sc &&
              ((e.stroke = this.buildColor(s.sc)),
              (e.strokeWidth = s.sw + "px"))
          var o = this.globalData.fontManager.getFontByName(s.f)
          if (!this.globalData.fontManager.chars)
            if (
              ((e.fontSize = s.finalSize + "px"),
              (e.lineHeight = s.finalSize + "px"),
              o.fClass)
            )
              this.innerElem.className = o.fClass
            else {
              e.fontFamily = o.fFamily
              var c = s.fWeight,
                d = s.fStyle
              ;(e.fontStyle = d), (e.fontWeight = c)
            }
          var g,
            _,
            b = s.l
          _ = b.length
          var j,
            $,
            _e,
            tt = this.mHelper,
            st,
            at = "",
            ot = 0
          for (g = 0; g < _; g += 1) {
            if (
              (this.globalData.fontManager.chars
                ? (this.textPaths[ot]
                    ? (j = this.textPaths[ot])
                    : ((j = createNS("path")),
                      j.setAttribute("stroke-linecap", lineCapEnum[1]),
                      j.setAttribute("stroke-linejoin", lineJoinEnum[2]),
                      j.setAttribute("stroke-miterlimit", "4")),
                  this.isMasked ||
                    (this.textSpans[ot]
                      ? (($ = this.textSpans[ot]), (_e = $.children[0]))
                      : (($ = createTag("div")),
                        ($.style.lineHeight = 0),
                        (_e = createNS("svg")),
                        _e.appendChild(j),
                        styleDiv($))))
                : this.isMasked
                ? (j = this.textPaths[ot]
                    ? this.textPaths[ot]
                    : createNS("text"))
                : this.textSpans[ot]
                ? (($ = this.textSpans[ot]), (j = this.textPaths[ot]))
                : (($ = createTag("span")),
                  styleDiv($),
                  (j = createTag("span")),
                  styleDiv(j),
                  $.appendChild(j)),
              this.globalData.fontManager.chars)
            ) {
              var ut = this.globalData.fontManager.getCharData(
                  s.finalText[g],
                  o.fStyle,
                  this.globalData.fontManager.getFontByName(s.f).fFamily
                ),
                it
              if (
                (ut ? (it = ut.data) : (it = null),
                tt.reset(),
                it &&
                  it.shapes &&
                  it.shapes.length &&
                  ((st = it.shapes[0].it),
                  tt.scale(s.finalSize / 100, s.finalSize / 100),
                  (at = this.createPathShape(tt, st)),
                  j.setAttribute("d", at)),
                this.isMasked)
              )
                this.innerElem.appendChild(j)
              else {
                if ((this.innerElem.appendChild($), it && it.shapes)) {
                  document.body.appendChild(_e)
                  var ct = _e.getBBox()
                  _e.setAttribute("width", ct.width + 2),
                    _e.setAttribute("height", ct.height + 2),
                    _e.setAttribute(
                      "viewBox",
                      ct.x -
                        1 +
                        " " +
                        (ct.y - 1) +
                        " " +
                        (ct.width + 2) +
                        " " +
                        (ct.height + 2)
                    )
                  var lt = _e.style,
                    ht = "translate(" + (ct.x - 1) + "px," + (ct.y - 1) + "px)"
                  ;(lt.transform = ht),
                    (lt.webkitTransform = ht),
                    (b[g].yOffset = ct.y - 1)
                } else _e.setAttribute("width", 1), _e.setAttribute("height", 1)
                $.appendChild(_e)
              }
            } else if (
              ((j.textContent = b[g].val),
              j.setAttributeNS(
                "http://www.w3.org/XML/1998/namespace",
                "xml:space",
                "preserve"
              ),
              this.isMasked)
            )
              this.innerElem.appendChild(j)
            else {
              this.innerElem.appendChild($)
              var dt = j.style,
                pt = "translate3d(0," + -s.finalSize / 1.2 + "px,0)"
              ;(dt.transform = pt), (dt.webkitTransform = pt)
            }
            this.isMasked ? (this.textSpans[ot] = j) : (this.textSpans[ot] = $),
              (this.textSpans[ot].style.display = "block"),
              (this.textPaths[ot] = j),
              (ot += 1)
          }
          for (; ot < this.textSpans.length; )
            (this.textSpans[ot].style.display = "none"), (ot += 1)
        }),
        (HTextElement.prototype.renderInnerContent = function () {
          this.validateText()
          var s
          if (this.data.singleShape) {
            if (!this._isFirstFrame && !this.lettersChangedFlag) return
            if (this.isMasked && this.finalTransform._matMdf) {
              this.svgElement.setAttribute(
                "viewBox",
                -this.finalTransform.mProp.p.v[0] +
                  " " +
                  -this.finalTransform.mProp.p.v[1] +
                  " " +
                  this.compW +
                  " " +
                  this.compH
              ),
                (s = this.svgElement.style)
              var e =
                "translate(" +
                -this.finalTransform.mProp.p.v[0] +
                "px," +
                -this.finalTransform.mProp.p.v[1] +
                "px)"
              ;(s.transform = e), (s.webkitTransform = e)
            }
          }
          if (
            (this.textAnimator.getMeasures(
              this.textProperty.currentData,
              this.lettersChangedFlag
            ),
            !(
              !this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag
            ))
          ) {
            var a,
              o,
              c = 0,
              d = this.textAnimator.renderedLetters,
              g = this.textProperty.currentData.l
            o = g.length
            var _, b, j
            for (a = 0; a < o; a += 1)
              g[a].n
                ? (c += 1)
                : ((b = this.textSpans[a]),
                  (j = this.textPaths[a]),
                  (_ = d[c]),
                  (c += 1),
                  _._mdf.m &&
                    (this.isMasked
                      ? b.setAttribute("transform", _.m)
                      : ((b.style.webkitTransform = _.m),
                        (b.style.transform = _.m))),
                  (b.style.opacity = _.o),
                  _.sw && _._mdf.sw && j.setAttribute("stroke-width", _.sw),
                  _.sc && _._mdf.sc && j.setAttribute("stroke", _.sc),
                  _.fc &&
                    _._mdf.fc &&
                    (j.setAttribute("fill", _.fc), (j.style.color = _.fc)))
            if (
              this.innerElem.getBBox &&
              !this.hidden &&
              (this._isFirstFrame || this._mdf)
            ) {
              var $ = this.innerElem.getBBox()
              this.currentBBox.w !== $.width &&
                ((this.currentBBox.w = $.width),
                this.svgElement.setAttribute("width", $.width)),
                this.currentBBox.h !== $.height &&
                  ((this.currentBBox.h = $.height),
                  this.svgElement.setAttribute("height", $.height))
              var _e = 1
              if (
                this.currentBBox.w !== $.width + _e * 2 ||
                this.currentBBox.h !== $.height + _e * 2 ||
                this.currentBBox.x !== $.x - _e ||
                this.currentBBox.y !== $.y - _e
              ) {
                ;(this.currentBBox.w = $.width + _e * 2),
                  (this.currentBBox.h = $.height + _e * 2),
                  (this.currentBBox.x = $.x - _e),
                  (this.currentBBox.y = $.y - _e),
                  this.svgElement.setAttribute(
                    "viewBox",
                    this.currentBBox.x +
                      " " +
                      this.currentBBox.y +
                      " " +
                      this.currentBBox.w +
                      " " +
                      this.currentBBox.h
                  ),
                  (s = this.svgElement.style)
                var tt =
                  "translate(" +
                  this.currentBBox.x +
                  "px," +
                  this.currentBBox.y +
                  "px)"
                ;(s.transform = tt), (s.webkitTransform = tt)
              }
            }
          }
        })
      function HCameraElement(s, e, a) {
        this.initFrame(), this.initBaseData(s, e, a), this.initHierarchy()
        var o = PropertyFactory.getProp
        if (
          ((this.pe = o(this, s.pe, 0, 0, this)),
          s.ks.p.s
            ? ((this.px = o(this, s.ks.p.x, 1, 0, this)),
              (this.py = o(this, s.ks.p.y, 1, 0, this)),
              (this.pz = o(this, s.ks.p.z, 1, 0, this)))
            : (this.p = o(this, s.ks.p, 1, 0, this)),
          s.ks.a && (this.a = o(this, s.ks.a, 1, 0, this)),
          s.ks.or.k.length && s.ks.or.k[0].to)
        ) {
          var c,
            d = s.ks.or.k.length
          for (c = 0; c < d; c += 1)
            (s.ks.or.k[c].to = null), (s.ks.or.k[c].ti = null)
        }
        ;(this.or = o(this, s.ks.or, 1, degToRads, this)),
          (this.or.sh = !0),
          (this.rx = o(this, s.ks.rx, 0, degToRads, this)),
          (this.ry = o(this, s.ks.ry, 0, degToRads, this)),
          (this.rz = o(this, s.ks.rz, 0, degToRads, this)),
          (this.mat = new Matrix()),
          (this._prevMat = new Matrix()),
          (this._isFirstFrame = !0),
          (this.finalTransform = { mProp: this })
      }
      extendPrototype(
        [BaseElement, FrameElement, HierarchyElement],
        HCameraElement
      ),
        (HCameraElement.prototype.setup = function () {
          var s,
            e = this.comp.threeDElements.length,
            a,
            o,
            c
          for (s = 0; s < e; s += 1)
            if (((a = this.comp.threeDElements[s]), a.type === "3d")) {
              ;(o = a.perspectiveElem.style), (c = a.container.style)
              var d = this.pe.v + "px",
                g = "0px 0px 0px",
                _ = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"
              ;(o.perspective = d),
                (o.webkitPerspective = d),
                (c.transformOrigin = g),
                (c.mozTransformOrigin = g),
                (c.webkitTransformOrigin = g),
                (o.transform = _),
                (o.webkitTransform = _)
            }
        }),
        (HCameraElement.prototype.createElements = function () {}),
        (HCameraElement.prototype.hide = function () {}),
        (HCameraElement.prototype.renderFrame = function () {
          var s = this._isFirstFrame,
            e,
            a
          if (this.hierarchy)
            for (a = this.hierarchy.length, e = 0; e < a; e += 1)
              s = this.hierarchy[e].finalTransform.mProp._mdf || s
          if (
            s ||
            this.pe._mdf ||
            (this.p && this.p._mdf) ||
            (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) ||
            this.rx._mdf ||
            this.ry._mdf ||
            this.rz._mdf ||
            this.or._mdf ||
            (this.a && this.a._mdf)
          ) {
            if ((this.mat.reset(), this.hierarchy))
              for (a = this.hierarchy.length - 1, e = a; e >= 0; e -= 1) {
                var o = this.hierarchy[e].finalTransform.mProp
                this.mat.translate(-o.p.v[0], -o.p.v[1], o.p.v[2]),
                  this.mat
                    .rotateX(-o.or.v[0])
                    .rotateY(-o.or.v[1])
                    .rotateZ(o.or.v[2]),
                  this.mat.rotateX(-o.rx.v).rotateY(-o.ry.v).rotateZ(o.rz.v),
                  this.mat.scale(1 / o.s.v[0], 1 / o.s.v[1], 1 / o.s.v[2]),
                  this.mat.translate(o.a.v[0], o.a.v[1], o.a.v[2])
              }
            if (
              (this.p
                ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2])
                : this.mat.translate(-this.px.v, -this.py.v, this.pz.v),
              this.a)
            ) {
              var c
              this.p
                ? (c = [
                    this.p.v[0] - this.a.v[0],
                    this.p.v[1] - this.a.v[1],
                    this.p.v[2] - this.a.v[2],
                  ])
                : (c = [
                    this.px.v - this.a.v[0],
                    this.py.v - this.a.v[1],
                    this.pz.v - this.a.v[2],
                  ])
              var d = Math.sqrt(
                  Math.pow(c[0], 2) + Math.pow(c[1], 2) + Math.pow(c[2], 2)
                ),
                g = [c[0] / d, c[1] / d, c[2] / d],
                _ = Math.sqrt(g[2] * g[2] + g[0] * g[0]),
                b = Math.atan2(g[1], _),
                j = Math.atan2(g[0], -g[2])
              this.mat.rotateY(j).rotateX(-b)
            }
            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v),
              this.mat
                .rotateX(-this.or.v[0])
                .rotateY(-this.or.v[1])
                .rotateZ(this.or.v[2]),
              this.mat.translate(
                this.globalData.compSize.w / 2,
                this.globalData.compSize.h / 2,
                0
              ),
              this.mat.translate(0, 0, this.pe.v)
            var $ = !this._prevMat.equals(this.mat)
            if (($ || this.pe._mdf) && this.comp.threeDElements) {
              a = this.comp.threeDElements.length
              var _e, tt, st
              for (e = 0; e < a; e += 1)
                if (((_e = this.comp.threeDElements[e]), _e.type === "3d")) {
                  if ($) {
                    var at = this.mat.toCSS()
                    ;(st = _e.container.style),
                      (st.transform = at),
                      (st.webkitTransform = at)
                  }
                  this.pe._mdf &&
                    ((tt = _e.perspectiveElem.style),
                    (tt.perspective = this.pe.v + "px"),
                    (tt.webkitPerspective = this.pe.v + "px"))
                }
              this.mat.clone(this._prevMat)
            }
          }
          this._isFirstFrame = !1
        }),
        (HCameraElement.prototype.prepareFrame = function (s) {
          this.prepareProperties(s, !0)
        }),
        (HCameraElement.prototype.destroy = function () {}),
        (HCameraElement.prototype.getBaseElement = function () {
          return null
        })
      function HImageElement(s, e, a) {
        ;(this.assetData = e.getAssetData(s.refId)), this.initElement(s, e, a)
      }
      extendPrototype(
        [
          BaseElement,
          TransformElement,
          HBaseElement,
          HSolidElement,
          HierarchyElement,
          FrameElement,
          RenderableElement,
        ],
        HImageElement
      ),
        (HImageElement.prototype.createContent = function () {
          var s = this.globalData.getAssetsPath(this.assetData),
            e = new Image()
          this.data.hasMask
            ? ((this.imageElem = createNS("image")),
              this.imageElem.setAttribute("width", this.assetData.w + "px"),
              this.imageElem.setAttribute("height", this.assetData.h + "px"),
              this.imageElem.setAttributeNS(
                "http://www.w3.org/1999/xlink",
                "href",
                s
              ),
              this.layerElement.appendChild(this.imageElem),
              this.baseElement.setAttribute("width", this.assetData.w),
              this.baseElement.setAttribute("height", this.assetData.h))
            : this.layerElement.appendChild(e),
            (e.crossOrigin = "anonymous"),
            (e.src = s),
            this.data.ln && this.baseElement.setAttribute("id", this.data.ln)
        })
      function HybridRendererBase(s, e) {
        ;(this.animationItem = s),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.renderConfig = {
            className: (e && e.className) || "",
            imagePreserveAspectRatio:
              (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
            hideOnTransparent: !(e && e.hideOnTransparent === !1),
            filterSize: {
              width: (e && e.filterSize && e.filterSize.width) || "400%",
              height: (e && e.filterSize && e.filterSize.height) || "400%",
              x: (e && e.filterSize && e.filterSize.x) || "-100%",
              y: (e && e.filterSize && e.filterSize.y) || "-100%",
            },
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            renderConfig: this.renderConfig,
          }),
          (this.pendingElements = []),
          (this.elements = []),
          (this.threeDElements = []),
          (this.destroyed = !1),
          (this.camera = null),
          (this.supports3d = !0),
          (this.rendererType = "html")
      }
      extendPrototype([BaseRenderer], HybridRendererBase),
        (HybridRendererBase.prototype.buildItem =
          SVGRenderer.prototype.buildItem),
        (HybridRendererBase.prototype.checkPendingElements = function () {
          for (; this.pendingElements.length; ) {
            var s = this.pendingElements.pop()
            s.checkParenting()
          }
        }),
        (HybridRendererBase.prototype.appendElementInPos = function (s, e) {
          var a = s.getBaseElement()
          if (a) {
            var o = this.layers[e]
            if (!o.ddd || !this.supports3d)
              if (this.threeDElements) this.addTo3dContainer(a, e)
              else {
                for (var c = 0, d, g, _; c < e; )
                  this.elements[c] &&
                    this.elements[c] !== !0 &&
                    this.elements[c].getBaseElement &&
                    ((g = this.elements[c]),
                    (_ = this.layers[c].ddd
                      ? this.getThreeDContainerByPos(c)
                      : g.getBaseElement()),
                    (d = _ || d)),
                    (c += 1)
                d
                  ? (!o.ddd || !this.supports3d) &&
                    this.layerElement.insertBefore(a, d)
                  : (!o.ddd || !this.supports3d) &&
                    this.layerElement.appendChild(a)
              }
            else this.addTo3dContainer(a, e)
          }
        }),
        (HybridRendererBase.prototype.createShape = function (s) {
          return this.supports3d
            ? new HShapeElement(s, this.globalData, this)
            : new SVGShapeElement(s, this.globalData, this)
        }),
        (HybridRendererBase.prototype.createText = function (s) {
          return this.supports3d
            ? new HTextElement(s, this.globalData, this)
            : new SVGTextLottieElement(s, this.globalData, this)
        }),
        (HybridRendererBase.prototype.createCamera = function (s) {
          return (
            (this.camera = new HCameraElement(s, this.globalData, this)),
            this.camera
          )
        }),
        (HybridRendererBase.prototype.createImage = function (s) {
          return this.supports3d
            ? new HImageElement(s, this.globalData, this)
            : new IImageElement(s, this.globalData, this)
        }),
        (HybridRendererBase.prototype.createSolid = function (s) {
          return this.supports3d
            ? new HSolidElement(s, this.globalData, this)
            : new ISolidElement(s, this.globalData, this)
        }),
        (HybridRendererBase.prototype.createNull =
          SVGRenderer.prototype.createNull),
        (HybridRendererBase.prototype.getThreeDContainerByPos = function (s) {
          for (var e = 0, a = this.threeDElements.length; e < a; ) {
            if (
              this.threeDElements[e].startPos <= s &&
              this.threeDElements[e].endPos >= s
            )
              return this.threeDElements[e].perspectiveElem
            e += 1
          }
          return null
        }),
        (HybridRendererBase.prototype.createThreeDContainer = function (s, e) {
          var a = createTag("div"),
            o,
            c
          styleDiv(a)
          var d = createTag("div")
          if ((styleDiv(d), e === "3d")) {
            ;(o = a.style),
              (o.width = this.globalData.compSize.w + "px"),
              (o.height = this.globalData.compSize.h + "px")
            var g = "50% 50%"
            ;(o.webkitTransformOrigin = g),
              (o.mozTransformOrigin = g),
              (o.transformOrigin = g),
              (c = d.style)
            var _ = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)"
            ;(c.transform = _), (c.webkitTransform = _)
          }
          a.appendChild(d)
          var b = {
            container: d,
            perspectiveElem: a,
            startPos: s,
            endPos: s,
            type: e,
          }
          return this.threeDElements.push(b), b
        }),
        (HybridRendererBase.prototype.build3dContainers = function () {
          var s,
            e = this.layers.length,
            a,
            o = ""
          for (s = 0; s < e; s += 1)
            this.layers[s].ddd && this.layers[s].ty !== 3
              ? (o !== "3d" &&
                  ((o = "3d"), (a = this.createThreeDContainer(s, "3d"))),
                (a.endPos = Math.max(a.endPos, s)))
              : (o !== "2d" &&
                  ((o = "2d"), (a = this.createThreeDContainer(s, "2d"))),
                (a.endPos = Math.max(a.endPos, s)))
          for (e = this.threeDElements.length, s = e - 1; s >= 0; s -= 1)
            this.resizerElem.appendChild(this.threeDElements[s].perspectiveElem)
        }),
        (HybridRendererBase.prototype.addTo3dContainer = function (s, e) {
          for (var a = 0, o = this.threeDElements.length; a < o; ) {
            if (e <= this.threeDElements[a].endPos) {
              for (var c = this.threeDElements[a].startPos, d; c < e; )
                this.elements[c] &&
                  this.elements[c].getBaseElement &&
                  (d = this.elements[c].getBaseElement()),
                  (c += 1)
              d
                ? this.threeDElements[a].container.insertBefore(s, d)
                : this.threeDElements[a].container.appendChild(s)
              break
            }
            a += 1
          }
        }),
        (HybridRendererBase.prototype.configAnimation = function (s) {
          var e = createTag("div"),
            a = this.animationItem.wrapper,
            o = e.style
          ;(o.width = s.w + "px"),
            (o.height = s.h + "px"),
            (this.resizerElem = e),
            styleDiv(e),
            (o.transformStyle = "flat"),
            (o.mozTransformStyle = "flat"),
            (o.webkitTransformStyle = "flat"),
            this.renderConfig.className &&
              e.setAttribute("class", this.renderConfig.className),
            a.appendChild(e),
            (o.overflow = "hidden")
          var c = createNS("svg")
          c.setAttribute("width", "1"),
            c.setAttribute("height", "1"),
            styleDiv(c),
            this.resizerElem.appendChild(c)
          var d = createNS("defs")
          c.appendChild(d),
            (this.data = s),
            this.setupGlobalData(s, c),
            (this.globalData.defs = d),
            (this.layers = s.layers),
            (this.layerElement = this.resizerElem),
            this.build3dContainers(),
            this.updateContainerSize()
        }),
        (HybridRendererBase.prototype.destroy = function () {
          this.animationItem.wrapper &&
            (this.animationItem.wrapper.innerText = ""),
            (this.animationItem.container = null),
            (this.globalData.defs = null)
          var s,
            e = this.layers ? this.layers.length : 0
          for (s = 0; s < e; s += 1)
            this.elements[s] &&
              this.elements[s].destroy &&
              this.elements[s].destroy()
          ;(this.elements.length = 0),
            (this.destroyed = !0),
            (this.animationItem = null)
        }),
        (HybridRendererBase.prototype.updateContainerSize = function () {
          var s = this.animationItem.wrapper.offsetWidth,
            e = this.animationItem.wrapper.offsetHeight,
            a = s / e,
            o = this.globalData.compSize.w / this.globalData.compSize.h,
            c,
            d,
            g,
            _
          o > a
            ? ((c = s / this.globalData.compSize.w),
              (d = s / this.globalData.compSize.w),
              (g = 0),
              (_ =
                (e -
                  this.globalData.compSize.h *
                    (s / this.globalData.compSize.w)) /
                2))
            : ((c = e / this.globalData.compSize.h),
              (d = e / this.globalData.compSize.h),
              (g =
                (s -
                  this.globalData.compSize.w *
                    (e / this.globalData.compSize.h)) /
                2),
              (_ = 0))
          var b = this.resizerElem.style
          ;(b.webkitTransform =
            "matrix3d(" +
            c +
            ",0,0,0,0," +
            d +
            ",0,0,0,0,1,0," +
            g +
            "," +
            _ +
            ",0,1)"),
            (b.transform = b.webkitTransform)
        }),
        (HybridRendererBase.prototype.renderFrame =
          SVGRenderer.prototype.renderFrame),
        (HybridRendererBase.prototype.hide = function () {
          this.resizerElem.style.display = "none"
        }),
        (HybridRendererBase.prototype.show = function () {
          this.resizerElem.style.display = "block"
        }),
        (HybridRendererBase.prototype.initItems = function () {
          if ((this.buildAllItems(), this.camera)) this.camera.setup()
          else {
            var s = this.globalData.compSize.w,
              e = this.globalData.compSize.h,
              a,
              o = this.threeDElements.length
            for (a = 0; a < o; a += 1) {
              var c = this.threeDElements[a].perspectiveElem.style
              ;(c.webkitPerspective =
                Math.sqrt(Math.pow(s, 2) + Math.pow(e, 2)) + "px"),
                (c.perspective = c.webkitPerspective)
            }
          }
        }),
        (HybridRendererBase.prototype.searchExtraCompositions = function (s) {
          var e,
            a = s.length,
            o = createTag("div")
          for (e = 0; e < a; e += 1)
            if (s[e].xt) {
              var c = this.createComp(s[e], o, this.globalData.comp, null)
              c.initExpressions(),
                this.globalData.projectInterface.registerComposition(c)
            }
        })
      function HCompElement(s, e, a) {
        ;(this.layers = s.layers),
          (this.supports3d = !s.hasMask),
          (this.completeLayers = !1),
          (this.pendingElements = []),
          (this.elements = this.layers
            ? createSizedArray(this.layers.length)
            : []),
          this.initElement(s, e, a),
          (this.tm = s.tm
            ? PropertyFactory.getProp(this, s.tm, 0, e.frameRate, this)
            : { _placeholder: !0 })
      }
      extendPrototype(
        [HybridRendererBase, ICompElement, HBaseElement],
        HCompElement
      ),
        (HCompElement.prototype._createBaseContainerElements =
          HCompElement.prototype.createContainerElements),
        (HCompElement.prototype.createContainerElements = function () {
          this._createBaseContainerElements(),
            this.data.hasMask
              ? (this.svgElement.setAttribute("width", this.data.w),
                this.svgElement.setAttribute("height", this.data.h),
                (this.transformedElement = this.baseElement))
              : (this.transformedElement = this.layerElement)
        }),
        (HCompElement.prototype.addTo3dContainer = function (s, e) {
          for (var a = 0, o; a < e; )
            this.elements[a] &&
              this.elements[a].getBaseElement &&
              (o = this.elements[a].getBaseElement()),
              (a += 1)
          o
            ? this.layerElement.insertBefore(s, o)
            : this.layerElement.appendChild(s)
        }),
        (HCompElement.prototype.createComp = function (s) {
          return this.supports3d
            ? new HCompElement(s, this.globalData, this)
            : new SVGCompElement(s, this.globalData, this)
        })
      function HybridRenderer(s, e) {
        ;(this.animationItem = s),
          (this.layers = null),
          (this.renderedFrame = -1),
          (this.renderConfig = {
            className: (e && e.className) || "",
            imagePreserveAspectRatio:
              (e && e.imagePreserveAspectRatio) || "xMidYMid slice",
            hideOnTransparent: !(e && e.hideOnTransparent === !1),
            filterSize: {
              width: (e && e.filterSize && e.filterSize.width) || "400%",
              height: (e && e.filterSize && e.filterSize.height) || "400%",
              x: (e && e.filterSize && e.filterSize.x) || "-100%",
              y: (e && e.filterSize && e.filterSize.y) || "-100%",
            },
            runExpressions:
              !e || e.runExpressions === void 0 || e.runExpressions,
          }),
          (this.globalData = {
            _mdf: !1,
            frameNum: -1,
            renderConfig: this.renderConfig,
          }),
          (this.pendingElements = []),
          (this.elements = []),
          (this.threeDElements = []),
          (this.destroyed = !1),
          (this.camera = null),
          (this.supports3d = !0),
          (this.rendererType = "html")
      }
      extendPrototype([HybridRendererBase], HybridRenderer),
        (HybridRenderer.prototype.createComp = function (s) {
          return this.supports3d
            ? new HCompElement(s, this.globalData, this)
            : new SVGCompElement(s, this.globalData, this)
        })
      var CompExpressionInterface = (function () {
        return function (s) {
          function e(a) {
            for (var o = 0, c = s.layers.length; o < c; ) {
              if (s.layers[o].nm === a || s.layers[o].ind === a)
                return s.elements[o].layerInterface
              o += 1
            }
            return null
          }
          return (
            Object.defineProperty(e, "_name", { value: s.data.nm }),
            (e.layer = e),
            (e.pixelAspect = 1),
            (e.height = s.data.h || s.globalData.compSize.h),
            (e.width = s.data.w || s.globalData.compSize.w),
            (e.pixelAspect = 1),
            (e.frameDuration = 1 / s.globalData.frameRate),
            (e.displayStartTime = 0),
            (e.numLayers = s.layers.length),
            e
          )
        }
      })()
      function _typeof$2(s) {
        "@babel/helpers - typeof"
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$2 = function (a) {
                return typeof a
              })
            : (_typeof$2 = function (a) {
                return a &&
                  typeof Symbol == "function" &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a
              }),
          _typeof$2(s)
        )
      }
      function seedRandom(s, e) {
        var a = this,
          o = 256,
          c = 6,
          d = 52,
          g = "random",
          _ = e.pow(o, c),
          b = e.pow(2, d),
          j = b * 2,
          $ = o - 1,
          _e
        function tt(lt, ht, dt) {
          var pt = []
          ht = ht === !0 ? { entropy: !0 } : ht || {}
          var vt = ut(
              ot(ht.entropy ? [lt, ct(s)] : lt === null ? it() : lt, 3),
              pt
            ),
            _t = new st(pt),
            yt = function () {
              for (var Rt = _t.g(c), Ft = _, kt = 0; Rt < b; )
                (Rt = (Rt + kt) * o), (Ft *= o), (kt = _t.g(1))
              for (; Rt >= j; ) (Rt /= 2), (Ft /= 2), (kt >>>= 1)
              return (Rt + kt) / Ft
            }
          return (
            (yt.int32 = function () {
              return _t.g(4) | 0
            }),
            (yt.quick = function () {
              return _t.g(4) / 4294967296
            }),
            (yt.double = yt),
            ut(ct(_t.S), s),
            (
              ht.pass ||
              dt ||
              function (Et, Rt, Ft, kt) {
                return (
                  kt &&
                    (kt.S && at(kt, _t),
                    (Et.state = function () {
                      return at(_t, {})
                    })),
                  Ft ? ((e[g] = Et), Rt) : Et
                )
              }
            )(yt, vt, "global" in ht ? ht.global : this == e, ht.state)
          )
        }
        e["seed" + g] = tt
        function st(lt) {
          var ht,
            dt = lt.length,
            pt = this,
            vt = 0,
            _t = (pt.i = pt.j = 0),
            yt = (pt.S = [])
          for (dt || (lt = [dt++]); vt < o; ) yt[vt] = vt++
          for (vt = 0; vt < o; vt++)
            (yt[vt] = yt[(_t = $ & (_t + lt[vt % dt] + (ht = yt[vt])))]),
              (yt[_t] = ht)
          pt.g = function (Et) {
            for (var Rt, Ft = 0, kt = pt.i, Nt = pt.j, Dt = pt.S; Et--; )
              (Rt = Dt[(kt = $ & (kt + 1))]),
                (Ft =
                  Ft * o +
                  Dt[$ & ((Dt[kt] = Dt[(Nt = $ & (Nt + Rt))]) + (Dt[Nt] = Rt))])
            return (pt.i = kt), (pt.j = Nt), Ft
          }
        }
        function at(lt, ht) {
          return (ht.i = lt.i), (ht.j = lt.j), (ht.S = lt.S.slice()), ht
        }
        function ot(lt, ht) {
          var dt = [],
            pt = _typeof$2(lt),
            vt
          if (ht && pt == "object")
            for (vt in lt)
              try {
                dt.push(ot(lt[vt], ht - 1))
              } catch {}
          return dt.length ? dt : pt == "string" ? lt : lt + "\0"
        }
        function ut(lt, ht) {
          for (var dt = lt + "", pt, vt = 0; vt < dt.length; )
            ht[$ & vt] = $ & ((pt ^= ht[$ & vt] * 19) + dt.charCodeAt(vt++))
          return ct(ht)
        }
        function it() {
          try {
            var lt = new Uint8Array(o)
            return (a.crypto || a.msCrypto).getRandomValues(lt), ct(lt)
          } catch {
            var ht = a.navigator,
              dt = ht && ht.plugins
            return [+new Date(), a, dt, a.screen, ct(s)]
          }
        }
        function ct(lt) {
          return String.fromCharCode.apply(0, lt)
        }
        ut(e.random(), s)
      }
      function initialize$2(s) {
        seedRandom([], s)
      }
      var propTypes = { SHAPE: "shape" }
      function _typeof$1(s) {
        "@babel/helpers - typeof"
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof$1 = function (a) {
                return typeof a
              })
            : (_typeof$1 = function (a) {
                return a &&
                  typeof Symbol == "function" &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a
              }),
          _typeof$1(s)
        )
      }
      var ExpressionManager = (function () {
          var ob = {},
            Math = BMMath,
            window = null,
            document = null,
            XMLHttpRequest = null,
            fetch = null,
            frames = null,
            _lottieGlobal = {}
          initialize$2(BMMath)
          function resetFrame() {
            _lottieGlobal = {}
          }
          function $bm_isInstanceOfArray(s) {
            return s.constructor === Array || s.constructor === Float32Array
          }
          function isNumerable(s, e) {
            return (
              s === "number" ||
              e instanceof Number ||
              s === "boolean" ||
              s === "string"
            )
          }
          function $bm_neg(s) {
            var e = _typeof$1(s)
            if (e === "number" || s instanceof Number || e === "boolean")
              return -s
            if ($bm_isInstanceOfArray(s)) {
              var a,
                o = s.length,
                c = []
              for (a = 0; a < o; a += 1) c[a] = -s[a]
              return c
            }
            return s.propType ? s.v : -s
          }
          var easeInBez = BezierFactory.getBezierEasing(
              0.333,
              0,
              0.833,
              0.833,
              "easeIn"
            ).get,
            easeOutBez = BezierFactory.getBezierEasing(
              0.167,
              0.167,
              0.667,
              1,
              "easeOut"
            ).get,
            easeInOutBez = BezierFactory.getBezierEasing(
              0.33,
              0,
              0.667,
              1,
              "easeInOut"
            ).get
          function sum(s, e) {
            var a = _typeof$1(s),
              o = _typeof$1(e)
            if (
              (isNumerable(a, s) && isNumerable(o, e)) ||
              a === "string" ||
              o === "string"
            )
              return s + e
            if ($bm_isInstanceOfArray(s) && isNumerable(o, e))
              return (s = s.slice(0)), (s[0] += e), s
            if (isNumerable(a, s) && $bm_isInstanceOfArray(e))
              return (e = e.slice(0)), (e[0] = s + e[0]), e
            if ($bm_isInstanceOfArray(s) && $bm_isInstanceOfArray(e)) {
              for (
                var c = 0, d = s.length, g = e.length, _ = [];
                c < d || c < g;

              )
                (typeof s[c] == "number" || s[c] instanceof Number) &&
                (typeof e[c] == "number" || e[c] instanceof Number)
                  ? (_[c] = s[c] + e[c])
                  : (_[c] = e[c] === void 0 ? s[c] : s[c] || e[c]),
                  (c += 1)
              return _
            }
            return 0
          }
          var add = sum
          function sub(s, e) {
            var a = _typeof$1(s),
              o = _typeof$1(e)
            if (isNumerable(a, s) && isNumerable(o, e))
              return (
                a === "string" && (s = parseInt(s, 10)),
                o === "string" && (e = parseInt(e, 10)),
                s - e
              )
            if ($bm_isInstanceOfArray(s) && isNumerable(o, e))
              return (s = s.slice(0)), (s[0] -= e), s
            if (isNumerable(a, s) && $bm_isInstanceOfArray(e))
              return (e = e.slice(0)), (e[0] = s - e[0]), e
            if ($bm_isInstanceOfArray(s) && $bm_isInstanceOfArray(e)) {
              for (
                var c = 0, d = s.length, g = e.length, _ = [];
                c < d || c < g;

              )
                (typeof s[c] == "number" || s[c] instanceof Number) &&
                (typeof e[c] == "number" || e[c] instanceof Number)
                  ? (_[c] = s[c] - e[c])
                  : (_[c] = e[c] === void 0 ? s[c] : s[c] || e[c]),
                  (c += 1)
              return _
            }
            return 0
          }
          function mul(s, e) {
            var a = _typeof$1(s),
              o = _typeof$1(e),
              c
            if (isNumerable(a, s) && isNumerable(o, e)) return s * e
            var d, g
            if ($bm_isInstanceOfArray(s) && isNumerable(o, e)) {
              for (
                g = s.length, c = createTypedArray("float32", g), d = 0;
                d < g;
                d += 1
              )
                c[d] = s[d] * e
              return c
            }
            if (isNumerable(a, s) && $bm_isInstanceOfArray(e)) {
              for (
                g = e.length, c = createTypedArray("float32", g), d = 0;
                d < g;
                d += 1
              )
                c[d] = s * e[d]
              return c
            }
            return 0
          }
          function div(s, e) {
            var a = _typeof$1(s),
              o = _typeof$1(e),
              c
            if (isNumerable(a, s) && isNumerable(o, e)) return s / e
            var d, g
            if ($bm_isInstanceOfArray(s) && isNumerable(o, e)) {
              for (
                g = s.length, c = createTypedArray("float32", g), d = 0;
                d < g;
                d += 1
              )
                c[d] = s[d] / e
              return c
            }
            if (isNumerable(a, s) && $bm_isInstanceOfArray(e)) {
              for (
                g = e.length, c = createTypedArray("float32", g), d = 0;
                d < g;
                d += 1
              )
                c[d] = s / e[d]
              return c
            }
            return 0
          }
          function mod(s, e) {
            return (
              typeof s == "string" && (s = parseInt(s, 10)),
              typeof e == "string" && (e = parseInt(e, 10)),
              s % e
            )
          }
          var $bm_sum = sum,
            $bm_sub = sub,
            $bm_mul = mul,
            $bm_div = div,
            $bm_mod = mod
          function clamp(s, e, a) {
            if (e > a) {
              var o = a
              ;(a = e), (e = o)
            }
            return Math.min(Math.max(s, e), a)
          }
          function radiansToDegrees(s) {
            return s / degToRads
          }
          var radians_to_degrees = radiansToDegrees
          function degreesToRadians(s) {
            return s * degToRads
          }
          var degrees_to_radians = radiansToDegrees,
            helperLengthArray = [0, 0, 0, 0, 0, 0]
          function length(s, e) {
            if (typeof s == "number" || s instanceof Number)
              return (e = e || 0), Math.abs(s - e)
            e || (e = helperLengthArray)
            var a,
              o = Math.min(s.length, e.length),
              c = 0
            for (a = 0; a < o; a += 1) c += Math.pow(e[a] - s[a], 2)
            return Math.sqrt(c)
          }
          function normalize(s) {
            return div(s, length(s))
          }
          function rgbToHsl(s) {
            var e = s[0],
              a = s[1],
              o = s[2],
              c = Math.max(e, a, o),
              d = Math.min(e, a, o),
              g,
              _,
              b = (c + d) / 2
            if (c === d) (g = 0), (_ = 0)
            else {
              var j = c - d
              switch (((_ = b > 0.5 ? j / (2 - c - d) : j / (c + d)), c)) {
                case e:
                  g = (a - o) / j + (a < o ? 6 : 0)
                  break
                case a:
                  g = (o - e) / j + 2
                  break
                case o:
                  g = (e - a) / j + 4
                  break
              }
              g /= 6
            }
            return [g, _, b, s[3]]
          }
          function hue2rgb(s, e, a) {
            return (
              a < 0 && (a += 1),
              a > 1 && (a -= 1),
              a < 1 / 6
                ? s + (e - s) * 6 * a
                : a < 1 / 2
                ? e
                : a < 2 / 3
                ? s + (e - s) * (2 / 3 - a) * 6
                : s
            )
          }
          function hslToRgb(s) {
            var e = s[0],
              a = s[1],
              o = s[2],
              c,
              d,
              g
            if (a === 0) (c = o), (g = o), (d = o)
            else {
              var _ = o < 0.5 ? o * (1 + a) : o + a - o * a,
                b = 2 * o - _
              ;(c = hue2rgb(b, _, e + 1 / 3)),
                (d = hue2rgb(b, _, e)),
                (g = hue2rgb(b, _, e - 1 / 3))
            }
            return [c, d, g, s[3]]
          }
          function linear(s, e, a, o, c) {
            if (
              ((o === void 0 || c === void 0) &&
                ((o = e), (c = a), (e = 0), (a = 1)),
              a < e)
            ) {
              var d = a
              ;(a = e), (e = d)
            }
            if (s <= e) return o
            if (s >= a) return c
            var g = a === e ? 0 : (s - e) / (a - e)
            if (!o.length) return o + (c - o) * g
            var _,
              b = o.length,
              j = createTypedArray("float32", b)
            for (_ = 0; _ < b; _ += 1) j[_] = o[_] + (c[_] - o[_]) * g
            return j
          }
          function random(s, e) {
            if (
              (e === void 0 &&
                (s === void 0 ? ((s = 0), (e = 1)) : ((e = s), (s = void 0))),
              e.length)
            ) {
              var a,
                o = e.length
              s || (s = createTypedArray("float32", o))
              var c = createTypedArray("float32", o),
                d = BMMath.random()
              for (a = 0; a < o; a += 1) c[a] = s[a] + d * (e[a] - s[a])
              return c
            }
            s === void 0 && (s = 0)
            var g = BMMath.random()
            return s + g * (e - s)
          }
          function createPath(s, e, a, o) {
            var c,
              d = s.length,
              g = shapePool.newElement()
            g.setPathData(!!o, d)
            var _ = [0, 0],
              b,
              j
            for (c = 0; c < d; c += 1)
              (b = e && e[c] ? e[c] : _),
                (j = a && a[c] ? a[c] : _),
                g.setTripleAt(
                  s[c][0],
                  s[c][1],
                  j[0] + s[c][0],
                  j[1] + s[c][1],
                  b[0] + s[c][0],
                  b[1] + s[c][1],
                  c,
                  !0
                )
            return g
          }
          function initiateExpression(elem, data, property) {
            function noOp(s) {
              return s
            }
            if (!elem.globalData.renderConfig.runExpressions) return noOp
            var val = data.x,
              needsVelocity = /velocity(?![\w\d])/.test(val),
              _needsRandom = val.indexOf("random") !== -1,
              elemType = elem.data.ty,
              transform,
              $bm_transform,
              content,
              effect,
              thisProperty = property
            ;(thisProperty.valueAtTime = thisProperty.getValueAtTime),
              Object.defineProperty(thisProperty, "value", {
                get: function () {
                  return thisProperty.v
                },
              }),
              (elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate),
              (elem.comp.displayStartTime = 0)
            var inPoint = elem.data.ip / elem.comp.globalData.frameRate,
              outPoint = elem.data.op / elem.comp.globalData.frameRate,
              width = elem.data.sw ? elem.data.sw : 0,
              height = elem.data.sh ? elem.data.sh : 0,
              name = elem.data.nm,
              loopIn,
              loop_in,
              loopOut,
              loop_out,
              smooth,
              toWorld,
              fromWorld,
              fromComp,
              toComp,
              fromCompToSurface,
              position,
              rotation,
              anchorPoint,
              scale,
              thisLayer,
              thisComp,
              mask,
              valueAtTime,
              velocityAtTime,
              scoped_bm_rt,
              expression_function = eval(
                "[function _expression_function(){" +
                  val +
                  ";scoped_bm_rt=$bm_rt}]"
              )[0],
              numKeys = property.kf ? data.k.length : 0,
              active = !this.data || this.data.hd !== !0,
              wiggle = function s(e, a) {
                var o,
                  c,
                  d = this.pv.length ? this.pv.length : 1,
                  g = createTypedArray("float32", d)
                e = 5
                var _ = Math.floor(time * e)
                for (o = 0, c = 0; o < _; ) {
                  for (c = 0; c < d; c += 1)
                    g[c] += -a + a * 2 * BMMath.random()
                  o += 1
                }
                var b = time * e,
                  j = b - Math.floor(b),
                  $ = createTypedArray("float32", d)
                if (d > 1) {
                  for (c = 0; c < d; c += 1)
                    $[c] =
                      this.pv[c] + g[c] + (-a + a * 2 * BMMath.random()) * j
                  return $
                }
                return this.pv + g[0] + (-a + a * 2 * BMMath.random()) * j
              }.bind(this)
            thisProperty.loopIn &&
              ((loopIn = thisProperty.loopIn.bind(thisProperty)),
              (loop_in = loopIn)),
              thisProperty.loopOut &&
                ((loopOut = thisProperty.loopOut.bind(thisProperty)),
                (loop_out = loopOut)),
              thisProperty.smooth &&
                (smooth = thisProperty.smooth.bind(thisProperty))
            function loopInDuration(s, e) {
              return loopIn(s, e, !0)
            }
            function loopOutDuration(s, e) {
              return loopOut(s, e, !0)
            }
            this.getValueAtTime &&
              (valueAtTime = this.getValueAtTime.bind(this)),
              this.getVelocityAtTime &&
                (velocityAtTime = this.getVelocityAtTime.bind(this))
            var comp = elem.comp.globalData.projectInterface.bind(
              elem.comp.globalData.projectInterface
            )
            function lookAt(s, e) {
              var a = [e[0] - s[0], e[1] - s[1], e[2] - s[2]],
                o =
                  Math.atan2(a[0], Math.sqrt(a[1] * a[1] + a[2] * a[2])) /
                  degToRads,
                c = -Math.atan2(a[1], a[2]) / degToRads
              return [c, o, 0]
            }
            function easeOut(s, e, a, o, c) {
              return applyEase(easeOutBez, s, e, a, o, c)
            }
            function easeIn(s, e, a, o, c) {
              return applyEase(easeInBez, s, e, a, o, c)
            }
            function ease(s, e, a, o, c) {
              return applyEase(easeInOutBez, s, e, a, o, c)
            }
            function applyEase(s, e, a, o, c, d) {
              c === void 0 ? ((c = a), (d = o)) : (e = (e - a) / (o - a)),
                e > 1 ? (e = 1) : e < 0 && (e = 0)
              var g = s(e)
              if ($bm_isInstanceOfArray(c)) {
                var _,
                  b = c.length,
                  j = createTypedArray("float32", b)
                for (_ = 0; _ < b; _ += 1) j[_] = (d[_] - c[_]) * g + c[_]
                return j
              }
              return (d - c) * g + c
            }
            function nearestKey(s) {
              var e,
                a = data.k.length,
                o,
                c
              if (!data.k.length || typeof data.k[0] == "number")
                (o = 0), (c = 0)
              else if (
                ((o = -1),
                (s *= elem.comp.globalData.frameRate),
                s < data.k[0].t)
              )
                (o = 1), (c = data.k[0].t)
              else {
                for (e = 0; e < a - 1; e += 1)
                  if (s === data.k[e].t) {
                    ;(o = e + 1), (c = data.k[e].t)
                    break
                  } else if (s > data.k[e].t && s < data.k[e + 1].t) {
                    s - data.k[e].t > data.k[e + 1].t - s
                      ? ((o = e + 2), (c = data.k[e + 1].t))
                      : ((o = e + 1), (c = data.k[e].t))
                    break
                  }
                o === -1 && ((o = e + 1), (c = data.k[e].t))
              }
              var d = {}
              return (
                (d.index = o), (d.time = c / elem.comp.globalData.frameRate), d
              )
            }
            function key(s) {
              var e, a, o
              if (!data.k.length || typeof data.k[0] == "number")
                throw new Error("The property has no keyframe at index " + s)
              ;(s -= 1),
                (e = {
                  time: data.k[s].t / elem.comp.globalData.frameRate,
                  value: [],
                })
              var c = Object.prototype.hasOwnProperty.call(data.k[s], "s")
                ? data.k[s].s
                : data.k[s - 1].e
              for (o = c.length, a = 0; a < o; a += 1)
                (e[a] = c[a]), (e.value[a] = c[a])
              return e
            }
            function framesToTime(s, e) {
              return e || (e = elem.comp.globalData.frameRate), s / e
            }
            function timeToFrames(s, e) {
              return (
                !s && s !== 0 && (s = time),
                e || (e = elem.comp.globalData.frameRate),
                s * e
              )
            }
            function seedRandom(s) {
              BMMath.seedrandom(randSeed + s)
            }
            function sourceRectAtTime() {
              return elem.sourceRectAtTime()
            }
            function substring(s, e) {
              return typeof value == "string"
                ? e === void 0
                  ? value.substring(s)
                  : value.substring(s, e)
                : ""
            }
            function substr(s, e) {
              return typeof value == "string"
                ? e === void 0
                  ? value.substr(s)
                  : value.substr(s, e)
                : ""
            }
            function posterizeTime(s) {
              ;(time = s === 0 ? 0 : Math.floor(time * s) / s),
                (value = valueAtTime(time))
            }
            var time,
              velocity,
              value,
              text,
              textIndex,
              textTotal,
              selectorValue,
              index = elem.data.ind,
              hasParent = !!(elem.hierarchy && elem.hierarchy.length),
              parent,
              randSeed = Math.floor(Math.random() * 1e6),
              globalData = elem.globalData
            function executeExpression(s) {
              return (
                (value = s),
                this.frameExpressionId === elem.globalData.frameId &&
                this.propType !== "textSelector"
                  ? value
                  : (this.propType === "textSelector" &&
                      ((textIndex = this.textIndex),
                      (textTotal = this.textTotal),
                      (selectorValue = this.selectorValue)),
                    thisLayer ||
                      ((text = elem.layerInterface.text),
                      (thisLayer = elem.layerInterface),
                      (thisComp = elem.comp.compInterface),
                      (toWorld = thisLayer.toWorld.bind(thisLayer)),
                      (fromWorld = thisLayer.fromWorld.bind(thisLayer)),
                      (fromComp = thisLayer.fromComp.bind(thisLayer)),
                      (toComp = thisLayer.toComp.bind(thisLayer)),
                      (mask = thisLayer.mask
                        ? thisLayer.mask.bind(thisLayer)
                        : null),
                      (fromCompToSurface = fromComp)),
                    transform ||
                      ((transform = elem.layerInterface(
                        "ADBE Transform Group"
                      )),
                      ($bm_transform = transform),
                      transform && (anchorPoint = transform.anchorPoint)),
                    elemType === 4 &&
                      !content &&
                      (content = thisLayer("ADBE Root Vectors Group")),
                    effect || (effect = thisLayer(4)),
                    (hasParent = !!(elem.hierarchy && elem.hierarchy.length)),
                    hasParent &&
                      !parent &&
                      (parent = elem.hierarchy[0].layerInterface),
                    (time =
                      this.comp.renderedFrame / this.comp.globalData.frameRate),
                    _needsRandom && seedRandom(randSeed + time),
                    needsVelocity && (velocity = velocityAtTime(time)),
                    expression_function(),
                    (this.frameExpressionId = elem.globalData.frameId),
                    (scoped_bm_rt =
                      scoped_bm_rt.propType === propTypes.SHAPE
                        ? scoped_bm_rt.v
                        : scoped_bm_rt),
                    scoped_bm_rt)
              )
            }
            return (
              (executeExpression.__preventDeadCodeRemoval = [
                $bm_transform,
                anchorPoint,
                time,
                velocity,
                inPoint,
                outPoint,
                width,
                height,
                name,
                loop_in,
                loop_out,
                smooth,
                toComp,
                fromCompToSurface,
                toWorld,
                fromWorld,
                mask,
                position,
                rotation,
                scale,
                thisComp,
                numKeys,
                active,
                wiggle,
                loopInDuration,
                loopOutDuration,
                comp,
                lookAt,
                easeOut,
                easeIn,
                ease,
                nearestKey,
                key,
                text,
                textIndex,
                textTotal,
                selectorValue,
                framesToTime,
                timeToFrames,
                sourceRectAtTime,
                substring,
                substr,
                posterizeTime,
                index,
                globalData,
              ]),
              executeExpression
            )
          }
          return (
            (ob.initiateExpression = initiateExpression),
            (ob.__preventDeadCodeRemoval = [
              window,
              document,
              XMLHttpRequest,
              fetch,
              frames,
              $bm_neg,
              add,
              $bm_sum,
              $bm_sub,
              $bm_mul,
              $bm_div,
              $bm_mod,
              clamp,
              radians_to_degrees,
              degreesToRadians,
              degrees_to_radians,
              normalize,
              rgbToHsl,
              hslToRgb,
              linear,
              random,
              createPath,
              _lottieGlobal,
            ]),
            (ob.resetFrame = resetFrame),
            ob
          )
        })(),
        Expressions = (function () {
          var s = {}
          ;(s.initExpressions = e),
            (s.resetFrame = ExpressionManager.resetFrame)
          function e(a) {
            var o = 0,
              c = []
            function d() {
              o += 1
            }
            function g() {
              ;(o -= 1), o === 0 && b()
            }
            function _(j) {
              c.indexOf(j) === -1 && c.push(j)
            }
            function b() {
              var j,
                $ = c.length
              for (j = 0; j < $; j += 1) c[j].release()
              c.length = 0
            }
            ;(a.renderer.compInterface = CompExpressionInterface(a.renderer)),
              a.renderer.globalData.projectInterface.registerComposition(
                a.renderer
              ),
              (a.renderer.globalData.pushExpression = d),
              (a.renderer.globalData.popExpression = g),
              (a.renderer.globalData.registerExpressionProperty = _)
          }
          return s
        })(),
        MaskManagerInterface = (function () {
          function s(a, o) {
            ;(this._mask = a), (this._data = o)
          }
          Object.defineProperty(s.prototype, "maskPath", {
            get: function () {
              return (
                this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop
              )
            },
          }),
            Object.defineProperty(s.prototype, "maskOpacity", {
              get: function () {
                return (
                  this._mask.op.k && this._mask.op.getValue(),
                  this._mask.op.v * 100
                )
              },
            })
          var e = function (o) {
            var c = createSizedArray(o.viewData.length),
              d,
              g = o.viewData.length
            for (d = 0; d < g; d += 1)
              c[d] = new s(o.viewData[d], o.masksProperties[d])
            var _ = function (j) {
              for (d = 0; d < g; ) {
                if (o.masksProperties[d].nm === j) return c[d]
                d += 1
              }
              return null
            }
            return _
          }
          return e
        })(),
        ExpressionPropertyInterface = (function () {
          var s = { pv: 0, v: 0, mult: 1 },
            e = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 }
          function a(g, _, b) {
            Object.defineProperty(g, "velocity", {
              get: function () {
                return _.getVelocityAtTime(_.comp.currentFrame)
              },
            }),
              (g.numKeys = _.keyframes ? _.keyframes.length : 0),
              (g.key = function (j) {
                if (!g.numKeys) return 0
                var $ = ""
                "s" in _.keyframes[j - 1]
                  ? ($ = _.keyframes[j - 1].s)
                  : "e" in _.keyframes[j - 2]
                  ? ($ = _.keyframes[j - 2].e)
                  : ($ = _.keyframes[j - 2].s)
                var _e =
                  b === "unidimensional" ? new Number($) : Object.assign({}, $)
                return (
                  (_e.time =
                    _.keyframes[j - 1].t / _.elem.comp.globalData.frameRate),
                  (_e.value = b === "unidimensional" ? $[0] : $),
                  _e
                )
              }),
              (g.valueAtTime = _.getValueAtTime),
              (g.speedAtTime = _.getSpeedAtTime),
              (g.velocityAtTime = _.getVelocityAtTime),
              (g.propertyGroup = _.propertyGroup)
          }
          function o(g) {
            ;(!g || !("pv" in g)) && (g = s)
            var _ = 1 / g.mult,
              b = g.pv * _,
              j = new Number(b)
            return (
              (j.value = b),
              a(j, g, "unidimensional"),
              function () {
                return (
                  g.k && g.getValue(),
                  (b = g.v * _),
                  j.value !== b &&
                    ((j = new Number(b)),
                    (j.value = b),
                    a(j, g, "unidimensional")),
                  j
                )
              }
            )
          }
          function c(g) {
            ;(!g || !("pv" in g)) && (g = e)
            var _ = 1 / g.mult,
              b = (g.data && g.data.l) || g.pv.length,
              j = createTypedArray("float32", b),
              $ = createTypedArray("float32", b)
            return (
              (j.value = $),
              a(j, g, "multidimensional"),
              function () {
                g.k && g.getValue()
                for (var _e = 0; _e < b; _e += 1)
                  ($[_e] = g.v[_e] * _), (j[_e] = $[_e])
                return j
              }
            )
          }
          function d() {
            return s
          }
          return function (g) {
            return g ? (g.propType === "unidimensional" ? o(g) : c(g)) : d
          }
        })(),
        TransformExpressionInterface = (function () {
          return function (s) {
            function e(g) {
              switch (g) {
                case "scale":
                case "Scale":
                case "ADBE Scale":
                case 6:
                  return e.scale
                case "rotation":
                case "Rotation":
                case "ADBE Rotation":
                case "ADBE Rotate Z":
                case 10:
                  return e.rotation
                case "ADBE Rotate X":
                  return e.xRotation
                case "ADBE Rotate Y":
                  return e.yRotation
                case "position":
                case "Position":
                case "ADBE Position":
                case 2:
                  return e.position
                case "ADBE Position_0":
                  return e.xPosition
                case "ADBE Position_1":
                  return e.yPosition
                case "ADBE Position_2":
                  return e.zPosition
                case "anchorPoint":
                case "AnchorPoint":
                case "Anchor Point":
                case "ADBE AnchorPoint":
                case 1:
                  return e.anchorPoint
                case "opacity":
                case "Opacity":
                case 11:
                  return e.opacity
                default:
                  return null
              }
            }
            Object.defineProperty(e, "rotation", {
              get: ExpressionPropertyInterface(s.r || s.rz),
            }),
              Object.defineProperty(e, "zRotation", {
                get: ExpressionPropertyInterface(s.rz || s.r),
              }),
              Object.defineProperty(e, "xRotation", {
                get: ExpressionPropertyInterface(s.rx),
              }),
              Object.defineProperty(e, "yRotation", {
                get: ExpressionPropertyInterface(s.ry),
              }),
              Object.defineProperty(e, "scale", {
                get: ExpressionPropertyInterface(s.s),
              })
            var a, o, c, d
            return (
              s.p
                ? (d = ExpressionPropertyInterface(s.p))
                : ((a = ExpressionPropertyInterface(s.px)),
                  (o = ExpressionPropertyInterface(s.py)),
                  s.pz && (c = ExpressionPropertyInterface(s.pz))),
              Object.defineProperty(e, "position", {
                get: function () {
                  return s.p ? d() : [a(), o(), c ? c() : 0]
                },
              }),
              Object.defineProperty(e, "xPosition", {
                get: ExpressionPropertyInterface(s.px),
              }),
              Object.defineProperty(e, "yPosition", {
                get: ExpressionPropertyInterface(s.py),
              }),
              Object.defineProperty(e, "zPosition", {
                get: ExpressionPropertyInterface(s.pz),
              }),
              Object.defineProperty(e, "anchorPoint", {
                get: ExpressionPropertyInterface(s.a),
              }),
              Object.defineProperty(e, "opacity", {
                get: ExpressionPropertyInterface(s.o),
              }),
              Object.defineProperty(e, "skew", {
                get: ExpressionPropertyInterface(s.sk),
              }),
              Object.defineProperty(e, "skewAxis", {
                get: ExpressionPropertyInterface(s.sa),
              }),
              Object.defineProperty(e, "orientation", {
                get: ExpressionPropertyInterface(s.or),
              }),
              e
            )
          }
        })(),
        LayerExpressionInterface = (function () {
          function s(j) {
            var $ = new Matrix()
            if (j !== void 0) {
              var _e = this._elem.finalTransform.mProp.getValueAtTime(j)
              _e.clone($)
            } else {
              var tt = this._elem.finalTransform.mProp
              tt.applyToMatrix($)
            }
            return $
          }
          function e(j, $) {
            var _e = this.getMatrix($)
            return (
              (_e.props[12] = 0),
              (_e.props[13] = 0),
              (_e.props[14] = 0),
              this.applyPoint(_e, j)
            )
          }
          function a(j, $) {
            var _e = this.getMatrix($)
            return this.applyPoint(_e, j)
          }
          function o(j, $) {
            var _e = this.getMatrix($)
            return (
              (_e.props[12] = 0),
              (_e.props[13] = 0),
              (_e.props[14] = 0),
              this.invertPoint(_e, j)
            )
          }
          function c(j, $) {
            var _e = this.getMatrix($)
            return this.invertPoint(_e, j)
          }
          function d(j, $) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var _e,
                tt = this._elem.hierarchy.length
              for (_e = 0; _e < tt; _e += 1)
                this._elem.hierarchy[_e].finalTransform.mProp.applyToMatrix(j)
            }
            return j.applyToPointArray($[0], $[1], $[2] || 0)
          }
          function g(j, $) {
            if (this._elem.hierarchy && this._elem.hierarchy.length) {
              var _e,
                tt = this._elem.hierarchy.length
              for (_e = 0; _e < tt; _e += 1)
                this._elem.hierarchy[_e].finalTransform.mProp.applyToMatrix(j)
            }
            return j.inversePoint($)
          }
          function _(j) {
            var $ = new Matrix()
            if (
              ($.reset(),
              this._elem.finalTransform.mProp.applyToMatrix($),
              this._elem.hierarchy && this._elem.hierarchy.length)
            ) {
              var _e,
                tt = this._elem.hierarchy.length
              for (_e = 0; _e < tt; _e += 1)
                this._elem.hierarchy[_e].finalTransform.mProp.applyToMatrix($)
              return $.inversePoint(j)
            }
            return $.inversePoint(j)
          }
          function b() {
            return [1, 1, 1, 1]
          }
          return function (j) {
            var $
            function _e(ot) {
              st.mask = new MaskManagerInterface(ot, j)
            }
            function tt(ot) {
              st.effect = ot
            }
            function st(ot) {
              switch (ot) {
                case "ADBE Root Vectors Group":
                case "Contents":
                case 2:
                  return st.shapeInterface
                case 1:
                case 6:
                case "Transform":
                case "transform":
                case "ADBE Transform Group":
                  return $
                case 4:
                case "ADBE Effect Parade":
                case "effects":
                case "Effects":
                  return st.effect
                case "ADBE Text Properties":
                  return st.textInterface
                default:
                  return null
              }
            }
            ;(st.getMatrix = s),
              (st.invertPoint = g),
              (st.applyPoint = d),
              (st.toWorld = a),
              (st.toWorldVec = e),
              (st.fromWorld = c),
              (st.fromWorldVec = o),
              (st.toComp = a),
              (st.fromComp = _),
              (st.sampleImage = b),
              (st.sourceRectAtTime = j.sourceRectAtTime.bind(j)),
              (st._elem = j),
              ($ = TransformExpressionInterface(j.finalTransform.mProp))
            var at = getDescriptor($, "anchorPoint")
            return (
              Object.defineProperties(st, {
                hasParent: {
                  get: function () {
                    return j.hierarchy.length
                  },
                },
                parent: {
                  get: function () {
                    return j.hierarchy[0].layerInterface
                  },
                },
                rotation: getDescriptor($, "rotation"),
                scale: getDescriptor($, "scale"),
                position: getDescriptor($, "position"),
                opacity: getDescriptor($, "opacity"),
                anchorPoint: at,
                anchor_point: at,
                transform: {
                  get: function () {
                    return $
                  },
                },
                active: {
                  get: function () {
                    return j.isInRange
                  },
                },
              }),
              (st.startTime = j.data.st),
              (st.index = j.data.ind),
              (st.source = j.data.refId),
              (st.height = j.data.ty === 0 ? j.data.h : 100),
              (st.width = j.data.ty === 0 ? j.data.w : 100),
              (st.inPoint = j.data.ip / j.comp.globalData.frameRate),
              (st.outPoint = j.data.op / j.comp.globalData.frameRate),
              (st._name = j.data.nm),
              (st.registerMaskInterface = _e),
              (st.registerEffectsInterface = tt),
              st
            )
          }
        })(),
        propertyGroupFactory = (function () {
          return function (s, e) {
            return function (a) {
              return (a = a === void 0 ? 1 : a), a <= 0 ? s : e(a - 1)
            }
          }
        })(),
        PropertyInterface = (function () {
          return function (s, e) {
            var a = { _name: s }
            function o(c) {
              return (c = c === void 0 ? 1 : c), c <= 0 ? a : e(c - 1)
            }
            return o
          }
        })(),
        EffectsExpressionInterface = (function () {
          var s = { createEffectsInterface: e }
          function e(c, d) {
            if (c.effectsManager) {
              var g = [],
                _ = c.data.ef,
                b,
                j = c.effectsManager.effectElements.length
              for (b = 0; b < j; b += 1)
                g.push(a(_[b], c.effectsManager.effectElements[b], d, c))
              var $ = c.data.ef || [],
                _e = function (st) {
                  for (b = 0, j = $.length; b < j; ) {
                    if (st === $[b].nm || st === $[b].mn || st === $[b].ix)
                      return g[b]
                    b += 1
                  }
                  return null
                }
              return (
                Object.defineProperty(_e, "numProperties", {
                  get: function () {
                    return $.length
                  },
                }),
                _e
              )
            }
            return null
          }
          function a(c, d, g, _) {
            function b(st) {
              for (var at = c.ef, ot = 0, ut = at.length; ot < ut; ) {
                if (st === at[ot].nm || st === at[ot].mn || st === at[ot].ix)
                  return at[ot].ty === 5 ? $[ot] : $[ot]()
                ot += 1
              }
              throw new Error()
            }
            var j = propertyGroupFactory(b, g),
              $ = [],
              _e,
              tt = c.ef.length
            for (_e = 0; _e < tt; _e += 1)
              c.ef[_e].ty === 5
                ? $.push(
                    a(
                      c.ef[_e],
                      d.effectElements[_e],
                      d.effectElements[_e].propertyGroup,
                      _
                    )
                  )
                : $.push(o(d.effectElements[_e], c.ef[_e].ty, _, j))
            return (
              c.mn === "ADBE Color Control" &&
                Object.defineProperty(b, "color", {
                  get: function () {
                    return $[0]()
                  },
                }),
              Object.defineProperties(b, {
                numProperties: {
                  get: function () {
                    return c.np
                  },
                },
                _name: { value: c.nm },
                propertyGroup: { value: j },
              }),
              (b.enabled = c.en !== 0),
              (b.active = b.enabled),
              b
            )
          }
          function o(c, d, g, _) {
            var b = ExpressionPropertyInterface(c.p)
            function j() {
              return d === 10 ? g.comp.compInterface(c.p.v) : b()
            }
            return (
              c.p.setGroupProperty &&
                c.p.setGroupProperty(PropertyInterface("", _)),
              j
            )
          }
          return s
        })(),
        ShapePathInterface = (function () {
          return function (e, a, o) {
            var c = a.sh
            function d(_) {
              return _ === "Shape" ||
                _ === "shape" ||
                _ === "Path" ||
                _ === "path" ||
                _ === "ADBE Vector Shape" ||
                _ === 2
                ? d.path
                : null
            }
            var g = propertyGroupFactory(d, o)
            return (
              c.setGroupProperty(PropertyInterface("Path", g)),
              Object.defineProperties(d, {
                path: {
                  get: function () {
                    return c.k && c.getValue(), c
                  },
                },
                shape: {
                  get: function () {
                    return c.k && c.getValue(), c
                  },
                },
                _name: { value: e.nm },
                ix: { value: e.ix },
                propertyIndex: { value: e.ix },
                mn: { value: e.mn },
                propertyGroup: { value: o },
              }),
              d
            )
          }
        })(),
        ShapeExpressionInterface = (function () {
          function s(at, ot, ut) {
            var it = [],
              ct,
              lt = at ? at.length : 0
            for (ct = 0; ct < lt; ct += 1)
              at[ct].ty === "gr"
                ? it.push(a(at[ct], ot[ct], ut))
                : at[ct].ty === "fl"
                ? it.push(o(at[ct], ot[ct], ut))
                : at[ct].ty === "st"
                ? it.push(g(at[ct], ot[ct], ut))
                : at[ct].ty === "tm"
                ? it.push(_(at[ct], ot[ct], ut))
                : at[ct].ty === "tr" ||
                  (at[ct].ty === "el"
                    ? it.push(j(at[ct], ot[ct], ut))
                    : at[ct].ty === "sr"
                    ? it.push($(at[ct], ot[ct], ut))
                    : at[ct].ty === "sh"
                    ? it.push(ShapePathInterface(at[ct], ot[ct], ut))
                    : at[ct].ty === "rc"
                    ? it.push(_e(at[ct], ot[ct], ut))
                    : at[ct].ty === "rd"
                    ? it.push(tt(at[ct], ot[ct], ut))
                    : at[ct].ty === "rp"
                    ? it.push(st(at[ct], ot[ct], ut))
                    : at[ct].ty === "gf"
                    ? it.push(c(at[ct], ot[ct], ut))
                    : it.push(d(at[ct], ot[ct])))
            return it
          }
          function e(at, ot, ut) {
            var it,
              ct = function (dt) {
                for (var pt = 0, vt = it.length; pt < vt; ) {
                  if (
                    it[pt]._name === dt ||
                    it[pt].mn === dt ||
                    it[pt].propertyIndex === dt ||
                    it[pt].ix === dt ||
                    it[pt].ind === dt
                  )
                    return it[pt]
                  pt += 1
                }
                return typeof dt == "number" ? it[dt - 1] : null
              }
            ;(ct.propertyGroup = propertyGroupFactory(ct, ut)),
              (it = s(at.it, ot.it, ct.propertyGroup)),
              (ct.numProperties = it.length)
            var lt = b(
              at.it[at.it.length - 1],
              ot.it[ot.it.length - 1],
              ct.propertyGroup
            )
            return (
              (ct.transform = lt),
              (ct.propertyIndex = at.cix),
              (ct._name = at.nm),
              ct
            )
          }
          function a(at, ot, ut) {
            var it = function (dt) {
              switch (dt) {
                case "ADBE Vectors Group":
                case "Contents":
                case 2:
                  return it.content
                default:
                  return it.transform
              }
            }
            it.propertyGroup = propertyGroupFactory(it, ut)
            var ct = e(at, ot, it.propertyGroup),
              lt = b(
                at.it[at.it.length - 1],
                ot.it[ot.it.length - 1],
                it.propertyGroup
              )
            return (
              (it.content = ct),
              (it.transform = lt),
              Object.defineProperty(it, "_name", {
                get: function () {
                  return at.nm
                },
              }),
              (it.numProperties = at.np),
              (it.propertyIndex = at.ix),
              (it.nm = at.nm),
              (it.mn = at.mn),
              it
            )
          }
          function o(at, ot, ut) {
            function it(ct) {
              return ct === "Color" || ct === "color"
                ? it.color
                : ct === "Opacity" || ct === "opacity"
                ? it.opacity
                : null
            }
            return (
              Object.defineProperties(it, {
                color: { get: ExpressionPropertyInterface(ot.c) },
                opacity: { get: ExpressionPropertyInterface(ot.o) },
                _name: { value: at.nm },
                mn: { value: at.mn },
              }),
              ot.c.setGroupProperty(PropertyInterface("Color", ut)),
              ot.o.setGroupProperty(PropertyInterface("Opacity", ut)),
              it
            )
          }
          function c(at, ot, ut) {
            function it(ct) {
              return ct === "Start Point" || ct === "start point"
                ? it.startPoint
                : ct === "End Point" || ct === "end point"
                ? it.endPoint
                : ct === "Opacity" || ct === "opacity"
                ? it.opacity
                : null
            }
            return (
              Object.defineProperties(it, {
                startPoint: { get: ExpressionPropertyInterface(ot.s) },
                endPoint: { get: ExpressionPropertyInterface(ot.e) },
                opacity: { get: ExpressionPropertyInterface(ot.o) },
                type: {
                  get: function () {
                    return "a"
                  },
                },
                _name: { value: at.nm },
                mn: { value: at.mn },
              }),
              ot.s.setGroupProperty(PropertyInterface("Start Point", ut)),
              ot.e.setGroupProperty(PropertyInterface("End Point", ut)),
              ot.o.setGroupProperty(PropertyInterface("Opacity", ut)),
              it
            )
          }
          function d() {
            function at() {
              return null
            }
            return at
          }
          function g(at, ot, ut) {
            var it = propertyGroupFactory(vt, ut),
              ct = propertyGroupFactory(pt, it)
            function lt(_t) {
              Object.defineProperty(pt, at.d[_t].nm, {
                get: ExpressionPropertyInterface(ot.d.dataProps[_t].p),
              })
            }
            var ht,
              dt = at.d ? at.d.length : 0,
              pt = {}
            for (ht = 0; ht < dt; ht += 1)
              lt(ht), ot.d.dataProps[ht].p.setGroupProperty(ct)
            function vt(_t) {
              return _t === "Color" || _t === "color"
                ? vt.color
                : _t === "Opacity" || _t === "opacity"
                ? vt.opacity
                : _t === "Stroke Width" || _t === "stroke width"
                ? vt.strokeWidth
                : null
            }
            return (
              Object.defineProperties(vt, {
                color: { get: ExpressionPropertyInterface(ot.c) },
                opacity: { get: ExpressionPropertyInterface(ot.o) },
                strokeWidth: { get: ExpressionPropertyInterface(ot.w) },
                dash: {
                  get: function () {
                    return pt
                  },
                },
                _name: { value: at.nm },
                mn: { value: at.mn },
              }),
              ot.c.setGroupProperty(PropertyInterface("Color", it)),
              ot.o.setGroupProperty(PropertyInterface("Opacity", it)),
              ot.w.setGroupProperty(PropertyInterface("Stroke Width", it)),
              vt
            )
          }
          function _(at, ot, ut) {
            function it(lt) {
              return lt === at.e.ix || lt === "End" || lt === "end"
                ? it.end
                : lt === at.s.ix
                ? it.start
                : lt === at.o.ix
                ? it.offset
                : null
            }
            var ct = propertyGroupFactory(it, ut)
            return (
              (it.propertyIndex = at.ix),
              ot.s.setGroupProperty(PropertyInterface("Start", ct)),
              ot.e.setGroupProperty(PropertyInterface("End", ct)),
              ot.o.setGroupProperty(PropertyInterface("Offset", ct)),
              (it.propertyIndex = at.ix),
              (it.propertyGroup = ut),
              Object.defineProperties(it, {
                start: { get: ExpressionPropertyInterface(ot.s) },
                end: { get: ExpressionPropertyInterface(ot.e) },
                offset: { get: ExpressionPropertyInterface(ot.o) },
                _name: { value: at.nm },
              }),
              (it.mn = at.mn),
              it
            )
          }
          function b(at, ot, ut) {
            function it(lt) {
              return at.a.ix === lt || lt === "Anchor Point"
                ? it.anchorPoint
                : at.o.ix === lt || lt === "Opacity"
                ? it.opacity
                : at.p.ix === lt || lt === "Position"
                ? it.position
                : at.r.ix === lt ||
                  lt === "Rotation" ||
                  lt === "ADBE Vector Rotation"
                ? it.rotation
                : at.s.ix === lt || lt === "Scale"
                ? it.scale
                : (at.sk && at.sk.ix === lt) || lt === "Skew"
                ? it.skew
                : (at.sa && at.sa.ix === lt) || lt === "Skew Axis"
                ? it.skewAxis
                : null
            }
            var ct = propertyGroupFactory(it, ut)
            return (
              ot.transform.mProps.o.setGroupProperty(
                PropertyInterface("Opacity", ct)
              ),
              ot.transform.mProps.p.setGroupProperty(
                PropertyInterface("Position", ct)
              ),
              ot.transform.mProps.a.setGroupProperty(
                PropertyInterface("Anchor Point", ct)
              ),
              ot.transform.mProps.s.setGroupProperty(
                PropertyInterface("Scale", ct)
              ),
              ot.transform.mProps.r.setGroupProperty(
                PropertyInterface("Rotation", ct)
              ),
              ot.transform.mProps.sk &&
                (ot.transform.mProps.sk.setGroupProperty(
                  PropertyInterface("Skew", ct)
                ),
                ot.transform.mProps.sa.setGroupProperty(
                  PropertyInterface("Skew Angle", ct)
                )),
              ot.transform.op.setGroupProperty(
                PropertyInterface("Opacity", ct)
              ),
              Object.defineProperties(it, {
                opacity: {
                  get: ExpressionPropertyInterface(ot.transform.mProps.o),
                },
                position: {
                  get: ExpressionPropertyInterface(ot.transform.mProps.p),
                },
                anchorPoint: {
                  get: ExpressionPropertyInterface(ot.transform.mProps.a),
                },
                scale: {
                  get: ExpressionPropertyInterface(ot.transform.mProps.s),
                },
                rotation: {
                  get: ExpressionPropertyInterface(ot.transform.mProps.r),
                },
                skew: {
                  get: ExpressionPropertyInterface(ot.transform.mProps.sk),
                },
                skewAxis: {
                  get: ExpressionPropertyInterface(ot.transform.mProps.sa),
                },
                _name: { value: at.nm },
              }),
              (it.ty = "tr"),
              (it.mn = at.mn),
              (it.propertyGroup = ut),
              it
            )
          }
          function j(at, ot, ut) {
            function it(ht) {
              return at.p.ix === ht
                ? it.position
                : at.s.ix === ht
                ? it.size
                : null
            }
            var ct = propertyGroupFactory(it, ut)
            it.propertyIndex = at.ix
            var lt = ot.sh.ty === "tm" ? ot.sh.prop : ot.sh
            return (
              lt.s.setGroupProperty(PropertyInterface("Size", ct)),
              lt.p.setGroupProperty(PropertyInterface("Position", ct)),
              Object.defineProperties(it, {
                size: { get: ExpressionPropertyInterface(lt.s) },
                position: { get: ExpressionPropertyInterface(lt.p) },
                _name: { value: at.nm },
              }),
              (it.mn = at.mn),
              it
            )
          }
          function $(at, ot, ut) {
            function it(ht) {
              return at.p.ix === ht
                ? it.position
                : at.r.ix === ht
                ? it.rotation
                : at.pt.ix === ht
                ? it.points
                : at.or.ix === ht || ht === "ADBE Vector Star Outer Radius"
                ? it.outerRadius
                : at.os.ix === ht
                ? it.outerRoundness
                : at.ir &&
                  (at.ir.ix === ht || ht === "ADBE Vector Star Inner Radius")
                ? it.innerRadius
                : at.is && at.is.ix === ht
                ? it.innerRoundness
                : null
            }
            var ct = propertyGroupFactory(it, ut),
              lt = ot.sh.ty === "tm" ? ot.sh.prop : ot.sh
            return (
              (it.propertyIndex = at.ix),
              lt.or.setGroupProperty(PropertyInterface("Outer Radius", ct)),
              lt.os.setGroupProperty(PropertyInterface("Outer Roundness", ct)),
              lt.pt.setGroupProperty(PropertyInterface("Points", ct)),
              lt.p.setGroupProperty(PropertyInterface("Position", ct)),
              lt.r.setGroupProperty(PropertyInterface("Rotation", ct)),
              at.ir &&
                (lt.ir.setGroupProperty(PropertyInterface("Inner Radius", ct)),
                lt.is.setGroupProperty(
                  PropertyInterface("Inner Roundness", ct)
                )),
              Object.defineProperties(it, {
                position: { get: ExpressionPropertyInterface(lt.p) },
                rotation: { get: ExpressionPropertyInterface(lt.r) },
                points: { get: ExpressionPropertyInterface(lt.pt) },
                outerRadius: { get: ExpressionPropertyInterface(lt.or) },
                outerRoundness: { get: ExpressionPropertyInterface(lt.os) },
                innerRadius: { get: ExpressionPropertyInterface(lt.ir) },
                innerRoundness: { get: ExpressionPropertyInterface(lt.is) },
                _name: { value: at.nm },
              }),
              (it.mn = at.mn),
              it
            )
          }
          function _e(at, ot, ut) {
            function it(ht) {
              return at.p.ix === ht
                ? it.position
                : at.r.ix === ht
                ? it.roundness
                : at.s.ix === ht ||
                  ht === "Size" ||
                  ht === "ADBE Vector Rect Size"
                ? it.size
                : null
            }
            var ct = propertyGroupFactory(it, ut),
              lt = ot.sh.ty === "tm" ? ot.sh.prop : ot.sh
            return (
              (it.propertyIndex = at.ix),
              lt.p.setGroupProperty(PropertyInterface("Position", ct)),
              lt.s.setGroupProperty(PropertyInterface("Size", ct)),
              lt.r.setGroupProperty(PropertyInterface("Rotation", ct)),
              Object.defineProperties(it, {
                position: { get: ExpressionPropertyInterface(lt.p) },
                roundness: { get: ExpressionPropertyInterface(lt.r) },
                size: { get: ExpressionPropertyInterface(lt.s) },
                _name: { value: at.nm },
              }),
              (it.mn = at.mn),
              it
            )
          }
          function tt(at, ot, ut) {
            function it(ht) {
              return at.r.ix === ht || ht === "Round Corners 1"
                ? it.radius
                : null
            }
            var ct = propertyGroupFactory(it, ut),
              lt = ot
            return (
              (it.propertyIndex = at.ix),
              lt.rd.setGroupProperty(PropertyInterface("Radius", ct)),
              Object.defineProperties(it, {
                radius: { get: ExpressionPropertyInterface(lt.rd) },
                _name: { value: at.nm },
              }),
              (it.mn = at.mn),
              it
            )
          }
          function st(at, ot, ut) {
            function it(ht) {
              return at.c.ix === ht || ht === "Copies"
                ? it.copies
                : at.o.ix === ht || ht === "Offset"
                ? it.offset
                : null
            }
            var ct = propertyGroupFactory(it, ut),
              lt = ot
            return (
              (it.propertyIndex = at.ix),
              lt.c.setGroupProperty(PropertyInterface("Copies", ct)),
              lt.o.setGroupProperty(PropertyInterface("Offset", ct)),
              Object.defineProperties(it, {
                copies: { get: ExpressionPropertyInterface(lt.c) },
                offset: { get: ExpressionPropertyInterface(lt.o) },
                _name: { value: at.nm },
              }),
              (it.mn = at.mn),
              it
            )
          }
          return function (at, ot, ut) {
            var it
            function ct(ht) {
              if (typeof ht == "number")
                return (ht = ht === void 0 ? 1 : ht), ht === 0 ? ut : it[ht - 1]
              for (var dt = 0, pt = it.length; dt < pt; ) {
                if (it[dt]._name === ht) return it[dt]
                dt += 1
              }
              return null
            }
            function lt() {
              return ut
            }
            return (
              (ct.propertyGroup = propertyGroupFactory(ct, lt)),
              (it = s(at, ot, ct.propertyGroup)),
              (ct.numProperties = it.length),
              (ct._name = "Contents"),
              ct
            )
          }
        })(),
        TextExpressionInterface = (function () {
          return function (s) {
            var e
            function a(o) {
              switch (o) {
                case "ADBE Text Document":
                  return a.sourceText
                default:
                  return null
              }
            }
            return (
              Object.defineProperty(a, "sourceText", {
                get: function () {
                  s.textProperty.getValue()
                  var c = s.textProperty.currentData.t
                  return (
                    (!e || c !== e.value) &&
                      ((e = new String(c)),
                      (e.value = c || new String(c)),
                      Object.defineProperty(e, "style", {
                        get: function () {
                          return { fillColor: s.textProperty.currentData.fc }
                        },
                      })),
                    e
                  )
                },
              }),
              a
            )
          }
        })()
      function _typeof(s) {
        "@babel/helpers - typeof"
        return (
          typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
            ? (_typeof = function (a) {
                return typeof a
              })
            : (_typeof = function (a) {
                return a &&
                  typeof Symbol == "function" &&
                  a.constructor === Symbol &&
                  a !== Symbol.prototype
                  ? "symbol"
                  : typeof a
              }),
          _typeof(s)
        )
      }
      var FootageInterface = (function () {
          var s = function (o) {
              var c = "",
                d = o.getFootageData()
              function g() {
                return (c = ""), (d = o.getFootageData()), _
              }
              function _(b) {
                if (d[b])
                  return (c = b), (d = d[b]), _typeof(d) === "object" ? _ : d
                var j = b.indexOf(c)
                if (j !== -1) {
                  var $ = parseInt(b.substr(j + c.length), 10)
                  return (d = d[$]), _typeof(d) === "object" ? _ : d
                }
                return ""
              }
              return g
            },
            e = function (o) {
              function c(d) {
                return d === "Outline" ? c.outlineInterface() : null
              }
              return (c._name = "Outline"), (c.outlineInterface = s(o)), c
            }
          return function (a) {
            function o(c) {
              return c === "Data" ? o.dataInterface : null
            }
            return (o._name = "Data"), (o.dataInterface = e(a)), o
          }
        })(),
        interfaces = {
          layer: LayerExpressionInterface,
          effects: EffectsExpressionInterface,
          comp: CompExpressionInterface,
          shape: ShapeExpressionInterface,
          text: TextExpressionInterface,
          footage: FootageInterface,
        }
      function getInterface(s) {
        return interfaces[s] || null
      }
      var expressionHelpers = (function () {
        function s(g, _, b) {
          _.x &&
            ((b.k = !0),
            (b.x = !0),
            (b.initiateExpression = ExpressionManager.initiateExpression),
            b.effectsSequence.push(b.initiateExpression(g, _, b).bind(b)))
        }
        function e(g) {
          return (
            (g *= this.elem.globalData.frameRate),
            (g -= this.offsetTime),
            g !== this._cachingAtTime.lastFrame &&
              ((this._cachingAtTime.lastIndex =
                this._cachingAtTime.lastFrame < g
                  ? this._cachingAtTime.lastIndex
                  : 0),
              (this._cachingAtTime.value = this.interpolateValue(
                g,
                this._cachingAtTime
              )),
              (this._cachingAtTime.lastFrame = g)),
            this._cachingAtTime.value
          )
        }
        function a(g) {
          var _ = -0.01,
            b = this.getValueAtTime(g),
            j = this.getValueAtTime(g + _),
            $ = 0
          if (b.length) {
            var _e
            for (_e = 0; _e < b.length; _e += 1) $ += Math.pow(j[_e] - b[_e], 2)
            $ = Math.sqrt($) * 100
          } else $ = 0
          return $
        }
        function o(g) {
          if (this.vel !== void 0) return this.vel
          var _ = -0.001,
            b = this.getValueAtTime(g),
            j = this.getValueAtTime(g + _),
            $
          if (b.length) {
            $ = createTypedArray("float32", b.length)
            var _e
            for (_e = 0; _e < b.length; _e += 1) $[_e] = (j[_e] - b[_e]) / _
          } else $ = (j - b) / _
          return $
        }
        function c() {
          return this.pv
        }
        function d(g) {
          this.propertyGroup = g
        }
        return {
          searchExpressions: s,
          getSpeedAtTime: a,
          getVelocityAtTime: o,
          getValueAtTime: e,
          getStaticValueAtTime: c,
          setGroupProperty: d,
        }
      })()
      function addPropertyDecorator() {
        function s(tt, st, at) {
          if (!this.k || !this.keyframes) return this.pv
          tt = tt ? tt.toLowerCase() : ""
          var ot = this.comp.renderedFrame,
            ut = this.keyframes,
            it = ut[ut.length - 1].t
          if (ot <= it) return this.pv
          var ct, lt
          at
            ? (st
                ? (ct = Math.abs(it - this.elem.comp.globalData.frameRate * st))
                : (ct = Math.max(0, it - this.elem.data.ip)),
              (lt = it - ct))
            : ((!st || st > ut.length - 1) && (st = ut.length - 1),
              (lt = ut[ut.length - 1 - st].t),
              (ct = it - lt))
          var ht, dt, pt
          if (tt === "pingpong") {
            var vt = Math.floor((ot - lt) / ct)
            if (vt % 2 !== 0)
              return this.getValueAtTime(
                (ct - ((ot - lt) % ct) + lt) / this.comp.globalData.frameRate,
                0
              )
          } else if (tt === "offset") {
            var _t = this.getValueAtTime(
                lt / this.comp.globalData.frameRate,
                0
              ),
              yt = this.getValueAtTime(it / this.comp.globalData.frameRate, 0),
              Et = this.getValueAtTime(
                (((ot - lt) % ct) + lt) / this.comp.globalData.frameRate,
                0
              ),
              Rt = Math.floor((ot - lt) / ct)
            if (this.pv.length) {
              for (
                pt = new Array(_t.length), dt = pt.length, ht = 0;
                ht < dt;
                ht += 1
              )
                pt[ht] = (yt[ht] - _t[ht]) * Rt + Et[ht]
              return pt
            }
            return (yt - _t) * Rt + Et
          } else if (tt === "continue") {
            var Ft = this.getValueAtTime(
                it / this.comp.globalData.frameRate,
                0
              ),
              kt = this.getValueAtTime(
                (it - 0.001) / this.comp.globalData.frameRate,
                0
              )
            if (this.pv.length) {
              for (
                pt = new Array(Ft.length), dt = pt.length, ht = 0;
                ht < dt;
                ht += 1
              )
                pt[ht] =
                  Ft[ht] +
                  ((Ft[ht] - kt[ht]) *
                    ((ot - it) / this.comp.globalData.frameRate)) /
                    5e-4
              return pt
            }
            return Ft + (Ft - kt) * ((ot - it) / 0.001)
          }
          return this.getValueAtTime(
            (((ot - lt) % ct) + lt) / this.comp.globalData.frameRate,
            0
          )
        }
        function e(tt, st, at) {
          if (!this.k) return this.pv
          tt = tt ? tt.toLowerCase() : ""
          var ot = this.comp.renderedFrame,
            ut = this.keyframes,
            it = ut[0].t
          if (ot >= it) return this.pv
          var ct, lt
          at
            ? (st
                ? (ct = Math.abs(this.elem.comp.globalData.frameRate * st))
                : (ct = Math.max(0, this.elem.data.op - it)),
              (lt = it + ct))
            : ((!st || st > ut.length - 1) && (st = ut.length - 1),
              (lt = ut[st].t),
              (ct = lt - it))
          var ht, dt, pt
          if (tt === "pingpong") {
            var vt = Math.floor((it - ot) / ct)
            if (vt % 2 === 0)
              return this.getValueAtTime(
                (((it - ot) % ct) + it) / this.comp.globalData.frameRate,
                0
              )
          } else if (tt === "offset") {
            var _t = this.getValueAtTime(
                it / this.comp.globalData.frameRate,
                0
              ),
              yt = this.getValueAtTime(lt / this.comp.globalData.frameRate, 0),
              Et = this.getValueAtTime(
                (ct - ((it - ot) % ct) + it) / this.comp.globalData.frameRate,
                0
              ),
              Rt = Math.floor((it - ot) / ct) + 1
            if (this.pv.length) {
              for (
                pt = new Array(_t.length), dt = pt.length, ht = 0;
                ht < dt;
                ht += 1
              )
                pt[ht] = Et[ht] - (yt[ht] - _t[ht]) * Rt
              return pt
            }
            return Et - (yt - _t) * Rt
          } else if (tt === "continue") {
            var Ft = this.getValueAtTime(
                it / this.comp.globalData.frameRate,
                0
              ),
              kt = this.getValueAtTime(
                (it + 0.001) / this.comp.globalData.frameRate,
                0
              )
            if (this.pv.length) {
              for (
                pt = new Array(Ft.length), dt = pt.length, ht = 0;
                ht < dt;
                ht += 1
              )
                pt[ht] = Ft[ht] + ((Ft[ht] - kt[ht]) * (it - ot)) / 0.001
              return pt
            }
            return Ft + ((Ft - kt) * (it - ot)) / 0.001
          }
          return this.getValueAtTime(
            (ct - (((it - ot) % ct) + it)) / this.comp.globalData.frameRate,
            0
          )
        }
        function a(tt, st) {
          if (!this.k) return this.pv
          if (((tt = (tt || 0.4) * 0.5), (st = Math.floor(st || 5)), st <= 1))
            return this.pv
          var at = this.comp.renderedFrame / this.comp.globalData.frameRate,
            ot = at - tt,
            ut = at + tt,
            it = st > 1 ? (ut - ot) / (st - 1) : 1,
            ct = 0,
            lt = 0,
            ht
          this.pv.length
            ? (ht = createTypedArray("float32", this.pv.length))
            : (ht = 0)
          for (var dt; ct < st; ) {
            if (((dt = this.getValueAtTime(ot + ct * it)), this.pv.length))
              for (lt = 0; lt < this.pv.length; lt += 1) ht[lt] += dt[lt]
            else ht += dt
            ct += 1
          }
          if (this.pv.length)
            for (lt = 0; lt < this.pv.length; lt += 1) ht[lt] /= st
          else ht /= st
          return ht
        }
        function o(tt) {
          this._transformCachingAtTime ||
            (this._transformCachingAtTime = { v: new Matrix() })
          var st = this._transformCachingAtTime.v
          if (
            (st.cloneFromProps(this.pre.props), this.appliedTransformations < 1)
          ) {
            var at = this.a.getValueAtTime(tt)
            st.translate(
              -at[0] * this.a.mult,
              -at[1] * this.a.mult,
              at[2] * this.a.mult
            )
          }
          if (this.appliedTransformations < 2) {
            var ot = this.s.getValueAtTime(tt)
            st.scale(
              ot[0] * this.s.mult,
              ot[1] * this.s.mult,
              ot[2] * this.s.mult
            )
          }
          if (this.sk && this.appliedTransformations < 3) {
            var ut = this.sk.getValueAtTime(tt),
              it = this.sa.getValueAtTime(tt)
            st.skewFromAxis(-ut * this.sk.mult, it * this.sa.mult)
          }
          if (this.r && this.appliedTransformations < 4) {
            var ct = this.r.getValueAtTime(tt)
            st.rotate(-ct * this.r.mult)
          } else if (!this.r && this.appliedTransformations < 4) {
            var lt = this.rz.getValueAtTime(tt),
              ht = this.ry.getValueAtTime(tt),
              dt = this.rx.getValueAtTime(tt),
              pt = this.or.getValueAtTime(tt)
            st.rotateZ(-lt * this.rz.mult)
              .rotateY(ht * this.ry.mult)
              .rotateX(dt * this.rx.mult)
              .rotateZ(-pt[2] * this.or.mult)
              .rotateY(pt[1] * this.or.mult)
              .rotateX(pt[0] * this.or.mult)
          }
          if (this.data.p && this.data.p.s) {
            var vt = this.px.getValueAtTime(tt),
              _t = this.py.getValueAtTime(tt)
            if (this.data.p.z) {
              var yt = this.pz.getValueAtTime(tt)
              st.translate(
                vt * this.px.mult,
                _t * this.py.mult,
                -yt * this.pz.mult
              )
            } else st.translate(vt * this.px.mult, _t * this.py.mult, 0)
          } else {
            var Et = this.p.getValueAtTime(tt)
            st.translate(
              Et[0] * this.p.mult,
              Et[1] * this.p.mult,
              -Et[2] * this.p.mult
            )
          }
          return st
        }
        function c() {
          return this.v.clone(new Matrix())
        }
        var d = TransformPropertyFactory.getTransformProperty
        TransformPropertyFactory.getTransformProperty = function (tt, st, at) {
          var ot = d(tt, st, at)
          return (
            ot.dynamicProperties.length
              ? (ot.getValueAtTime = o.bind(ot))
              : (ot.getValueAtTime = c.bind(ot)),
            (ot.setGroupProperty = expressionHelpers.setGroupProperty),
            ot
          )
        }
        var g = PropertyFactory.getProp
        PropertyFactory.getProp = function (tt, st, at, ot, ut) {
          var it = g(tt, st, at, ot, ut)
          it.kf
            ? (it.getValueAtTime = expressionHelpers.getValueAtTime.bind(it))
            : (it.getValueAtTime =
                expressionHelpers.getStaticValueAtTime.bind(it)),
            (it.setGroupProperty = expressionHelpers.setGroupProperty),
            (it.loopOut = s),
            (it.loopIn = e),
            (it.smooth = a),
            (it.getVelocityAtTime =
              expressionHelpers.getVelocityAtTime.bind(it)),
            (it.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(it)),
            (it.numKeys = st.a === 1 ? st.k.length : 0),
            (it.propertyIndex = st.ix)
          var ct = 0
          return (
            at !== 0 &&
              (ct = createTypedArray(
                "float32",
                st.a === 1 ? st.k[0].s.length : st.k.length
              )),
            (it._cachingAtTime = {
              lastFrame: initialDefaultFrame,
              lastIndex: 0,
              value: ct,
            }),
            expressionHelpers.searchExpressions(tt, st, it),
            it.k && ut.addDynamicProperty(it),
            it
          )
        }
        function _(tt) {
          return (
            this._cachingAtTime ||
              (this._cachingAtTime = {
                shapeValue: shapePool.clone(this.pv),
                lastIndex: 0,
                lastTime: initialDefaultFrame,
              }),
            (tt *= this.elem.globalData.frameRate),
            (tt -= this.offsetTime),
            tt !== this._cachingAtTime.lastTime &&
              ((this._cachingAtTime.lastIndex =
                this._cachingAtTime.lastTime < tt
                  ? this._caching.lastIndex
                  : 0),
              (this._cachingAtTime.lastTime = tt),
              this.interpolateShape(
                tt,
                this._cachingAtTime.shapeValue,
                this._cachingAtTime
              )),
            this._cachingAtTime.shapeValue
          )
        }
        var b = ShapePropertyFactory.getConstructorFunction(),
          j = ShapePropertyFactory.getKeyframedConstructorFunction()
        function $() {}
        ;($.prototype = {
          vertices: function (st, at) {
            this.k && this.getValue()
            var ot = this.v
            at !== void 0 && (ot = this.getValueAtTime(at, 0))
            var ut,
              it = ot._length,
              ct = ot[st],
              lt = ot.v,
              ht = createSizedArray(it)
            for (ut = 0; ut < it; ut += 1)
              st === "i" || st === "o"
                ? (ht[ut] = [ct[ut][0] - lt[ut][0], ct[ut][1] - lt[ut][1]])
                : (ht[ut] = [ct[ut][0], ct[ut][1]])
            return ht
          },
          points: function (st) {
            return this.vertices("v", st)
          },
          inTangents: function (st) {
            return this.vertices("i", st)
          },
          outTangents: function (st) {
            return this.vertices("o", st)
          },
          isClosed: function () {
            return this.v.c
          },
          pointOnPath: function (st, at) {
            var ot = this.v
            at !== void 0 && (ot = this.getValueAtTime(at, 0)),
              this._segmentsLength ||
                (this._segmentsLength = bez.getSegmentsLength(ot))
            for (
              var ut = this._segmentsLength,
                it = ut.lengths,
                ct = ut.totalLength * st,
                lt = 0,
                ht = it.length,
                dt = 0,
                pt;
              lt < ht;

            ) {
              if (dt + it[lt].addedLength > ct) {
                var vt = lt,
                  _t = ot.c && lt === ht - 1 ? 0 : lt + 1,
                  yt = (ct - dt) / it[lt].addedLength
                pt = bez.getPointInSegment(
                  ot.v[vt],
                  ot.v[_t],
                  ot.o[vt],
                  ot.i[_t],
                  yt,
                  it[lt]
                )
                break
              } else dt += it[lt].addedLength
              lt += 1
            }
            return (
              pt ||
                (pt = ot.c
                  ? [ot.v[0][0], ot.v[0][1]]
                  : [ot.v[ot._length - 1][0], ot.v[ot._length - 1][1]]),
              pt
            )
          },
          vectorOnPath: function (st, at, ot) {
            st == 1 ? (st = this.v.c) : st == 0 && (st = 0.999)
            var ut = this.pointOnPath(st, at),
              it = this.pointOnPath(st + 0.001, at),
              ct = it[0] - ut[0],
              lt = it[1] - ut[1],
              ht = Math.sqrt(Math.pow(ct, 2) + Math.pow(lt, 2))
            if (ht === 0) return [0, 0]
            var dt = ot === "tangent" ? [ct / ht, lt / ht] : [-lt / ht, ct / ht]
            return dt
          },
          tangentOnPath: function (st, at) {
            return this.vectorOnPath(st, at, "tangent")
          },
          normalOnPath: function (st, at) {
            return this.vectorOnPath(st, at, "normal")
          },
          setGroupProperty: expressionHelpers.setGroupProperty,
          getValueAtTime: expressionHelpers.getStaticValueAtTime,
        }),
          extendPrototype([$], b),
          extendPrototype([$], j),
          (j.prototype.getValueAtTime = _),
          (j.prototype.initiateExpression =
            ExpressionManager.initiateExpression)
        var _e = ShapePropertyFactory.getShapeProp
        ShapePropertyFactory.getShapeProp = function (tt, st, at, ot, ut) {
          var it = _e(tt, st, at, ot, ut)
          return (
            (it.propertyIndex = st.ix),
            (it.lock = !1),
            at === 3
              ? expressionHelpers.searchExpressions(tt, st.pt, it)
              : at === 4 && expressionHelpers.searchExpressions(tt, st.ks, it),
            it.k && tt.addDynamicProperty(it),
            it
          )
        }
      }
      function initialize$1() {
        addPropertyDecorator()
      }
      function addDecorator() {
        function s() {
          return this.data.d.x
            ? ((this.calculateExpression =
                ExpressionManager.initiateExpression.bind(this)(
                  this.elem,
                  this.data.d,
                  this
                )),
              this.addEffect(this.getExpressionValue.bind(this)),
              !0)
            : null
        }
        ;(TextProperty.prototype.getExpressionValue = function (e, a) {
          var o = this.calculateExpression(a)
          if (e.t !== o) {
            var c = {}
            return (
              this.copyData(c, e), (c.t = o.toString()), (c.__complete = !1), c
            )
          }
          return e
        }),
          (TextProperty.prototype.searchProperty = function () {
            var e = this.searchKeyframes(),
              a = this.searchExpressions()
            return (this.kf = e || a), this.kf
          }),
          (TextProperty.prototype.searchExpressions = s)
      }
      function initialize() {
        addDecorator()
      }
      function SVGComposableEffect() {}
      SVGComposableEffect.prototype = {
        createMergeNode: function s(e, a) {
          var o = createNS("feMerge")
          o.setAttribute("result", e)
          var c, d
          for (d = 0; d < a.length; d += 1)
            (c = createNS("feMergeNode")),
              c.setAttribute("in", a[d]),
              o.appendChild(c),
              o.appendChild(c)
          return o
        },
      }
      var linearFilterValue =
        "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0"
      function SVGTintFilter(s, e, a, o, c) {
        this.filterManager = e
        var d = createNS("feColorMatrix")
        d.setAttribute("type", "matrix"),
          d.setAttribute("color-interpolation-filters", "linearRGB"),
          d.setAttribute("values", linearFilterValue + " 1 0"),
          (this.linearFilter = d),
          d.setAttribute("result", o + "_tint_1"),
          s.appendChild(d),
          (d = createNS("feColorMatrix")),
          d.setAttribute("type", "matrix"),
          d.setAttribute("color-interpolation-filters", "sRGB"),
          d.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
          d.setAttribute("result", o + "_tint_2"),
          s.appendChild(d),
          (this.matrixFilter = d)
        var g = this.createMergeNode(o, [c, o + "_tint_1", o + "_tint_2"])
        s.appendChild(g)
      }
      extendPrototype([SVGComposableEffect], SVGTintFilter),
        (SVGTintFilter.prototype.renderFrame = function (s) {
          if (s || this.filterManager._mdf) {
            var e = this.filterManager.effectElements[0].p.v,
              a = this.filterManager.effectElements[1].p.v,
              o = this.filterManager.effectElements[2].p.v / 100
            this.linearFilter.setAttribute(
              "values",
              linearFilterValue + " " + o + " 0"
            ),
              this.matrixFilter.setAttribute(
                "values",
                a[0] -
                  e[0] +
                  " 0 0 0 " +
                  e[0] +
                  " " +
                  (a[1] - e[1]) +
                  " 0 0 0 " +
                  e[1] +
                  " " +
                  (a[2] - e[2]) +
                  " 0 0 0 " +
                  e[2] +
                  " 0 0 0 1 0"
              )
          }
        })
      function SVGFillFilter(s, e, a, o) {
        this.filterManager = e
        var c = createNS("feColorMatrix")
        c.setAttribute("type", "matrix"),
          c.setAttribute("color-interpolation-filters", "sRGB"),
          c.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"),
          c.setAttribute("result", o),
          s.appendChild(c),
          (this.matrixFilter = c)
      }
      SVGFillFilter.prototype.renderFrame = function (s) {
        if (s || this.filterManager._mdf) {
          var e = this.filterManager.effectElements[2].p.v,
            a = this.filterManager.effectElements[6].p.v
          this.matrixFilter.setAttribute(
            "values",
            "0 0 0 0 " +
              e[0] +
              " 0 0 0 0 " +
              e[1] +
              " 0 0 0 0 " +
              e[2] +
              " 0 0 0 " +
              a +
              " 0"
          )
        }
      }
      function SVGStrokeEffect(s, e, a) {
        ;(this.initialized = !1),
          (this.filterManager = e),
          (this.elem = a),
          (this.paths = [])
      }
      ;(SVGStrokeEffect.prototype.initialize = function () {
        var s =
            this.elem.layerElement.children ||
            this.elem.layerElement.childNodes,
          e,
          a,
          o,
          c
        for (
          this.filterManager.effectElements[1].p.v === 1
            ? ((c = this.elem.maskManager.masksProperties.length), (o = 0))
            : ((o = this.filterManager.effectElements[0].p.v - 1), (c = o + 1)),
            a = createNS("g"),
            a.setAttribute("fill", "none"),
            a.setAttribute("stroke-linecap", "round"),
            a.setAttribute("stroke-dashoffset", 1),
            o;
          o < c;
          o += 1
        )
          (e = createNS("path")),
            a.appendChild(e),
            this.paths.push({ p: e, m: o })
        if (this.filterManager.effectElements[10].p.v === 3) {
          var d = createNS("mask"),
            g = createElementID()
          d.setAttribute("id", g),
            d.setAttribute("mask-type", "alpha"),
            d.appendChild(a),
            this.elem.globalData.defs.appendChild(d)
          var _ = createNS("g")
          for (
            _.setAttribute("mask", "url(" + getLocationHref() + "#" + g + ")");
            s[0];

          )
            _.appendChild(s[0])
          this.elem.layerElement.appendChild(_),
            (this.masker = d),
            a.setAttribute("stroke", "#fff")
        } else if (
          this.filterManager.effectElements[10].p.v === 1 ||
          this.filterManager.effectElements[10].p.v === 2
        ) {
          if (this.filterManager.effectElements[10].p.v === 2)
            for (
              s =
                this.elem.layerElement.children ||
                this.elem.layerElement.childNodes;
              s.length;

            )
              this.elem.layerElement.removeChild(s[0])
          this.elem.layerElement.appendChild(a),
            this.elem.layerElement.removeAttribute("mask"),
            a.setAttribute("stroke", "#fff")
        }
        ;(this.initialized = !0), (this.pathMasker = a)
      }),
        (SVGStrokeEffect.prototype.renderFrame = function (s) {
          this.initialized || this.initialize()
          var e,
            a = this.paths.length,
            o,
            c
          for (e = 0; e < a; e += 1)
            if (
              this.paths[e].m !== -1 &&
              ((o = this.elem.maskManager.viewData[this.paths[e].m]),
              (c = this.paths[e].p),
              (s || this.filterManager._mdf || o.prop._mdf) &&
                c.setAttribute("d", o.lastPath),
              s ||
                this.filterManager.effectElements[9].p._mdf ||
                this.filterManager.effectElements[4].p._mdf ||
                this.filterManager.effectElements[7].p._mdf ||
                this.filterManager.effectElements[8].p._mdf ||
                o.prop._mdf)
            ) {
              var d
              if (
                this.filterManager.effectElements[7].p.v !== 0 ||
                this.filterManager.effectElements[8].p.v !== 100
              ) {
                var g =
                    Math.min(
                      this.filterManager.effectElements[7].p.v,
                      this.filterManager.effectElements[8].p.v
                    ) * 0.01,
                  _ =
                    Math.max(
                      this.filterManager.effectElements[7].p.v,
                      this.filterManager.effectElements[8].p.v
                    ) * 0.01,
                  b = c.getTotalLength()
                d = "0 0 0 " + b * g + " "
                var j = b * (_ - g),
                  $ =
                    1 +
                    this.filterManager.effectElements[4].p.v *
                      2 *
                      this.filterManager.effectElements[9].p.v *
                      0.01,
                  _e = Math.floor(j / $),
                  tt
                for (tt = 0; tt < _e; tt += 1)
                  d +=
                    "1 " +
                    this.filterManager.effectElements[4].p.v *
                      2 *
                      this.filterManager.effectElements[9].p.v *
                      0.01 +
                    " "
                d += "0 " + b * 10 + " 0 0"
              } else
                d =
                  "1 " +
                  this.filterManager.effectElements[4].p.v *
                    2 *
                    this.filterManager.effectElements[9].p.v *
                    0.01
              c.setAttribute("stroke-dasharray", d)
            }
          if (
            ((s || this.filterManager.effectElements[4].p._mdf) &&
              this.pathMasker.setAttribute(
                "stroke-width",
                this.filterManager.effectElements[4].p.v * 2
              ),
            (s || this.filterManager.effectElements[6].p._mdf) &&
              this.pathMasker.setAttribute(
                "opacity",
                this.filterManager.effectElements[6].p.v
              ),
            (this.filterManager.effectElements[10].p.v === 1 ||
              this.filterManager.effectElements[10].p.v === 2) &&
              (s || this.filterManager.effectElements[3].p._mdf))
          ) {
            var st = this.filterManager.effectElements[3].p.v
            this.pathMasker.setAttribute(
              "stroke",
              "rgb(" +
                bmFloor(st[0] * 255) +
                "," +
                bmFloor(st[1] * 255) +
                "," +
                bmFloor(st[2] * 255) +
                ")"
            )
          }
        })
      function SVGTritoneFilter(s, e, a, o) {
        this.filterManager = e
        var c = createNS("feColorMatrix")
        c.setAttribute("type", "matrix"),
          c.setAttribute("color-interpolation-filters", "linearRGB"),
          c.setAttribute(
            "values",
            "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"
          ),
          s.appendChild(c)
        var d = createNS("feComponentTransfer")
        d.setAttribute("color-interpolation-filters", "sRGB"),
          d.setAttribute("result", o),
          (this.matrixFilter = d)
        var g = createNS("feFuncR")
        g.setAttribute("type", "table"), d.appendChild(g), (this.feFuncR = g)
        var _ = createNS("feFuncG")
        _.setAttribute("type", "table"), d.appendChild(_), (this.feFuncG = _)
        var b = createNS("feFuncB")
        b.setAttribute("type", "table"),
          d.appendChild(b),
          (this.feFuncB = b),
          s.appendChild(d)
      }
      SVGTritoneFilter.prototype.renderFrame = function (s) {
        if (s || this.filterManager._mdf) {
          var e = this.filterManager.effectElements[0].p.v,
            a = this.filterManager.effectElements[1].p.v,
            o = this.filterManager.effectElements[2].p.v,
            c = o[0] + " " + a[0] + " " + e[0],
            d = o[1] + " " + a[1] + " " + e[1],
            g = o[2] + " " + a[2] + " " + e[2]
          this.feFuncR.setAttribute("tableValues", c),
            this.feFuncG.setAttribute("tableValues", d),
            this.feFuncB.setAttribute("tableValues", g)
        }
      }
      function SVGProLevelsFilter(s, e, a, o) {
        this.filterManager = e
        var c = this.filterManager.effectElements,
          d = createNS("feComponentTransfer")
        ;(c[10].p.k ||
          c[10].p.v !== 0 ||
          c[11].p.k ||
          c[11].p.v !== 1 ||
          c[12].p.k ||
          c[12].p.v !== 1 ||
          c[13].p.k ||
          c[13].p.v !== 0 ||
          c[14].p.k ||
          c[14].p.v !== 1) &&
          (this.feFuncR = this.createFeFunc("feFuncR", d)),
          (c[17].p.k ||
            c[17].p.v !== 0 ||
            c[18].p.k ||
            c[18].p.v !== 1 ||
            c[19].p.k ||
            c[19].p.v !== 1 ||
            c[20].p.k ||
            c[20].p.v !== 0 ||
            c[21].p.k ||
            c[21].p.v !== 1) &&
            (this.feFuncG = this.createFeFunc("feFuncG", d)),
          (c[24].p.k ||
            c[24].p.v !== 0 ||
            c[25].p.k ||
            c[25].p.v !== 1 ||
            c[26].p.k ||
            c[26].p.v !== 1 ||
            c[27].p.k ||
            c[27].p.v !== 0 ||
            c[28].p.k ||
            c[28].p.v !== 1) &&
            (this.feFuncB = this.createFeFunc("feFuncB", d)),
          (c[31].p.k ||
            c[31].p.v !== 0 ||
            c[32].p.k ||
            c[32].p.v !== 1 ||
            c[33].p.k ||
            c[33].p.v !== 1 ||
            c[34].p.k ||
            c[34].p.v !== 0 ||
            c[35].p.k ||
            c[35].p.v !== 1) &&
            (this.feFuncA = this.createFeFunc("feFuncA", d)),
          (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) &&
            (d.setAttribute("color-interpolation-filters", "sRGB"),
            s.appendChild(d)),
          (c[3].p.k ||
            c[3].p.v !== 0 ||
            c[4].p.k ||
            c[4].p.v !== 1 ||
            c[5].p.k ||
            c[5].p.v !== 1 ||
            c[6].p.k ||
            c[6].p.v !== 0 ||
            c[7].p.k ||
            c[7].p.v !== 1) &&
            ((d = createNS("feComponentTransfer")),
            d.setAttribute("color-interpolation-filters", "sRGB"),
            d.setAttribute("result", o),
            s.appendChild(d),
            (this.feFuncRComposed = this.createFeFunc("feFuncR", d)),
            (this.feFuncGComposed = this.createFeFunc("feFuncG", d)),
            (this.feFuncBComposed = this.createFeFunc("feFuncB", d)))
      }
      ;(SVGProLevelsFilter.prototype.createFeFunc = function (s, e) {
        var a = createNS(s)
        return a.setAttribute("type", "table"), e.appendChild(a), a
      }),
        (SVGProLevelsFilter.prototype.getTableValue = function (s, e, a, o, c) {
          for (
            var d = 0,
              g = 256,
              _,
              b = Math.min(s, e),
              j = Math.max(s, e),
              $ = Array.call(null, { length: g }),
              _e,
              tt = 0,
              st = c - o,
              at = e - s;
            d <= 256;

          )
            (_ = d / 256),
              _ <= b
                ? (_e = at < 0 ? c : o)
                : _ >= j
                ? (_e = at < 0 ? o : c)
                : (_e = o + st * Math.pow((_ - s) / at, 1 / a)),
              ($[tt] = _e),
              (tt += 1),
              (d += 256 / (g - 1))
          return $.join(" ")
        }),
        (SVGProLevelsFilter.prototype.renderFrame = function (s) {
          if (s || this.filterManager._mdf) {
            var e,
              a = this.filterManager.effectElements
            this.feFuncRComposed &&
              (s ||
                a[3].p._mdf ||
                a[4].p._mdf ||
                a[5].p._mdf ||
                a[6].p._mdf ||
                a[7].p._mdf) &&
              ((e = this.getTableValue(
                a[3].p.v,
                a[4].p.v,
                a[5].p.v,
                a[6].p.v,
                a[7].p.v
              )),
              this.feFuncRComposed.setAttribute("tableValues", e),
              this.feFuncGComposed.setAttribute("tableValues", e),
              this.feFuncBComposed.setAttribute("tableValues", e)),
              this.feFuncR &&
                (s ||
                  a[10].p._mdf ||
                  a[11].p._mdf ||
                  a[12].p._mdf ||
                  a[13].p._mdf ||
                  a[14].p._mdf) &&
                ((e = this.getTableValue(
                  a[10].p.v,
                  a[11].p.v,
                  a[12].p.v,
                  a[13].p.v,
                  a[14].p.v
                )),
                this.feFuncR.setAttribute("tableValues", e)),
              this.feFuncG &&
                (s ||
                  a[17].p._mdf ||
                  a[18].p._mdf ||
                  a[19].p._mdf ||
                  a[20].p._mdf ||
                  a[21].p._mdf) &&
                ((e = this.getTableValue(
                  a[17].p.v,
                  a[18].p.v,
                  a[19].p.v,
                  a[20].p.v,
                  a[21].p.v
                )),
                this.feFuncG.setAttribute("tableValues", e)),
              this.feFuncB &&
                (s ||
                  a[24].p._mdf ||
                  a[25].p._mdf ||
                  a[26].p._mdf ||
                  a[27].p._mdf ||
                  a[28].p._mdf) &&
                ((e = this.getTableValue(
                  a[24].p.v,
                  a[25].p.v,
                  a[26].p.v,
                  a[27].p.v,
                  a[28].p.v
                )),
                this.feFuncB.setAttribute("tableValues", e)),
              this.feFuncA &&
                (s ||
                  a[31].p._mdf ||
                  a[32].p._mdf ||
                  a[33].p._mdf ||
                  a[34].p._mdf ||
                  a[35].p._mdf) &&
                ((e = this.getTableValue(
                  a[31].p.v,
                  a[32].p.v,
                  a[33].p.v,
                  a[34].p.v,
                  a[35].p.v
                )),
                this.feFuncA.setAttribute("tableValues", e))
          }
        })
      function SVGDropShadowEffect(s, e, a, o, c) {
        var d = e.container.globalData.renderConfig.filterSize,
          g = e.data.fs || d
        s.setAttribute("x", g.x || d.x),
          s.setAttribute("y", g.y || d.y),
          s.setAttribute("width", g.width || d.width),
          s.setAttribute("height", g.height || d.height),
          (this.filterManager = e)
        var _ = createNS("feGaussianBlur")
        _.setAttribute("in", "SourceAlpha"),
          _.setAttribute("result", o + "_drop_shadow_1"),
          _.setAttribute("stdDeviation", "0"),
          (this.feGaussianBlur = _),
          s.appendChild(_)
        var b = createNS("feOffset")
        b.setAttribute("dx", "25"),
          b.setAttribute("dy", "0"),
          b.setAttribute("in", o + "_drop_shadow_1"),
          b.setAttribute("result", o + "_drop_shadow_2"),
          (this.feOffset = b),
          s.appendChild(b)
        var j = createNS("feFlood")
        j.setAttribute("flood-color", "#00ff00"),
          j.setAttribute("flood-opacity", "1"),
          j.setAttribute("result", o + "_drop_shadow_3"),
          (this.feFlood = j),
          s.appendChild(j)
        var $ = createNS("feComposite")
        $.setAttribute("in", o + "_drop_shadow_3"),
          $.setAttribute("in2", o + "_drop_shadow_2"),
          $.setAttribute("operator", "in"),
          $.setAttribute("result", o + "_drop_shadow_4"),
          s.appendChild($)
        var _e = this.createMergeNode(o, [o + "_drop_shadow_4", c])
        s.appendChild(_e)
      }
      extendPrototype([SVGComposableEffect], SVGDropShadowEffect),
        (SVGDropShadowEffect.prototype.renderFrame = function (s) {
          if (s || this.filterManager._mdf) {
            if (
              ((s || this.filterManager.effectElements[4].p._mdf) &&
                this.feGaussianBlur.setAttribute(
                  "stdDeviation",
                  this.filterManager.effectElements[4].p.v / 4
                ),
              s || this.filterManager.effectElements[0].p._mdf)
            ) {
              var e = this.filterManager.effectElements[0].p.v
              this.feFlood.setAttribute(
                "flood-color",
                rgbToHex(
                  Math.round(e[0] * 255),
                  Math.round(e[1] * 255),
                  Math.round(e[2] * 255)
                )
              )
            }
            if (
              ((s || this.filterManager.effectElements[1].p._mdf) &&
                this.feFlood.setAttribute(
                  "flood-opacity",
                  this.filterManager.effectElements[1].p.v / 255
                ),
              s ||
                this.filterManager.effectElements[2].p._mdf ||
                this.filterManager.effectElements[3].p._mdf)
            ) {
              var a = this.filterManager.effectElements[3].p.v,
                o = (this.filterManager.effectElements[2].p.v - 90) * degToRads,
                c = a * Math.cos(o),
                d = a * Math.sin(o)
              this.feOffset.setAttribute("dx", c),
                this.feOffset.setAttribute("dy", d)
            }
          }
        })
      var _svgMatteSymbols = []
      function SVGMatte3Effect(s, e, a) {
        ;(this.initialized = !1),
          (this.filterManager = e),
          (this.filterElem = s),
          (this.elem = a),
          (a.matteElement = createNS("g")),
          a.matteElement.appendChild(a.layerElement),
          a.matteElement.appendChild(a.transformedElement),
          (a.baseElement = a.matteElement)
      }
      ;(SVGMatte3Effect.prototype.findSymbol = function (s) {
        for (var e = 0, a = _svgMatteSymbols.length; e < a; ) {
          if (_svgMatteSymbols[e] === s) return _svgMatteSymbols[e]
          e += 1
        }
        return null
      }),
        (SVGMatte3Effect.prototype.replaceInParent = function (s, e) {
          var a = s.layerElement.parentNode
          if (a) {
            for (
              var o = a.children, c = 0, d = o.length;
              c < d && o[c] !== s.layerElement;

            )
              c += 1
            var g
            c <= d - 2 && (g = o[c + 1])
            var _ = createNS("use")
            _.setAttribute("href", "#" + e),
              g ? a.insertBefore(_, g) : a.appendChild(_)
          }
        }),
        (SVGMatte3Effect.prototype.setElementAsMask = function (s, e) {
          if (!this.findSymbol(e)) {
            var a = createElementID(),
              o = createNS("mask")
            o.setAttribute("id", e.layerId),
              o.setAttribute("mask-type", "alpha"),
              _svgMatteSymbols.push(e)
            var c = s.globalData.defs
            c.appendChild(o)
            var d = createNS("symbol")
            d.setAttribute("id", a),
              this.replaceInParent(e, a),
              d.appendChild(e.layerElement),
              c.appendChild(d)
            var g = createNS("use")
            g.setAttribute("href", "#" + a),
              o.appendChild(g),
              (e.data.hd = !1),
              e.show()
          }
          s.setMatte(e.layerId)
        }),
        (SVGMatte3Effect.prototype.initialize = function () {
          for (
            var s = this.filterManager.effectElements[0].p.v,
              e = this.elem.comp.elements,
              a = 0,
              o = e.length;
            a < o;

          )
            e[a] &&
              e[a].data.ind === s &&
              this.setElementAsMask(this.elem, e[a]),
              (a += 1)
          this.initialized = !0
        }),
        (SVGMatte3Effect.prototype.renderFrame = function () {
          this.initialized || this.initialize()
        })
      function SVGGaussianBlurEffect(s, e, a, o) {
        s.setAttribute("x", "-100%"),
          s.setAttribute("y", "-100%"),
          s.setAttribute("width", "300%"),
          s.setAttribute("height", "300%"),
          (this.filterManager = e)
        var c = createNS("feGaussianBlur")
        c.setAttribute("result", o), s.appendChild(c), (this.feGaussianBlur = c)
      }
      SVGGaussianBlurEffect.prototype.renderFrame = function (s) {
        if (s || this.filterManager._mdf) {
          var e = 0.3,
            a = this.filterManager.effectElements[0].p.v * e,
            o = this.filterManager.effectElements[1].p.v,
            c = o == 3 ? 0 : a,
            d = o == 2 ? 0 : a
          this.feGaussianBlur.setAttribute("stdDeviation", c + " " + d)
          var g =
            this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate"
          this.feGaussianBlur.setAttribute("edgeMode", g)
        }
      }
      function TransformEffect() {}
      ;(TransformEffect.prototype.init = function (s) {
        ;(this.effectsManager = s),
          (this.type = effectTypes.TRANSFORM_EFFECT),
          (this.matrix = new Matrix()),
          (this.opacity = -1),
          (this._mdf = !1),
          (this._opMdf = !1)
      }),
        (TransformEffect.prototype.renderFrame = function (s) {
          if (
            ((this._opMdf = !1),
            (this._mdf = !1),
            s || this.effectsManager._mdf)
          ) {
            var e = this.effectsManager.effectElements,
              a = e[0].p.v,
              o = e[1].p.v,
              c = e[2].p.v === 1,
              d = e[3].p.v,
              g = c ? d : e[4].p.v,
              _ = e[5].p.v,
              b = e[6].p.v,
              j = e[7].p.v
            this.matrix.reset(),
              this.matrix.translate(-a[0], -a[1], a[2]),
              this.matrix.scale(g * 0.01, d * 0.01, 1),
              this.matrix.rotate(-j * degToRads),
              this.matrix.skewFromAxis(-_ * degToRads, (b + 90) * degToRads),
              this.matrix.translate(o[0], o[1], 0),
              (this._mdf = !0),
              this.opacity !== e[8].p.v &&
                ((this.opacity = e[8].p.v), (this._opMdf = !0))
          }
        })
      function SVGTransformEffect(s, e) {
        this.init(e)
      }
      extendPrototype([TransformEffect], SVGTransformEffect)
      function CVTransformEffect(s) {
        this.init(s)
      }
      return (
        extendPrototype([TransformEffect], CVTransformEffect),
        registerRenderer("canvas", CanvasRenderer),
        registerRenderer("html", HybridRenderer),
        registerRenderer("svg", SVGRenderer),
        ShapeModifiers.registerModifier("tm", TrimModifier),
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier),
        ShapeModifiers.registerModifier("rp", RepeaterModifier),
        ShapeModifiers.registerModifier("rd", RoundCornersModifier),
        ShapeModifiers.registerModifier("zz", ZigZagModifier),
        ShapeModifiers.registerModifier("op", OffsetPathModifier),
        setExpressionsPlugin(Expressions),
        setExpressionInterfaces(getInterface),
        initialize$1(),
        initialize(),
        registerEffect$1(20, SVGTintFilter, !0),
        registerEffect$1(21, SVGFillFilter, !0),
        registerEffect$1(22, SVGStrokeEffect, !1),
        registerEffect$1(23, SVGTritoneFilter, !0),
        registerEffect$1(24, SVGProLevelsFilter, !0),
        registerEffect$1(25, SVGDropShadowEffect, !0),
        registerEffect$1(28, SVGMatte3Effect, !1),
        registerEffect$1(29, SVGGaussianBlurEffect, !0),
        registerEffect$1(35, SVGTransformEffect, !1),
        registerEffect(35, CVTransformEffect),
        lottie
      )
    })
})(lottie$1, lottie$1.exports)
var lottieExports = lottie$1.exports
const lottie = getDefaultExportFromCjs(lottieExports)
function _iterableToArrayLimit(s, e) {
  var a =
    s == null
      ? null
      : (typeof Symbol < "u" && s[Symbol.iterator]) || s["@@iterator"]
  if (a != null) {
    var o,
      c,
      d,
      g,
      _ = [],
      b = !0,
      j = !1
    try {
      if (((d = (a = a.call(s)).next), e === 0)) {
        if (Object(a) !== a) return
        b = !1
      } else
        for (
          ;
          !(b = (o = d.call(a)).done) && (_.push(o.value), _.length !== e);
          b = !0
        );
    } catch ($) {
      ;(j = !0), (c = $)
    } finally {
      try {
        if (!b && a.return != null && ((g = a.return()), Object(g) !== g))
          return
      } finally {
        if (j) throw c
      }
    }
    return _
  }
}
function ownKeys(s, e) {
  var a = Object.keys(s)
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(s)
    e &&
      (o = o.filter(function (c) {
        return Object.getOwnPropertyDescriptor(s, c).enumerable
      })),
      a.push.apply(a, o)
  }
  return a
}
function _objectSpread2(s) {
  for (var e = 1; e < arguments.length; e++) {
    var a = arguments[e] != null ? arguments[e] : {}
    e % 2
      ? ownKeys(Object(a), !0).forEach(function (o) {
          _defineProperty(s, o, a[o])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(a))
      : ownKeys(Object(a)).forEach(function (o) {
          Object.defineProperty(s, o, Object.getOwnPropertyDescriptor(a, o))
        })
  }
  return s
}
function _defineProperty(s, e, a) {
  return (
    (e = _toPropertyKey(e)),
    e in s
      ? Object.defineProperty(s, e, {
          value: a,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (s[e] = a),
    s
  )
}
function _objectWithoutPropertiesLoose(s, e) {
  if (s == null) return {}
  var a = {},
    o = Object.keys(s),
    c,
    d
  for (d = 0; d < o.length; d++)
    (c = o[d]), !(e.indexOf(c) >= 0) && (a[c] = s[c])
  return a
}
function _objectWithoutProperties(s, e) {
  if (s == null) return {}
  var a = _objectWithoutPropertiesLoose(s, e),
    o,
    c
  if (Object.getOwnPropertySymbols) {
    var d = Object.getOwnPropertySymbols(s)
    for (c = 0; c < d.length; c++)
      (o = d[c]),
        !(e.indexOf(o) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(s, o) &&
          (a[o] = s[o])
  }
  return a
}
function _slicedToArray(s, e) {
  return (
    _arrayWithHoles(s) ||
    _iterableToArrayLimit(s, e) ||
    _unsupportedIterableToArray(s, e) ||
    _nonIterableRest()
  )
}
function _arrayWithHoles(s) {
  if (Array.isArray(s)) return s
}
function _unsupportedIterableToArray(s, e) {
  if (s) {
    if (typeof s == "string") return _arrayLikeToArray(s, e)
    var a = Object.prototype.toString.call(s).slice(8, -1)
    if (
      (a === "Object" && s.constructor && (a = s.constructor.name),
      a === "Map" || a === "Set")
    )
      return Array.from(s)
    if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a))
      return _arrayLikeToArray(s, e)
  }
}
function _arrayLikeToArray(s, e) {
  ;(e == null || e > s.length) && (e = s.length)
  for (var a = 0, o = new Array(e); a < e; a++) o[a] = s[a]
  return o
}
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function _toPrimitive(s, e) {
  if (typeof s != "object" || s === null) return s
  var a = s[Symbol.toPrimitive]
  if (a !== void 0) {
    var o = a.call(s, e || "default")
    if (typeof o != "object") return o
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (e === "string" ? String : Number)(s)
}
function _toPropertyKey(s) {
  var e = _toPrimitive(s, "string")
  return typeof e == "symbol" ? e : String(e)
}
var _excluded$1 = [
    "animationData",
    "loop",
    "autoplay",
    "initialSegment",
    "onComplete",
    "onLoopComplete",
    "onEnterFrame",
    "onSegmentStart",
    "onConfigReady",
    "onDataReady",
    "onDataFailed",
    "onLoadedImages",
    "onDOMLoaded",
    "onDestroy",
    "lottieRef",
    "renderer",
    "name",
    "assetsPath",
    "rendererSettings",
  ],
  useLottie = function s(e, a) {
    var o = e.animationData,
      c = e.loop,
      d = e.autoplay,
      g = e.initialSegment,
      _ = e.onComplete,
      b = e.onLoopComplete,
      j = e.onEnterFrame,
      $ = e.onSegmentStart,
      _e = e.onConfigReady,
      tt = e.onDataReady,
      st = e.onDataFailed,
      at = e.onLoadedImages,
      ot = e.onDOMLoaded,
      ut = e.onDestroy
    e.lottieRef, e.renderer, e.name, e.assetsPath, e.rendererSettings
    var it = _objectWithoutProperties(e, _excluded$1),
      ct = reactExports.useState(!1),
      lt = _slicedToArray(ct, 2),
      ht = lt[0],
      dt = lt[1],
      pt = reactExports.useRef(),
      vt = reactExports.useRef(null),
      _t = function () {
        var It
        ;(It = pt.current) === null || It === void 0 || It.play()
      },
      yt = function () {
        var It
        ;(It = pt.current) === null || It === void 0 || It.stop()
      },
      Et = function () {
        var It
        ;(It = pt.current) === null || It === void 0 || It.pause()
      },
      Rt = function (It) {
        var $t
        ;($t = pt.current) === null || $t === void 0 || $t.setSpeed(It)
      },
      Ft = function (It, $t) {
        var Xt
        ;(Xt = pt.current) === null || Xt === void 0 || Xt.goToAndPlay(It, $t)
      },
      kt = function (It, $t) {
        var Xt
        ;(Xt = pt.current) === null || Xt === void 0 || Xt.goToAndStop(It, $t)
      },
      Nt = function (It) {
        var $t
        ;($t = pt.current) === null || $t === void 0 || $t.setDirection(It)
      },
      Dt = function (It, $t) {
        var Xt
        ;(Xt = pt.current) === null || Xt === void 0 || Xt.playSegments(It, $t)
      },
      Mt = function (It) {
        var $t
        ;($t = pt.current) === null || $t === void 0 || $t.setSubframe(It)
      },
      wt = function (It) {
        var $t
        return ($t = pt.current) === null || $t === void 0
          ? void 0
          : $t.getDuration(It)
      },
      gt = function () {
        var It
        ;(It = pt.current) === null || It === void 0 || It.destroy(),
          (pt.current = void 0)
      },
      At = function () {
        var It =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
          $t
        if (vt.current) {
          ;($t = pt.current) === null || $t === void 0 || $t.destroy()
          var Xt = _objectSpread2(
            _objectSpread2(_objectSpread2({}, e), It),
            {},
            { container: vt.current }
          )
          return (
            (pt.current = lottie.loadAnimation(Xt)),
            dt(!!pt.current),
            function () {
              var qt
              ;(qt = pt.current) === null || qt === void 0 || qt.destroy(),
                (pt.current = void 0)
            }
          )
        }
      }
    reactExports.useEffect(
      function () {
        var Tt = At()
        return function () {
          return Tt == null ? void 0 : Tt()
        }
      },
      [o, c]
    ),
      reactExports.useEffect(
        function () {
          pt.current && (pt.current.autoplay = !!d)
        },
        [d]
      ),
      reactExports.useEffect(
        function () {
          if (pt.current) {
            if (!g) {
              pt.current.resetSegments(!0)
              return
            }
            !Array.isArray(g) ||
              !g.length ||
              ((pt.current.currentRawFrame < g[0] ||
                pt.current.currentRawFrame > g[1]) &&
                (pt.current.currentRawFrame = g[0]),
              pt.current.setSegment(g[0], g[1]))
          }
        },
        [g]
      ),
      reactExports.useEffect(
        function () {
          var Tt = [
              { name: "complete", handler: _ },
              { name: "loopComplete", handler: b },
              { name: "enterFrame", handler: j },
              { name: "segmentStart", handler: $ },
              { name: "config_ready", handler: _e },
              { name: "data_ready", handler: tt },
              { name: "data_failed", handler: st },
              { name: "loaded_images", handler: at },
              { name: "DOMLoaded", handler: ot },
              { name: "destroy", handler: ut },
            ],
            It = Tt.filter(function (Xt) {
              return Xt.handler != null
            })
          if (It.length) {
            var $t = It.map(function (Xt) {
              var qt
              return (
                (qt = pt.current) === null ||
                  qt === void 0 ||
                  qt.addEventListener(Xt.name, Xt.handler),
                function () {
                  var en
                  ;(en = pt.current) === null ||
                    en === void 0 ||
                    en.removeEventListener(Xt.name, Xt.handler)
                }
              )
            })
            return function () {
              $t.forEach(function (Xt) {
                return Xt()
              })
            }
          }
        },
        [_, b, j, $, _e, tt, st, at, ot, ut]
      )
    var bt = React.createElement(
      "div",
      _objectSpread2({ style: a, ref: vt }, it)
    )
    return {
      View: bt,
      play: _t,
      stop: yt,
      pause: Et,
      setSpeed: Rt,
      goToAndStop: kt,
      goToAndPlay: Ft,
      setDirection: Nt,
      playSegments: Dt,
      setSubframe: Mt,
      getDuration: wt,
      destroy: gt,
      animationContainerRef: vt,
      animationLoaded: ht,
      animationItem: pt.current,
    }
  }
function getContainerVisibility(s) {
  var e = s.getBoundingClientRect(),
    a = e.top,
    o = e.height,
    c = window.innerHeight - a,
    d = window.innerHeight + o
  return c / d
}
function getContainerCursorPosition(s, e, a) {
  var o = s.getBoundingClientRect(),
    c = o.top,
    d = o.left,
    g = o.width,
    _ = o.height,
    b = (e - d) / g,
    j = (a - c) / _
  return { x: b, y: j }
}
var useInitInteractivity = function s(e) {
    var a = e.wrapperRef,
      o = e.animationItem,
      c = e.mode,
      d = e.actions
    reactExports.useEffect(
      function () {
        var g = a.current
        if (!(!g || !o || !d.length)) {
          o.stop()
          var _ = function () {
              var $ = null,
                _e = function () {
                  var st = getContainerVisibility(g),
                    at = d.find(function (ut) {
                      var it = ut.visibility
                      return it && st >= it[0] && st <= it[1]
                    })
                  if (at) {
                    if (
                      at.type === "seek" &&
                      at.visibility &&
                      at.frames.length === 2
                    ) {
                      var ot =
                        at.frames[0] +
                        Math.ceil(
                          ((st - at.visibility[0]) /
                            (at.visibility[1] - at.visibility[0])) *
                            at.frames[1]
                        ) //! goToAndStop must be relative to the start of the current segment
                      o.goToAndStop(ot - o.firstFrame - 1, !0)
                    }
                    at.type === "loop" &&
                      ($ === null || $ !== at.frames || o.isPaused) &&
                      (o.playSegments(at.frames, !0), ($ = at.frames)),
                      at.type === "play" &&
                        o.isPaused &&
                        (o.resetSegments(!0), o.play()),
                      at.type === "stop" &&
                        o.goToAndStop(at.frames[0] - o.firstFrame - 1, !0)
                  }
                }
              return (
                document.addEventListener("scroll", _e),
                function () {
                  document.removeEventListener("scroll", _e)
                }
              )
            },
            b = function () {
              var $ = function (at, ot) {
                  var ut = at,
                    it = ot
                  if (ut !== -1 && it !== -1) {
                    var ct = getContainerCursorPosition(g, ut, it)
                    ;(ut = ct.x), (it = ct.y)
                  }
                  var lt = d.find(function (pt) {
                    var vt = pt.position
                    return vt && Array.isArray(vt.x) && Array.isArray(vt.y)
                      ? ut >= vt.x[0] &&
                          ut <= vt.x[1] &&
                          it >= vt.y[0] &&
                          it <= vt.y[1]
                      : vt && !Number.isNaN(vt.x) && !Number.isNaN(vt.y)
                      ? ut === vt.x && it === vt.y
                      : !1
                  })
                  if (lt) {
                    if (
                      lt.type === "seek" &&
                      lt.position &&
                      Array.isArray(lt.position.x) &&
                      Array.isArray(lt.position.y) &&
                      lt.frames.length === 2
                    ) {
                      var ht =
                          (ut - lt.position.x[0]) /
                          (lt.position.x[1] - lt.position.x[0]),
                        dt =
                          (it - lt.position.y[0]) /
                          (lt.position.y[1] - lt.position.y[0])
                      o.playSegments(lt.frames, !0),
                        o.goToAndStop(
                          Math.ceil(
                            ((ht + dt) / 2) * (lt.frames[1] - lt.frames[0])
                          ),
                          !0
                        )
                    }
                    lt.type === "loop" && o.playSegments(lt.frames, !0),
                      lt.type === "play" &&
                        (o.isPaused && o.resetSegments(!1),
                        o.playSegments(lt.frames)),
                      lt.type === "stop" && o.goToAndStop(lt.frames[0], !0)
                  }
                },
                _e = function (at) {
                  $(at.clientX, at.clientY)
                },
                tt = function () {
                  $(-1, -1)
                }
              return (
                g.addEventListener("mousemove", _e),
                g.addEventListener("mouseout", tt),
                function () {
                  g.removeEventListener("mousemove", _e),
                    g.removeEventListener("mouseout", tt)
                }
              )
            }
          switch (c) {
            case "scroll":
              return _()
            case "cursor":
              return b()
          }
        }
      },
      [c, o]
    )
  },
  useLottieInteractivity = function s(e) {
    var a = e.actions,
      o = e.mode,
      c = e.lottieObj,
      d = c.animationItem,
      g = c.View,
      _ = c.animationContainerRef
    return (
      useInitInteractivity({
        actions: a,
        animationItem: d,
        mode: o,
        wrapperRef: _,
      }),
      g
    )
  },
  _excluded = ["style", "interactivity"],
  Lottie = function s(e) {
    var a,
      o,
      c,
      d = e.style,
      g = e.interactivity,
      _ = _objectWithoutProperties(e, _excluded),
      b = useLottie(_, d),
      j = b.View,
      $ = b.play,
      _e = b.stop,
      tt = b.pause,
      st = b.setSpeed,
      at = b.goToAndStop,
      ot = b.goToAndPlay,
      ut = b.setDirection,
      it = b.playSegments,
      ct = b.setSubframe,
      lt = b.getDuration,
      ht = b.destroy,
      dt = b.animationContainerRef,
      pt = b.animationLoaded,
      vt = b.animationItem
    return (
      reactExports.useEffect(
        function () {
          e.lottieRef &&
            (e.lottieRef.current = {
              play: $,
              stop: _e,
              pause: tt,
              setSpeed: st,
              goToAndPlay: ot,
              goToAndStop: at,
              setDirection: ut,
              playSegments: it,
              setSubframe: ct,
              getDuration: lt,
              destroy: ht,
              animationContainerRef: dt,
              animationLoaded: pt,
              animationItem: vt,
            })
        },
        [(a = e.lottieRef) === null || a === void 0 ? void 0 : a.current]
      ),
      useLottieInteractivity({
        lottieObj: {
          View: j,
          play: $,
          stop: _e,
          pause: tt,
          setSpeed: st,
          goToAndStop: at,
          goToAndPlay: ot,
          setDirection: ut,
          playSegments: it,
          setSubframe: ct,
          getDuration: lt,
          destroy: ht,
          animationContainerRef: dt,
          animationLoaded: pt,
          animationItem: vt,
        },
        actions:
          (o = g == null ? void 0 : g.actions) !== null && o !== void 0
            ? o
            : [],
        mode:
          (c = g == null ? void 0 : g.mode) !== null && c !== void 0
            ? c
            : "scroll",
      })
    )
  }
const v = "5.5.9",
  fr = 60,
  ip = 0,
  op = 144,
  w = 1500,
  h = 1500,
  nm = "Email 2",
  ddd = 1,
  assets = [],
  layers = [
    {
      ddd: 0,
      ind: 1,
      ty: 4,
      nm: "poof",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: -45, ix: 10 },
        p: { a: 0, k: [749.1, 748.06, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [196, 196, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [20, -35],
                    [1, -1],
                  ],
                  c: !1,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 3,
              },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 6, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Shape 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
        {
          ty: "tm",
          s: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 125,
                s: [100],
              },
              { t: 138, s: [0] },
            ],
            ix: 1,
          },
          e: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 123,
                s: [100],
              },
              { t: 136, s: [0] },
            ],
            ix: 2,
          },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: !1,
        },
      ],
      ip: 123,
      op: 141,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 2,
      ty: 4,
      nm: "poof 2",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: -90, ix: 10 },
        p: { a: 0, k: [749.1, 748.06, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [196, 196, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [20, -35],
                    [1, -1],
                  ],
                  c: !1,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 3,
              },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 6, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Shape 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
        {
          ty: "tm",
          s: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 125,
                s: [100],
              },
              { t: 138, s: [0] },
            ],
            ix: 1,
          },
          e: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 123,
                s: [100],
              },
              { t: 136, s: [0] },
            ],
            ix: 2,
          },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: !1,
        },
      ],
      ip: 123,
      op: 141,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 3,
      ty: 4,
      nm: "poof 3",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: -135, ix: 10 },
        p: { a: 0, k: [749.1, 748.06, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [196, 196, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [20, -35],
                    [1, -1],
                  ],
                  c: !1,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 3,
              },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 6, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Shape 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
        {
          ty: "tm",
          s: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 125,
                s: [100],
              },
              { t: 138, s: [0] },
            ],
            ix: 1,
          },
          e: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 123,
                s: [100],
              },
              { t: 136, s: [0] },
            ],
            ix: 2,
          },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: !1,
        },
      ],
      ip: 123,
      op: 141,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 4,
      ty: 4,
      nm: "poof 4",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 180, ix: 10 },
        p: { a: 0, k: [749.1, 748.06, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [196, 196, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [20, -35],
                    [1, -1],
                  ],
                  c: !1,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 3,
              },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 6, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Shape 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
        {
          ty: "tm",
          s: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 125,
                s: [100],
              },
              { t: 138, s: [0] },
            ],
            ix: 1,
          },
          e: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 123,
                s: [100],
              },
              { t: 136, s: [0] },
            ],
            ix: 2,
          },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: !1,
        },
      ],
      ip: 123,
      op: 141,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 5,
      ty: 4,
      nm: "poof 5",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 135, ix: 10 },
        p: { a: 0, k: [749.1, 748.06, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [196, 196, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [20, -35],
                    [1, -1],
                  ],
                  c: !1,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 3,
              },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 6, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Shape 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
        {
          ty: "tm",
          s: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 125,
                s: [100],
              },
              { t: 138, s: [0] },
            ],
            ix: 1,
          },
          e: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 123,
                s: [100],
              },
              { t: 136, s: [0] },
            ],
            ix: 2,
          },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: !1,
        },
      ],
      ip: 123,
      op: 141,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 6,
      ty: 4,
      nm: "poof 6",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 90, ix: 10 },
        p: { a: 0, k: [749.1, 748.06, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [196, 196, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [20, -35],
                    [1, -1],
                  ],
                  c: !1,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 3,
              },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 6, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Shape 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
        {
          ty: "tm",
          s: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 125,
                s: [100],
              },
              { t: 138, s: [0] },
            ],
            ix: 1,
          },
          e: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 123,
                s: [100],
              },
              { t: 136, s: [0] },
            ],
            ix: 2,
          },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: !1,
        },
      ],
      ip: 123,
      op: 141,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 7,
      ty: 4,
      nm: "poof 7",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 45, ix: 10 },
        p: { a: 0, k: [749.1, 748.06, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [196, 196, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [20, -35],
                    [1, -1],
                  ],
                  c: !1,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 3,
              },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 6, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Shape 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
        {
          ty: "tm",
          s: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 125,
                s: [100],
              },
              { t: 138, s: [0] },
            ],
            ix: 1,
          },
          e: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 123,
                s: [100],
              },
              { t: 136, s: [0] },
            ],
            ix: 2,
          },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: !1,
        },
      ],
      ip: 123,
      op: 141,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 8,
      ty: 4,
      nm: "poof 8",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [749.1, 748.06, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [196, 196, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [20, -35],
                    [1, -1],
                  ],
                  c: !1,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 3,
              },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 6, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [0, 0], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Shape 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
        {
          ty: "tm",
          s: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 125,
                s: [100],
              },
              { t: 138, s: [0] },
            ],
            ix: 1,
          },
          e: {
            a: 1,
            k: [
              {
                i: { x: [0.667], y: [1] },
                o: { x: [0.333], y: [0] },
                t: 123,
                s: [100],
              },
              { t: 136, s: [0] },
            ],
            ix: 2,
          },
          o: { a: 0, k: 0, ix: 3 },
          m: 1,
          ix: 2,
          nm: "Trim Paths 1",
          mn: "ADBE Vector Filter - Trim",
          hd: !1,
        },
      ],
      ip: 123,
      op: 141,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 9,
      ty: 3,
      nm: "flight null",
      sr: 1,
      ks: {
        o: { a: 0, k: 0, ix: 11 },
        r: { a: 0, k: 27, ix: 10 },
        p: {
          a: 1,
          k: [
            {
              i: { x: 0.657, y: 0 },
              o: { x: 0.165, y: 0 },
              t: 57,
              s: [759, 1032, 0],
              to: [346.667, -177.333, 0],
              ti: [185.333, 260, 0],
            },
            {
              i: { x: 0.085, y: 0 },
              o: { x: 0.167, y: 0.174 },
              t: 94,
              s: [1183, 376, 0],
              to: [-185.333, -260, 0],
              ti: [376.667, -270.667, 0],
            },
            {
              i: { x: 0.349, y: 0.714 },
              o: { x: 0.167, y: 0.152 },
              t: 110,
              s: [199, 396, 0],
              to: [-376.667, 270.667, 0],
              ti: [-88, 269.333, 0],
            },
            { t: 123, s: [751, 870, 0] },
          ],
          ix: 2,
        },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: {
          a: 1,
          k: [
            {
              i: { x: [0.667, 0.667, 0.667], y: [0.751, 0.751, 25.148] },
              o: { x: [0.333, 0.333, 0.333], y: [0, 0, 0] },
              t: 71,
              s: [100, 100, 100],
            },
            { t: 123, s: [3, 3, 100] },
          ],
          ix: 6,
        },
      },
      ao: 1,
      ip: -22,
      op: 126,
      st: 80,
      bm: 0,
    },
    {
      ddd: 1,
      ind: 10,
      ty: 4,
      nm: "Top open evlope 3",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        rx: {
          a: 1,
          k: [
            {
              i: { x: [0.46], y: [1] },
              o: { x: [0.167], y: [-0.177] },
              t: 3,
              s: [169.912],
            },
            { t: 30, s: [0] },
          ],
          ix: 8,
        },
        ry: { a: 0, k: 0, ix: 9 },
        rz: { a: 0, k: 0, ix: 10 },
        or: { a: 0, k: [0, 0, 359.909], ix: 7 },
        p: { a: 0, k: [752.605, 785.01, 0], ix: 2 },
        a: { a: 0, k: [6, 404, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [399.348, 246.688],
                    [-399.348, 246.688],
                    [1.333, -0.823],
                  ],
                  c: !0,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: { a: 0, k: [0, 0, 0, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 0, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.309803932905, 0.674509823322, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [-0.652, 158.688], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Rectangle 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
      ],
      ip: 0,
      op: 30,
      st: 19,
      bm: 0,
    },
    {
      ddd: 1,
      ind: 11,
      ty: 4,
      nm: "Top open evlope 5",
      parent: 9,
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        rx: {
          a: 1,
          k: [
            {
              i: { x: [0.432], y: [0.821] },
              o: { x: [0.001], y: [0.284] },
              t: 45,
              s: [0],
            },
            { t: 53, s: [169.912] },
          ],
          ix: 8,
        },
        ry: { a: 0, k: 0, ix: 9 },
        rz: { a: 0, k: 0, ix: 10 },
        or: { a: 0, k: [0, 0, 0], ix: 7 },
        p: { a: 0, k: [-6, -247, 0], ix: 2 },
        a: { a: 0, k: [6, 404, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.586, y: 1 },
                    o: { x: 0.407, y: 0 },
                    t: 47,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [399.348, 246.688],
                          [-399.348, 246.688],
                          [1.333, -0.823],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 69,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [399.348, 246.688],
                          [-150.348, -2.312],
                          [-171.667, -141.823],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: { a: 0, k: [0, 0, 0, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 0, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.309803932905, 0.674509823322, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [-0.652, 158.688], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Rectangle 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
      ],
      ip: 58,
      op: 124,
      st: 34,
      bm: 0,
    },
    {
      ddd: 1,
      ind: 12,
      ty: 4,
      nm: "Top open evlope 2",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        rx: {
          a: 1,
          k: [
            {
              i: { x: [0.432], y: [0.821] },
              o: { x: [0.001], y: [0.284] },
              t: 45,
              s: [0],
            },
            { t: 53, s: [169.912] },
          ],
          ix: 8,
        },
        ry: { a: 0, k: 0, ix: 9 },
        rz: { a: 0, k: 0, ix: 10 },
        or: { a: 0, k: [0, 0, 359.906], ix: 7 },
        p: { a: 0, k: [752.696, 784.959, 0], ix: 2 },
        a: { a: 0, k: [6, 404, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.586, y: 1 },
                    o: { x: 0.407, y: 0 },
                    t: 47,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [399.348, 246.688],
                          [-399.348, 246.688],
                          [1.333, -0.823],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 69,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [399.348, 246.688],
                          [-150.348, -2.312],
                          [-171.667, -141.823],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: { a: 0, k: [0, 0, 0, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 0, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.309803932905, 0.674509823322, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [-0.652, 158.688], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Rectangle 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
      ],
      ip: 45,
      op: 58,
      st: 34,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 13,
      ty: 4,
      nm: "lieftside 2",
      parent: 9,
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 180, ix: 10 },
        p: { a: 0, k: [-26, 2, 0], ix: 2 },
        a: { a: 0, k: [16, 156, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.586, y: 1 },
                    o: { x: 0.407, y: 0 },
                    t: 47,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [399.348, -246.688],
                          [399.348, 246.688],
                          [1.333, -0.823],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 69,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [82.348, -78.688],
                          [307.348, 152.687],
                          [-396.667, 248.177],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: { a: 0, k: [0, 0, 0, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 0, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.262745112181, 0.572549045086, 0.847058832645, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [-0.652, 158.688], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Rectangle 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
      ],
      ip: 58,
      op: 124,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 14,
      ty: 4,
      nm: "lieftside",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 179.906, ix: 10 },
        p: { a: 0, k: [733.103, 1033.992, 0], ix: 2 },
        a: { a: 0, k: [16, 156, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.586, y: 1 },
                    o: { x: 0.407, y: 0 },
                    t: 47,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [399.348, -246.688],
                          [399.348, 246.688],
                          [1.333, -0.823],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 69,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [82.348, -78.688],
                          [307.348, 152.687],
                          [-396.667, 248.177],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: { a: 0, k: [0, 0, 0, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 0, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.262745112181, 0.572549045086, 0.847058832645, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [-0.652, 158.688], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Rectangle 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
      ],
      ip: 0,
      op: 58,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 15,
      ty: 4,
      nm: "Botom fold 2",
      parent: 9,
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 0, ix: 10 },
        p: { a: 0, k: [-10, -162, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.586, y: 1 },
                    o: { x: 0.407, y: 0 },
                    t: 47,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [399.348, -246.688],
                          [399.348, 246.688],
                          [-399.348, 246.688],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 69,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [399.348, -246.688],
                          [57.348, 224.688],
                          [-87.348, 78.688],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: { a: 0, k: [0, 0, 0, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 0, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.411764711142, 0.721568644047, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [-0.652, 158.688], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Rectangle 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
      ],
      ip: 58,
      op: 124,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 16,
      ty: 4,
      nm: "Botom fold",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: -0.094, ix: 10 },
        p: { a: 0, k: [748.835, 869.966, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 1,
                k: [
                  {
                    i: { x: 0.586, y: 1 },
                    o: { x: 0.407, y: 0 },
                    t: 47,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [399.348, -246.688],
                          [399.348, 246.688],
                          [-399.348, 246.688],
                        ],
                        c: !0,
                      },
                    ],
                  },
                  {
                    t: 69,
                    s: [
                      {
                        i: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        o: [
                          [0, 0],
                          [0, 0],
                          [0, 0],
                        ],
                        v: [
                          [399.348, -246.688],
                          [57.348, 224.688],
                          [-87.348, 78.688],
                        ],
                        c: !0,
                      },
                    ],
                  },
                ],
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: { a: 0, k: [0, 0, 0, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 0, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.411764711142, 0.721568644047, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [-0.652, 158.688], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Rectangle 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
      ],
      ip: 0,
      op: 58,
      st: 31,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 17,
      ty: 4,
      nm: "Paper",
      sr: 1,
      ks: {
        o: {
          a: 1,
          k: [
            {
              i: { x: [0.833], y: [0.833] },
              o: { x: [0.167], y: [0.167] },
              t: 32,
              s: [0],
            },
            { t: 44, s: [100] },
          ],
          ix: 11,
        },
        r: { a: 0, k: -0.094, ix: 10 },
        p: {
          a: 1,
          k: [
            {
              i: { x: 0.667, y: 1 },
              o: { x: 0.333, y: 0 },
              t: 32,
              s: [747.433, 89.967, 0],
              to: [0.245, 136.666, 0],
              ti: [-0.245, -136.666, 0],
            },
            { t: 47, s: [748.9, 909.966, 0] },
          ],
          ix: 2,
        },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ty: "rc",
              d: 1,
              s: { a: 0, k: [641.516, 354.195], ix: 2 },
              p: { a: 0, k: [0, 0], ix: 3 },
              r: { a: 0, k: 0, ix: 4 },
              nm: "Rectangle Path 1",
              mn: "ADBE Vector Shape - Rect",
              hd: !1,
            },
            {
              ty: "st",
              c: { a: 0, k: [0, 0, 0, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 0, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.65098041296, 0.835294127464, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [-1.242, 127.098], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Rectangle 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
      ],
      ip: 0,
      op: 53,
      st: 31,
      bm: 0,
    },
    {
      ddd: 1,
      ind: 18,
      ty: 4,
      nm: "Top open evlope 6",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        rx: {
          a: 1,
          k: [
            {
              i: { x: [0.46], y: [1] },
              o: { x: [0.167], y: [-0.177] },
              t: 3,
              s: [169.912],
            },
            { t: 30, s: [0] },
          ],
          ix: 8,
        },
        ry: { a: 0, k: 0, ix: 9 },
        rz: { a: 0, k: 0, ix: 10 },
        or: { a: 0, k: [0, 0, 359.909], ix: 7 },
        p: { a: 0, k: [752.605, 785.01, 0], ix: 2 },
        a: { a: 0, k: [6, 404, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [399.348, 246.688],
                    [-399.348, 246.688],
                    [1.333, -0.823],
                  ],
                  c: !0,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: { a: 0, k: [0, 0, 0, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 0, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.309803932905, 0.674509823322, 0.996078431606, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [-0.652, 158.688], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Rectangle 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
      ],
      ip: 30,
      op: 45,
      st: 19,
      bm: 0,
    },
    {
      ddd: 0,
      ind: 19,
      ty: 4,
      nm: "Back of evelope",
      sr: 1,
      ks: {
        o: { a: 0, k: 100, ix: 11 },
        r: { a: 0, k: 179.906, ix: 10 },
        p: { a: 0, k: [749.358, 1189.965, 0], ix: 2 },
        a: { a: 0, k: [0, 0, 0], ix: 1 },
        s: { a: 0, k: [100, 100, 100], ix: 6 },
      },
      ao: 0,
      shapes: [
        {
          ty: "gr",
          it: [
            {
              ind: 0,
              ty: "sh",
              ix: 1,
              ks: {
                a: 0,
                k: {
                  i: [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                  ],
                  o: [
                    [0, 0],
                    [0, 0],
                    [0, 0],
                  ],
                  v: [
                    [399.348, 246.688],
                    [-399.348, 246.688],
                    [1.333, -0.823],
                  ],
                  c: !0,
                },
                ix: 2,
              },
              nm: "Path 1",
              mn: "ADBE Vector Shape - Group",
              hd: !1,
            },
            {
              ty: "st",
              c: { a: 0, k: [0, 0, 0, 1], ix: 3 },
              o: { a: 0, k: 100, ix: 4 },
              w: { a: 0, k: 0, ix: 5 },
              lc: 1,
              lj: 1,
              ml: 4,
              bm: 0,
              nm: "Stroke 1",
              mn: "ADBE Vector Graphic - Stroke",
              hd: !1,
            },
            {
              ty: "fl",
              c: {
                a: 0,
                k: [0.23137255013, 0.505882382393, 0.745098054409, 1],
                ix: 4,
              },
              o: { a: 0, k: 100, ix: 5 },
              r: 1,
              bm: 0,
              nm: "Fill 1",
              mn: "ADBE Vector Graphic - Fill",
              hd: !1,
            },
            {
              ty: "tr",
              p: { a: 0, k: [-0.652, 158.688], ix: 2 },
              a: { a: 0, k: [0, 0], ix: 1 },
              s: { a: 0, k: [100, 100], ix: 3 },
              r: { a: 0, k: 0, ix: 6 },
              o: { a: 0, k: 100, ix: 7 },
              sk: { a: 0, k: 0, ix: 4 },
              sa: { a: 0, k: 0, ix: 5 },
              nm: "Transform",
            },
          ],
          nm: "Rectangle 1",
          np: 3,
          cix: 2,
          bm: 0,
          ix: 1,
          mn: "ADBE Vector Group",
          hd: !1,
        },
      ],
      ip: 0,
      op: 53,
      st: 31,
      bm: 0,
    },
  ],
  markers = [],
  animationData = { v, fr, ip, op, w, h, nm, ddd, assets, layers, markers },
  Animation = (s) =>
    jsxRuntimeExports.jsx("div", {
      className: `absolute bottom-[-10px] left-100 overflow-visible z-10 ${
        s.visibility ? "" : "z-[-1] invisible"
      }`,
      children: jsxRuntimeExports.jsx(Lottie, {
        animationData,
        loop: s.visibility,
        autoplay: s.visibility,
        style: { width: 300, height: 300 },
      }),
    }),
  store = { _origin: "https://api.emailjs.com" },
  init = (s, e = "https://api.emailjs.com") => {
    ;(store._userID = s), (store._origin = e)
  },
  validateParams = (s, e, a) => {
    if (!s)
      throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account"
    if (!e)
      throw "The service ID is required. Visit https://dashboard.emailjs.com/admin"
    if (!a)
      throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates"
    return !0
  }
class EmailJSResponseStatus {
  constructor(e) {
    ;(this.status = e ? e.status : 0),
      (this.text = e ? e.responseText : "Network Error")
  }
}
const sendPost = (s, e, a = {}) =>
    new Promise((o, c) => {
      const d = new XMLHttpRequest()
      d.addEventListener("load", ({ target: g }) => {
        const _ = new EmailJSResponseStatus(g)
        _.status === 200 || _.text === "OK" ? o(_) : c(_)
      }),
        d.addEventListener("error", ({ target: g }) => {
          c(new EmailJSResponseStatus(g))
        }),
        d.open("POST", store._origin + s, !0),
        Object.keys(a).forEach((g) => {
          d.setRequestHeader(g, a[g])
        }),
        d.send(e)
    }),
  send = (s, e, a, o) => {
    const c = o || store._userID
    return (
      validateParams(c, s, e),
      sendPost(
        "/api/v1.0/email/send",
        JSON.stringify({
          lib_version: "3.11.0",
          user_id: c,
          service_id: s,
          template_id: e,
          template_params: a,
        }),
        { "Content-type": "application/json" }
      )
    )
  },
  findHTMLForm = (s) => {
    let e
    if (
      (typeof s == "string" ? (e = document.querySelector(s)) : (e = s),
      !e || e.nodeName !== "FORM")
    )
      throw "The 3rd parameter is expected to be the HTML form element or the style selector of form"
    return e
  },
  sendForm = (s, e, a, o) => {
    const c = o || store._userID,
      d = findHTMLForm(a)
    validateParams(c, s, e)
    const g = new FormData(d)
    return (
      g.append("lib_version", "3.11.0"),
      g.append("service_id", s),
      g.append("template_id", e),
      g.append("user_id", c),
      sendPost("/api/v1.0/email/send-form", g)
    )
  },
  emailjs = { init, send, sendForm },
  Contact = () => {
    const [s, e] = reactExports.useState(!1),
      [a, o] = reactExports.useState(""),
      c = reactExports.useRef(),
      [d, g] = reactExports.useState({ name: "", email: "", message: "" }),
      [_, b] = reactExports.useState({ name: "", email: "", message: "" }),
      [j, $] = reactExports.useState(!1),
      _e = (at) => {
        const { target: ot } = at,
          { name: ut, value: it } = ot
        g({ ...d, [ut]: it }), b({ ..._, [ut]: "" })
      },
      tt = () => {
        let at = !0
        const ot = {}
        d.name.trim() || ((ot.name = "Name is required"), (at = !1))
        const ut = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
        return (
          (!d.email.trim() || !ut.test(d.email)) &&
            ((ot.email = "Valid email is required"), (at = !1)),
          d.message.trim() || ((ot.message = "Message is required"), (at = !1)),
          b(ot),
          at
        )
      },
      st = (at) => {
        at.preventDefault(),
          tt() &&
            ($(!0),
            emailjs
              .send(
                "service_5do17kb",
                "template_c74two7",
                {
                  from_name: d.name,
                  to_name: "Ali",
                  from_email: d.email,
                  to_email: "Aliozzaim788@gmail.com",
                  message: d.message,
                },
                "RxwvCc3HpuVVISH5y"
              )
              .then(() => {
                g({ name: "", email: "", message: "" }),
                  setTimeout(() => {
                    $(!1)
                  }, 1100),
                  o("Thank you. I will get back to you as soon as possible."),
                  e(!0)
              })
              .catch((ot) => {
                e(!0),
                  $(!1),
                  console.error(ot),
                  o("Ahh, something went wrong. Please try again.")
              }))
      }
    return jsxRuntimeExports.jsxs("div", {
      className:
        "xl:mt-12 flex xl:flex-row flex-col-reverse gap-10 overflow-hidden",
      children: [
        jsxRuntimeExports.jsxs(motion.div, {
          variants: slideIn("left", "tween", 0.2, 1),
          className: "flex-[0.75] bg-black-100 p-8 rounded-2xl",
          children: [
            jsxRuntimeExports.jsx("p", {
              className: styles.sectionSubText,
              children: "Get in touch",
            }),
            jsxRuntimeExports.jsx("h3", {
              className: styles.sectionHeadText,
              children: "Contact.",
            }),
            jsxRuntimeExports.jsxs("form", {
              ref: c,
              onSubmit: st,
              className: "mt-12 flex flex-col gap-8 relative",
              children: [
                jsxRuntimeExports.jsxs("label", {
                  className: "flex flex-col",
                  children: [
                    jsxRuntimeExports.jsx("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your Name",
                    }),
                    jsxRuntimeExports.jsx("input", {
                      type: "text",
                      name: "name",
                      value: d.name,
                      onChange: _e,
                      placeholder: "What's your good name?",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                    jsxRuntimeExports.jsx("p", {
                      className: "text-red-500 mt-1",
                      children: _.name,
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs("label", {
                  className: "flex flex-col",
                  children: [
                    jsxRuntimeExports.jsx("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your email",
                    }),
                    jsxRuntimeExports.jsx("input", {
                      type: "email",
                      name: "email",
                      value: d.email,
                      onChange: _e,
                      placeholder: "What's your web address?",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                    jsxRuntimeExports.jsx("p", {
                      className: "text-red-500 mt-1",
                      children: _.email,
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs("label", {
                  className: "flex flex-col",
                  children: [
                    jsxRuntimeExports.jsx("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your Message",
                    }),
                    jsxRuntimeExports.jsx("textarea", {
                      rows: 7,
                      name: "message",
                      value: d.message,
                      onChange: _e,
                      placeholder: "What you want to say?",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                    jsxRuntimeExports.jsx("p", {
                      className: "text-red-500 mt-1",
                      children: _.message,
                    }),
                  ],
                }),
                jsxRuntimeExports.jsx("button", {
                  type: "submit",
                  className:
                    "bg-tertiary py-3 px-8 rounded-xl outline-none w-fit text-white font-bold shadow-md shadow-primary relative hover:shadow-black hover:scale-105 transition-all duration-200",
                  children: j ? "Sending..." : "Send",
                }),
                jsxRuntimeExports.jsx(Animation, { visibility: j }),
              ],
            }),
            s &&
              jsxRuntimeExports.jsx("div", {
                className: `mt-4 text-white ${
                  a.includes("Thank") ? "text-green-500" : "text-red-500"
                }`,
                children: a,
              }),
          ],
        }),
        jsxRuntimeExports.jsx(motion.div, {
          variants: slideIn("right", "tween", 0.2, 1),
          className: "xl:flex-1 xl:h-auto md:h-[550px] h-[350px] ",
          children: jsxRuntimeExports.jsx(EarthCanvas, {}),
        }),
      ],
    })
  },
  Contact$1 = StarWrapper(Contact, "contact"),
  EducationCard = ({ education: s }) =>
    jsxRuntimeExports.jsxs(distEs6.VerticalTimelineElement, {
      contentStyle: { background: "#1d1836", color: "#fff" },
      contentArrowStyle: { borderRight: "7px solid  #232631" },
      date: s.date,
      iconClassName: "overflow-hidden",
      iconStyle: { background: s.iconBg },
      icon: jsxRuntimeExports.jsx("div", {
        className: "flex justify-center items-center w-full h-full",
        children: jsxRuntimeExports.jsx("img", {
          src: s.icon,
          alt: s.company_name,
          className: "w-[100%] h-[100%] object-contain overflow-hidden",
        }),
      }),
      children: [
        jsxRuntimeExports.jsxs("div", {
          children: [
            jsxRuntimeExports.jsx("h3", {
              className: "text-white text-[24px] font-bold",
              children: s.title,
            }),
            jsxRuntimeExports.jsxs("p", {
              className: "text-secondary text-[16px] font-semibold",
              style: { margin: 0 },
              children: [s.company_name, ", ", s.location],
            }),
          ],
        }),
        jsxRuntimeExports.jsx("ul", {
          className: "mt-5 list-disc ml-5 space-y-2",
          children: s.points.map((e, a) =>
            jsxRuntimeExports.jsx(
              "li",
              {
                className: "text-white-100 text-[14px] pl-1 tracking-wider",
                children: e,
              },
              `education-point-${a}`
            )
          ),
        }),
      ],
    }),
  Education = () =>
    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsxs(motion.div, {
          variants: textVariant(),
          children: [
            jsxRuntimeExports.jsx("p", {
              className: `${styles.sectionSubText} text-center`,
            }),
            jsxRuntimeExports.jsx("h2", {
              className: `${styles.sectionHeadText} text-center`,
              children: "Education",
            }),
          ],
        }),
        jsxRuntimeExports.jsx("div", {
          className: "mt-20 flex flex-col",
          children: jsxRuntimeExports.jsx(distEs6.VerticalTimeline, {
            children: education.map((s, e) =>
              jsxRuntimeExports.jsx(
                EducationCard,
                { education: s },
                `education-${e}`
              )
            ),
          }),
        }),
      ],
    }),
  Education$1 = StarWrapper(Education, "Education"),
  App = () =>
    jsxRuntimeExports.jsx(BrowserRouter, {
      children: jsxRuntimeExports.jsxs("div", {
        className: "relative z-0 bg-primary",
        children: [
          jsxRuntimeExports.jsxs("div", {
            className: " bg-cover bg-no-repeat bg-center",
            children: [
              jsxRuntimeExports.jsx(Navbar, {}),
              jsxRuntimeExports.jsx(Hero, {}),
            ],
          }),
          jsxRuntimeExports.jsx(About$1, {}),
          jsxRuntimeExports.jsx(Experience$1, {}),
          jsxRuntimeExports.jsx(Education$1, {}),
          jsxRuntimeExports.jsx(Tech$1, {}),
          jsxRuntimeExports.jsxs("div", {
            className: "relative z-0",
            children: [
              jsxRuntimeExports.jsx(StarsCanvas, {}),
              jsxRuntimeExports.jsx(Works$1, {}),
              jsxRuntimeExports.jsx(Contact$1, {}),
            ],
          }),
        ],
      }),
    }),
  index = ""
client
  .createRoot(document.getElementById("root"))
  .render(
    jsxRuntimeExports.jsx(React.StrictMode, {
      children: jsxRuntimeExports.jsx(App, {}),
    })
  )
